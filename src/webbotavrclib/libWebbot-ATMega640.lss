In archive libWebbot-ATMega640.a:

BufferQueue.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000090  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000c4  2**0
                  ALLOC
  3 .debug_info   00000202  00000000  00000000  000000c4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000121  00000000  00000000  000002c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001ab  00000000  00000000  000003e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000592  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000112  00000000  00000000  000005b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000172  00000000  00000000  000006c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000836  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000040  00000000  00000000  00000860  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferQueue>:
 *  Created on: 21 Jun 2011
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	fc 01       	movw	r30, r24
   c:	8b 01       	movw	r16, r22
   e:	9a 01       	movw	r18, r20
	boolean rtn = FALSE;
	if(buffer && buffer->size){
  10:	00 97       	sbiw	r24, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <bufferQueue+0x14>
  14:	82 81       	ldd	r24, Z+2	; 0x02
  16:	93 81       	ldd	r25, Z+3	; 0x03
  18:	89 2b       	or	r24, r25
  1a:	01 f0       	breq	.+0      	; 0x1c <bufferQueue+0x1c>
		CRITICAL_SECTION{
  1c:	ff b6       	in	r15, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  1e:	f8 94       	cli
			// Check there is enough space
			if(buffer->size - buffer->datalength >= len){
  20:	62 81       	ldd	r22, Z+2	; 0x02
  22:	73 81       	ldd	r23, Z+3	; 0x03
  24:	c4 81       	ldd	r28, Z+4	; 0x04
  26:	d5 81       	ldd	r29, Z+5	; 0x05
  28:	cb 01       	movw	r24, r22
  2a:	8c 1b       	sub	r24, r28
  2c:	9d 0b       	sbc	r25, r29
  2e:	84 17       	cp	r24, r20
  30:	95 07       	cpc	r25, r21
  32:	00 f4       	brcc	.+0      	; 0x34 <bufferQueue+0x34>
  34:	80 e0       	ldi	r24, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  36:	ff be       	out	0x3f, r15	; 63
  38:	00 c0       	rjmp	.+0      	; 0x3a <bufferQueue+0x3a>
				rtn = TRUE;
				const uint8_t* srcBytes = (const uint8_t*)src;

				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
  3a:	86 81       	ldd	r24, Z+6	; 0x06
  3c:	97 81       	ldd	r25, Z+7	; 0x07
  3e:	8c 0f       	add	r24, r28
  40:	9d 1f       	adc	r25, r29
  42:	0e 94 00 00 	call	0	; 0x0 <bufferQueue>
				// Get the final length of the buffer
				buffer->datalength += len;
  46:	c2 0f       	add	r28, r18
  48:	d3 1f       	adc	r29, r19
  4a:	d5 83       	std	Z+5, r29	; 0x05
  4c:	c4 83       	std	Z+4, r28	; 0x04
  4e:	d8 01       	movw	r26, r16
 *  Created on: 21 Jun 2011
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
  50:	20 0f       	add	r18, r16
  52:	31 1f       	adc	r19, r17
				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
				// Get the final length of the buffer
				buffer->datalength += len;
				// Put out all the bytes
				while(len--){
  54:	00 c0       	rjmp	.+0      	; 0x56 <bufferQueue+0x56>
					buffer->dataptr[dstIndex++] = *srcBytes++;
  56:	ac 01       	movw	r20, r24
  58:	4f 5f       	subi	r20, 0xFF	; 255
  5a:	5f 4f       	sbci	r21, 0xFF	; 255
  5c:	6d 91       	ld	r22, X+
  5e:	c0 81       	ld	r28, Z
  60:	d1 81       	ldd	r29, Z+1	; 0x01
  62:	c8 0f       	add	r28, r24
  64:	d9 1f       	adc	r29, r25
  66:	68 83       	st	Y, r22
					if(dstIndex == buffer->size){
  68:	82 81       	ldd	r24, Z+2	; 0x02
  6a:	93 81       	ldd	r25, Z+3	; 0x03
  6c:	48 17       	cp	r20, r24
  6e:	59 07       	cpc	r21, r25
  70:	01 f4       	brne	.+0      	; 0x72 <bufferQueue+0x72>
						dstIndex = 0;
  72:	40 e0       	ldi	r20, 0x00	; 0
  74:	50 e0       	ldi	r21, 0x00	; 0
  76:	ca 01       	movw	r24, r20
				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
				// Get the final length of the buffer
				buffer->datalength += len;
				// Put out all the bytes
				while(len--){
  78:	a2 17       	cp	r26, r18
  7a:	b3 07       	cpc	r27, r19
  7c:	01 f4       	brne	.+0      	; 0x7e <bufferQueue+0x7e>
	boolean rtn = FALSE;
	if(buffer && buffer->size){
		CRITICAL_SECTION{
			// Check there is enough space
			if(buffer->size - buffer->datalength >= len){
				rtn = TRUE;
  7e:	8f ef       	ldi	r24, 0xFF	; 255
  80:	00 c0       	rjmp	.+0      	; 0x82 <bufferQueue+0x82>
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
	boolean rtn = FALSE;
  82:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	return rtn;
}
  84:	df 91       	pop	r29
  86:	cf 91       	pop	r28
  88:	1f 91       	pop	r17
  8a:	0f 91       	pop	r16
  8c:	ff 90       	pop	r15
  8e:	08 95       	ret

avrcam.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009f6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000a2a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000102  00000000  00000000  00000a2a  2**0
                  ALLOC
  3 .rodata.str1.1 0000000f  00000000  00000000  00000a2a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .progmem.data 00000027  00000000  00000000  00000a39  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  5 .debug_info   00001ff9  00000000  00000000  00000a60  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_abbrev 000004c5  00000000  00000000  00002a59  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00001850  00000000  00000000  00002f1e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_aranges 00000020  00000000  00000000  0000476e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_ranges 00000108  00000000  00000000  0000478e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000035e  00000000  00000000  00004896  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000837  00000000  00000000  00004bf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002a  00000000  00000000  0000542b  2**0
                  CONTENTS, READONLY
 13 .debug_frame  000002ac  00000000  00000000  00005458  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <xres>:
}

static uint16_t  xres(CAMERA* camera){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	return (uint16_t)176;
}
   0:	80 eb       	ldi	r24, 0xB0	; 176
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	08 95       	ret

00000006 <yres>:

static uint16_t  yres(CAMERA* camera){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	return (uint16_t)144;
}
   6:	80 e9       	ldi	r24, 0x90	; 144
   8:	90 e0       	ldi	r25, 0x00	; 0
   a:	08 95       	ret

0000000c <sendChar>:
#define flush(camera) __uartFlushReceiveBuffer(camera->_camera_.uart)


static UART* active;

static MAKE_WRITER(sendChar) {
   c:	cf 93       	push	r28
   e:	c8 2f       	mov	r28, r24
	_uartSendByte(active,byte);
  10:	68 2f       	mov	r22, r24
  12:	80 91 00 00 	lds	r24, 0x0000
  16:	90 91 00 00 	lds	r25, 0x0000
  1a:	0e 94 00 00 	call	0	; 0x0 <xres>
	return byte;
}
  1e:	8c 2f       	mov	r24, r28
  20:	cf 91       	pop	r28
  22:	08 95       	ret

00000024 <setBin>:
static boolean ping(AVRCAM* camera){
	return sendCmd(camera,"PG");
}

// Set the value of a colour bin to RGB
static boolean setBin(CAMERA* camera, uint8_t binNo, const COLOR* min, const COLOR* max){
  24:	cf 92       	push	r12
  26:	df 92       	push	r13
  28:	ef 92       	push	r14
  2a:	ff 92       	push	r15
  2c:	0f 93       	push	r16
  2e:	1f 93       	push	r17
  30:	cf 93       	push	r28
  32:	df 93       	push	r29
  34:	cd b7       	in	r28, 0x3d	; 61
  36:	de b7       	in	r29, 0x3e	; 62
  38:	28 97       	sbiw	r28, 0x08	; 8
  3a:	0f b6       	in	r0, 0x3f	; 63
  3c:	f8 94       	cli
  3e:	de bf       	out	0x3e, r29	; 62
  40:	0f be       	out	0x3f, r0	; 63
  42:	cd bf       	out	0x3d, r28	; 61
  44:	fc 01       	movw	r30, r24
  46:	ca 01       	movw	r24, r20
  48:	69 01       	movw	r12, r18
//	AVRCAM* avrcam = (AVRCAM*)camera;
	boolean rtn = FALSE;

	if(binNo < AVRCAM_BINS){
  4a:	68 30       	cpi	r22, 0x08	; 8
  4c:	00 f0       	brcs	.+0      	; 0x4e <setBin+0x2a>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <setBin+0x2c>
		CAMERA_BIN* bin = &camera->bins[binNo];
  50:	04 81       	ldd	r16, Z+4	; 0x04
  52:	15 81       	ldd	r17, Z+5	; 0x05
  54:	29 e0       	ldi	r18, 0x09	; 9
  56:	62 9f       	mul	r22, r18
  58:	00 0d       	add	r16, r0
  5a:	11 1d       	adc	r17, r1
  5c:	11 24       	eor	r1, r1
		COLOR _max;
		COLOR_RGB *_minRGB;
		COLOR_RGB *_maxRGB;

		// Convert min to rgb
		_minRGB = color2rgb(min, &_min);
  5e:	be 01       	movw	r22, r28
  60:	6b 5f       	subi	r22, 0xFB	; 251
  62:	7f 4f       	sbci	r23, 0xFF	; 255
  64:	0e 94 00 00 	call	0	; 0x0 <xres>
  68:	7c 01       	movw	r14, r24

		// Convert max to rgb
		_maxRGB = color2rgb(max, &_max);
  6a:	be 01       	movw	r22, r28
  6c:	6f 5f       	subi	r22, 0xFF	; 255
  6e:	7f 4f       	sbci	r23, 0xFF	; 255
  70:	c6 01       	movw	r24, r12
  72:	0e 94 00 00 	call	0	; 0x0 <xres>
  76:	fc 01       	movw	r30, r24

		if(_minRGB->r > _maxRGB->r){
  78:	d7 01       	movw	r26, r14
  7a:	8c 91       	ld	r24, X
  7c:	90 81       	ld	r25, Z
  7e:	98 17       	cp	r25, r24
  80:	00 f4       	brcc	.+0      	; 0x82 <setBin+0x5e>
			// swap the red values
			uint8_t c = _minRGB->r;
			_minRGB->r = _maxRGB->r;
  82:	9c 93       	st	X, r25
			_maxRGB->r = c;
  84:	80 83       	st	Z, r24
		}

		if(_minRGB->g > _maxRGB->g){
  86:	d7 01       	movw	r26, r14
  88:	11 96       	adiw	r26, 0x01	; 1
  8a:	8c 91       	ld	r24, X
  8c:	11 97       	sbiw	r26, 0x01	; 1
  8e:	91 81       	ldd	r25, Z+1	; 0x01
  90:	98 17       	cp	r25, r24
  92:	00 f4       	brcc	.+0      	; 0x94 <setBin+0x70>
			// swap the green values
			uint8_t c = _minRGB->g;
			_minRGB->g = _maxRGB->g;
  94:	11 96       	adiw	r26, 0x01	; 1
  96:	9c 93       	st	X, r25
			_maxRGB->g = c;
  98:	81 83       	std	Z+1, r24	; 0x01
		}

		if(_minRGB->b > _maxRGB->b){
  9a:	d7 01       	movw	r26, r14
  9c:	12 96       	adiw	r26, 0x02	; 2
  9e:	8c 91       	ld	r24, X
  a0:	12 97       	sbiw	r26, 0x02	; 2
  a2:	92 81       	ldd	r25, Z+2	; 0x02
  a4:	98 17       	cp	r25, r24
  a6:	00 f4       	brcc	.+0      	; 0xa8 <setBin+0x84>
			// swap the blue values
			uint8_t c = _minRGB->b;
			_minRGB->b = _maxRGB->b;
  a8:	12 96       	adiw	r26, 0x02	; 2
  aa:	9c 93       	st	X, r25
			_maxRGB->b = c;
  ac:	82 83       	std	Z+2, r24	; 0x02
		}

		if(colorEquals(&_min, &bin->min)==FALSE || colorEquals(&_max, &bin->max)==FALSE){
  ae:	f0 2e       	mov	r15, r16
  b0:	e1 2e       	mov	r14, r17
  b2:	b8 01       	movw	r22, r16
  b4:	ce 01       	movw	r24, r28
  b6:	05 96       	adiw	r24, 0x05	; 5
  b8:	0e 94 00 00 	call	0	; 0x0 <xres>
  bc:	81 11       	cpse	r24, r1
  be:	00 c0       	rjmp	.+0      	; 0xc0 <setBin+0x9c>
			// The colours have changed

			// Put into color bank table
			color2rgb(&_min, &bin->min);
  c0:	6f 2d       	mov	r22, r15
  c2:	7e 2d       	mov	r23, r14
  c4:	ce 01       	movw	r24, r28
  c6:	05 96       	adiw	r24, 0x05	; 5
  c8:	0e 94 00 00 	call	0	; 0x0 <xres>
			color2rgb(&_max, &bin->max);
  cc:	b8 01       	movw	r22, r16
  ce:	6c 5f       	subi	r22, 0xFC	; 252
  d0:	7f 4f       	sbci	r23, 0xFF	; 255
  d2:	ce 01       	movw	r24, r28
  d4:	01 96       	adiw	r24, 0x01	; 1
  d6:	0e 94 00 00 	call	0	; 0x0 <xres>
			bin->dirty = TRUE;
  da:	f8 01       	movw	r30, r16
  dc:	80 85       	ldd	r24, Z+8	; 0x08
  de:	ff ef       	ldi	r31, 0xFF	; 255
  e0:	f0 fb       	bst	r31, 0
  e2:	80 f9       	bld	r24, 0
  e4:	d8 01       	movw	r26, r16
  e6:	18 96       	adiw	r26, 0x08	; 8
  e8:	8c 93       	st	X, r24
  ea:	00 c0       	rjmp	.+0      	; 0xec <setBin+0xc8>
			uint8_t c = _minRGB->b;
			_minRGB->b = _maxRGB->b;
			_maxRGB->b = c;
		}

		if(colorEquals(&_min, &bin->min)==FALSE || colorEquals(&_max, &bin->max)==FALSE){
  ec:	b8 01       	movw	r22, r16
  ee:	6c 5f       	subi	r22, 0xFC	; 252
  f0:	7f 4f       	sbci	r23, 0xFF	; 255
  f2:	ce 01       	movw	r24, r28
  f4:	01 96       	adiw	r24, 0x01	; 1
  f6:	0e 94 00 00 	call	0	; 0x0 <xres>
  fa:	88 23       	and	r24, r24
  fc:	01 f0       	breq	.+0      	; 0xfe <setBin+0xda>
			color2rgb(&_min, &bin->min);
			color2rgb(&_max, &bin->max);
			bin->dirty = TRUE;
		}

		rtn = bin->active = TRUE;
  fe:	f8 01       	movw	r30, r16
 100:	80 85       	ldd	r24, Z+8	; 0x08
 102:	ff ef       	ldi	r31, 0xFF	; 255
 104:	f0 fb       	bst	r31, 0
 106:	81 f9       	bld	r24, 1
 108:	d8 01       	movw	r26, r16
 10a:	18 96       	adiw	r26, 0x08	; 8
 10c:	8c 93       	st	X, r24
 10e:	8f ef       	ldi	r24, 0xFF	; 255
 110:	00 c0       	rjmp	.+0      	; 0x112 <setBin+0xee>
}

// Set the value of a colour bin to RGB
static boolean setBin(CAMERA* camera, uint8_t binNo, const COLOR* min, const COLOR* max){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	boolean rtn = FALSE;
 112:	80 e0       	ldi	r24, 0x00	; 0

		rtn = bin->active = TRUE;

	}
	return rtn;
}
 114:	28 96       	adiw	r28, 0x08	; 8
 116:	0f b6       	in	r0, 0x3f	; 63
 118:	f8 94       	cli
 11a:	de bf       	out	0x3e, r29	; 62
 11c:	0f be       	out	0x3f, r0	; 63
 11e:	cd bf       	out	0x3d, r28	; 61
 120:	df 91       	pop	r29
 122:	cf 91       	pop	r28
 124:	1f 91       	pop	r17
 126:	0f 91       	pop	r16
 128:	ff 90       	pop	r15
 12a:	ef 90       	pop	r14
 12c:	df 90       	pop	r13
 12e:	cf 90       	pop	r12
 130:	08 95       	ret

00000132 <getResponse.isra.1.constprop.4>:
	}
	return rtn;
}

// Get a line of response and return the length (0=error)
static size_t getResponse(AVRCAM* camera, char chStart, char chEnd, size_t minLen, size_t maxLen) {
 132:	3f 92       	push	r3
 134:	4f 92       	push	r4
 136:	5f 92       	push	r5
 138:	6f 92       	push	r6
 13a:	7f 92       	push	r7
 13c:	8f 92       	push	r8
 13e:	9f 92       	push	r9
 140:	af 92       	push	r10
 142:	bf 92       	push	r11
 144:	cf 92       	push	r12
 146:	df 92       	push	r13
 148:	ef 92       	push	r14
 14a:	ff 92       	push	r15
 14c:	0f 93       	push	r16
 14e:	1f 93       	push	r17
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
 154:	5c 01       	movw	r10, r24
 156:	66 2e       	mov	r6, r22
 158:	44 2e       	mov	r4, r20
 15a:	49 01       	movw	r8, r18
	size_t		counter=0;		// Counts the length of the string

	// Have we located the start character yet?
	boolean		inLine= (chStart) ? FALSE : TRUE;
 15c:	66 23       	and	r22, r22
 15e:	01 f0       	breq	.+0      	; 0x160 <getResponse.isra.1.constprop.4+0x2e>
 160:	31 2c       	mov	r3, r1
 162:	00 c0       	rjmp	.+0      	; 0x164 <getResponse.isra.1.constprop.4+0x32>
 164:	33 24       	eor	r3, r3
 166:	3a 94       	dec	r3
	if (! maxLen) {
		maxLen=MAX_REPLY;
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
 168:	0e 94 00 00 	call	0	; 0x0 <xres>
 16c:	6b 01       	movw	r12, r22
 16e:	7c 01       	movw	r14, r24
	return rtn;
}

// Get a line of response and return the length (0=error)
static size_t getResponse(AVRCAM* camera, char chStart, char chEnd, size_t minLen, size_t maxLen) {
	size_t		counter=0;		// Counts the length of the string
 170:	c0 e0       	ldi	r28, 0x00	; 0
 172:	d0 e0       	ldi	r29, 0x00	; 0
		maxLen=MAX_REPLY;
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
 174:	00 e6       	ldi	r16, 0x60	; 96
 176:	1a ee       	ldi	r17, 0xEA	; 234
					return 0;
				}
			}
		}else{
			// we are waiting for start of line
			if(temp == chStart){
 178:	71 2c       	mov	r7, r1
			noclock = 60000;
		}

		if(inLine){
			// We are processing the line
			if(temp==chEnd && counter>=minLen) {
 17a:	51 2c       	mov	r5, r1

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
	while(noclock) {
		if(g_heartbeat){
 17c:	80 91 00 00 	lds	r24, 0x0000
 180:	90 91 00 00 	lds	r25, 0x0000
 184:	89 2b       	or	r24, r25
 186:	01 f0       	breq	.+0      	; 0x188 <getResponse.isra.1.constprop.4+0x56>
			if(clockHasElapsed(startTime, TIMEOUT)){
 188:	20 ee       	ldi	r18, 0xE0	; 224
 18a:	33 e9       	ldi	r19, 0x93	; 147
 18c:	44 e0       	ldi	r20, 0x04	; 4
 18e:	50 e0       	ldi	r21, 0x00	; 0
 190:	c7 01       	movw	r24, r14
 192:	b6 01       	movw	r22, r12
 194:	0e 94 00 00 	call	0	; 0x0 <xres>
 198:	88 23       	and	r24, r24
 19a:	01 f0       	breq	.+0      	; 0x19c <getResponse.isra.1.constprop.4+0x6a>
				// We've timed out
				return 0;
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <getResponse.isra.1.constprop.4+0x70>
			}
		}else{
			noclock--;
 1a2:	01 50       	subi	r16, 0x01	; 1
 1a4:	11 09       	sbc	r17, r1
		}

		// Get next byte, or -1 if none
		int temp=__uartGetByte(camera->_camera_.uart);
 1a6:	f5 01       	movw	r30, r10
 1a8:	80 81       	ld	r24, Z
 1aa:	91 81       	ldd	r25, Z+1	; 0x01
 1ac:	0e 94 00 00 	call	0	; 0x0 <xres>

		if(temp!=-1){
 1b0:	8f 3f       	cpi	r24, 0xFF	; 255
 1b2:	ff ef       	ldi	r31, 0xFF	; 255
 1b4:	9f 07       	cpc	r25, r31
 1b6:	01 f0       	breq	.+0      	; 0x1b8 <getResponse.isra.1.constprop.4+0x86>
			noclock = 60000;
 1b8:	00 e6       	ldi	r16, 0x60	; 96
 1ba:	1a ee       	ldi	r17, 0xEA	; 234
		}

		if(inLine){
 1bc:	33 20       	and	r3, r3
 1be:	01 f0       	breq	.+0      	; 0x1c0 <getResponse.isra.1.constprop.4+0x8e>
			// We are processing the line
			if(temp==chEnd && counter>=minLen) {
 1c0:	84 15       	cp	r24, r4
 1c2:	95 05       	cpc	r25, r5
 1c4:	01 f4       	brne	.+0      	; 0x1c6 <getResponse.isra.1.constprop.4+0x94>
 1c6:	c8 15       	cp	r28, r8
 1c8:	d9 05       	cpc	r29, r9
 1ca:	00 f0       	brcs	.+0      	; 0x1cc <getResponse.isra.1.constprop.4+0x9a>
				// Found the end of the line
				response[counter]='\0';
 1cc:	fe 01       	movw	r30, r28
 1ce:	e0 50       	subi	r30, 0x00	; 0
 1d0:	f0 40       	sbci	r31, 0x00	; 0
 1d2:	10 82       	st	Z, r1
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <getResponse.isra.1.constprop.4+0xa4>
				return counter;
			}else if (temp != -1) {
 1d6:	8f 3f       	cpi	r24, 0xFF	; 255
 1d8:	2f ef       	ldi	r18, 0xFF	; 255
 1da:	92 07       	cpc	r25, r18
 1dc:	01 f0       	breq	.+0      	; 0x1de <getResponse.isra.1.constprop.4+0xac>
				// Save the next character
				response[counter++]=temp;
 1de:	fe 01       	movw	r30, r28
 1e0:	31 96       	adiw	r30, 0x01	; 1
 1e2:	c0 50       	subi	r28, 0x00	; 0
 1e4:	d0 40       	sbci	r29, 0x00	; 0
 1e6:	88 83       	st	Y, r24

				// Check if the line is too long
				if (counter>=maxLen) {
 1e8:	ef 3f       	cpi	r30, 0xFF	; 255
 1ea:	f1 05       	cpc	r31, r1
 1ec:	00 f4       	brcc	.+0      	; 0x1ee <getResponse.isra.1.constprop.4+0xbc>
 1ee:	ef 01       	movw	r28, r30
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <getResponse.isra.1.constprop.4+0xc0>
					return 0;
				}
			}
		}else{
			// we are waiting for start of line
			if(temp == chStart){
 1f2:	86 15       	cp	r24, r6
 1f4:	97 05       	cpc	r25, r7
 1f6:	01 f4       	brne	.+0      	; 0x1f8 <getResponse.isra.1.constprop.4+0xc6>
				inLine = TRUE;
 1f8:	33 24       	eor	r3, r3
 1fa:	3a 94       	dec	r3
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
	while(noclock) {
 1fc:	01 15       	cp	r16, r1
 1fe:	11 05       	cpc	r17, r1
 200:	01 f0       	breq	.+0      	; 0x202 <getResponse.isra.1.constprop.4+0xd0>
 202:	00 c0       	rjmp	.+0      	; 0x204 <getResponse.isra.1.constprop.4+0xd2>
 204:	00 c0       	rjmp	.+0      	; 0x206 <getResponse.isra.1.constprop.4+0xd4>
				inLine = TRUE;
			}
		}
	}
	return 0;
}
 206:	ce 01       	movw	r24, r28
 208:	df 91       	pop	r29
 20a:	cf 91       	pop	r28
 20c:	1f 91       	pop	r17
 20e:	0f 91       	pop	r16
 210:	ff 90       	pop	r15
 212:	ef 90       	pop	r14
 214:	df 90       	pop	r13
 216:	cf 90       	pop	r12
 218:	bf 90       	pop	r11
 21a:	af 90       	pop	r10
 21c:	9f 90       	pop	r9
 21e:	8f 90       	pop	r8
 220:	7f 90       	pop	r7
 222:	6f 90       	pop	r6
 224:	5f 90       	pop	r5
 226:	4f 90       	pop	r4
 228:	3f 90       	pop	r3
 22a:	08 95       	ret

0000022c <sendCmd>:



// Send a null terminated string and await response
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
 22c:	ef 92       	push	r14
 22e:	ff 92       	push	r15
 230:	0f 93       	push	r16
 232:	1f 93       	push	r17
 234:	cf 93       	push	r28
 236:	df 93       	push	r29
 238:	00 d0       	rcall	.+0      	; 0x23a <sendCmd+0xe>
 23a:	cd b7       	in	r28, 0x3d	; 61
 23c:	de b7       	in	r29, 0x3e	; 62
 23e:	7c 01       	movw	r14, r24
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 240:	fc 01       	movw	r30, r24
 242:	82 81       	ldd	r24, Z+2	; 0x02
 244:	93 81       	ldd	r25, Z+3	; 0x03
 246:	90 93 00 00 	sts	0x0000, r25
 24a:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 24e:	80 e0       	ldi	r24, 0x00	; 0
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	69 83       	std	Y+1, r22	; 0x01
 254:	7a 83       	std	Y+2, r23	; 0x02
 256:	0e 94 00 00 	call	0	; 0x0 <xres>
 25a:	8c 01       	movw	r16, r24
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
	boolean rtn = FALSE;

	Writer old = setActive(camera);
	flush(camera);							// Flush receive buffer
 25c:	f7 01       	movw	r30, r14
 25e:	82 81       	ldd	r24, Z+2	; 0x02
 260:	93 81       	ldd	r25, Z+3	; 0x03
 262:	0e 94 00 00 	call	0	; 0x0 <xres>
	rprintf("%s\r",cmd);					// Send the command
 266:	7a 81       	ldd	r23, Y+2	; 0x02
 268:	7f 93       	push	r23
 26a:	69 81       	ldd	r22, Y+1	; 0x01
 26c:	6f 93       	push	r22
 26e:	20 e0       	ldi	r18, 0x00	; 0
 270:	30 e0       	ldi	r19, 0x00	; 0
 272:	3f 93       	push	r19
 274:	2f 93       	push	r18
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	8f 93       	push	r24
 27a:	0e 94 00 00 	call	0	; 0x0 <xres>
	rprintfInit(old);
 27e:	c8 01       	movw	r24, r16
 280:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Read the response
	size_t len=getResponse(camera, 0,'\r',0,0);
 284:	20 e0       	ldi	r18, 0x00	; 0
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	4d e0       	ldi	r20, 0x0D	; 13
 28a:	60 e0       	ldi	r22, 0x00	; 0
 28c:	c7 01       	movw	r24, r14
 28e:	02 96       	adiw	r24, 0x02	; 2
 290:	0e 94 00 00 	call	0	; 0x0 <xres>

	if (len>0) {
 294:	0f 90       	pop	r0
 296:	0f 90       	pop	r0
 298:	0f 90       	pop	r0
 29a:	0f 90       	pop	r0
 29c:	0f 90       	pop	r0
 29e:	00 97       	sbiw	r24, 0x00	; 0
 2a0:	01 f4       	brne	.+0      	; 0x2a2 <sendCmd+0x76>


// Send a null terminated string and await response
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
	boolean rtn = FALSE;
 2a2:	80 e0       	ldi	r24, 0x00	; 0
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <sendCmd+0x7a>

	// Read the response
	size_t len=getResponse(camera, 0,'\r',0,0);

	if (len>0) {
		char * ack=response+len-3;			// Look at last 3 characters
 2a6:	fc 01       	movw	r30, r24
 2a8:	e0 50       	subi	r30, 0x00	; 0
 2aa:	f0 40       	sbci	r31, 0x00	; 0

		// Test for an ACK response
		if(ack[0]=='A' && ack[1]=='C' && ack[2]=='K'){
 2ac:	80 81       	ld	r24, Z
 2ae:	81 34       	cpi	r24, 0x41	; 65
 2b0:	01 f4       	brne	.+0      	; 0x2b2 <sendCmd+0x86>
 2b2:	81 81       	ldd	r24, Z+1	; 0x01
 2b4:	83 34       	cpi	r24, 0x43	; 67
 2b6:	01 f4       	brne	.+0      	; 0x2b8 <sendCmd+0x8c>
 2b8:	82 81       	ldd	r24, Z+2	; 0x02
 2ba:	8b 34       	cpi	r24, 0x4B	; 75
 2bc:	01 f4       	brne	.+0      	; 0x2be <sendCmd+0x92>
			rtn = TRUE;
 2be:	8f ef       	ldi	r24, 0xFF	; 255
		}
	}
	return rtn;
}
 2c0:	0f 90       	pop	r0
 2c2:	0f 90       	pop	r0
 2c4:	df 91       	pop	r29
 2c6:	cf 91       	pop	r28
 2c8:	1f 91       	pop	r17
 2ca:	0f 91       	pop	r16
 2cc:	ff 90       	pop	r15
 2ce:	ef 90       	pop	r14
 2d0:	08 95       	ret

000002d2 <getVersion>:
	return camera->numBlobs;
}

// Get the version of camera software
static char *getVersion(CAMERA* camera) {
	return(sendCmd((AVRCAM*)camera,"GV")) ? response : null;
 2d2:	60 e0       	ldi	r22, 0x00	; 0
 2d4:	70 e0       	ldi	r23, 0x00	; 0
 2d6:	0e 94 00 00 	call	0	; 0x0 <xres>
 2da:	88 23       	and	r24, r24
 2dc:	01 f0       	breq	.+0      	; 0x2de <getVersion+0xc>
 2de:	20 e0       	ldi	r18, 0x00	; 0
 2e0:	30 e0       	ldi	r19, 0x00	; 0
 2e2:	00 c0       	rjmp	.+0      	; 0x2e4 <getVersion+0x12>
 2e4:	20 e0       	ldi	r18, 0x00	; 0
 2e6:	30 e0       	ldi	r19, 0x00	; 0
}
 2e8:	c9 01       	movw	r24, r18
 2ea:	08 95       	ret

000002ec <trackStop>:
	return (camera->tracking) ? TRUE : FALSE;
}

// Turn off tracking mode
// return TRUE if tacking mode disabled
static boolean trackStop(AVRCAM* camera) {
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	ec 01       	movw	r28, r24
	if(camera->tracking) {
 2f2:	8d 85       	ldd	r24, Y+13	; 0x0d
 2f4:	80 ff       	sbrs	r24, 0
 2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <trackStop+0xc>
		if(sendCmd(camera, "DT")){
 2f8:	60 e0       	ldi	r22, 0x00	; 0
 2fa:	70 e0       	ldi	r23, 0x00	; 0
 2fc:	ce 01       	movw	r24, r28
 2fe:	0e 94 00 00 	call	0	; 0x0 <xres>
 302:	88 23       	and	r24, r24
 304:	01 f0       	breq	.+0      	; 0x306 <trackStop+0x1a>
			camera->tracking = FALSE;
 306:	8d 85       	ldd	r24, Y+13	; 0x0d
 308:	8e 7f       	andi	r24, 0xFE	; 254
 30a:	8d 87       	std	Y+13, r24	; 0x0d
		}
	}
	return (camera->tracking) ? FALSE : TRUE;
 30c:	8d 85       	ldd	r24, Y+13	; 0x0d
 30e:	80 ff       	sbrs	r24, 0
 310:	00 c0       	rjmp	.+0      	; 0x312 <trackStop+0x26>
 312:	80 e0       	ldi	r24, 0x00	; 0
 314:	00 c0       	rjmp	.+0      	; 0x316 <trackStop+0x2a>
 316:	8f ef       	ldi	r24, 0xFF	; 255
}
 318:	df 91       	pop	r29
 31a:	cf 91       	pop	r28
 31c:	08 95       	ret

0000031e <getBlobs>:
	}
	return 0;
}

// Read the blobs for a given color bin
static uint8_t	getBlobs(CAMERA* camera, uint8_t bin){
 31e:	2f 92       	push	r2
 320:	3f 92       	push	r3
 322:	4f 92       	push	r4
 324:	5f 92       	push	r5
 326:	6f 92       	push	r6
 328:	7f 92       	push	r7
 32a:	8f 92       	push	r8
 32c:	9f 92       	push	r9
 32e:	af 92       	push	r10
 330:	bf 92       	push	r11
 332:	cf 92       	push	r12
 334:	df 92       	push	r13
 336:	ef 92       	push	r14
 338:	ff 92       	push	r15
 33a:	0f 93       	push	r16
 33c:	1f 93       	push	r17
 33e:	cf 93       	push	r28
 340:	df 93       	push	r29
 342:	cd b7       	in	r28, 0x3d	; 61
 344:	de b7       	in	r29, 0x3e	; 62
 346:	6b 97       	sbiw	r28, 0x1b	; 27
 348:	0f b6       	in	r0, 0x3f	; 63
 34a:	f8 94       	cli
 34c:	de bf       	out	0x3e, r29	; 62
 34e:	0f be       	out	0x3f, r0	; 63
 350:	cd bf       	out	0x3d, r28	; 61
 352:	8c 01       	movw	r16, r24
 354:	6a 8f       	std	Y+26, r22	; 0x1a
	AVRCAM* avrcam = (AVRCAM*)camera;
	camera->numBlobs = 0;
 356:	dc 01       	movw	r26, r24
 358:	1c 96       	adiw	r26, 0x0c	; 12
 35a:	1c 92       	st	X, r1
 35c:	1c 97       	sbiw	r26, 0x0c	; 12
}

// Turn on tracking mode
// return TRUE if tracking mode enabled
static boolean trackStart(AVRCAM* camera) {
	if(!camera->tracking) {
 35e:	1d 96       	adiw	r26, 0x0d	; 13
 360:	8c 91       	ld	r24, X
 362:	80 fd       	sbrc	r24, 0
 364:	00 c0       	rjmp	.+0      	; 0x366 <getBlobs+0x48>
// This will only do something if the color bins have changed
static boolean sendBins(AVRCAM* camera){
	// See if anything is dirty
	boolean dirty = FALSE;
	for (uint8_t index=0; index<AVRCAM_BINS; index++) {
		CAMERA_BIN* bin = &camera->_camera_.bins[index];
 366:	f8 01       	movw	r30, r16
 368:	24 81       	ldd	r18, Z+4	; 0x04
 36a:	35 81       	ldd	r19, Z+5	; 0x05
 36c:	80 e0       	ldi	r24, 0x00	; 0
 36e:	90 e0       	ldi	r25, 0x00	; 0
 370:	50 e0       	ldi	r21, 0x00	; 0
		dirty |= bin->dirty;
 372:	f9 01       	movw	r30, r18
 374:	e8 0f       	add	r30, r24
 376:	f9 1f       	adc	r31, r25
 378:	40 85       	ldd	r20, Z+8	; 0x08
 37a:	47 95       	ror	r20
 37c:	44 27       	eor	r20, r20
 37e:	47 95       	ror	r20
 380:	44 0f       	add	r20, r20
 382:	44 0b       	sbc	r20, r20
 384:	54 2b       	or	r21, r20
 386:	09 96       	adiw	r24, 0x09	; 9
// Send the color bins to the camera
// This will only do something if the color bins have changed
static boolean sendBins(AVRCAM* camera){
	// See if anything is dirty
	boolean dirty = FALSE;
	for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 388:	88 34       	cpi	r24, 0x48	; 72
 38a:	91 05       	cpc	r25, r1
 38c:	01 f4       	brne	.+0      	; 0x38e <getBlobs+0x70>
		CAMERA_BIN* bin = &camera->_camera_.bins[index];
		dirty |= bin->dirty;
	}
	if(dirty==FALSE){
 38e:	55 23       	and	r21, r21
 390:	01 f4       	brne	.+0      	; 0x392 <getBlobs+0x74>
 392:	00 c0       	rjmp	.+0      	; 0x394 <getBlobs+0x76>
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 394:	d8 01       	movw	r26, r16
 396:	12 96       	adiw	r26, 0x02	; 2
 398:	8d 91       	ld	r24, X+
 39a:	9c 91       	ld	r25, X
 39c:	13 97       	sbiw	r26, 0x03	; 3
 39e:	90 93 00 00 	sts	0x0000, r25
 3a2:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 3a6:	80 e0       	ldi	r24, 0x00	; 0
 3a8:	90 e0       	ldi	r25, 0x00	; 0
 3aa:	0e 94 00 00 	call	0	; 0x0 <xres>
 3ae:	1c 01       	movw	r2, r24

	// Send rprintf output to the camera
	Writer old = setActive(camera);

	// Command for set colour maps
	rprintf("SM");
 3b0:	20 e0       	ldi	r18, 0x00	; 0
 3b2:	30 e0       	ldi	r19, 0x00	; 0
 3b4:	3f 93       	push	r19
 3b6:	2f 93       	push	r18
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	8f 93       	push	r24
 3bc:	0e 94 00 00 	call	0	; 0x0 <xres>
 3c0:	0f 90       	pop	r0
 3c2:	0f 90       	pop	r0
 3c4:	0f 90       	pop	r0

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
 3c6:	51 2c       	mov	r5, r1
		rprintf(" 0");							// First entry is always 0
 3c8:	20 e0       	ldi	r18, 0x00	; 0
 3ca:	30 e0       	ldi	r19, 0x00	; 0
 3cc:	3f 93       	push	r19
 3ce:	2f 93       	push	r18
 3d0:	81 e0       	ldi	r24, 0x01	; 1
 3d2:	8f 93       	push	r24
 3d4:	0e 94 00 00 	call	0	; 0x0 <xres>
 3d8:	0f 90       	pop	r0
 3da:	0f 90       	pop	r0
 3dc:	0f 90       	pop	r0
 3de:	80 e1       	ldi	r24, 0x10	; 16
 3e0:	e8 2e       	mov	r14, r24
 3e2:	f1 2c       	mov	r15, r1
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <getBlobs+0xc8>
			for (uint8_t index=0; index<AVRCAM_BINS; index++) {

				// Get the min and max colours
				uint8_t high,low;

				CAMERA_BIN* bin = &camera->_camera_.bins[index];
 3e6:	f8 01       	movw	r30, r16
 3e8:	a4 80       	ldd	r10, Z+4	; 0x04
 3ea:	b5 80       	ldd	r11, Z+5	; 0x05
 3ec:	ac 0c       	add	r10, r12
 3ee:	bd 1c       	adc	r11, r13
				COLOR min,max;
				COLOR_RGB* minRGB = color2rgb(&bin->min, &min);
 3f0:	be 01       	movw	r22, r28
 3f2:	6a 5e       	subi	r22, 0xEA	; 234
 3f4:	7f 4f       	sbci	r23, 0xFF	; 255
 3f6:	c5 01       	movw	r24, r10
 3f8:	0e 94 00 00 	call	0	; 0x0 <xres>
 3fc:	4c 01       	movw	r8, r24
				COLOR_RGB* maxRGB = color2rgb(&bin->max, &max);
 3fe:	be 01       	movw	r22, r28
 400:	6e 5e       	subi	r22, 0xEE	; 238
 402:	7f 4f       	sbci	r23, 0xFF	; 255
 404:	c5 01       	movw	r24, r10
 406:	04 96       	adiw	r24, 0x04	; 4
 408:	0e 94 00 00 	call	0	; 0x0 <xres>
 40c:	fc 01       	movw	r30, r24

				if (color==0) {
 40e:	51 10       	cpse	r5, r1
 410:	00 c0       	rjmp	.+0      	; 0x412 <getBlobs+0xf4>
					// Red
					high=maxRGB->r;
 412:	80 81       	ld	r24, Z
					low =minRGB->r;
 414:	d4 01       	movw	r26, r8
 416:	2c 91       	ld	r18, X
 418:	00 c0       	rjmp	.+0      	; 0x41a <getBlobs+0xfc>
				} else if (color==1) {
 41a:	b1 e0       	ldi	r27, 0x01	; 1
 41c:	5b 12       	cpse	r5, r27
 41e:	00 c0       	rjmp	.+0      	; 0x420 <getBlobs+0x102>
					// Green
					high=maxRGB->g;
 420:	81 81       	ldd	r24, Z+1	; 0x01
					low =minRGB->g;
 422:	f4 01       	movw	r30, r8
 424:	21 81       	ldd	r18, Z+1	; 0x01
 426:	00 c0       	rjmp	.+0      	; 0x428 <getBlobs+0x10a>
				} else if (color==2) {
					// Blue
					high=maxRGB->b;
 428:	82 81       	ldd	r24, Z+2	; 0x02
					low =minRGB->b;
 42a:	d4 01       	movw	r26, r8
 42c:	12 96       	adiw	r26, 0x02	; 2
 42e:	2c 91       	ld	r18, X
				}

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
 430:	30 e0       	ldi	r19, 0x00	; 0
 432:	e2 16       	cp	r14, r18
 434:	f3 06       	cpc	r15, r19
 436:	04 f0       	brlt	.+0      	; 0x438 <getBlobs+0x11a>
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	8e 15       	cp	r24, r14
 43c:	9f 05       	cpc	r25, r15
 43e:	04 f0       	brlt	.+0      	; 0x440 <getBlobs+0x122>
					entry |= 1<<index;
 440:	81 e0       	ldi	r24, 0x01	; 1
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	06 2c       	mov	r0, r6
 446:	00 c0       	rjmp	.+0      	; 0x448 <getBlobs+0x12a>
 448:	88 0f       	add	r24, r24
 44a:	0a 94       	dec	r0
 44c:	02 f4       	brpl	.+0      	; 0x44e <getBlobs+0x130>
 44e:	48 2a       	or	r4, r24
 450:	bf ef       	ldi	r27, 0xFF	; 255
 452:	6b 1a       	sub	r6, r27
 454:	7b 0a       	sbc	r7, r27
 456:	e9 e0       	ldi	r30, 0x09	; 9
 458:	ce 0e       	add	r12, r30
 45a:	d1 1c       	adc	r13, r1

		for(uint8_t i=1; i<16; i++) {			// Step through bits of the grid
			uint8_t entry=0;

			// Step through the color map entries
			for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 45c:	f8 e4       	ldi	r31, 0x48	; 72
 45e:	cf 16       	cp	r12, r31
 460:	d1 04       	cpc	r13, r1
 462:	01 f4       	brne	.+0      	; 0x464 <getBlobs+0x146>

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
					entry |= 1<<index;
				}											// Set bit
			}
			rprintf(" %d",entry);							// Send byte
 464:	1f 92       	push	r1
 466:	4f 92       	push	r4
 468:	80 e0       	ldi	r24, 0x00	; 0
 46a:	90 e0       	ldi	r25, 0x00	; 0
 46c:	9f 93       	push	r25
 46e:	8f 93       	push	r24
 470:	b1 e0       	ldi	r27, 0x01	; 1
 472:	bf 93       	push	r27
 474:	0e 94 00 00 	call	0	; 0x0 <xres>
 478:	e0 e1       	ldi	r30, 0x10	; 16
 47a:	ee 0e       	add	r14, r30
 47c:	f1 1c       	adc	r15, r1

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
		rprintf(" 0");							// First entry is always 0

		for(uint8_t i=1; i<16; i++) {			// Step through bits of the grid
 47e:	0f 90       	pop	r0
 480:	0f 90       	pop	r0
 482:	0f 90       	pop	r0
 484:	0f 90       	pop	r0
 486:	0f 90       	pop	r0
 488:	e1 14       	cp	r14, r1
 48a:	f1 e0       	ldi	r31, 0x01	; 1
 48c:	ff 06       	cpc	r15, r31
 48e:	01 f0       	breq	.+0      	; 0x490 <getBlobs+0x172>
					// Blue
					high=maxRGB->b;
					low =minRGB->b;
				}

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
 490:	c1 2c       	mov	r12, r1
 492:	d1 2c       	mov	r13, r1
 494:	61 2c       	mov	r6, r1
 496:	71 2c       	mov	r7, r1
 498:	41 2c       	mov	r4, r1
 49a:	00 c0       	rjmp	.+0      	; 0x49c <getBlobs+0x17e>

	// Command for set colour maps
	rprintf("SM");

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
 49c:	53 94       	inc	r5
 49e:	23 e0       	ldi	r18, 0x03	; 3
 4a0:	52 12       	cpse	r5, r18
 4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <getBlobs+0x186>
			}
			rprintf(" %d",entry);							// Send byte
		}
	}
	// Restore rprintf destination
	rprintfInit(old);
 4a4:	c1 01       	movw	r24, r2
 4a6:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Send a null command
	boolean rtn = sendCmd(camera, NULL);
 4aa:	60 e0       	ldi	r22, 0x00	; 0
 4ac:	70 e0       	ldi	r23, 0x00	; 0
 4ae:	c8 01       	movw	r24, r16
 4b0:	0e 94 00 00 	call	0	; 0x0 <xres>

	// If success - then clear all dirty flags
	if(rtn){
 4b4:	88 23       	and	r24, r24
 4b6:	01 f0       	breq	.+0      	; 0x4b8 <getBlobs+0x19a>
 4b8:	80 e0       	ldi	r24, 0x00	; 0
 4ba:	90 e0       	ldi	r25, 0x00	; 0
		for (uint8_t index=0; index<AVRCAM_BINS; index++) {
			CAMERA_BIN* bin = &camera->_camera_.bins[index];
			bin->dirty = FALSE;
 4bc:	d8 01       	movw	r26, r16
 4be:	14 96       	adiw	r26, 0x04	; 4
 4c0:	ed 91       	ld	r30, X+
 4c2:	fc 91       	ld	r31, X
 4c4:	15 97       	sbiw	r26, 0x05	; 5
 4c6:	e8 0f       	add	r30, r24
 4c8:	f9 1f       	adc	r31, r25
 4ca:	20 85       	ldd	r18, Z+8	; 0x08
 4cc:	2e 7f       	andi	r18, 0xFE	; 254
 4ce:	20 87       	std	Z+8, r18	; 0x08
 4d0:	09 96       	adiw	r24, 0x09	; 9
	// Send a null command
	boolean rtn = sendCmd(camera, NULL);

	// If success - then clear all dirty flags
	if(rtn){
		for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 4d2:	88 34       	cpi	r24, 0x48	; 72
 4d4:	91 05       	cpc	r25, r1
 4d6:	01 f4       	brne	.+0      	; 0x4d8 <getBlobs+0x1ba>
 4d8:	00 c0       	rjmp	.+0      	; 0x4da <getBlobs+0x1bc>
	if(!camera->tracking) {
		// Send any colour bin changes
		if(sendBins(camera)){
			// Now put into tracing mode
			if(sendCmd(camera, "ET")){
				camera->tracking = TRUE;
 4da:	f8 01       	movw	r30, r16
 4dc:	85 85       	ldd	r24, Z+13	; 0x0d
 4de:	ff ef       	ldi	r31, 0xFF	; 255
 4e0:	f0 fb       	bst	r31, 0
 4e2:	80 f9       	bld	r24, 0
 4e4:	d8 01       	movw	r26, r16
 4e6:	1d 96       	adiw	r26, 0x0d	; 13
 4e8:	8c 93       	st	X, r24
			}
		}
	}
	return (camera->tracking) ? TRUE : FALSE;
 4ea:	f8 01       	movw	r30, r16
 4ec:	85 85       	ldd	r24, Z+13	; 0x0d
 4ee:	80 fd       	sbrc	r24, 0
 4f0:	00 c0       	rjmp	.+0      	; 0x4f2 <getBlobs+0x1d4>
				}
			}
		}
	}
	// Make sure tracking is off
	trackStop(avrcam);
 4f2:	c8 01       	movw	r24, r16
 4f4:	0e 94 00 00 	call	0	; 0x0 <xres>
	return camera->numBlobs;
 4f8:	d8 01       	movw	r26, r16
 4fa:	1c 96       	adiw	r26, 0x0c	; 12
 4fc:	8c 91       	ld	r24, X
 4fe:	00 c0       	rjmp	.+0      	; 0x500 <getBlobs+0x1e2>

		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
		if (len>0) {
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
 500:	e0 90 00 00 	lds	r14, 0x0000
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 504:	f1 2c       	mov	r15, r1

		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
		if (len>0) {
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
 506:	21 e0       	ldi	r18, 0x01	; 1
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 508:	00 c0       	rjmp	.+0      	; 0x50a <getBlobs+0x1ec>
				CAMERA_BLOB aBlob;									// Build the blob info here

				aBlob.bin = response[ptr++];						// Get the color bin
 50a:	e2 2f       	mov	r30, r18
 50c:	f0 e0       	ldi	r31, 0x00	; 0
 50e:	e0 50       	subi	r30, 0x00	; 0
 510:	f0 40       	sbci	r31, 0x00	; 0
 512:	80 81       	ld	r24, Z
 514:	89 8b       	std	Y+17, r24	; 0x11
 516:	e2 2f       	mov	r30, r18
 518:	ef 5f       	subi	r30, 0xFF	; 255
				aBlob.left = response[ptr++];						// Get left
 51a:	f0 e0       	ldi	r31, 0x00	; 0
 51c:	e0 50       	subi	r30, 0x00	; 0
 51e:	f0 40       	sbci	r31, 0x00	; 0
 520:	90 81       	ld	r25, Z
 522:	99 83       	std	Y+1, r25	; 0x01
 524:	1a 82       	std	Y+2, r1	; 0x02
 526:	e2 2f       	mov	r30, r18
 528:	ee 5f       	subi	r30, 0xFE	; 254
				aBlob.top  = response[ptr++];						// Get top
 52a:	f0 e0       	ldi	r31, 0x00	; 0
 52c:	e0 50       	subi	r30, 0x00	; 0
 52e:	f0 40       	sbci	r31, 0x00	; 0
 530:	90 81       	ld	r25, Z
 532:	9d 83       	std	Y+5, r25	; 0x05
 534:	1e 82       	std	Y+6, r1	; 0x06
				aBlob.right = response[ptr++];						// Get right
 536:	e2 2f       	mov	r30, r18
 538:	ec 5f       	subi	r30, 0xFC	; 252
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
				CAMERA_BLOB aBlob;									// Build the blob info here

				aBlob.bin = response[ptr++];						// Get the color bin
				aBlob.left = response[ptr++];						// Get left
				aBlob.top  = response[ptr++];						// Get top
 53a:	a2 2f       	mov	r26, r18
 53c:	ad 5f       	subi	r26, 0xFD	; 253
				aBlob.right = response[ptr++];						// Get right
 53e:	b0 e0       	ldi	r27, 0x00	; 0
 540:	a0 50       	subi	r26, 0x00	; 0
 542:	b0 40       	sbci	r27, 0x00	; 0
 544:	9c 91       	ld	r25, X
 546:	9b 83       	std	Y+3, r25	; 0x03
 548:	1c 82       	std	Y+4, r1	; 0x04
				aBlob.bottom  = response[ptr++];					// Get bottom
 54a:	2b 5f       	subi	r18, 0xFB	; 251
 54c:	f0 e0       	ldi	r31, 0x00	; 0
 54e:	e0 50       	subi	r30, 0x00	; 0
 550:	f0 40       	sbci	r31, 0x00	; 0
 552:	90 81       	ld	r25, Z
 554:	9f 83       	std	Y+7, r25	; 0x07
 556:	18 86       	std	Y+8, r1	; 0x08

				// Ignore if it is not for the correct bin
				if(bin == CAMERA_ALL_BINS || aBlob.bin == bin){
 558:	ba 8d       	ldd	r27, Y+26	; 0x1a
 55a:	bf 3f       	cpi	r27, 0xFF	; 255
 55c:	01 f0       	breq	.+0      	; 0x55e <getBlobs+0x240>
 55e:	8b 13       	cpse	r24, r27
 560:	00 c0       	rjmp	.+0      	; 0x562 <getBlobs+0x244>
					_cameraInsertBlob(camera,&aBlob);
 562:	be 01       	movw	r22, r28
 564:	6f 5f       	subi	r22, 0xFF	; 255
 566:	7f 4f       	sbci	r23, 0xFF	; 255
 568:	c8 01       	movw	r24, r16
 56a:	2b 8f       	std	Y+27, r18	; 0x1b
 56c:	0e 94 00 00 	call	0	; 0x0 <xres>
 570:	2b 8d       	ldd	r18, Y+27	; 0x1b
		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
		if (len>0) {
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 572:	f3 94       	inc	r15
 574:	fe 10       	cpse	r15, r14
 576:	00 c0       	rjmp	.+0      	; 0x578 <getBlobs+0x25a>
 578:	00 c0       	rjmp	.+0      	; 0x57a <getBlobs+0x25c>
static boolean trackStart(AVRCAM* camera) {
	if(!camera->tracking) {
		// Send any colour bin changes
		if(sendBins(camera)){
			// Now put into tracing mode
			if(sendCmd(camera, "ET")){
 57a:	60 e0       	ldi	r22, 0x00	; 0
 57c:	70 e0       	ldi	r23, 0x00	; 0
 57e:	c8 01       	movw	r24, r16
 580:	0e 94 00 00 	call	0	; 0x0 <xres>
 584:	81 11       	cpse	r24, r1
 586:	00 c0       	rjmp	.+0      	; 0x588 <getBlobs+0x26a>
 588:	00 c0       	rjmp	.+0      	; 0x58a <getBlobs+0x26c>

	if(trackStart(avrcam)){
		// ok we are in tracking mode

		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
 58a:	20 e0       	ldi	r18, 0x00	; 0
 58c:	30 e0       	ldi	r19, 0x00	; 0
 58e:	4f ef       	ldi	r20, 0xFF	; 255
 590:	6a e0       	ldi	r22, 0x0A	; 10
 592:	c8 01       	movw	r24, r16
 594:	02 96       	adiw	r24, 0x02	; 2
 596:	0e 94 00 00 	call	0	; 0x0 <xres>
		if (len>0) {
 59a:	89 2b       	or	r24, r25
 59c:	01 f0       	breq	.+0      	; 0x59e <getBlobs+0x280>
 59e:	00 c0       	rjmp	.+0      	; 0x5a0 <getBlobs+0x282>
 5a0:	00 c0       	rjmp	.+0      	; 0x5a2 <getBlobs+0x284>
		}
	}
	// Make sure tracking is off
	trackStop(avrcam);
	return camera->numBlobs;
}
 5a2:	6b 96       	adiw	r28, 0x1b	; 27
 5a4:	0f b6       	in	r0, 0x3f	; 63
 5a6:	f8 94       	cli
 5a8:	de bf       	out	0x3e, r29	; 62
 5aa:	0f be       	out	0x3f, r0	; 63
 5ac:	cd bf       	out	0x3d, r28	; 61
 5ae:	df 91       	pop	r29
 5b0:	cf 91       	pop	r28
 5b2:	1f 91       	pop	r17
 5b4:	0f 91       	pop	r16
 5b6:	ff 90       	pop	r15
 5b8:	ef 90       	pop	r14
 5ba:	df 90       	pop	r13
 5bc:	cf 90       	pop	r12
 5be:	bf 90       	pop	r11
 5c0:	af 90       	pop	r10
 5c2:	9f 90       	pop	r9
 5c4:	8f 90       	pop	r8
 5c6:	7f 90       	pop	r7
 5c8:	6f 90       	pop	r6
 5ca:	5f 90       	pop	r5
 5cc:	4f 90       	pop	r4
 5ce:	3f 90       	pop	r3
 5d0:	2f 90       	pop	r2
 5d2:	08 95       	ret

000005d4 <getPixel>:
	boolean rtn = sendCmd(avrcam, NULL);
	rprintfInit(old);
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
 5d4:	2f 92       	push	r2
 5d6:	3f 92       	push	r3
 5d8:	4f 92       	push	r4
 5da:	5f 92       	push	r5
 5dc:	6f 92       	push	r6
 5de:	7f 92       	push	r7
 5e0:	8f 92       	push	r8
 5e2:	9f 92       	push	r9
 5e4:	af 92       	push	r10
 5e6:	bf 92       	push	r11
 5e8:	cf 92       	push	r12
 5ea:	df 92       	push	r13
 5ec:	ef 92       	push	r14
 5ee:	ff 92       	push	r15
 5f0:	0f 93       	push	r16
 5f2:	1f 93       	push	r17
 5f4:	cf 93       	push	r28
 5f6:	df 93       	push	r29
 5f8:	cd b7       	in	r28, 0x3d	; 61
 5fa:	de b7       	in	r29, 0x3e	; 62
 5fc:	61 97       	sbiw	r28, 0x11	; 17
 5fe:	0f b6       	in	r0, 0x3f	; 63
 600:	f8 94       	cli
 602:	de bf       	out	0x3e, r29	; 62
 604:	0f be       	out	0x3f, r0	; 63
 606:	cd bf       	out	0x3d, r28	; 61
 608:	9e 83       	std	Y+6, r25	; 0x06
 60a:	8d 83       	std	Y+5, r24	; 0x05
 60c:	8b 01       	movw	r16, r22
 60e:	7a 01       	movw	r14, r20
 610:	39 8b       	std	Y+17, r19	; 0x11
 612:	28 8b       	std	Y+16, r18	; 0x10
	COLOR  clrMax;
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
 614:	60 e0       	ldi	r22, 0x00	; 0
 616:	70 e0       	ldi	r23, 0x00	; 0
 618:	0e 94 00 00 	call	0	; 0x0 <xres>
 61c:	88 23       	and	r24, r24
 61e:	01 f4       	brne	.+0      	; 0x620 <getPixel+0x4c>
 620:	00 c0       	rjmp	.+0      	; 0x622 <getPixel+0x4e>
// A frame DUMP can take 4 seconds to transmit all of its data so very slow!
static boolean sampleRectangle(AVRCAM* avrcam, uint16_t minX, uint16_t minY, uint16_t width, uint16_t height,
		COLOR* rtnMin, COLOR *rtnMax, COLOR* rtnMean
		) {
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
 622:	98 01       	movw	r18, r16
 624:	36 95       	lsr	r19
 626:	27 95       	ror	r18
 628:	38 87       	std	Y+8, r19	; 0x08
 62a:	2f 83       	std	Y+7, r18	; 0x07
 62c:	29 87       	std	Y+9, r18	; 0x09
	uint8_t rectMinY = minY / 2;
 62e:	f6 94       	lsr	r15
 630:	e7 94       	ror	r14
 632:	ea 86       	std	Y+10, r14	; 0x0a
	if(sendCmd(avrcam, "DF")) {
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;

		// Takes a while for data to start
		delay_ms(1000);
 634:	68 ee       	ldi	r22, 0xE8	; 232
 636:	73 e0       	ldi	r23, 0x03	; 3
 638:	80 e0       	ldi	r24, 0x00	; 0
 63a:	90 e0       	ldi	r25, 0x00	; 0
 63c:	0e 94 00 00 	call	0	; 0x0 <xres>
 640:	59 e4       	ldi	r21, 0x49	; 73
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;
 642:	21 2c       	mov	r2, r1
 644:	31 2c       	mov	r3, r1
 646:	1c 82       	std	Y+4, r1	; 0x04
 648:	1b 82       	std	Y+3, r1	; 0x03
 64a:	1a 82       	std	Y+2, r1	; 0x02
 64c:	19 82       	std	Y+1, r1	; 0x01
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
		totalRed=totalGreen=totalBlue=0;
 64e:	81 2c       	mov	r8, r1
 650:	91 2c       	mov	r9, r1
 652:	54 01       	movw	r10, r8
 654:	c1 2c       	mov	r12, r1
 656:	d1 2c       	mov	r13, r1
 658:	76 01       	movw	r14, r12
 65a:	41 2c       	mov	r4, r1
 65c:	51 2c       	mov	r5, r1
 65e:	32 01       	movw	r6, r4
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
	uint8_t rectMinY = minY / 2;
	uint8_t rectMaxX = rectMinX + (width+1)/2;
	uint8_t rectMaxY = rectMinY + (height+1)/2;
	boolean first = TRUE;
 660:	1f ef       	ldi	r17, 0xFF	; 255
	return sampleRectangle((AVRCAM*)camera, x,y,1,1,NULL,NULL,color);
}


// Create the class for the AVRcam
const CAMERA_CLASS c_avrcam = MAKE_CAMERA_CLASS( &init, &xres, &yres, AVRCAM_BINS, AVRCAM_BLOBS,&setBin, &getBlobs, &getPixel, &getVersion);
 662:	8d 81       	ldd	r24, Y+5	; 0x05
 664:	9e 81       	ldd	r25, Y+6	; 0x06
 666:	02 96       	adiw	r24, 0x02	; 2
 668:	9c 87       	std	Y+12, r25	; 0x0c
 66a:	8b 87       	std	Y+11, r24	; 0x0b
		) {
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
	uint8_t rectMinY = minY / 2;
	uint8_t rectMaxX = rectMinX + (width+1)/2;
	uint8_t rectMaxY = rectMinY + (height+1)/2;
 66c:	7a 85       	ldd	r23, Y+10	; 0x0a
 66e:	7f 5f       	subi	r23, 0xFF	; 255
		COLOR* rtnMin, COLOR *rtnMax, COLOR* rtnMean
		) {
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
	uint8_t rectMinY = minY / 2;
	uint8_t rectMaxX = rectMinX + (width+1)/2;
 670:	99 85       	ldd	r25, Y+9	; 0x09
 672:	9f 5f       	subi	r25, 0xFF	; 255
 674:	9d 87       	std	Y+13, r25	; 0x0d
 676:	00 c0       	rjmp	.+0      	; 0x678 <getPixel+0xa4>

		// Takes a while for data to start
		delay_ms(1000);
		while(cnt--) {
			// NB line numbers can be sent in any order
			size_t len=getResponse(avrcam,0x0B,0x0F,2,0);
 678:	22 e0       	ldi	r18, 0x02	; 2
 67a:	30 e0       	ldi	r19, 0x00	; 0
 67c:	4f e0       	ldi	r20, 0x0F	; 15
 67e:	6b e0       	ldi	r22, 0x0B	; 11
 680:	8b 85       	ldd	r24, Y+11	; 0x0b
 682:	9c 85       	ldd	r25, Y+12	; 0x0c
 684:	5e 87       	std	Y+14, r21	; 0x0e
 686:	7f 87       	std	Y+15, r23	; 0x0f
 688:	0e 94 00 00 	call	0	; 0x0 <xres>
			uint8_t line=response[0];
 68c:	20 91 00 00 	lds	r18, 0x0000
			if(len==177) {
 690:	5e 85       	ldd	r21, Y+14	; 0x0e
 692:	7f 85       	ldd	r23, Y+15	; 0x0f
 694:	81 3b       	cpi	r24, 0xB1	; 177
 696:	91 05       	cpc	r25, r1
 698:	01 f0       	breq	.+0      	; 0x69a <getPixel+0xc6>
 69a:	00 c0       	rjmp	.+0      	; 0x69c <getPixel+0xc8>
				if(line>=rectMinY && line<=rectMaxY) {
 69c:	aa 85       	ldd	r26, Y+10	; 0x0a
 69e:	2a 17       	cp	r18, r26
 6a0:	00 f4       	brcc	.+0      	; 0x6a2 <getPixel+0xce>
 6a2:	00 c0       	rjmp	.+0      	; 0x6a4 <getPixel+0xd0>
 6a4:	72 17       	cp	r23, r18
 6a6:	00 f0       	brcs	.+0      	; 0x6a8 <getPixel+0xd4>
 6a8:	00 c0       	rjmp	.+0      	; 0x6aa <getPixel+0xd6>
 6aa:	00 c0       	rjmp	.+0      	; 0x6ac <getPixel+0xd8>
	boolean rtn = sendCmd(avrcam, NULL);
	rprintfInit(old);
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
 6ac:	9f 81       	ldd	r25, Y+7	; 0x07
 6ae:	92 0f       	add	r25, r18
 6b0:	99 0f       	add	r25, r25
 6b2:	9f 5f       	subi	r25, 0xFF	; 255
					// The line number is in range
					// So process the required X pixels
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
						uint8_t ptr=1+i*2;
						// Get the rgb colours for the pixel
						uint8_t x1=response[ptr];
 6b4:	a9 2f       	mov	r26, r25
 6b6:	b0 e0       	ldi	r27, 0x00	; 0
 6b8:	a0 50       	subi	r26, 0x00	; 0
 6ba:	b0 40       	sbci	r27, 0x00	; 0
 6bc:	8c 91       	ld	r24, X
						uint8_t x2=response[ptr+1];
 6be:	11 96       	adiw	r26, 0x01	; 1
 6c0:	2c 91       	ld	r18, X
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
						uint8_t gL=MIN(g1,g2);

						if(first) {
 6c2:	11 11       	cpse	r17, r1
 6c4:	00 c0       	rjmp	.+0      	; 0x6c6 <getPixel+0xf2>
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
						uint8_t ptr=1+i*2;
						// Get the rgb colours for the pixel
						uint8_t x1=response[ptr];
						uint8_t x2=response[ptr+1];
						uint8_t	g1=x1&0xF0;
 6c6:	98 2f       	mov	r25, r24
 6c8:	90 7f       	andi	r25, 0xF0	; 240
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
 6ca:	42 2f       	mov	r20, r18
 6cc:	40 7f       	andi	r20, 0xF0	; 240

							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
 6ce:	22 95       	swap	r18
 6d0:	20 7f       	andi	r18, 0xF0	; 240
 6d2:	42 0e       	add	r4, r18
 6d4:	51 1c       	adc	r5, r1
 6d6:	61 1c       	adc	r6, r1
 6d8:	71 1c       	adc	r7, r1
 6da:	29 81       	ldd	r18, Y+1	; 0x01
 6dc:	3a 81       	ldd	r19, Y+2	; 0x02
 6de:	2f 5f       	subi	r18, 0xFF	; 255
 6e0:	3f 4f       	sbci	r19, 0xFF	; 255
 6e2:	3a 83       	std	Y+2, r19	; 0x02
 6e4:	29 83       	std	Y+1, r18	; 0x01
						uint8_t	g1=x1&0xF0;
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
						uint8_t gL=MIN(g1,g2);
 6e6:	04 2f       	mov	r16, r20
 6e8:	94 17       	cp	r25, r20
 6ea:	00 f4       	brcc	.+0      	; 0x6ec <getPixel+0x118>
 6ec:	09 2f       	mov	r16, r25
							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
							totalGreen += gL;
 6ee:	10 e0       	ldi	r17, 0x00	; 0
 6f0:	20 e0       	ldi	r18, 0x00	; 0
 6f2:	30 e0       	ldi	r19, 0x00	; 0
						uint8_t x2=response[ptr+1];
						uint8_t	g1=x1&0xF0;
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
 6f4:	49 17       	cp	r20, r25
 6f6:	00 f4       	brcc	.+0      	; 0x6f8 <getPixel+0x124>
 6f8:	49 2f       	mov	r20, r25
							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
							totalGreen += gL;
 6fa:	04 0f       	add	r16, r20
 6fc:	11 1d       	adc	r17, r1
 6fe:	21 1d       	adc	r18, r1
 700:	31 1d       	adc	r19, r1
							totalGreen += gH; numGreen+=2;
 702:	c0 0e       	add	r12, r16
 704:	d1 1e       	adc	r13, r17
 706:	e2 1e       	adc	r14, r18
 708:	f3 1e       	adc	r15, r19
 70a:	ab 81       	ldd	r26, Y+3	; 0x03
 70c:	bc 81       	ldd	r27, Y+4	; 0x04
 70e:	12 96       	adiw	r26, 0x02	; 2
 710:	bc 83       	std	Y+4, r27	; 0x04
 712:	ab 83       	std	Y+3, r26	; 0x03
							totalBlue += b; ++numBlue;
 714:	82 95       	swap	r24
 716:	80 7f       	andi	r24, 0xF0	; 240
 718:	88 0e       	add	r8, r24
 71a:	91 1c       	adc	r9, r1
 71c:	a1 1c       	adc	r10, r1
 71e:	b1 1c       	adc	r11, r1
 720:	bf ef       	ldi	r27, 0xFF	; 255
 722:	2b 1a       	sub	r2, r27
 724:	3b 0a       	sbc	r3, r27
 726:	31 96       	adiw	r30, 0x01	; 1
 728:	10 e0       	ldi	r17, 0x00	; 0
 72a:	00 c0       	rjmp	.+0      	; 0x72c <getPixel+0x158>
		while(cnt--) {
			// NB line numbers can be sent in any order
			size_t len=getResponse(avrcam,0x0B,0x0F,2,0);
			uint8_t line=response[0];
			if(len==177) {
				if(line>=rectMinY && line<=rectMaxY) {
 72c:	e0 e0       	ldi	r30, 0x00	; 0
 72e:	f0 e0       	ldi	r31, 0x00	; 0
	boolean rtn = sendCmd(avrcam, NULL);
	rprintfInit(old);
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
 730:	2e 2f       	mov	r18, r30
			uint8_t line=response[0];
			if(len==177) {
				if(line>=rectMinY && line<=rectMaxY) {
					// The line number is in range
					// So process the required X pixels
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
 732:	89 85       	ldd	r24, Y+9	; 0x09
 734:	8e 0f       	add	r24, r30
 736:	3d 85       	ldd	r19, Y+13	; 0x0d
 738:	38 17       	cp	r19, r24
 73a:	00 f0       	brcs	.+0      	; 0x73c <getPixel+0x168>
 73c:	00 c0       	rjmp	.+0      	; 0x73e <getPixel+0x16a>
 73e:	51 50       	subi	r21, 0x01	; 1
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;

		// Takes a while for data to start
		delay_ms(1000);
		while(cnt--) {
 740:	01 f0       	breq	.+0      	; 0x742 <getPixel+0x16e>
 742:	00 c0       	rjmp	.+0      	; 0x744 <getPixel+0x170>
 744:	00 c0       	rjmp	.+0      	; 0x746 <getPixel+0x172>
		}
		if(rtnMax){
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
			totalRed = (numRed==0) ? 0 : totalRed / numRed;
 746:	89 81       	ldd	r24, Y+1	; 0x01
 748:	9a 81       	ldd	r25, Y+2	; 0x02
 74a:	00 97       	sbiw	r24, 0x00	; 0
 74c:	01 f0       	breq	.+0      	; 0x74e <getPixel+0x17a>
 74e:	9c 01       	movw	r18, r24
 750:	40 e0       	ldi	r20, 0x00	; 0
 752:	50 e0       	ldi	r21, 0x00	; 0
 754:	c3 01       	movw	r24, r6
 756:	b2 01       	movw	r22, r4
 758:	0e 94 00 00 	call	0	; 0x0 <xres>
 75c:	29 01       	movw	r4, r18
 75e:	3a 01       	movw	r6, r20
 760:	00 c0       	rjmp	.+0      	; 0x762 <getPixel+0x18e>
 762:	41 2c       	mov	r4, r1
 764:	51 2c       	mov	r5, r1
 766:	32 01       	movw	r6, r4
			totalGreen = (numGreen==0) ? 0 : totalGreen / numGreen;
 768:	ab 81       	ldd	r26, Y+3	; 0x03
 76a:	bc 81       	ldd	r27, Y+4	; 0x04
 76c:	10 97       	sbiw	r26, 0x00	; 0
 76e:	01 f0       	breq	.+0      	; 0x770 <getPixel+0x19c>
 770:	9d 01       	movw	r18, r26
 772:	40 e0       	ldi	r20, 0x00	; 0
 774:	50 e0       	ldi	r21, 0x00	; 0
 776:	c7 01       	movw	r24, r14
 778:	b6 01       	movw	r22, r12
 77a:	0e 94 00 00 	call	0	; 0x0 <xres>
 77e:	69 01       	movw	r12, r18
 780:	7a 01       	movw	r14, r20
 782:	00 c0       	rjmp	.+0      	; 0x784 <getPixel+0x1b0>
 784:	c1 2c       	mov	r12, r1
 786:	d1 2c       	mov	r13, r1
 788:	76 01       	movw	r14, r12
			totalBlue = (numBlue==0) ? 0 : totalBlue / numBlue;
 78a:	21 14       	cp	r2, r1
 78c:	31 04       	cpc	r3, r1
 78e:	01 f0       	breq	.+0      	; 0x790 <getPixel+0x1bc>
 790:	91 01       	movw	r18, r2
 792:	40 e0       	ldi	r20, 0x00	; 0
 794:	50 e0       	ldi	r21, 0x00	; 0
 796:	c5 01       	movw	r24, r10
 798:	b4 01       	movw	r22, r8
 79a:	0e 94 00 00 	call	0	; 0x0 <xres>
 79e:	00 c0       	rjmp	.+0      	; 0x7a0 <getPixel+0x1cc>
 7a0:	20 e0       	ldi	r18, 0x00	; 0
 7a2:	30 e0       	ldi	r19, 0x00	; 0
 7a4:	a9 01       	movw	r20, r18

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 7a6:	e8 89       	ldd	r30, Y+16	; 0x10
 7a8:	f9 89       	ldd	r31, Y+17	; 0x11
 7aa:	10 82       	st	Z, r1
			colorSetRGB(rtnMean, (uint8_t)totalRed, (uint8_t)totalGreen, (uint8_t)totalBlue);
 7ac:	41 82       	std	Z+1, r4	; 0x01
 7ae:	c2 82       	std	Z+2, r12	; 0x02
 7b0:	23 83       	std	Z+3, r18	; 0x03
 7b2:	00 c0       	rjmp	.+0      	; 0x7b4 <getPixel+0x1e0>
			colorSetRGB(rtnMin,clrMin.bands.rgb.r,clrMin.bands.rgb.g,clrMin.bands.rgb.b);
		}
		if(rtnMax){
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
 7b4:	e8 89       	ldd	r30, Y+16	; 0x10
 7b6:	f9 89       	ldd	r31, Y+17	; 0x11
 7b8:	ef 2b       	or	r30, r31
 7ba:	01 f4       	brne	.+0      	; 0x7bc <getPixel+0x1e8>
	boolean first = TRUE;
	COLOR  clrMin;
	COLOR  clrMax;
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;
 7bc:	1f ef       	ldi	r17, 0xFF	; 255
 7be:	00 c0       	rjmp	.+0      	; 0x7c0 <getPixel+0x1ec>
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
			totalRed = (numRed==0) ? 0 : totalRed / numRed;
			totalGreen = (numGreen==0) ? 0 : totalGreen / numGreen;
			totalBlue = (numBlue==0) ? 0 : totalBlue / numBlue;
 7c0:	10 e0       	ldi	r17, 0x00	; 0
			colorSetRGB(rtnMean, (uint8_t)totalRed, (uint8_t)totalGreen, (uint8_t)totalBlue);
		}
	}

	// Flush out anything left over
	flush(avrcam);
 7c2:	ad 81       	ldd	r26, Y+5	; 0x05
 7c4:	be 81       	ldd	r27, Y+6	; 0x06
 7c6:	12 96       	adiw	r26, 0x02	; 2
 7c8:	8d 91       	ld	r24, X+
 7ca:	9c 91       	ld	r25, X
 7cc:	13 97       	sbiw	r26, 0x03	; 3
 7ce:	0e 94 00 00 	call	0	; 0x0 <xres>
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
	return sampleRectangle((AVRCAM*)camera, x,y,1,1,NULL,NULL,color);
}
 7d2:	81 2f       	mov	r24, r17
 7d4:	61 96       	adiw	r28, 0x11	; 17
 7d6:	0f b6       	in	r0, 0x3f	; 63
 7d8:	f8 94       	cli
 7da:	de bf       	out	0x3e, r29	; 62
 7dc:	0f be       	out	0x3f, r0	; 63
 7de:	cd bf       	out	0x3d, r28	; 61
 7e0:	df 91       	pop	r29
 7e2:	cf 91       	pop	r28
 7e4:	1f 91       	pop	r17
 7e6:	0f 91       	pop	r16
 7e8:	ff 90       	pop	r15
 7ea:	ef 90       	pop	r14
 7ec:	df 90       	pop	r13
 7ee:	cf 90       	pop	r12
 7f0:	bf 90       	pop	r11
 7f2:	af 90       	pop	r10
 7f4:	9f 90       	pop	r9
 7f6:	8f 90       	pop	r8
 7f8:	7f 90       	pop	r7
 7fa:	6f 90       	pop	r6
 7fc:	5f 90       	pop	r5
 7fe:	4f 90       	pop	r4
 800:	3f 90       	pop	r3
 802:	2f 90       	pop	r2
 804:	08 95       	ret

00000806 <setCameraReg>:
	flush(avrcam);
	return rtn;
}

// Set a register
static boolean setCameraReg(AVRCAM* avrcam, uint8_t reg, uint8_t val) {
 806:	ef 92       	push	r14
 808:	ff 92       	push	r15
 80a:	0f 93       	push	r16
 80c:	1f 93       	push	r17
 80e:	cf 93       	push	r28
 810:	df 93       	push	r29
 812:	00 d0       	rcall	.+0      	; 0x814 <setCameraReg+0xe>
 814:	cd b7       	in	r28, 0x3d	; 61
 816:	de b7       	in	r29, 0x3e	; 62
 818:	7c 01       	movw	r14, r24
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 81a:	fc 01       	movw	r30, r24
 81c:	82 81       	ldd	r24, Z+2	; 0x02
 81e:	93 81       	ldd	r25, Z+3	; 0x03
 820:	90 93 00 00 	sts	0x0000, r25
 824:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 828:	80 e0       	ldi	r24, 0x00	; 0
 82a:	90 e0       	ldi	r25, 0x00	; 0
 82c:	4a 83       	std	Y+2, r20	; 0x02
 82e:	69 83       	std	Y+1, r22	; 0x01
 830:	0e 94 00 00 	call	0	; 0x0 <xres>
 834:	8c 01       	movw	r16, r24
}

// Set a register
static boolean setCameraReg(AVRCAM* avrcam, uint8_t reg, uint8_t val) {
	Writer old = setActive(avrcam);
	rprintf("CR %d %d",reg,val);
 836:	1f 92       	push	r1
 838:	4a 81       	ldd	r20, Y+2	; 0x02
 83a:	4f 93       	push	r20
 83c:	1f 92       	push	r1
 83e:	69 81       	ldd	r22, Y+1	; 0x01
 840:	6f 93       	push	r22
 842:	20 e0       	ldi	r18, 0x00	; 0
 844:	30 e0       	ldi	r19, 0x00	; 0
 846:	3f 93       	push	r19
 848:	2f 93       	push	r18
 84a:	81 e0       	ldi	r24, 0x01	; 1
 84c:	8f 93       	push	r24
 84e:	0e 94 00 00 	call	0	; 0x0 <xres>
	boolean rtn = sendCmd(avrcam, NULL);
 852:	60 e0       	ldi	r22, 0x00	; 0
 854:	70 e0       	ldi	r23, 0x00	; 0
 856:	c7 01       	movw	r24, r14
 858:	0e 94 00 00 	call	0	; 0x0 <xres>
 85c:	f8 2e       	mov	r15, r24
	rprintfInit(old);
 85e:	c8 01       	movw	r24, r16
 860:	0e 94 00 00 	call	0	; 0x0 <xres>
	return rtn;
 864:	0f b6       	in	r0, 0x3f	; 63
 866:	f8 94       	cli
 868:	de bf       	out	0x3e, r29	; 62
 86a:	0f be       	out	0x3f, r0	; 63
 86c:	cd bf       	out	0x3d, r28	; 61
}
 86e:	8f 2d       	mov	r24, r15
 870:	0f 90       	pop	r0
 872:	0f 90       	pop	r0
 874:	df 91       	pop	r29
 876:	cf 91       	pop	r28
 878:	1f 91       	pop	r17
 87a:	0f 91       	pop	r16
 87c:	ff 90       	pop	r15
 87e:	ef 90       	pop	r14
 880:	08 95       	ret

00000882 <init>:
	active = camera->_camera_.uart;
	return rprintfInit(&sendChar);
}


static void init(CAMERA* camera){
 882:	bf 92       	push	r11
 884:	cf 92       	push	r12
 886:	df 92       	push	r13
 888:	ef 92       	push	r14
 88a:	ff 92       	push	r15
 88c:	0f 93       	push	r16
 88e:	1f 93       	push	r17
 890:	cf 93       	push	r28
 892:	df 93       	push	r29
 894:	cd b7       	in	r28, 0x3d	; 61
 896:	de b7       	in	r29, 0x3e	; 62
 898:	28 97       	sbiw	r28, 0x08	; 8
 89a:	0f b6       	in	r0, 0x3f	; 63
 89c:	f8 94       	cli
 89e:	de bf       	out	0x3e, r29	; 62
 8a0:	0f be       	out	0x3f, r0	; 63
 8a2:	cd bf       	out	0x3d, r28	; 61
 8a4:	8c 01       	movw	r16, r24
	AVRCAM* avrcam = (AVRCAM*)camera;

	// set camera to 115200 baud - this is fixed by the camera
	_uartInit(avrcam->_camera_.uart, (BAUD_RATE) 115200);
 8a6:	40 e0       	ldi	r20, 0x00	; 0
 8a8:	52 ec       	ldi	r21, 0xC2	; 194
 8aa:	61 e0       	ldi	r22, 0x01	; 1
 8ac:	70 e0       	ldi	r23, 0x00	; 0
 8ae:	dc 01       	movw	r26, r24
 8b0:	12 96       	adiw	r26, 0x02	; 2
 8b2:	8d 91       	ld	r24, X+
 8b4:	9c 91       	ld	r25, X
 8b6:	13 97       	sbiw	r26, 0x03	; 3
 8b8:	0e 94 00 00 	call	0	; 0x0 <xres>
	flush(avrcam);
 8bc:	f8 01       	movw	r30, r16
 8be:	82 81       	ldd	r24, Z+2	; 0x02
 8c0:	93 81       	ldd	r25, Z+3	; 0x03
 8c2:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Make sure tracking mode is turned off
	trackStop(avrcam);
 8c6:	c8 01       	movw	r24, r16
 8c8:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Make RAM space for the colour bins
	if(camera->bins == NULL){
 8cc:	d8 01       	movw	r26, r16
 8ce:	14 96       	adiw	r26, 0x04	; 4
 8d0:	8d 91       	ld	r24, X+
 8d2:	9c 91       	ld	r25, X
 8d4:	15 97       	sbiw	r26, 0x05	; 5
 8d6:	89 2b       	or	r24, r25
 8d8:	01 f4       	brne	.+0      	; 0x8da <init+0x58>
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
 8da:	88 e4       	ldi	r24, 0x48	; 72
 8dc:	90 e0       	ldi	r25, 0x00	; 0
 8de:	0e 94 00 00 	call	0	; 0x0 <xres>
 8e2:	f8 01       	movw	r30, r16
 8e4:	84 83       	std	Z+4, r24	; 0x04
 8e6:	95 83       	std	Z+5, r25	; 0x05
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
 8e8:	d8 01       	movw	r26, r16
 8ea:	14 96       	adiw	r26, 0x04	; 4
 8ec:	8d 91       	ld	r24, X+
 8ee:	9c 91       	ld	r25, X
 8f0:	15 97       	sbiw	r26, 0x05	; 5
 8f2:	89 2b       	or	r24, r25
 8f4:	01 f4       	brne	.+0      	; 0x8f6 <init+0x74>
			}
		}
	}

	// Allocate space for blobs
	if(camera->blobs == null){
 8f6:	f8 01       	movw	r30, r16
 8f8:	86 81       	ldd	r24, Z+6	; 0x06
 8fa:	97 81       	ldd	r25, Z+7	; 0x07
 8fc:	89 2b       	or	r24, r25
 8fe:	01 f0       	breq	.+0      	; 0x900 <init+0x7e>
 900:	00 c0       	rjmp	.+0      	; 0x902 <init+0x80>
 902:	00 c0       	rjmp	.+0      	; 0x904 <init+0x82>
	if(camera->bins == NULL){
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
 904:	e1 2c       	mov	r14, r1
 906:	f1 2c       	mov	r15, r1
 908:	d1 2c       	mov	r13, r1
	color->bands.rgb.r = r;
 90a:	44 eb       	ldi	r20, 0xB4	; 180
 90c:	c4 2e       	mov	r12, r20
 90e:	bb 24       	eor	r11, r11
 910:	ba 94       	dec	r11
		for(uint8_t i = 0; i < AVRCAM_BINS; i++){
			CAMERA_BIN* bin = &camera->bins[i];
 912:	d8 01       	movw	r26, r16
 914:	14 96       	adiw	r26, 0x04	; 4
 916:	ed 91       	ld	r30, X+
 918:	fc 91       	ld	r31, X
 91a:	15 97       	sbiw	r26, 0x05	; 5
 91c:	ee 0d       	add	r30, r14
 91e:	ff 1d       	adc	r31, r15
			bin->active = bin->dirty = FALSE;
 920:	80 85       	ldd	r24, Z+8	; 0x08
 922:	8e 7f       	andi	r24, 0xFE	; 254
 924:	8d 7f       	andi	r24, 0xFD	; 253
 926:	80 87       	std	Z+8, r24	; 0x08
			if(i==0){
 928:	d1 10       	cpse	r13, r1
 92a:	00 c0       	rjmp	.+0      	; 0x92c <init+0xaa>

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 92c:	1d 82       	std	Y+5, r1	; 0x05
	color->bands.rgb.r = r;
 92e:	ce 82       	std	Y+6, r12	; 0x06
	color->bands.rgb.g = g;
 930:	cf 82       	std	Y+7, r12	; 0x07
	color->bands.rgb.b = b;
 932:	c8 86       	std	Y+8, r12	; 0x08

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 934:	19 82       	std	Y+1, r1	; 0x01
	color->bands.rgb.r = r;
 936:	ba 82       	std	Y+2, r11	; 0x02
	color->bands.rgb.g = g;
 938:	bb 82       	std	Y+3, r11	; 0x03
	color->bands.rgb.b = b;
 93a:	bc 82       	std	Y+4, r11	; 0x04
				COLOR min,max;
				colorSetRGB(&min,180,180,180);
				colorSetRGB(&max,255,255,255);
				setBin(camera,i,&min,&max);
 93c:	9e 01       	movw	r18, r28
 93e:	2f 5f       	subi	r18, 0xFF	; 255
 940:	3f 4f       	sbci	r19, 0xFF	; 255
 942:	ae 01       	movw	r20, r28
 944:	4b 5f       	subi	r20, 0xFB	; 251
 946:	5f 4f       	sbci	r21, 0xFF	; 255
 948:	60 e0       	ldi	r22, 0x00	; 0
 94a:	c8 01       	movw	r24, r16
 94c:	0e 94 00 00 	call	0	; 0x0 <xres>
 950:	00 c0       	rjmp	.+0      	; 0x952 <init+0xd0>

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 952:	10 82       	st	Z, r1
	color->bands.rgb.r = r;
 954:	11 82       	std	Z+1, r1	; 0x01
	color->bands.rgb.g = g;
 956:	12 82       	std	Z+2, r1	; 0x02
	color->bands.rgb.b = b;
 958:	13 82       	std	Z+3, r1	; 0x03

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 95a:	14 82       	std	Z+4, r1	; 0x04
	color->bands.rgb.r = r;
 95c:	15 82       	std	Z+5, r1	; 0x05
	color->bands.rgb.g = g;
 95e:	16 82       	std	Z+6, r1	; 0x06
	color->bands.rgb.b = b;
 960:	17 82       	std	Z+7, r1	; 0x07
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
		for(uint8_t i = 0; i < AVRCAM_BINS; i++){
 962:	d3 94       	inc	r13
 964:	b9 e0       	ldi	r27, 0x09	; 9
 966:	eb 0e       	add	r14, r27
 968:	f1 1c       	adc	r15, r1
 96a:	e8 e0       	ldi	r30, 0x08	; 8
 96c:	de 12       	cpse	r13, r30
 96e:	00 c0       	rjmp	.+0      	; 0x970 <init+0xee>
 970:	00 c0       	rjmp	.+0      	; 0x972 <init+0xf0>
		}
	}

	// Allocate space for blobs
	if(camera->blobs == null){
		camera->blobs = malloc(AVRCAM_BLOBS * sizeof(CAMERA_BLOB));
 972:	88 e8       	ldi	r24, 0x88	; 136
 974:	90 e0       	ldi	r25, 0x00	; 0
 976:	0e 94 00 00 	call	0	; 0x0 <xres>
 97a:	d8 01       	movw	r26, r16
 97c:	16 96       	adiw	r26, 0x06	; 6
 97e:	8c 93       	st	X, r24
 980:	16 97       	sbiw	r26, 0x06	; 6
 982:	17 96       	adiw	r26, 0x07	; 7
 984:	9c 93       	st	X, r25
	if(camera->bins == NULL){
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
 986:	3f e0       	ldi	r19, 0x0F	; 15
 988:	f3 2e       	mov	r15, r19
}

// ping the camera
// return TRUE if ok, FALSE if not
static boolean ping(AVRCAM* camera){
	return sendCmd(camera,"PG");
 98a:	60 e0       	ldi	r22, 0x00	; 0
 98c:	70 e0       	ldi	r23, 0x00	; 0
 98e:	c8 01       	movw	r24, r16
 990:	0e 94 00 00 	call	0	; 0x0 <xres>
		camera->blobs = malloc(AVRCAM_BLOBS * sizeof(CAMERA_BLOB));
	}

	// Try an initial ping of the camera
	uint8_t cnt = 15;
	while(!ping(avrcam) && --cnt);
 994:	81 11       	cpse	r24, r1
 996:	00 c0       	rjmp	.+0      	; 0x998 <init+0x116>
 998:	fa 94       	dec	r15
 99a:	01 f4       	brne	.+0      	; 0x99c <init+0x11a>
 99c:	00 c0       	rjmp	.+0      	; 0x99e <init+0x11c>

	if(cnt){
 99e:	ff 20       	and	r15, r15
 9a0:	01 f0       	breq	.+0      	; 0x9a2 <init+0x120>
		// We got a reply to our ping
		delay_us(TIMEOUT);
 9a2:	60 ee       	ldi	r22, 0xE0	; 224
 9a4:	73 e9       	ldi	r23, 0x93	; 147
 9a6:	84 e0       	ldi	r24, 0x04	; 4
 9a8:	90 e0       	ldi	r25, 0x00	; 0
 9aa:	0e 94 00 00 	call	0	; 0x0 <xres>
		flush(avrcam);
 9ae:	f8 01       	movw	r30, r16
 9b0:	82 81       	ldd	r24, Z+2	; 0x02
 9b2:	93 81       	ldd	r25, Z+3	; 0x03
 9b4:	0e 94 00 00 	call	0	; 0x0 <xres>

		setCameraReg(avrcam,0x12,0x28);					// AGC=on, RGB mode, AWB=off
 9b8:	48 e2       	ldi	r20, 0x28	; 40
 9ba:	62 e1       	ldi	r22, 0x12	; 18
 9bc:	c8 01       	movw	r24, r16
 9be:	0e 94 00 00 	call	0	; 0x0 <xres>
//		setCameraReg(avrcam,0x12,0x2C);					// AGC=on, RGB mode, AWB=on

		setCameraReg(avrcam,0x13,0);					// Turn off auto mode adjust
 9c2:	40 e0       	ldi	r20, 0x00	; 0
 9c4:	63 e1       	ldi	r22, 0x13	; 19
 9c6:	c8 01       	movw	r24, r16
 9c8:	0e 94 00 00 	call	0	; 0x0 <xres>
//		setCameraReg(avrcam,0x13,1);					// Turn on auto mode adjust

		setCameraReg(avrcam,0x2D,3);					// Turn off flourescent lighting filer
 9cc:	43 e0       	ldi	r20, 0x03	; 3
 9ce:	6d e2       	ldi	r22, 0x2D	; 45
 9d0:	c8 01       	movw	r24, r16
 9d2:	0e 94 00 00 	call	0	; 0x0 <xres>

		// Update camera with our initial colour bins
//		sendBins(avrcam);
	}

}
 9d6:	28 96       	adiw	r28, 0x08	; 8
 9d8:	0f b6       	in	r0, 0x3f	; 63
 9da:	f8 94       	cli
 9dc:	de bf       	out	0x3e, r29	; 62
 9de:	0f be       	out	0x3f, r0	; 63
 9e0:	cd bf       	out	0x3d, r28	; 61
 9e2:	df 91       	pop	r29
 9e4:	cf 91       	pop	r28
 9e6:	1f 91       	pop	r17
 9e8:	0f 91       	pop	r16
 9ea:	ff 90       	pop	r15
 9ec:	ef 90       	pop	r14
 9ee:	df 90       	pop	r13
 9f0:	cf 90       	pop	r12
 9f2:	bf 90       	pop	r11
 9f4:	08 95       	ret

blackfin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000448  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000047c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001c  00000000  00000000  0000047c  2**0
                  ALLOC
  3 .progmem.data 00000014  00000000  00000000  0000047c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000f46  00000000  00000000  00000490  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000035c  00000000  00000000  000013d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000009fa  00000000  00000000  00001732  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000212c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000022b  00000000  00000000  0000214c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000723  00000000  00000000  00002377  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00002a9a  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000180  00000000  00000000  00002ac4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_blackfin_putcmd>:



// rprintf destination to write to the command string
MAKE_WRITER(_blackfin_putcmd){
	_blackfin_command[_blackfin_index] = byte;
   0:	20 91 00 00 	lds	r18, 0x0000
   4:	30 91 00 00 	lds	r19, 0x0000
   8:	f9 01       	movw	r30, r18
   a:	e0 50       	subi	r30, 0x00	; 0
   c:	f0 40       	sbci	r31, 0x00	; 0
   e:	80 83       	st	Z, r24
	if(byte!='\0' && _blackfin_index < MAX_COMMAND){
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <_blackfin_putcmd+0x14>
  14:	29 31       	cpi	r18, 0x19	; 25
  16:	31 05       	cpc	r19, r1
  18:	00 f4       	brcc	.+0      	; 0x1a <_blackfin_putcmd+0x1a>
		_blackfin_index++;
  1a:	2f 5f       	subi	r18, 0xFF	; 255
  1c:	3f 4f       	sbci	r19, 0xFF	; 255
  1e:	30 93 00 00 	sts	0x0000, r19
  22:	20 93 00 00 	sts	0x0000, r18
	}
	_blackfin_command[_blackfin_index] = '\0';
  26:	e0 91 00 00 	lds	r30, 0x0000
  2a:	f0 91 00 00 	lds	r31, 0x0000
  2e:	e0 50       	subi	r30, 0x00	; 0
  30:	f0 40       	sbci	r31, 0x00	; 0
  32:	10 82       	st	Z, r1
	return byte;
}
  34:	08 95       	ret

00000036 <_blackfin_putchar>:

// Output a character to the Blackfin camera UART
MAKE_WRITER(_blackfin_putchar){
  36:	cf 93       	push	r28
  38:	c8 2f       	mov	r28, r24
	if(_blackfin_uart != null){
  3a:	80 91 00 00 	lds	r24, 0x0000
  3e:	90 91 00 00 	lds	r25, 0x0000
  42:	00 97       	sbiw	r24, 0x00	; 0
  44:	01 f0       	breq	.+0      	; 0x46 <_blackfin_putchar+0x10>
		_uartSendByte(_blackfin_uart, byte);
  46:	6c 2f       	mov	r22, r28
  48:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	}
	return byte;
}
  4c:	8c 2f       	mov	r24, r28
  4e:	cf 91       	pop	r28
  50:	08 95       	ret

00000052 <_blackfin_set_active>:

// Set the active uart for rprintf to go to the Blackfin
Writer _blackfin_set_active(UART* uart){
	_blackfin_uart = uart;
  52:	90 93 00 00 	sts	0x0000, r25
  56:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&_blackfin_putchar);
  5a:	80 e0       	ldi	r24, 0x00	; 0
  5c:	90 e0       	ldi	r25, 0x00	; 0
  5e:	0c 94 00 00 	jmp	0	; 0x0 <_blackfin_putcmd>

00000062 <__blackfin_get_args>:
}


int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
  62:	9f 92       	push	r9
  64:	af 92       	push	r10
  66:	bf 92       	push	r11
  68:	cf 92       	push	r12
  6a:	df 92       	push	r13
  6c:	ef 92       	push	r14
  6e:	ff 92       	push	r15
  70:	0f 93       	push	r16
  72:	1f 93       	push	r17
  74:	cf 93       	push	r28
  76:	df 93       	push	r29
  78:	5c 01       	movw	r10, r24
  7a:	eb 01       	movw	r28, r22
  7c:	6a 01       	movw	r12, r20
	int received=0;
	int args = 0;
  7e:	e1 2c       	mov	r14, r1
  80:	f1 2c       	mov	r15, r1
	return rprintfInit(&_blackfin_putchar);
}


int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
	int received=0;
  82:	00 e0       	ldi	r16, 0x00	; 0
  84:	10 e0       	ldi	r17, 0x00	; 0
	int args = 0;
	char c;

	while(numValues>0 && received!='\n'){
  86:	00 c0       	rjmp	.+0      	; 0x88 <__blackfin_get_args+0x26>
		boolean negative = FALSE;

		// Blank next value
		values[args] = 0;
  88:	18 82       	st	Y, r1
  8a:	19 82       	std	Y+1, r1	; 0x01
  8c:	1a 82       	std	Y+2, r1	; 0x02
  8e:	1b 82       	std	Y+3, r1	; 0x03
  90:	00 c0       	rjmp	.+0      	; 0x92 <__blackfin_get_args+0x30>
				if(trace){
					rprintfChar(c);
				}
#endif
				if( c=='-'){
					negative = (negative==FALSE) ? TRUE : FALSE;
  92:	99 24       	eor	r9, r9
  94:	9a 94       	dec	r9
		// Blank next value
		values[args] = 0;

		// Get a character and ignore anything not a digit or newline
		while(1){
			received = __uartGetByte(camera->camera);
  96:	f5 01       	movw	r30, r10
  98:	80 81       	ld	r24, Z
  9a:	91 81       	ldd	r25, Z+1	; 0x01
  9c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
  a0:	8c 01       	movw	r16, r24
			if(received!=-1){
  a2:	8f 3f       	cpi	r24, 0xFF	; 255
  a4:	ff ef       	ldi	r31, 0xFF	; 255
  a6:	9f 07       	cpc	r25, r31
  a8:	01 f0       	breq	.+0      	; 0xaa <__blackfin_get_args+0x48>
#ifdef BLACKFIN_DEBUG
				if(trace){
					rprintfChar(c);
				}
#endif
				if( c=='-'){
  aa:	8d 32       	cpi	r24, 0x2D	; 45
  ac:	01 f4       	brne	.+0      	; 0xae <__blackfin_get_args+0x4c>
					negative = (negative==FALSE) ? TRUE : FALSE;
  ae:	99 20       	and	r9, r9
  b0:	01 f0       	breq	.+0      	; 0xb2 <__blackfin_get_args+0x50>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <__blackfin_get_args+0x52>
					continue;
				}
				if( (c>='0' && c<='9') || c=='\n'){
  b4:	98 2f       	mov	r25, r24
  b6:	90 53       	subi	r25, 0x30	; 48
  b8:	9a 30       	cpi	r25, 0x0A	; 10
  ba:	00 f0       	brcs	.+0      	; 0xbc <__blackfin_get_args+0x5a>
  bc:	8a 30       	cpi	r24, 0x0A	; 10
  be:	01 f0       	breq	.+0      	; 0xc0 <__blackfin_get_args+0x5e>
					break;
				}
				negative = FALSE;
  c0:	91 2c       	mov	r9, r1
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <__blackfin_get_args+0x62>

		// Now get the number
		for(;received!='\n';){
			if(received!=-1){
				char c = received;
				if(c>='0' && c<='9'){
  c4:	80 2f       	mov	r24, r16
  c6:	80 53       	subi	r24, 0x30	; 48
  c8:	8a 30       	cpi	r24, 0x0A	; 10
  ca:	00 f4       	brcc	.+0      	; 0xcc <__blackfin_get_args+0x6a>
					values[args] *= 10;
  cc:	28 81       	ld	r18, Y
  ce:	39 81       	ldd	r19, Y+1	; 0x01
  d0:	4a 81       	ldd	r20, Y+2	; 0x02
  d2:	5b 81       	ldd	r21, Y+3	; 0x03
  d4:	aa e0       	ldi	r26, 0x0A	; 10
  d6:	b0 e0       	ldi	r27, 0x00	; 0
  d8:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
					values[args] += (c - '0');
  dc:	11 27       	eor	r17, r17
  de:	00 53       	subi	r16, 0x30	; 48
  e0:	11 09       	sbc	r17, r1
  e2:	22 27       	eor	r18, r18
  e4:	17 fd       	sbrc	r17, 7
  e6:	20 95       	com	r18
  e8:	32 2f       	mov	r19, r18
  ea:	60 0f       	add	r22, r16
  ec:	71 1f       	adc	r23, r17
  ee:	82 1f       	adc	r24, r18
  f0:	93 1f       	adc	r25, r19
  f2:	68 83       	st	Y, r22
  f4:	79 83       	std	Y+1, r23	; 0x01
  f6:	8a 83       	std	Y+2, r24	; 0x02
  f8:	9b 83       	std	Y+3, r25	; 0x03
					// get next character
					while(1){
						received = __uartGetByte(camera->camera);
  fa:	f5 01       	movw	r30, r10
  fc:	80 81       	ld	r24, Z
  fe:	91 81       	ldd	r25, Z+1	; 0x01
 100:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 104:	8c 01       	movw	r16, r24
						if(received!=-1){
 106:	8f 3f       	cpi	r24, 0xFF	; 255
 108:	ff ef       	ldi	r31, 0xFF	; 255
 10a:	9f 07       	cpc	r25, r31
 10c:	01 f0       	breq	.+0      	; 0x10e <__blackfin_get_args+0xac>
#ifdef BLACKFIN_DEBUG
							if(trace){
								rprintfChar(c);
							}
#endif
							if(c!='\r'){
 10e:	8d 30       	cpi	r24, 0x0D	; 13
 110:	01 f4       	brne	.+0      	; 0x112 <__blackfin_get_args+0xb0>
 112:	00 c0       	rjmp	.+0      	; 0x114 <__blackfin_get_args+0xb2>
								break;
							}
						}
					}
				}else{
					if(negative){
 114:	99 20       	and	r9, r9
 116:	01 f0       	breq	.+0      	; 0x118 <__blackfin_get_args+0xb6>
						values[args] *= -1;
 118:	48 81       	ld	r20, Y
 11a:	59 81       	ldd	r21, Y+1	; 0x01
 11c:	6a 81       	ldd	r22, Y+2	; 0x02
 11e:	7b 81       	ldd	r23, Y+3	; 0x03
 120:	70 95       	com	r23
 122:	60 95       	com	r22
 124:	50 95       	com	r21
 126:	41 95       	neg	r20
 128:	5f 4f       	sbci	r21, 0xFF	; 255
 12a:	6f 4f       	sbci	r22, 0xFF	; 255
 12c:	7f 4f       	sbci	r23, 0xFF	; 255
 12e:	48 83       	st	Y, r20
 130:	59 83       	std	Y+1, r21	; 0x01
 132:	6a 83       	std	Y+2, r22	; 0x02
 134:	7b 83       	std	Y+3, r23	; 0x03
 136:	00 c0       	rjmp	.+0      	; 0x138 <__blackfin_get_args+0xd6>
				negative = FALSE;
			}
		}

		// Now get the number
		for(;received!='\n';){
 138:	0a 30       	cpi	r16, 0x0A	; 10
 13a:	11 05       	cpc	r17, r1
 13c:	01 f4       	brne	.+0      	; 0x13e <__blackfin_get_args+0xdc>
					}
					break; // no longer a digit so exit for loop
				}
			}
		}
		args++;
 13e:	8f ef       	ldi	r24, 0xFF	; 255
 140:	e8 1a       	sub	r14, r24
 142:	f8 0a       	sbc	r15, r24
 144:	24 96       	adiw	r28, 0x04	; 4
int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
	int received=0;
	int args = 0;
	char c;

	while(numValues>0 && received!='\n'){
 146:	ec 14       	cp	r14, r12
 148:	fd 04       	cpc	r15, r13
 14a:	01 f0       	breq	.+0      	; 0x14c <__blackfin_get_args+0xea>
 14c:	0a 30       	cpi	r16, 0x0A	; 10
 14e:	11 05       	cpc	r17, r1
 150:	01 f0       	breq	.+0      	; 0x152 <__blackfin_get_args+0xf0>
 152:	00 c0       	rjmp	.+0      	; 0x154 <__blackfin_get_args+0xf2>
		}
		args++;
		numValues--;
	}
	return args;
}
 154:	c7 01       	movw	r24, r14
 156:	df 91       	pop	r29
 158:	cf 91       	pop	r28
 15a:	1f 91       	pop	r17
 15c:	0f 91       	pop	r16
 15e:	ff 90       	pop	r15
 160:	ef 90       	pop	r14
 162:	df 90       	pop	r13
 164:	cf 90       	pop	r12
 166:	bf 90       	pop	r11
 168:	af 90       	pop	r10
 16a:	9f 90       	pop	r9
 16c:	08 95       	ret

0000016e <__blackfinCommand>:
// error - The potential error msg or null if there isn't one
// values - Where to return the arguments
// numValues - The maximum number of arguments to return
// Returns the number of arguments found or -1 if there is an error

int __blackfinCommand(const BLACKFIN_CAMERA* camera, const char* response, const char* error, int32_t * values, size_t numValues){
 16e:	2f 92       	push	r2
 170:	3f 92       	push	r3
 172:	4f 92       	push	r4
 174:	5f 92       	push	r5
 176:	6f 92       	push	r6
 178:	7f 92       	push	r7
 17a:	8f 92       	push	r8
 17c:	9f 92       	push	r9
 17e:	af 92       	push	r10
 180:	bf 92       	push	r11
 182:	cf 92       	push	r12
 184:	df 92       	push	r13
 186:	ef 92       	push	r14
 188:	ff 92       	push	r15
 18a:	0f 93       	push	r16
 18c:	1f 93       	push	r17
 18e:	cf 93       	push	r28
 190:	df 93       	push	r29
 192:	00 d0       	rcall	.+0      	; 0x194 <__blackfinCommand+0x26>
 194:	00 d0       	rcall	.+0      	; 0x196 <__blackfinCommand+0x28>
 196:	cd b7       	in	r28, 0x3d	; 61
 198:	de b7       	in	r29, 0x3e	; 62
 19a:	5c 01       	movw	r10, r24
 19c:	2b 01       	movw	r4, r22
 19e:	4a 01       	movw	r8, r20
 1a0:	19 01       	movw	r2, r18
	const char* msg=null;
//	char first = pgm_read_byte(&response[0]);


	// Terminate the command string
	_blackfin_putcmd('\0');
 1a2:	80 e0       	ldi	r24, 0x00	; 0
 1a4:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 1a8:	9a e0       	ldi	r25, 0x0A	; 10
 1aa:	69 2e       	mov	r6, r25
 1ac:	71 2c       	mov	r7, r1
	uint16_t noDataCounter;
	int counter;
	int attempt=0;
	int args = 0;
	char c;
	const char* msg=null;
 1ae:	c1 2c       	mov	r12, r1
 1b0:	d1 2c       	mov	r13, r1
			counter = 0;
		}

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
 1b2:	f2 01       	movw	r30, r4
 1b4:	f4 91       	lpm	r31, Z
 1b6:	f9 83       	std	Y+1, r31	; 0x01
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
				if(c == pgm_read_byte(error)){
 1b8:	f4 01       	movw	r30, r8
 1ba:	f4 91       	lpm	r31, Z
 1bc:	fa 83       	std	Y+2, r31	; 0x02
	// Wait for transmission to end
	while(__uartIsBusy(camera->debug));
#endif

	// Start using the queue
	__uartFlushReceiveBuffer(camera->camera);
 1be:	f5 01       	movw	r30, r10
 1c0:	80 81       	ld	r24, Z
 1c2:	91 81       	ldd	r25, Z+1	; 0x01
 1c4:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 1c8:	80 e0       	ldi	r24, 0x00	; 0
 1ca:	e8 2e       	mov	r14, r24
 1cc:	80 e0       	ldi	r24, 0x00	; 0
 1ce:	f8 2e       	mov	r15, r24

	// Send the command to the camera
	char* str = _blackfin_command;
	while (*str)
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <__blackfinCommand+0x64>
		_uartSendByte(camera->camera, *str++);
 1d2:	f5 01       	movw	r30, r10
 1d4:	80 81       	ld	r24, Z
 1d6:	91 81       	ldd	r25, Z+1	; 0x01
 1d8:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	// Start using the queue
	__uartFlushReceiveBuffer(camera->camera);

	// Send the command to the camera
	char* str = _blackfin_command;
	while (*str)
 1dc:	f7 01       	movw	r30, r14
 1de:	61 91       	ld	r22, Z+
 1e0:	7f 01       	movw	r14, r30
 1e2:	61 11       	cpse	r22, r1
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <__blackfinCommand+0x78>
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <__blackfinCommand+0x7a>
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
				if(c == pgm_read_byte(error)){
 1e8:	64 01       	movw	r12, r8
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <__blackfinCommand+0x7e>

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
				// Its the start of a response
				msg = response;
 1ec:	62 01       	movw	r12, r4
			counter = 0;
		}

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
 1ee:	40 e0       	ldi	r20, 0x00	; 0
 1f0:	50 e0       	ldi	r21, 0x00	; 0
		_uartSendByte(camera->camera, *str++);
	goto listen;


getNext:
	counter++;
 1f2:	4f 5f       	subi	r20, 0xFF	; 255
 1f4:	5f 4f       	sbci	r21, 0xFF	; 255
	if(pgm_read_byte(&msg[counter]) == '\0'){
 1f6:	f6 01       	movw	r30, r12
 1f8:	e4 0f       	add	r30, r20
 1fa:	f5 1f       	adc	r31, r21
 1fc:	e4 91       	lpm	r30, Z
 1fe:	ee 23       	and	r30, r30
 200:	01 f4       	brne	.+0      	; 0x202 <__blackfinCommand+0x94>
 202:	00 c0       	rjmp	.+0      	; 0x204 <__blackfinCommand+0x96>
 204:	00 c0       	rjmp	.+0      	; 0x206 <__blackfinCommand+0x98>
			if(c == pgm_read_byte(response)){
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
 206:	40 e0       	ldi	r20, 0x00	; 0
 208:	50 e0       	ldi	r21, 0x00	; 0
	// Now listen for the response
listen:
	received = __uartGetByte(camera->camera);
	if(received != -1){
		// Got a character
		noDataCounter = 0;	// we have received a byte
 20a:	e1 2c       	mov	r14, r1
 20c:	f1 2c       	mov	r15, r1
		goto gotCmd;
	}

	// Now listen for the response
listen:
	received = __uartGetByte(camera->camera);
 20e:	f5 01       	movw	r30, r10
 210:	80 81       	ld	r24, Z
 212:	91 81       	ldd	r25, Z+1	; 0x01
 214:	4b 83       	std	Y+3, r20	; 0x03
 216:	5c 83       	std	Y+4, r21	; 0x04
 218:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	if(received != -1){
 21c:	4b 81       	ldd	r20, Y+3	; 0x03
 21e:	5c 81       	ldd	r21, Y+4	; 0x04
 220:	8f 3f       	cpi	r24, 0xFF	; 255
 222:	ff ef       	ldi	r31, 0xFF	; 255
 224:	9f 07       	cpc	r25, r31
 226:	01 f0       	breq	.+0      	; 0x228 <__blackfinCommand+0xba>
		// Got a character
		noDataCounter = 0;	// we have received a byte

		// Ignore carriage returns
		if(received=='\r'){
 228:	8d 30       	cpi	r24, 0x0D	; 13
 22a:	91 05       	cpc	r25, r1
 22c:	01 f0       	breq	.+0      	; 0x22e <__blackfinCommand+0xc0>
		// Echo to debugger
		rprintfChar(received);
#endif

		// Translate to a character
		c = (received=='\n') ? '\0' : (char)received;
 22e:	8a 30       	cpi	r24, 0x0A	; 10
 230:	91 05       	cpc	r25, r1
 232:	01 f4       	brne	.+0      	; 0x234 <__blackfinCommand+0xc6>
 234:	80 e0       	ldi	r24, 0x00	; 0

		// If its not the character we expected then start from beginning again
		if(counter != 0 && c != pgm_read_byte(&msg[counter])){
 236:	41 15       	cp	r20, r1
 238:	51 05       	cpc	r21, r1
 23a:	01 f4       	brne	.+0      	; 0x23c <__blackfinCommand+0xce>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <__blackfinCommand+0xd0>
 23e:	f6 01       	movw	r30, r12
 240:	e4 0f       	add	r30, r20
 242:	f5 1f       	adc	r31, r21
 244:	e4 91       	lpm	r30, Z
 246:	8e 13       	cpse	r24, r30
 248:	00 c0       	rjmp	.+0      	; 0x24a <__blackfinCommand+0xdc>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <__blackfinCommand+0xde>
			if(c == pgm_read_byte(response)){
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
 24c:	81 14       	cp	r8, r1
 24e:	91 04       	cpc	r9, r1
 250:	01 f0       	breq	.+0      	; 0x252 <__blackfinCommand+0xe4>
				if(c == pgm_read_byte(error)){
 252:	2a 81       	ldd	r18, Y+2	; 0x02
 254:	82 17       	cp	r24, r18
 256:	01 f0       	breq	.+0      	; 0x258 <__blackfinCommand+0xea>
 258:	00 c0       	rjmp	.+0      	; 0x25a <__blackfinCommand+0xec>
	}else{

		// No character available

		// No data received yet - so increment loop count
		if(counter==0 && ++noDataCounter >= MAX_RETRIES){
 25a:	41 15       	cp	r20, r1
 25c:	51 05       	cpc	r21, r1
 25e:	01 f4       	brne	.+0      	; 0x260 <__blackfinCommand+0xf2>
 260:	8f ef       	ldi	r24, 0xFF	; 255
 262:	e8 1a       	sub	r14, r24
 264:	f8 0a       	sbc	r15, r24
 266:	98 ee       	ldi	r25, 0xE8	; 232
 268:	e9 16       	cp	r14, r25
 26a:	9d ef       	ldi	r25, 0xFD	; 253
 26c:	f9 06       	cpc	r15, r25
 26e:	00 f0       	brcs	.+0      	; 0x270 <__blackfinCommand+0x102>
 270:	e1 e0       	ldi	r30, 0x01	; 1
 272:	6e 1a       	sub	r6, r30
 274:	71 08       	sbc	r7, r1

			// Resend the command 10 timers
			if(++attempt < 10){
 276:	01 f0       	breq	.+0      	; 0x278 <__blackfinCommand+0x10a>
 278:	00 c0       	rjmp	.+0      	; 0x27a <__blackfinCommand+0x10c>
 27a:	00 c0       	rjmp	.+0      	; 0x27c <__blackfinCommand+0x10e>
		goto listen;
	}

	// We have received the command
gotCmd:
	if(msg==error){
 27c:	c8 14       	cp	r12, r8
 27e:	d9 04       	cpc	r13, r9
 280:	01 f0       	breq	.+0      	; 0x282 <__blackfinCommand+0x114>
		rprintf("Recognised Error:");rprintfProgStr(error);rprintfCRLF();
#endif
		args = -1;
		goto exit;
	}
	args = __blackfin_get_args(camera, values, numValues, FALSE);
 282:	20 e0       	ldi	r18, 0x00	; 0
 284:	a8 01       	movw	r20, r16
 286:	b1 01       	movw	r22, r2
 288:	c5 01       	movw	r24, r10
#ifdef BLACKFIN_DEBUG
	// Restore rprintf to original position
	rprintfInit(old);
#endif
	return args;
}
 28a:	0f 90       	pop	r0
 28c:	0f 90       	pop	r0
 28e:	0f 90       	pop	r0
 290:	0f 90       	pop	r0
 292:	df 91       	pop	r29
 294:	cf 91       	pop	r28
 296:	1f 91       	pop	r17
 298:	0f 91       	pop	r16
 29a:	ff 90       	pop	r15
 29c:	ef 90       	pop	r14
 29e:	df 90       	pop	r13
 2a0:	cf 90       	pop	r12
 2a2:	bf 90       	pop	r11
 2a4:	af 90       	pop	r10
 2a6:	9f 90       	pop	r9
 2a8:	8f 90       	pop	r8
 2aa:	7f 90       	pop	r7
 2ac:	6f 90       	pop	r6
 2ae:	5f 90       	pop	r5
 2b0:	4f 90       	pop	r4
 2b2:	3f 90       	pop	r3
 2b4:	2f 90       	pop	r2
		rprintf("Recognised Error:");rprintfProgStr(error);rprintfCRLF();
#endif
		args = -1;
		goto exit;
	}
	args = __blackfin_get_args(camera, values, numValues, FALSE);
 2b6:	0c 94 00 00 	jmp	0	; 0x0 <_blackfin_putcmd>
			counter = 0;
		}

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
 2ba:	29 81       	ldd	r18, Y+1	; 0x01
 2bc:	82 13       	cpse	r24, r18
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <__blackfinCommand+0x152>
 2c0:	00 c0       	rjmp	.+0      	; 0x2c2 <__blackfinCommand+0x154>
#ifdef BLACKFIN_DEBUG
	// Restore rprintf to original position
	rprintfInit(old);
#endif
	return args;
}
 2c2:	8f ef       	ldi	r24, 0xFF	; 255
 2c4:	9f ef       	ldi	r25, 0xFF	; 255
 2c6:	0f 90       	pop	r0
 2c8:	0f 90       	pop	r0
 2ca:	0f 90       	pop	r0
 2cc:	0f 90       	pop	r0
 2ce:	df 91       	pop	r29
 2d0:	cf 91       	pop	r28
 2d2:	1f 91       	pop	r17
 2d4:	0f 91       	pop	r16
 2d6:	ff 90       	pop	r15
 2d8:	ef 90       	pop	r14
 2da:	df 90       	pop	r13
 2dc:	cf 90       	pop	r12
 2de:	bf 90       	pop	r11
 2e0:	af 90       	pop	r10
 2e2:	9f 90       	pop	r9
 2e4:	8f 90       	pop	r8
 2e6:	7f 90       	pop	r7
 2e8:	6f 90       	pop	r6
 2ea:	5f 90       	pop	r5
 2ec:	4f 90       	pop	r4
 2ee:	3f 90       	pop	r3
 2f0:	2f 90       	pop	r2
 2f2:	08 95       	ret

000002f4 <blackfinSetResolution>:


void blackfinSetResolution(BLACKFIN_CAMERA* camera, BLACKFIN_RESOLUTION res){
 2f4:	cf 92       	push	r12
 2f6:	df 92       	push	r13
 2f8:	ef 92       	push	r14
 2fa:	ff 92       	push	r15
 2fc:	0f 93       	push	r16
 2fe:	1f 93       	push	r17
 300:	cf 93       	push	r28
 302:	df 93       	push	r29
 304:	1f 92       	push	r1
 306:	cd b7       	in	r28, 0x3d	; 61
 308:	de b7       	in	r29, 0x3e	; 62
 30a:	6c 01       	movw	r12, r24
	const char* response;

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
 30c:	80 e0       	ldi	r24, 0x00	; 0
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	69 83       	std	Y+1, r22	; 0x01
 312:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 316:	7c 01       	movw	r14, r24
	_blackfin_index=0;
 318:	10 92 00 00 	sts	0x0000, r1
 31c:	10 92 00 00 	sts	0x0000, r1


	// Remember the current resolution
	camera->res = res;
 320:	69 81       	ldd	r22, Y+1	; 0x01
 322:	f6 01       	movw	r30, r12
 324:	62 83       	std	Z+2, r22	; 0x02

	switch(res){
 326:	62 30       	cpi	r22, 0x02	; 2
 328:	01 f0       	breq	.+0      	; 0x32a <blackfinSetResolution+0x36>
 32a:	63 30       	cpi	r22, 0x03	; 3
 32c:	01 f0       	breq	.+0      	; 0x32e <blackfinSetResolution+0x3a>
 32e:	61 30       	cpi	r22, 0x01	; 1
 330:	01 f4       	brne	.+0      	; 0x332 <blackfinSetResolution+0x3e>
 332:	00 c0       	rjmp	.+0      	; 0x334 <blackfinSetResolution+0x40>
	case BLACKFIN_1280_BY_1024:
		rprintf("A");
 334:	20 e0       	ldi	r18, 0x00	; 0
 336:	30 e0       	ldi	r19, 0x00	; 0
 338:	3f 93       	push	r19
 33a:	2f 93       	push	r18
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	8f 93       	push	r24
 340:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#A");
		break;
 344:	0f 90       	pop	r0
 346:	0f 90       	pop	r0
 348:	0f 90       	pop	r0
	camera->res = res;

	switch(res){
	case BLACKFIN_1280_BY_1024:
		rprintf("A");
		response = PSTR("#A");
 34a:	60 e0       	ldi	r22, 0x00	; 0
 34c:	70 e0       	ldi	r23, 0x00	; 0
		break;
 34e:	00 c0       	rjmp	.+0      	; 0x350 <blackfinSetResolution+0x5c>
	case BLACKFIN_320_BY_240:
		rprintf("b");
 350:	20 e0       	ldi	r18, 0x00	; 0
 352:	30 e0       	ldi	r19, 0x00	; 0
 354:	3f 93       	push	r19
 356:	2f 93       	push	r18
 358:	6f 93       	push	r22
 35a:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#b");
		break;
 35e:	0f 90       	pop	r0
 360:	0f 90       	pop	r0
 362:	0f 90       	pop	r0
		rprintf("A");
		response = PSTR("#A");
		break;
	case BLACKFIN_320_BY_240:
		rprintf("b");
		response = PSTR("#b");
 364:	60 e0       	ldi	r22, 0x00	; 0
 366:	70 e0       	ldi	r23, 0x00	; 0
		break;
 368:	00 c0       	rjmp	.+0      	; 0x36a <blackfinSetResolution+0x76>
	case BLACKFIN_640_BY_480:
		rprintf("c");
 36a:	20 e0       	ldi	r18, 0x00	; 0
 36c:	30 e0       	ldi	r19, 0x00	; 0
 36e:	3f 93       	push	r19
 370:	2f 93       	push	r18
 372:	81 e0       	ldi	r24, 0x01	; 1
 374:	8f 93       	push	r24
 376:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#c");
		break;
 37a:	0f 90       	pop	r0
 37c:	0f 90       	pop	r0
 37e:	0f 90       	pop	r0
		rprintf("b");
		response = PSTR("#b");
		break;
	case BLACKFIN_640_BY_480:
		rprintf("c");
		response = PSTR("#c");
 380:	60 e0       	ldi	r22, 0x00	; 0
 382:	70 e0       	ldi	r23, 0x00	; 0
		break;
 384:	00 c0       	rjmp	.+0      	; 0x386 <blackfinSetResolution+0x92>
	default:
		rprintf("a");
 386:	20 e0       	ldi	r18, 0x00	; 0
 388:	30 e0       	ldi	r19, 0x00	; 0
 38a:	3f 93       	push	r19
 38c:	2f 93       	push	r18
 38e:	81 e0       	ldi	r24, 0x01	; 1
 390:	8f 93       	push	r24
 392:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#a");
		break;
 396:	0f 90       	pop	r0
 398:	0f 90       	pop	r0
 39a:	0f 90       	pop	r0
		rprintf("c");
		response = PSTR("#c");
		break;
	default:
		rprintf("a");
		response = PSTR("#a");
 39c:	60 e0       	ldi	r22, 0x00	; 0
 39e:	70 e0       	ldi	r23, 0x00	; 0
		break;
	}

	// Send the command
	__blackfinCommand(camera,response,null,null,0);
 3a0:	00 e0       	ldi	r16, 0x00	; 0
 3a2:	10 e0       	ldi	r17, 0x00	; 0
 3a4:	20 e0       	ldi	r18, 0x00	; 0
 3a6:	30 e0       	ldi	r19, 0x00	; 0
 3a8:	40 e0       	ldi	r20, 0x00	; 0
 3aa:	50 e0       	ldi	r21, 0x00	; 0
 3ac:	c6 01       	movw	r24, r12
 3ae:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>

	// Restore rprintf to original position
	rprintfInit(old);
 3b2:	c7 01       	movw	r24, r14
 3b4:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>


	//must delay so that auto-brightness has time to adjust
	delay_ms(2000);
 3b8:	60 ed       	ldi	r22, 0xD0	; 208
 3ba:	77 e0       	ldi	r23, 0x07	; 7
 3bc:	80 e0       	ldi	r24, 0x00	; 0
 3be:	90 e0       	ldi	r25, 0x00	; 0
}
 3c0:	0f 90       	pop	r0
 3c2:	df 91       	pop	r29
 3c4:	cf 91       	pop	r28
 3c6:	1f 91       	pop	r17
 3c8:	0f 91       	pop	r16
 3ca:	ff 90       	pop	r15
 3cc:	ef 90       	pop	r14
 3ce:	df 90       	pop	r13
 3d0:	cf 90       	pop	r12
	// Restore rprintf to original position
	rprintfInit(old);


	//must delay so that auto-brightness has time to adjust
	delay_ms(2000);
 3d2:	0c 94 00 00 	jmp	0	; 0x0 <_blackfin_putcmd>

000003d6 <blackfinInit>:
}

void blackfinInit(BLACKFIN_CAMERA* camera){
 3d6:	cf 93       	push	r28
 3d8:	df 93       	push	r29
 3da:	ec 01       	movw	r28, r24

//	__uartAttach(camera->camera, &__blackfin_discard);
//	_uartInit(camera->camera, 115200);

	// allocate space for color
	if(camera->mean == null){
 3dc:	8d 81       	ldd	r24, Y+5	; 0x05
 3de:	9e 81       	ldd	r25, Y+6	; 0x06
 3e0:	89 2b       	or	r24, r25
 3e2:	01 f4       	brne	.+0      	; 0x3e4 <blackfinInit+0xe>
		camera->mean = malloc(sizeof(COLOR));
 3e4:	84 e0       	ldi	r24, 0x04	; 4
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 3ec:	8d 83       	std	Y+5, r24	; 0x05
 3ee:	9e 83       	std	Y+6, r25	; 0x06
	}

	if(camera->camera->rxBuffer== null){
 3f0:	e8 81       	ld	r30, Y
 3f2:	f9 81       	ldd	r31, Y+1	; 0x01
 3f4:	80 81       	ld	r24, Z
 3f6:	91 81       	ldd	r25, Z+1	; 0x01
 3f8:	89 2b       	or	r24, r25
 3fa:	01 f4       	brne	.+0      	; 0x3fc <blackfinInit+0x26>
		setError(BLACKFIN_RX_BUFFER);
 3fc:	87 ee       	ldi	r24, 0xE7	; 231
 3fe:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	}

	// Set the current resolution
	blackfinSetResolution(camera, camera->res);
 402:	6a 81       	ldd	r22, Y+2	; 0x02
 404:	ce 01       	movw	r24, r28

}
 406:	df 91       	pop	r29
 408:	cf 91       	pop	r28
	if(camera->camera->rxBuffer== null){
		setError(BLACKFIN_RX_BUFFER);
	}

	// Set the current resolution
	blackfinSetResolution(camera, camera->res);
 40a:	0c 94 00 00 	jmp	0	; 0x0 <_blackfin_putcmd>

0000040e <_blackfin_sendYUV>:

}


void _blackfin_sendYUV(uint8_t c){
 40e:	cf 93       	push	r28
 410:	df 93       	push	r29
 412:	1f 92       	push	r1
 414:	cd b7       	in	r28, 0x3d	; 61
 416:	de b7       	in	r29, 0x3e	; 62
	rprintfChar( (c / 100)+'0'); c = c % 100;
 418:	64 e6       	ldi	r22, 0x64	; 100
 41a:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 41e:	80 5d       	subi	r24, 0xD0	; 208
 420:	99 83       	std	Y+1, r25	; 0x01
 422:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	rprintfChar( (c /  10)+'0'); c = c % 10;
 426:	99 81       	ldd	r25, Y+1	; 0x01
 428:	89 2f       	mov	r24, r25
 42a:	6a e0       	ldi	r22, 0x0A	; 10
 42c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 430:	80 5d       	subi	r24, 0xD0	; 208
 432:	99 83       	std	Y+1, r25	; 0x01
 434:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	rprintfChar( c +'0');
 438:	99 81       	ldd	r25, Y+1	; 0x01
 43a:	89 2f       	mov	r24, r25
 43c:	80 5d       	subi	r24, 0xD0	; 208

}
 43e:	0f 90       	pop	r0
 440:	df 91       	pop	r29
 442:	cf 91       	pop	r28


void _blackfin_sendYUV(uint8_t c){
	rprintfChar( (c / 100)+'0'); c = c % 100;
	rprintfChar( (c /  10)+'0'); c = c % 10;
	rprintfChar( c +'0');
 444:	0c 94 00 00 	jmp	0	; 0x0 <_blackfin_putcmd>

blackfin_vb.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001aa  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001de  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001de  2**0
                  ALLOC
  3 .progmem.data 00000014  00000000  00000000  000001de  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000b36  00000000  00000000  000001f2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000289  00000000  00000000  00000d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000245  00000000  00000000  00000fb1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000011f6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000197  00000000  00000000  00001216  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000005fe  00000000  00000000  000013ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000019ab  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000074  00000000  00000000  000019d8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinDetectBlobs>:
                 printf(" %d - %d %d %d %d  \r\n",
                     blobcnt[iy], blobx1[iy], blobx2[iy], bloby1[iy],bloby2[iy]);
             }

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
   0:	9f 92       	push	r9
   2:	af 92       	push	r10
   4:	bf 92       	push	r11
   6:	cf 92       	push	r12
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	64 97       	sbiw	r28, 0x14	; 20
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	de bf       	out	0x3e, r29	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	cd bf       	out	0x3d, r28	; 61
  26:	6c 01       	movw	r12, r24
  28:	96 2e       	mov	r9, r22
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;

	// allocate space for blob storage
	if(camera->blob==null){
  2a:	dc 01       	movw	r26, r24
  2c:	13 96       	adiw	r26, 0x03	; 3
  2e:	8d 91       	ld	r24, X+
  30:	9c 91       	ld	r25, X
  32:	14 97       	sbiw	r26, 0x04	; 4
  34:	89 2b       	or	r24, r25
  36:	01 f4       	brne	.+0      	; 0x38 <blackfinDetectBlobs+0x38>
		camera->blob = malloc(MAX_BLOBS * sizeof(BLACKFIN_BLOB)) ;
  38:	80 e4       	ldi	r24, 0x40	; 64
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
  40:	f6 01       	movw	r30, r12
  42:	83 83       	std	Z+3, r24	; 0x03
  44:	94 83       	std	Z+4, r25	; 0x04
	}
	dest = camera->blob;
  46:	d6 01       	movw	r26, r12
  48:	13 96       	adiw	r26, 0x03	; 3
  4a:	ed 90       	ld	r14, X+
  4c:	fc 90       	ld	r15, X
  4e:	14 97       	sbiw	r26, 0x04	; 4

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
  58:	5c 01       	movw	r10, r24
	_blackfin_index=0;
  5a:	10 92 00 00 	sts	0x0000, r1
  5e:	10 92 00 00 	sts	0x0000, r1

	rprintf("vb%d",bin);//start command, send bin #
  62:	1f 92       	push	r1
  64:	9f 92       	push	r9
  66:	80 e0       	ldi	r24, 0x00	; 0
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	9f 93       	push	r25
  6c:	8f 93       	push	r24
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	8f 93       	push	r24
  72:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	// process the command
	int args = __blackfinCommand(camera,PSTR("##vb"),PSTR("  vblob #"),values,2);
  76:	02 e0       	ldi	r16, 0x02	; 2
  78:	10 e0       	ldi	r17, 0x00	; 0
  7a:	9e 01       	movw	r18, r28
  7c:	2f 5f       	subi	r18, 0xFF	; 255
  7e:	3f 4f       	sbci	r19, 0xFF	; 255
  80:	40 e0       	ldi	r20, 0x00	; 0
  82:	50 e0       	ldi	r21, 0x00	; 0
  84:	60 e0       	ldi	r22, 0x00	; 0
  86:	70 e0       	ldi	r23, 0x00	; 0
  88:	c6 01       	movw	r24, r12
  8a:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	#ifdef BLACKFIN_DEBUG
	_blackfin_set_active(camera->debug);	//Send rprintf to the debugger
	#endif

	if(args==2 && values[0]==bin){
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	0f 90       	pop	r0
  94:	0f 90       	pop	r0
  96:	0f 90       	pop	r0
  98:	02 97       	sbiw	r24, 0x02	; 2
  9a:	01 f0       	breq	.+0      	; 0x9c <blackfinDetectBlobs+0x9c>
  9c:	00 c0       	rjmp	.+0      	; 0x9e <blackfinDetectBlobs+0x9e>
  9e:	49 2d       	mov	r20, r9
  a0:	50 e0       	ldi	r21, 0x00	; 0
  a2:	60 e0       	ldi	r22, 0x00	; 0
  a4:	70 e0       	ldi	r23, 0x00	; 0
  a6:	09 81       	ldd	r16, Y+1	; 0x01
  a8:	1a 81       	ldd	r17, Y+2	; 0x02
  aa:	2b 81       	ldd	r18, Y+3	; 0x03
  ac:	3c 81       	ldd	r19, Y+4	; 0x04
  ae:	04 17       	cp	r16, r20
  b0:	15 07       	cpc	r17, r21
  b2:	26 07       	cpc	r18, r22
  b4:	37 07       	cpc	r19, r23
  b6:	01 f0       	breq	.+0      	; 0xb8 <blackfinDetectBlobs+0xb8>
  b8:	00 c0       	rjmp	.+0      	; 0xba <blackfinDetectBlobs+0xba>
		int8_t numBlobs = values[1];		// The number of blobs
  ba:	0d 81       	ldd	r16, Y+5	; 0x05
  bc:	05 30       	cpi	r16, 0x05	; 5
  be:	04 f0       	brlt	.+0      	; 0xc0 <blackfinDetectBlobs+0xc0>
  c0:	04 e0       	ldi	r16, 0x04	; 4
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
  c2:	91 2c       	mov	r9, r1

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;
  c4:	10 e0       	ldi	r17, 0x00	; 0
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <blackfinDetectBlobs+0xc8>
			args = __blackfin_get_args(camera, values, 5, TRUE);
  c8:	2f ef       	ldi	r18, 0xFF	; 255
  ca:	45 e0       	ldi	r20, 0x05	; 5
  cc:	50 e0       	ldi	r21, 0x00	; 0
  ce:	be 01       	movw	r22, r28
  d0:	6f 5f       	subi	r22, 0xFF	; 255
  d2:	7f 4f       	sbci	r23, 0xFF	; 255
  d4:	c6 01       	movw	r24, r12
  d6:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
			#ifdef BLACKFIN_DEBUG
			rprintf(" #%d=",(int)num);
			#endif
			if(args==5){
  da:	05 97       	sbiw	r24, 0x05	; 5
  dc:	01 f4       	brne	.+0      	; 0xde <blackfinDetectBlobs+0xde>
				dest->pixels = values[0];
  de:	49 81       	ldd	r20, Y+1	; 0x01
  e0:	5a 81       	ldd	r21, Y+2	; 0x02
  e2:	6b 81       	ldd	r22, Y+3	; 0x03
  e4:	7c 81       	ldd	r23, Y+4	; 0x04
  e6:	f7 01       	movw	r30, r14
  e8:	44 87       	std	Z+12, r20	; 0x0c
  ea:	55 87       	std	Z+13, r21	; 0x0d
  ec:	66 87       	std	Z+14, r22	; 0x0e
  ee:	77 87       	std	Z+15, r23	; 0x0f
				dest->left 	 = values[1];
  f0:	ed 81       	ldd	r30, Y+5	; 0x05
  f2:	fe 81       	ldd	r31, Y+6	; 0x06
  f4:	d7 01       	movw	r26, r14
  f6:	11 96       	adiw	r26, 0x01	; 1
  f8:	fc 93       	st	X, r31
  fa:	ee 93       	st	-X, r30
				dest->right  = values[2];
  fc:	49 85       	ldd	r20, Y+9	; 0x09
  fe:	5a 85       	ldd	r21, Y+10	; 0x0a
 100:	13 96       	adiw	r26, 0x03	; 3
 102:	5c 93       	st	X, r21
 104:	4e 93       	st	-X, r20
 106:	12 97       	sbiw	r26, 0x02	; 2
				dest->top  	 = values[3];
 108:	6d 85       	ldd	r22, Y+13	; 0x0d
 10a:	7e 85       	ldd	r23, Y+14	; 0x0e
 10c:	15 96       	adiw	r26, 0x05	; 5
 10e:	7c 93       	st	X, r23
 110:	6e 93       	st	-X, r22
 112:	14 97       	sbiw	r26, 0x04	; 4
				dest->bottom = values[4];
 114:	29 89       	ldd	r18, Y+17	; 0x11
 116:	3a 89       	ldd	r19, Y+18	; 0x12
 118:	17 96       	adiw	r26, 0x07	; 7
 11a:	3c 93       	st	X, r19
 11c:	2e 93       	st	-X, r18
 11e:	16 97       	sbiw	r26, 0x06	; 6
				dest->xCenter = dest->left + ((dest->right - dest->left)>>1);
 120:	4e 1b       	sub	r20, r30
 122:	5f 0b       	sbc	r21, r31
 124:	56 95       	lsr	r21
 126:	47 95       	ror	r20
 128:	4e 0f       	add	r20, r30
 12a:	5f 1f       	adc	r21, r31
 12c:	19 96       	adiw	r26, 0x09	; 9
 12e:	5c 93       	st	X, r21
 130:	4e 93       	st	-X, r20
 132:	18 97       	sbiw	r26, 0x08	; 8
				dest->yCenter = dest->top + ((dest->bottom - dest->top)>>1);
 134:	26 1b       	sub	r18, r22
 136:	37 0b       	sbc	r19, r23
 138:	36 95       	lsr	r19
 13a:	27 95       	ror	r18
 13c:	26 0f       	add	r18, r22
 13e:	37 1f       	adc	r19, r23
 140:	1b 96       	adiw	r26, 0x0b	; 11
 142:	3c 93       	st	X, r19
 144:	2e 93       	st	-X, r18
 146:	1a 97       	sbiw	r26, 0x0a	; 10
					rprintfChar(',');
					rprintfNum(10,4,FALSE,'0',dest->bottom);
					rprintf(" Pixels=");rprintfNum(10,10,FALSE,' ',dest->pixels);
					rprintfCRLF();
				#endif
				dest++;
 148:	b0 e1       	ldi	r27, 0x10	; 16
 14a:	eb 0e       	add	r14, r27
 14c:	f1 1c       	adc	r15, r1
				actual++;
 14e:	1f 5f       	subi	r17, 0xFF	; 255
				#ifdef BLACKFIN_DEBUG
					rprintf("Expected 5 args but got %d\n",args);
				#endif
			}
			// Read up to linefeed
			while(__uartGetByte(camera->camera)!='\n');
 150:	f6 01       	movw	r30, r12
 152:	80 81       	ld	r24, Z
 154:	91 81       	ldd	r25, Z+1	; 0x01
 156:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
 15a:	0a 97       	sbiw	r24, 0x0a	; 10
 15c:	01 f4       	brne	.+0      	; 0x15e <blackfinDetectBlobs+0x15e>
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
 15e:	93 94       	inc	r9
 160:	90 16       	cp	r9, r16
 162:	04 f4       	brge	.+0      	; 0x164 <blackfinDetectBlobs+0x164>
 164:	00 c0       	rjmp	.+0      	; 0x166 <blackfinDetectBlobs+0x166>
 166:	00 c0       	rjmp	.+0      	; 0x168 <blackfinDetectBlobs+0x168>

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;
 168:	10 e0       	ldi	r17, 0x00	; 0
		rprintf("vb - missing num blobs\n");
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
 16a:	c5 01       	movw	r24, r10
 16c:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	return actual;
}
 170:	81 2f       	mov	r24, r17
 172:	64 96       	adiw	r28, 0x14	; 20
 174:	0f b6       	in	r0, 0x3f	; 63
 176:	f8 94       	cli
 178:	de bf       	out	0x3e, r29	; 62
 17a:	0f be       	out	0x3f, r0	; 63
 17c:	cd bf       	out	0x3d, r28	; 61
 17e:	df 91       	pop	r29
 180:	cf 91       	pop	r28
 182:	1f 91       	pop	r17
 184:	0f 91       	pop	r16
 186:	ff 90       	pop	r15
 188:	ef 90       	pop	r14
 18a:	df 90       	pop	r13
 18c:	cf 90       	pop	r12
 18e:	bf 90       	pop	r11
 190:	af 90       	pop	r10
 192:	9f 90       	pop	r9
 194:	08 95       	ret

00000196 <blackfinFetchBlob>:


const BLACKFIN_BLOB* blackfinFetchBlob(BLACKFIN_CAMERA* camera, uint8_t blobNo){
	return &camera->blob[blobNo];
 196:	fc 01       	movw	r30, r24
 198:	23 81       	ldd	r18, Z+3	; 0x03
 19a:	34 81       	ldd	r19, Z+4	; 0x04
 19c:	f0 e1       	ldi	r31, 0x10	; 16
 19e:	6f 9f       	mul	r22, r31
 1a0:	20 0d       	add	r18, r0
 1a2:	31 1d       	adc	r19, r1
 1a4:	11 24       	eor	r1, r1
}
 1a6:	c9 01       	movw	r24, r18
 1a8:	08 95       	ret

blackfin_vc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000126  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000015a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000015a  2**0
                  ALLOC
  3 .progmem.data 0000000a  00000000  00000000  0000015a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000877  00000000  00000000  00000164  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000022e  00000000  00000000  000009db  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000001c2  00000000  00000000  00000c09  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000dcb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000145  00000000  00000000  00000deb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000445  00000000  00000000  00000f30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001375  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000064  00000000  00000000  000013a0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinSetBinRange>:
//example:	vc0090255000255000255      returns ##vc0
//              012345678901234567890
//sets color bin #0 using Y mean, 255, 0, 255, 0, 255 so
//pixels of higher than average brightness will appear in blob search

void blackfinSetBinRange(BLACKFIN_CAMERA* camera,uint8_t bin, const COLOR* min, const COLOR* max){
   0:	9f 92       	push	r9
   2:	af 92       	push	r10
   4:	bf 92       	push	r11
   6:	cf 92       	push	r12
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	2c 97       	sbiw	r28, 0x0c	; 12
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	de bf       	out	0x3e, r29	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	cd bf       	out	0x3d, r28	; 61
  26:	5c 01       	movw	r10, r24
  28:	96 2e       	mov	r9, r22
  2a:	ca 01       	movw	r24, r20
  2c:	79 01       	movw	r14, r18

	COLOR yuvMin;
	COLOR yuvMax;

	// Convert the colors to the YUV color space
	COLOR_YUV* minPtr = color2yuv(min, &yuvMin);
  2e:	be 01       	movw	r22, r28
  30:	6b 5f       	subi	r22, 0xFB	; 251
  32:	7f 4f       	sbci	r23, 0xFF	; 255
  34:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  38:	8c 01       	movw	r16, r24
	COLOR_YUV* maxPtr = color2yuv(max, &yuvMax);
  3a:	be 01       	movw	r22, r28
  3c:	6f 5f       	subi	r22, 0xFF	; 255
  3e:	7f 4f       	sbci	r23, 0xFF	; 255
  40:	c7 01       	movw	r24, r14
  42:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  46:	7c 01       	movw	r14, r24

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  48:	80 e0       	ldi	r24, 0x00	; 0
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  50:	6c 01       	movw	r12, r24
	_blackfin_index=0;
  52:	10 92 00 00 	sts	0x0000, r1
  56:	10 92 00 00 	sts	0x0000, r1

	// send 'vc' command
	rprintf("vc%d",(int)bin);//start command, send bin #
  5a:	1f 92       	push	r1
  5c:	9f 92       	push	r9
  5e:	20 e0       	ldi	r18, 0x00	; 0
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	3f 93       	push	r19
  64:	2f 93       	push	r18
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	8f 93       	push	r24
  6a:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->y,maxPtr->y));	// minimum y
  6e:	f7 01       	movw	r30, r14
  70:	90 81       	ld	r25, Z
  72:	f8 01       	movw	r30, r16
  74:	80 81       	ld	r24, Z
  76:	98 17       	cp	r25, r24
  78:	00 f4       	brcc	.+0      	; 0x7a <blackfinSetBinRange+0x7a>
  7a:	89 2f       	mov	r24, r25
  7c:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->y,maxPtr->y));	// maximum y
  80:	f7 01       	movw	r30, r14
  82:	90 81       	ld	r25, Z
  84:	f8 01       	movw	r30, r16
  86:	80 81       	ld	r24, Z
  88:	89 17       	cp	r24, r25
  8a:	00 f4       	brcc	.+0      	; 0x8c <blackfinSetBinRange+0x8c>
  8c:	89 2f       	mov	r24, r25
  8e:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->u,maxPtr->u));	// minimum u
  92:	f7 01       	movw	r30, r14
  94:	91 81       	ldd	r25, Z+1	; 0x01
  96:	f8 01       	movw	r30, r16
  98:	81 81       	ldd	r24, Z+1	; 0x01
  9a:	98 17       	cp	r25, r24
  9c:	00 f4       	brcc	.+0      	; 0x9e <blackfinSetBinRange+0x9e>
  9e:	89 2f       	mov	r24, r25
  a0:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->u,maxPtr->u));	// maximum u
  a4:	f7 01       	movw	r30, r14
  a6:	91 81       	ldd	r25, Z+1	; 0x01
  a8:	f8 01       	movw	r30, r16
  aa:	81 81       	ldd	r24, Z+1	; 0x01
  ac:	89 17       	cp	r24, r25
  ae:	00 f4       	brcc	.+0      	; 0xb0 <blackfinSetBinRange+0xb0>
  b0:	89 2f       	mov	r24, r25
  b2:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->v,maxPtr->v));	// minimum v
  b6:	f7 01       	movw	r30, r14
  b8:	92 81       	ldd	r25, Z+2	; 0x02
  ba:	f8 01       	movw	r30, r16
  bc:	82 81       	ldd	r24, Z+2	; 0x02
  be:	98 17       	cp	r25, r24
  c0:	00 f4       	brcc	.+0      	; 0xc2 <blackfinSetBinRange+0xc2>
  c2:	89 2f       	mov	r24, r25
  c4:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->v,maxPtr->v));	// maximum v
  c8:	f7 01       	movw	r30, r14
  ca:	92 81       	ldd	r25, Z+2	; 0x02
  cc:	f8 01       	movw	r30, r16
  ce:	82 81       	ldd	r24, Z+2	; 0x02
  d0:	89 17       	cp	r24, r25
  d2:	00 f4       	brcc	.+0      	; 0xd4 <blackfinSetBinRange+0xd4>
  d4:	89 2f       	mov	r24, r25
  d6:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
		rprintf(" Min="); colorDump(min);
		rprintf(" Max="); colorDump(max);
		rprintfCRLF();
	}
	#else
	__blackfinCommand(camera,PSTR("##vc"),null,values,1);
  da:	01 e0       	ldi	r16, 0x01	; 1
  dc:	10 e0       	ldi	r17, 0x00	; 0
  de:	9e 01       	movw	r18, r28
  e0:	27 5f       	subi	r18, 0xF7	; 247
  e2:	3f 4f       	sbci	r19, 0xFF	; 255
  e4:	40 e0       	ldi	r20, 0x00	; 0
  e6:	50 e0       	ldi	r21, 0x00	; 0
  e8:	60 e0       	ldi	r22, 0x00	; 0
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	c5 01       	movw	r24, r10
  ee:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	#endif

	// Restore rprintf to original position
	rprintfInit(old);
  f2:	c6 01       	movw	r24, r12
  f4:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  f8:	0f 90       	pop	r0
  fa:	0f 90       	pop	r0
  fc:	0f 90       	pop	r0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
}
 102:	2c 96       	adiw	r28, 0x0c	; 12
 104:	0f b6       	in	r0, 0x3f	; 63
 106:	f8 94       	cli
 108:	de bf       	out	0x3e, r29	; 62
 10a:	0f be       	out	0x3f, r0	; 63
 10c:	cd bf       	out	0x3d, r28	; 61
 10e:	df 91       	pop	r29
 110:	cf 91       	pop	r28
 112:	1f 91       	pop	r17
 114:	0f 91       	pop	r16
 116:	ff 90       	pop	r15
 118:	ef 90       	pop	r14
 11a:	df 90       	pop	r13
 11c:	cf 90       	pop	r12
 11e:	bf 90       	pop	r11
 120:	af 90       	pop	r10
 122:	9f 90       	pop	r9
 124:	08 95       	ret

blackfin_vf.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000144  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000178  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000178  2**0
                  ALLOC
  3 .progmem.data 0000000b  00000000  00000000  00000178  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000085d  00000000  00000000  00000183  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000230  00000000  00000000  000009e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000277  00000000  00000000  00000c10  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000e87  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000014e  00000000  00000000  00000ea7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000041d  00000000  00000000  00000ff5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001412  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000084  00000000  00000000  0000143c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinCountPixels>:

/*
 * Count the number of pixels in a rectangle that match a given color bin
 */

uint32_t blackfinCountPixels(BLACKFIN_CAMERA* camera,uint8_t bin, uint16_t x1, uint16_t x2, uint16_t y1, uint16_t y2){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <blackfinCountPixels+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <blackfinCountPixels+0x28>
  28:	1f 92       	push	r1
  2a:	cd b7       	in	r28, 0x3d	; 61
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	4c 01       	movw	r8, r24
  30:	2a 01       	movw	r4, r20
  32:	32 2e       	mov	r3, r18
  34:	23 2e       	mov	r2, r19
  36:	38 01       	movw	r6, r16
  38:	67 01       	movw	r12, r14

	int32_t values[1];

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	6d 83       	std	Y+5, r22	; 0x05
  40:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
  44:	5c 01       	movw	r10, r24
	_blackfin_index=0;
  46:	10 92 00 00 	sts	0x0000, r1
  4a:	10 92 00 00 	sts	0x0000, r1

	// send 'vf' command
	rprintf("vf%d",(int)bin);//start command, send bin #
  4e:	1f 92       	push	r1
  50:	6d 81       	ldd	r22, Y+5	; 0x05
  52:	6f 93       	push	r22
  54:	80 e0       	ldi	r24, 0x00	; 0
  56:	90 e0       	ldi	r25, 0x00	; 0
  58:	9f 93       	push	r25
  5a:	8f 93       	push	r24
  5c:	81 e0       	ldi	r24, 0x01	; 1
  5e:	8f 93       	push	r24
  60:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MIN(x1,x2));
  64:	e3 2c       	mov	r14, r3
  66:	f2 2c       	mov	r15, r2
  68:	4e 14       	cp	r4, r14
  6a:	5f 04       	cpc	r5, r15
  6c:	00 f4       	brcc	.+0      	; 0x6e <blackfinCountPixels+0x6e>
  6e:	72 01       	movw	r14, r4
  70:	00 e0       	ldi	r16, 0x00	; 0
  72:	10 e0       	ldi	r17, 0x00	; 0
  74:	20 e3       	ldi	r18, 0x30	; 48
  76:	40 e0       	ldi	r20, 0x00	; 0
  78:	64 e0       	ldi	r22, 0x04	; 4
  7a:	8a e0       	ldi	r24, 0x0A	; 10
  7c:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MAX(x1,x2));
  80:	e3 2c       	mov	r14, r3
  82:	f2 2c       	mov	r15, r2
  84:	e4 14       	cp	r14, r4
  86:	f5 04       	cpc	r15, r5
  88:	00 f4       	brcc	.+0      	; 0x8a <blackfinCountPixels+0x8a>
  8a:	72 01       	movw	r14, r4
  8c:	00 e0       	ldi	r16, 0x00	; 0
  8e:	10 e0       	ldi	r17, 0x00	; 0
  90:	20 e3       	ldi	r18, 0x30	; 48
  92:	40 e0       	ldi	r20, 0x00	; 0
  94:	64 e0       	ldi	r22, 0x04	; 4
  96:	8a e0       	ldi	r24, 0x0A	; 10
  98:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MIN(y1,y2));
  9c:	76 01       	movw	r14, r12
  9e:	6c 14       	cp	r6, r12
  a0:	7d 04       	cpc	r7, r13
  a2:	00 f4       	brcc	.+0      	; 0xa4 <blackfinCountPixels+0xa4>
  a4:	73 01       	movw	r14, r6
  a6:	00 e0       	ldi	r16, 0x00	; 0
  a8:	10 e0       	ldi	r17, 0x00	; 0
  aa:	20 e3       	ldi	r18, 0x30	; 48
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	64 e0       	ldi	r22, 0x04	; 4
  b0:	8a e0       	ldi	r24, 0x0A	; 10
  b2:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MAX(y1,y2));
  b6:	76 01       	movw	r14, r12
  b8:	c6 14       	cp	r12, r6
  ba:	d7 04       	cpc	r13, r7
  bc:	00 f4       	brcc	.+0      	; 0xbe <blackfinCountPixels+0xbe>
  be:	73 01       	movw	r14, r6
  c0:	00 e0       	ldi	r16, 0x00	; 0
  c2:	10 e0       	ldi	r17, 0x00	; 0
  c4:	20 e3       	ldi	r18, 0x30	; 48
  c6:	40 e0       	ldi	r20, 0x00	; 0
  c8:	64 e0       	ldi	r22, 0x04	; 4
  ca:	8a e0       	ldi	r24, 0x0A	; 10
  cc:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>

	// process the command

	int args = __blackfinCommand(camera,PSTR("##vf "),null,values,1);
  d0:	01 e0       	ldi	r16, 0x01	; 1
  d2:	10 e0       	ldi	r17, 0x00	; 0
  d4:	9e 01       	movw	r18, r28
  d6:	2f 5f       	subi	r18, 0xFF	; 255
  d8:	3f 4f       	sbci	r19, 0xFF	; 255
  da:	40 e0       	ldi	r20, 0x00	; 0
  dc:	50 e0       	ldi	r21, 0x00	; 0
  de:	60 e0       	ldi	r22, 0x00	; 0
  e0:	70 e0       	ldi	r23, 0x00	; 0
  e2:	c4 01       	movw	r24, r8
  e4:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
  e8:	8c 01       	movw	r16, r24
		rprintfCRLF();
	}
	#endif

	// Restore rprintf to original position
	rprintfInit(old);
  ea:	c5 01       	movw	r24, r10
  ec:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>

	return (args==1) ? values[0] : 0;
  f0:	0f 90       	pop	r0
  f2:	0f 90       	pop	r0
  f4:	0f 90       	pop	r0
  f6:	0f 90       	pop	r0
  f8:	0f 90       	pop	r0
  fa:	01 30       	cpi	r16, 0x01	; 1
  fc:	11 05       	cpc	r17, r1
  fe:	01 f4       	brne	.+0      	; 0x100 <blackfinCountPixels+0x100>
 100:	09 81       	ldd	r16, Y+1	; 0x01
 102:	1a 81       	ldd	r17, Y+2	; 0x02
 104:	2b 81       	ldd	r18, Y+3	; 0x03
 106:	3c 81       	ldd	r19, Y+4	; 0x04
 108:	00 c0       	rjmp	.+0      	; 0x10a <blackfinCountPixels+0x10a>
 10a:	00 e0       	ldi	r16, 0x00	; 0
 10c:	10 e0       	ldi	r17, 0x00	; 0
 10e:	98 01       	movw	r18, r16
}
 110:	b8 01       	movw	r22, r16
 112:	c9 01       	movw	r24, r18
 114:	0f 90       	pop	r0
 116:	0f 90       	pop	r0
 118:	0f 90       	pop	r0
 11a:	0f 90       	pop	r0
 11c:	0f 90       	pop	r0
 11e:	df 91       	pop	r29
 120:	cf 91       	pop	r28
 122:	1f 91       	pop	r17
 124:	0f 91       	pop	r16
 126:	ff 90       	pop	r15
 128:	ef 90       	pop	r14
 12a:	df 90       	pop	r13
 12c:	cf 90       	pop	r12
 12e:	bf 90       	pop	r11
 130:	af 90       	pop	r10
 132:	9f 90       	pop	r9
 134:	8f 90       	pop	r8
 136:	7f 90       	pop	r7
 138:	6f 90       	pop	r6
 13a:	5f 90       	pop	r5
 13c:	4f 90       	pop	r4
 13e:	3f 90       	pop	r3
 140:	2f 90       	pop	r2
 142:	08 95       	ret

blackfin_vm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000130  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000164  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000164  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000164  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000078a  00000000  00000000  00000170  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000219  00000000  00000000  000008fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000011d  00000000  00000000  00000b13  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000c30  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000177  00000000  00000000  00000c50  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000416  00000000  00000000  00000dc7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000011dd  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000058  00000000  00000000  00001208  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinMeanColor>:
 */
#include "blackfin.h"

#include "../../rprintf.h"

const COLOR * blackfinMeanColor(BLACKFIN_CAMERA* camera){
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
   6:	ef 92       	push	r14
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	2c 97       	sbiw	r28, 0x0c	; 12
  18:	0f b6       	in	r0, 0x3f	; 63
  1a:	f8 94       	cli
  1c:	de bf       	out	0x3e, r29	; 62
  1e:	0f be       	out	0x3f, r0	; 63
  20:	cd bf       	out	0x3d, r28	; 61
  22:	7c 01       	movw	r14, r24
	int32_t values[3];

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>
  2c:	6c 01       	movw	r12, r24
	_blackfin_index=0;
  2e:	10 92 00 00 	sts	0x0000, r1
  32:	10 92 00 00 	sts	0x0000, r1

	// send 'vm' command to camera
	rprintf("vm");
  36:	20 e0       	ldi	r18, 0x00	; 0
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	3f 93       	push	r19
  3c:	2f 93       	push	r18
  3e:	bb 24       	eor	r11, r11
  40:	b3 94       	inc	r11
  42:	bf 92       	push	r11
  44:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	// process the command
	int args = __blackfinCommand(camera,PSTR("##vmean "),null,values,3);
  48:	03 e0       	ldi	r16, 0x03	; 3
  4a:	10 e0       	ldi	r17, 0x00	; 0
  4c:	9e 01       	movw	r18, r28
  4e:	2f 5f       	subi	r18, 0xFF	; 255
  50:	3f 4f       	sbci	r19, 0xFF	; 255
  52:	40 e0       	ldi	r20, 0x00	; 0
  54:	50 e0       	ldi	r21, 0x00	; 0
  56:	60 e0       	ldi	r22, 0x00	; 0
  58:	70 e0       	ldi	r23, 0x00	; 0
  5a:	c7 01       	movw	r24, r14
  5c:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	#ifdef BLACKFIN_DEBUG
	_blackfin_set_active(camera->debug);	//Send rprintf to the debugger
	#endif

	if(args == 3){
  60:	0f 90       	pop	r0
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	03 97       	sbiw	r24, 0x03	; 3
  68:	01 f0       	breq	.+0      	; 0x6a <blackfinMeanColor+0x6a>
  6a:	00 c0       	rjmp	.+0      	; 0x6c <blackfinMeanColor+0x6c>
		//save it away - stay within limits of 0 to 255 for each band
		CRITICAL_SECTION_START;
  6c:	8f b7       	in	r24, 0x3f	; 63
  6e:	f8 94       	cli
		camera->mean->colorSpace = YUV;
  70:	d7 01       	movw	r26, r14
  72:	15 96       	adiw	r26, 0x05	; 5
  74:	ed 91       	ld	r30, X+
  76:	fc 91       	ld	r31, X
  78:	16 97       	sbiw	r26, 0x06	; 6
  7a:	b0 82       	st	Z, r11
		camera->mean->bands.yuv.y = (uint8_t)CLAMP(values[0],0,255);
  7c:	49 81       	ldd	r20, Y+1	; 0x01
  7e:	5a 81       	ldd	r21, Y+2	; 0x02
  80:	6b 81       	ldd	r22, Y+3	; 0x03
  82:	7c 81       	ldd	r23, Y+4	; 0x04
  84:	14 16       	cp	r1, r20
  86:	15 06       	cpc	r1, r21
  88:	16 06       	cpc	r1, r22
  8a:	17 06       	cpc	r1, r23
  8c:	04 f4       	brge	.+0      	; 0x8e <blackfinMeanColor+0x8e>
  8e:	4f 3f       	cpi	r20, 0xFF	; 255
  90:	51 05       	cpc	r21, r1
  92:	61 05       	cpc	r22, r1
  94:	71 05       	cpc	r23, r1
  96:	04 f4       	brge	.+0      	; 0x98 <blackfinMeanColor+0x98>
  98:	00 c0       	rjmp	.+0      	; 0x9a <blackfinMeanColor+0x9a>
  9a:	40 e0       	ldi	r20, 0x00	; 0
  9c:	00 c0       	rjmp	.+0      	; 0x9e <blackfinMeanColor+0x9e>
  9e:	4f ef       	ldi	r20, 0xFF	; 255
  a0:	41 83       	std	Z+1, r20	; 0x01
		camera->mean->bands.yuv.u = (uint8_t)CLAMP(values[1],0,255);
  a2:	d7 01       	movw	r26, r14
  a4:	15 96       	adiw	r26, 0x05	; 5
  a6:	ed 91       	ld	r30, X+
  a8:	fc 91       	ld	r31, X
  aa:	16 97       	sbiw	r26, 0x06	; 6
  ac:	4d 81       	ldd	r20, Y+5	; 0x05
  ae:	5e 81       	ldd	r21, Y+6	; 0x06
  b0:	6f 81       	ldd	r22, Y+7	; 0x07
  b2:	78 85       	ldd	r23, Y+8	; 0x08
  b4:	14 16       	cp	r1, r20
  b6:	15 06       	cpc	r1, r21
  b8:	16 06       	cpc	r1, r22
  ba:	17 06       	cpc	r1, r23
  bc:	04 f4       	brge	.+0      	; 0xbe <blackfinMeanColor+0xbe>
  be:	4f 3f       	cpi	r20, 0xFF	; 255
  c0:	51 05       	cpc	r21, r1
  c2:	61 05       	cpc	r22, r1
  c4:	71 05       	cpc	r23, r1
  c6:	04 f4       	brge	.+0      	; 0xc8 <blackfinMeanColor+0xc8>
  c8:	00 c0       	rjmp	.+0      	; 0xca <blackfinMeanColor+0xca>
  ca:	40 e0       	ldi	r20, 0x00	; 0
  cc:	00 c0       	rjmp	.+0      	; 0xce <blackfinMeanColor+0xce>
  ce:	4f ef       	ldi	r20, 0xFF	; 255
  d0:	42 83       	std	Z+2, r20	; 0x02
		camera->mean->bands.yuv.v = (uint8_t)CLAMP(values[2],0,255);
  d2:	d7 01       	movw	r26, r14
  d4:	15 96       	adiw	r26, 0x05	; 5
  d6:	ed 91       	ld	r30, X+
  d8:	fc 91       	ld	r31, X
  da:	16 97       	sbiw	r26, 0x06	; 6
  dc:	49 85       	ldd	r20, Y+9	; 0x09
  de:	5a 85       	ldd	r21, Y+10	; 0x0a
  e0:	6b 85       	ldd	r22, Y+11	; 0x0b
  e2:	7c 85       	ldd	r23, Y+12	; 0x0c
  e4:	14 16       	cp	r1, r20
  e6:	15 06       	cpc	r1, r21
  e8:	16 06       	cpc	r1, r22
  ea:	17 06       	cpc	r1, r23
  ec:	04 f4       	brge	.+0      	; 0xee <blackfinMeanColor+0xee>
  ee:	4f 3f       	cpi	r20, 0xFF	; 255
  f0:	51 05       	cpc	r21, r1
  f2:	61 05       	cpc	r22, r1
  f4:	71 05       	cpc	r23, r1
  f6:	04 f4       	brge	.+0      	; 0xf8 <blackfinMeanColor+0xf8>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <blackfinMeanColor+0xfa>
  fa:	40 e0       	ldi	r20, 0x00	; 0
  fc:	00 c0       	rjmp	.+0      	; 0xfe <blackfinMeanColor+0xfe>
  fe:	4f ef       	ldi	r20, 0xFF	; 255
 100:	43 83       	std	Z+3, r20	; 0x03
		CRITICAL_SECTION_END;
 102:	8f bf       	out	0x3f, r24	; 63
		rprintf("vm got %d values!\n",args);
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
 104:	c6 01       	movw	r24, r12
 106:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	return camera->mean;
}
 10a:	f7 01       	movw	r30, r14
 10c:	85 81       	ldd	r24, Z+5	; 0x05
 10e:	96 81       	ldd	r25, Z+6	; 0x06
 110:	2c 96       	adiw	r28, 0x0c	; 12
 112:	0f b6       	in	r0, 0x3f	; 63
 114:	f8 94       	cli
 116:	de bf       	out	0x3e, r29	; 62
 118:	0f be       	out	0x3f, r0	; 63
 11a:	cd bf       	out	0x3d, r28	; 61
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	bf 90       	pop	r11
 12e:	08 95       	ret

blackfin_vp.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000e0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000114  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000114  2**0
                  ALLOC
  3 .progmem.data 00000009  00000000  00000000  00000114  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000861  00000000  00000000  0000011d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000273  00000000  00000000  0000097e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000249  00000000  00000000  00000bf1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000e3a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000014b  00000000  00000000  00000e5a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000042c  00000000  00000000  00000fa5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000013d1  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000078  00000000  00000000  000013fc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinGetPixel>:

/*
 * Fetch the pixel color at a given location
 */

void blackfinGetPixel(BLACKFIN_CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
   0:	5f 92       	push	r5
   2:	6f 92       	push	r6
   4:	7f 92       	push	r7
   6:	8f 92       	push	r8
   8:	9f 92       	push	r9
   a:	af 92       	push	r10
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	cd b7       	in	r28, 0x3d	; 61
  20:	de b7       	in	r29, 0x3e	; 62
  22:	2c 97       	sbiw	r28, 0x0c	; 12
  24:	0f b6       	in	r0, 0x3f	; 63
  26:	f8 94       	cli
  28:	de bf       	out	0x3e, r29	; 62
  2a:	0f be       	out	0x3f, r0	; 63
  2c:	cd bf       	out	0x3d, r28	; 61
  2e:	4c 01       	movw	r8, r24
  30:	7b 01       	movw	r14, r22
  32:	3a 01       	movw	r6, r20
  34:	69 01       	movw	r12, r18

	int32_t values[3];

	// Make rprintf go to _blackfin_command
	 Writer old = rprintfInit(&_blackfin_putcmd);
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	90 e0       	ldi	r25, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
  3e:	5c 01       	movw	r10, r24
	_blackfin_index=0;
  40:	10 92 00 00 	sts	0x0000, r1
  44:	10 92 00 00 	sts	0x0000, r1

	// send 'vp' command
	rprintf("vp");
  48:	20 e0       	ldi	r18, 0x00	; 0
  4a:	30 e0       	ldi	r19, 0x00	; 0
  4c:	3f 93       	push	r19
  4e:	2f 93       	push	r18
  50:	55 24       	eor	r5, r5
  52:	53 94       	inc	r5
  54:	5f 92       	push	r5
  56:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
	rprintfNum(10,4,FALSE,'0',x);
  5a:	00 e0       	ldi	r16, 0x00	; 0
  5c:	10 e0       	ldi	r17, 0x00	; 0
  5e:	20 e3       	ldi	r18, 0x30	; 48
  60:	40 e0       	ldi	r20, 0x00	; 0
  62:	64 e0       	ldi	r22, 0x04	; 4
  64:	8a e0       	ldi	r24, 0x0A	; 10
  66:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
	rprintfNum(10,4,FALSE,'0',y);
  6a:	73 01       	movw	r14, r6
  6c:	00 e0       	ldi	r16, 0x00	; 0
  6e:	10 e0       	ldi	r17, 0x00	; 0
  70:	20 e3       	ldi	r18, 0x30	; 48
  72:	40 e0       	ldi	r20, 0x00	; 0
  74:	64 e0       	ldi	r22, 0x04	; 4
  76:	8a e0       	ldi	r24, 0x0A	; 10
  78:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>

	// process the command

	int args = __blackfinCommand(camera,PSTR("##vp "),null,values,3);
  7c:	03 e0       	ldi	r16, 0x03	; 3
  7e:	10 e0       	ldi	r17, 0x00	; 0
  80:	9e 01       	movw	r18, r28
  82:	2f 5f       	subi	r18, 0xFF	; 255
  84:	3f 4f       	sbci	r19, 0xFF	; 255
  86:	40 e0       	ldi	r20, 0x00	; 0
  88:	50 e0       	ldi	r21, 0x00	; 0
  8a:	60 e0       	ldi	r22, 0x00	; 0
  8c:	70 e0       	ldi	r23, 0x00	; 0
  8e:	c4 01       	movw	r24, r8
  90:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>

	if(args==3){
  94:	0f 90       	pop	r0
  96:	0f 90       	pop	r0
  98:	0f 90       	pop	r0
  9a:	03 97       	sbiw	r24, 0x03	; 3
  9c:	01 f4       	brne	.+0      	; 0x9e <blackfinGetPixel+0x9e>
		colorSetYUV(color,(uint8_t)(values[0]), (uint8_t)(values[1]),(uint8_t)(values[2]));
  9e:	89 85       	ldd	r24, Y+9	; 0x09
  a0:	9d 81       	ldd	r25, Y+5	; 0x05
  a2:	29 81       	ldd	r18, Y+1	; 0x01
	color->bands.rgb.g = g;
	color->bands.rgb.b = b;
}

static __inline__ void colorSetYUV(COLOR* color, uint8_t y, uint8_t u, uint8_t v ){
	color->colorSpace = YUV;
  a4:	f6 01       	movw	r30, r12
  a6:	50 82       	st	Z, r5
	color->bands.yuv.y = y;
  a8:	21 83       	std	Z+1, r18	; 0x01
	color->bands.yuv.u = u;
  aa:	92 83       	std	Z+2, r25	; 0x02
	color->bands.yuv.v = v;
  ac:	83 83       	std	Z+3, r24	; 0x03
		rprintfCRLF();
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
  ae:	c5 01       	movw	r24, r10
  b0:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
}
  b4:	2c 96       	adiw	r28, 0x0c	; 12
  b6:	0f b6       	in	r0, 0x3f	; 63
  b8:	f8 94       	cli
  ba:	de bf       	out	0x3e, r29	; 62
  bc:	0f be       	out	0x3f, r0	; 63
  be:	cd bf       	out	0x3d, r28	; 61
  c0:	df 91       	pop	r29
  c2:	cf 91       	pop	r28
  c4:	1f 91       	pop	r17
  c6:	0f 91       	pop	r16
  c8:	ff 90       	pop	r15
  ca:	ef 90       	pop	r14
  cc:	df 90       	pop	r13
  ce:	cf 90       	pop	r12
  d0:	bf 90       	pop	r11
  d2:	af 90       	pop	r10
  d4:	9f 90       	pop	r9
  d6:	8f 90       	pop	r8
  d8:	7f 90       	pop	r7
  da:	6f 90       	pop	r6
  dc:	5f 90       	pop	r5
  de:	08 95       	ret

_camera_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000266  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000029a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000029a  2**0
                  ALLOC
  3 .debug_info   00000df0  00000000  00000000  0000029a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000252  00000000  00000000  0000108a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000a7a  00000000  00000000  000012dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001d56  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000180  00000000  00000000  00001d76  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004c9  00000000  00000000  00001ef6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000023bf  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000104  00000000  00000000  000023ec  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_cameraInit>:
#include <string.h>

void     _cameraInit(CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	void (*fn)(CAMERA*) = (void (*)(CAMERA*))pgm_read_word(&class->init);
   0:	dc 01       	movw	r26, r24
   2:	ed 91       	ld	r30, X+
   4:	fc 91       	ld	r31, X
   6:	25 91       	lpm	r18, Z+
   8:	34 91       	lpm	r19, Z
   a:	f9 01       	movw	r30, r18
	if(fn){
   c:	30 97       	sbiw	r30, 0x00	; 0
   e:	01 f0       	breq	.+0      	; 0x10 <_cameraInit+0x10>
		fn(camera);
  10:	09 94       	ijmp
  12:	08 95       	ret

00000014 <_cameraXresolution>:

uint16_t  _cameraXresolution(CAMERA* camera){
	uint16_t rtn = 0;
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->xResolution);
  14:	dc 01       	movw	r26, r24
  16:	ed 91       	ld	r30, X+
  18:	fc 91       	ld	r31, X
  1a:	32 96       	adiw	r30, 0x02	; 2
  1c:	25 91       	lpm	r18, Z+
  1e:	34 91       	lpm	r19, Z
  20:	f9 01       	movw	r30, r18
	if(fn){
  22:	30 97       	sbiw	r30, 0x00	; 0
  24:	01 f0       	breq	.+0      	; 0x26 <_cameraXresolution+0x12>
		rtn = fn(camera);
  26:	09 94       	ijmp
	}
	return rtn;
}
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	90 e0       	ldi	r25, 0x00	; 0
  2c:	08 95       	ret

0000002e <_cameraYresolution>:

uint16_t  _cameraYresolution(CAMERA* camera){
	uint16_t rtn = 0;
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->yResolution);
  2e:	dc 01       	movw	r26, r24
  30:	ed 91       	ld	r30, X+
  32:	fc 91       	ld	r31, X
  34:	34 96       	adiw	r30, 0x04	; 4
  36:	25 91       	lpm	r18, Z+
  38:	34 91       	lpm	r19, Z
  3a:	f9 01       	movw	r30, r18
	if(fn){
  3c:	30 97       	sbiw	r30, 0x00	; 0
  3e:	01 f0       	breq	.+0      	; 0x40 <_cameraYresolution+0x12>
		rtn = fn(camera);
  40:	09 94       	ijmp
	}
	return rtn;
}
  42:	80 e0       	ldi	r24, 0x00	; 0
  44:	90 e0       	ldi	r25, 0x00	; 0
  46:	08 95       	ret

00000048 <_cameraNumColorBins>:

uint8_t  _cameraNumColorBins(const CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->numColorBins);
  48:	dc 01       	movw	r26, r24
  4a:	ed 91       	ld	r30, X+
  4c:	fc 91       	ld	r31, X
  4e:	36 96       	adiw	r30, 0x06	; 6
  50:	84 91       	lpm	r24, Z
}
  52:	08 95       	ret

00000054 <_cameraMaxBlobs>:

uint8_t  _cameraMaxBlobs(const CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->maxBlobs);
  54:	dc 01       	movw	r26, r24
  56:	ed 91       	ld	r30, X+
  58:	fc 91       	ld	r31, X
  5a:	37 96       	adiw	r30, 0x07	; 7
  5c:	84 91       	lpm	r24, Z
}
  5e:	08 95       	ret

00000060 <_cameraSetBin>:

boolean   _cameraSetBin(CAMERA* camera,uint8_t bin,const COLOR*min, const COLOR*max){
	boolean rtn = FALSE;
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*, uint8_t,const COLOR*,const COLOR*) =
		(boolean (*)(CAMERA*, uint8_t, const COLOR*, const COLOR*))pgm_read_word(&class->setBin);
  60:	dc 01       	movw	r26, r24
  62:	ed 91       	ld	r30, X+
  64:	fc 91       	ld	r31, X
  66:	38 96       	adiw	r30, 0x08	; 8
  68:	a5 91       	lpm	r26, Z+
  6a:	b4 91       	lpm	r27, Z
}

boolean   _cameraSetBin(CAMERA* camera,uint8_t bin,const COLOR*min, const COLOR*max){
	boolean rtn = FALSE;
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*, uint8_t,const COLOR*,const COLOR*) =
  6c:	fd 01       	movw	r30, r26
		(boolean (*)(CAMERA*, uint8_t, const COLOR*, const COLOR*))pgm_read_word(&class->setBin);
	if(fn){
  6e:	10 97       	sbiw	r26, 0x00	; 0
  70:	01 f0       	breq	.+0      	; 0x72 <_cameraSetBin+0x12>
		rtn = fn(camera,bin,min,max);
  72:	09 94       	ijmp
	}
	return rtn;
}
  74:	80 e0       	ldi	r24, 0x00	; 0
  76:	08 95       	ret

00000078 <_cameraGetBlobs>:

uint8_t   _cameraGetBlobs(CAMERA* camera,uint8_t bin){
	uint16_t rtn = 0;
	camera->numBlobs = 0;
  78:	dc 01       	movw	r26, r24
  7a:	1c 96       	adiw	r26, 0x0c	; 12
  7c:	1c 92       	st	X, r1
  7e:	1c 97       	sbiw	r26, 0x0c	; 12

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint8_t (*fn)(CAMERA*, uint8_t) = (uint8_t (*)(CAMERA*, uint8_t))pgm_read_word(&class->getBlobs);
  80:	ed 91       	ld	r30, X+
  82:	fc 91       	ld	r31, X
  84:	3a 96       	adiw	r30, 0x0a	; 10
  86:	25 91       	lpm	r18, Z+
  88:	34 91       	lpm	r19, Z
  8a:	f9 01       	movw	r30, r18
	if(fn){
  8c:	30 97       	sbiw	r30, 0x00	; 0
  8e:	01 f0       	breq	.+0      	; 0x90 <_cameraGetBlobs+0x18>
		rtn = fn(camera,bin);
  90:	09 95       	icall
  92:	08 95       	ret
	}
	return rtn;
}

uint8_t   _cameraGetBlobs(CAMERA* camera,uint8_t bin){
	uint16_t rtn = 0;
  94:	80 e0       	ldi	r24, 0x00	; 0
  96:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t (*fn)(CAMERA*, uint8_t) = (uint8_t (*)(CAMERA*, uint8_t))pgm_read_word(&class->getBlobs);
	if(fn){
		rtn = fn(camera,bin);
	}
	return rtn;
}
  98:	08 95       	ret

0000009a <_cameraGetPixel>:
	boolean rtn = FALSE;

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*,uint16_t,uint16_t,COLOR*) = (boolean (*)(CAMERA*, uint16_t,uint16_t,COLOR*))
		pgm_read_word(&class->getPixel);
  9a:	dc 01       	movw	r26, r24
  9c:	ed 91       	ld	r30, X+
  9e:	fc 91       	ld	r31, X
  a0:	3c 96       	adiw	r30, 0x0c	; 12
  a2:	a5 91       	lpm	r26, Z+
  a4:	b4 91       	lpm	r27, Z
boolean _cameraGetPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
	boolean rtn = FALSE;

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*,uint16_t,uint16_t,COLOR*) = (boolean (*)(CAMERA*, uint16_t,uint16_t,COLOR*))
  a6:	fd 01       	movw	r30, r26
		pgm_read_word(&class->getPixel);
	if(fn){
  a8:	10 97       	sbiw	r26, 0x00	; 0
  aa:	01 f0       	breq	.+0      	; 0xac <_cameraGetPixel+0x12>
		rtn = fn(camera,x,y,color);
  ac:	09 94       	ijmp
	}
	return rtn;

}
  ae:	80 e0       	ldi	r24, 0x00	; 0
  b0:	08 95       	ret

000000b2 <_cameraInsertBlob>:



// Library only method to insert a new blob
// This uses an insert sort
void	_cameraInsertBlob(CAMERA* camera, const CAMERA_BLOB* blob){
  b2:	4f 92       	push	r4
  b4:	5f 92       	push	r5
  b6:	6f 92       	push	r6
  b8:	7f 92       	push	r7
  ba:	8f 92       	push	r8
  bc:	9f 92       	push	r9
  be:	af 92       	push	r10
  c0:	bf 92       	push	r11
  c2:	cf 92       	push	r12
  c4:	df 92       	push	r13
  c6:	ef 92       	push	r14
  c8:	ff 92       	push	r15
  ca:	0f 93       	push	r16
  cc:	1f 93       	push	r17
  ce:	cf 93       	push	r28
  d0:	df 93       	push	r29
  d2:	ec 01       	movw	r28, r24
  d4:	3b 01       	movw	r6, r22
	uint16_t width = blob->right - blob->left + 1;
  d6:	fb 01       	movw	r30, r22
  d8:	82 80       	ldd	r8, Z+2	; 0x02
  da:	93 80       	ldd	r9, Z+3	; 0x03
  dc:	ff ef       	ldi	r31, 0xFF	; 255
  de:	8f 1a       	sub	r8, r31
  e0:	9f 0a       	sbc	r9, r31
  e2:	fb 01       	movw	r30, r22
  e4:	80 81       	ld	r24, Z
  e6:	91 81       	ldd	r25, Z+1	; 0x01
  e8:	88 1a       	sub	r8, r24
  ea:	99 0a       	sbc	r9, r25
	uint16_t height = blob->bottom - blob->top + 1;
  ec:	a6 80       	ldd	r10, Z+6	; 0x06
  ee:	b7 80       	ldd	r11, Z+7	; 0x07
  f0:	ff ef       	ldi	r31, 0xFF	; 255
  f2:	af 1a       	sub	r10, r31
  f4:	bf 0a       	sbc	r11, r31
  f6:	fb 01       	movw	r30, r22
  f8:	84 81       	ldd	r24, Z+4	; 0x04
  fa:	95 81       	ldd	r25, Z+5	; 0x05
  fc:	a8 1a       	sub	r10, r24
  fe:	b9 0a       	sbc	r11, r25
	uint32_t pixels = width * height;
 100:	a8 9c       	mul	r10, r8
 102:	60 01       	movw	r12, r0
 104:	a9 9c       	mul	r10, r9
 106:	d0 0c       	add	r13, r0
 108:	b8 9c       	mul	r11, r8
 10a:	d0 0c       	add	r13, r0
 10c:	11 24       	eor	r1, r1
 10e:	e1 2c       	mov	r14, r1
 110:	f1 2c       	mov	r15, r1
	if(pixels >= camera->minBlobSize && camera->blobs != null){
 112:	48 85       	ldd	r20, Y+8	; 0x08
 114:	59 85       	ldd	r21, Y+9	; 0x09
 116:	6a 85       	ldd	r22, Y+10	; 0x0a
 118:	7b 85       	ldd	r23, Y+11	; 0x0b
 11a:	c4 16       	cp	r12, r20
 11c:	d5 06       	cpc	r13, r21
 11e:	e6 06       	cpc	r14, r22
 120:	f7 06       	cpc	r15, r23
 122:	00 f4       	brcc	.+0      	; 0x124 <_cameraInsertBlob+0x72>
 124:	00 c0       	rjmp	.+0      	; 0x126 <_cameraInsertBlob+0x74>
 126:	0e 81       	ldd	r16, Y+6	; 0x06
 128:	1f 81       	ldd	r17, Y+7	; 0x07
 12a:	01 15       	cp	r16, r1
 12c:	11 05       	cpc	r17, r1
 12e:	01 f4       	brne	.+0      	; 0x130 <_cameraInsertBlob+0x7e>
 130:	00 c0       	rjmp	.+0      	; 0x132 <_cameraInsertBlob+0x80>
		// Its big enough to be considered
		uint8_t maxBlobs = _cameraMaxBlobs(camera);
 132:	ce 01       	movw	r24, r28
 134:	0e 94 00 00 	call	0	; 0x0 <_cameraInit>
 138:	58 2e       	mov	r5, r24

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
 13a:	8c 85       	ldd	r24, Y+12	; 0x0c
 13c:	98 01       	movw	r18, r16
 13e:	41 2c       	mov	r4, r1
 140:	00 c0       	rjmp	.+0      	; 0x142 <_cameraInsertBlob+0x90>
 142:	2f 5e       	subi	r18, 0xEF	; 239
 144:	3f 4f       	sbci	r19, 0xFF	; 255



// Library only method to insert a new blob
// This uses an insert sort
void	_cameraInsertBlob(CAMERA* camera, const CAMERA_BLOB* blob){
 146:	f9 01       	movw	r30, r18
 148:	35 97       	sbiw	r30, 0x05	; 5
		uint8_t maxBlobs = _cameraMaxBlobs(camera);

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
 14a:	40 81       	ld	r20, Z
 14c:	51 81       	ldd	r21, Z+1	; 0x01
 14e:	62 81       	ldd	r22, Z+2	; 0x02
 150:	73 81       	ldd	r23, Z+3	; 0x03
 152:	4c 15       	cp	r20, r12
 154:	5d 05       	cpc	r21, r13
 156:	6e 05       	cpc	r22, r14
 158:	7f 05       	cpc	r23, r15
 15a:	00 f4       	brcc	.+0      	; 0x15c <_cameraInsertBlob+0xaa>
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
 15c:	45 2d       	mov	r20, r5
 15e:	50 e0       	ldi	r21, 0x00	; 0
 160:	41 50       	subi	r20, 0x01	; 1
 162:	51 09       	sbc	r21, r1
 164:	28 2f       	mov	r18, r24
 166:	30 e0       	ldi	r19, 0x00	; 0
 168:	42 17       	cp	r20, r18
 16a:	53 07       	cpc	r21, r19
 16c:	04 f4       	brge	.+0      	; 0x16e <_cameraInsertBlob+0xbc>
 16e:	9a 01       	movw	r18, r20
				while( last < slot+1){
 170:	33 27       	eor	r19, r19
					memcpy(&camera->blobs[last], &camera->blobs[last-1], sizeof(CAMERA_BLOB));
 172:	c9 01       	movw	r24, r18
 174:	01 97       	sbiw	r24, 0x01	; 1
 176:	41 e1       	ldi	r20, 0x11	; 17
 178:	48 9f       	mul	r20, r24
 17a:	b0 01       	movw	r22, r0
 17c:	49 9f       	mul	r20, r25
 17e:	70 0d       	add	r23, r0
 180:	11 24       	eor	r1, r1
 182:	42 9f       	mul	r20, r18
 184:	80 01       	movw	r16, r0
 186:	43 9f       	mul	r20, r19
 188:	10 0d       	add	r17, r0
 18a:	11 24       	eor	r1, r1
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
				while( last < slot+1){
 18c:	44 2d       	mov	r20, r4
 18e:	50 e0       	ldi	r21, 0x00	; 0
					memcpy(&camera->blobs[last], &camera->blobs[last-1], sizeof(CAMERA_BLOB));
 190:	81 e1       	ldi	r24, 0x11	; 17
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
				while( last < slot+1){
 192:	00 c0       	rjmp	.+0      	; 0x194 <_cameraInsertBlob+0xe2>
					memcpy(&camera->blobs[last], &camera->blobs[last-1], sizeof(CAMERA_BLOB));
 194:	ee 81       	ldd	r30, Y+6	; 0x06
 196:	ff 81       	ldd	r31, Y+7	; 0x07
 198:	df 01       	movw	r26, r30
 19a:	a0 0f       	add	r26, r16
 19c:	b1 1f       	adc	r27, r17
 19e:	e6 0f       	add	r30, r22
 1a0:	f7 1f       	adc	r31, r23
 1a2:	98 2f       	mov	r25, r24
 1a4:	01 90       	ld	r0, Z+
 1a6:	0d 92       	st	X+, r0
 1a8:	9a 95       	dec	r25
 1aa:	01 f4       	brne	.+0      	; 0x1ac <_cameraInsertBlob+0xfa>
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
				while( last < slot+1){
 1ac:	42 17       	cp	r20, r18
 1ae:	53 07       	cpc	r21, r19
 1b0:	04 f4       	brge	.+0      	; 0x1b2 <_cameraInsertBlob+0x100>
				break;
			}
		}

		// set variables at blob[slot]
		if(slot < maxBlobs){
 1b2:	45 14       	cp	r4, r5
 1b4:	00 f4       	brcc	.+0      	; 0x1b6 <_cameraInsertBlob+0x104>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <_cameraInsertBlob+0x106>
		// Its big enough to be considered
		uint8_t maxBlobs = _cameraMaxBlobs(camera);

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
 1b8:	43 94       	inc	r4
 1ba:	48 12       	cpse	r4, r24
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <_cameraInsertBlob+0x10c>
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <_cameraInsertBlob+0x10e>
			}
		}

		// set variables at blob[slot]
		if(slot < maxBlobs){
			CAMERA_BLOB* dest = &camera->blobs[slot];
 1c0:	0e 81       	ldd	r16, Y+6	; 0x06
 1c2:	1f 81       	ldd	r17, Y+7	; 0x07
 1c4:	f1 e1       	ldi	r31, 0x11	; 17
 1c6:	4f 9e       	mul	r4, r31
 1c8:	00 0d       	add	r16, r0
 1ca:	11 1d       	adc	r17, r1
 1cc:	11 24       	eor	r1, r1
			memcpy(dest, blob, sizeof(CAMERA_BLOB));
 1ce:	81 e1       	ldi	r24, 0x11	; 17
 1d0:	f3 01       	movw	r30, r6
 1d2:	d8 01       	movw	r26, r16
 1d4:	01 90       	ld	r0, Z+
 1d6:	0d 92       	st	X+, r0
 1d8:	8a 95       	dec	r24
 1da:	01 f4       	brne	.+0      	; 0x1dc <_cameraInsertBlob+0x12a>
			dest->pixels = pixels;
 1dc:	f8 01       	movw	r30, r16
 1de:	c4 86       	std	Z+12, r12	; 0x0c
 1e0:	d5 86       	std	Z+13, r13	; 0x0d
 1e2:	e6 86       	std	Z+14, r14	; 0x0e
 1e4:	f7 86       	std	Z+15, r15	; 0x0f
			dest->xCenter = (width / 2) + dest->left - (_cameraXresolution(camera) / 2);
 1e6:	96 94       	lsr	r9
 1e8:	87 94       	ror	r8
 1ea:	80 81       	ld	r24, Z
 1ec:	91 81       	ldd	r25, Z+1	; 0x01
 1ee:	88 0e       	add	r8, r24
 1f0:	99 1e       	adc	r9, r25
 1f2:	ce 01       	movw	r24, r28
 1f4:	0e 94 00 00 	call	0	; 0x0 <_cameraInit>
 1f8:	96 95       	lsr	r25
 1fa:	87 95       	ror	r24
 1fc:	88 1a       	sub	r8, r24
 1fe:	99 0a       	sbc	r9, r25
 200:	f8 01       	movw	r30, r16
 202:	91 86       	std	Z+9, r9	; 0x09
 204:	80 86       	std	Z+8, r8	; 0x08
			dest->yCenter = (height / 2) + dest->top - (_cameraYresolution(camera) / 2);
 206:	b6 94       	lsr	r11
 208:	a7 94       	ror	r10
 20a:	24 81       	ldd	r18, Z+4	; 0x04
 20c:	35 81       	ldd	r19, Z+5	; 0x05
 20e:	a2 0e       	add	r10, r18
 210:	b3 1e       	adc	r11, r19
 212:	ce 01       	movw	r24, r28
 214:	0e 94 00 00 	call	0	; 0x0 <_cameraInit>
 218:	96 95       	lsr	r25
 21a:	87 95       	ror	r24
			dest->yCenter *= -1;
 21c:	8a 19       	sub	r24, r10
 21e:	9b 09       	sbc	r25, r11
 220:	f8 01       	movw	r30, r16
 222:	93 87       	std	Z+11, r25	; 0x0b
 224:	82 87       	std	Z+10, r24	; 0x0a

			if(camera->numBlobs < maxBlobs){
 226:	8c 85       	ldd	r24, Y+12	; 0x0c
 228:	85 15       	cp	r24, r5
 22a:	00 f4       	brcc	.+0      	; 0x22c <_cameraInsertBlob+0x17a>
				camera->numBlobs++;
 22c:	8f 5f       	subi	r24, 0xFF	; 255
 22e:	8c 87       	std	Y+12, r24	; 0x0c
			}
		}
	}
}
 230:	df 91       	pop	r29
 232:	cf 91       	pop	r28
 234:	1f 91       	pop	r17
 236:	0f 91       	pop	r16
 238:	ff 90       	pop	r15
 23a:	ef 90       	pop	r14
 23c:	df 90       	pop	r13
 23e:	cf 90       	pop	r12
 240:	bf 90       	pop	r11
 242:	af 90       	pop	r10
 244:	9f 90       	pop	r9
 246:	8f 90       	pop	r8
 248:	7f 90       	pop	r7
 24a:	6f 90       	pop	r6
 24c:	5f 90       	pop	r5
 24e:	4f 90       	pop	r4
 250:	08 95       	ret

00000252 <_cameraFetchBlob>:



const CAMERA_BLOB* _cameraFetchBlob(const CAMERA* camera, uint8_t blobNo){
	return &camera->blobs[blobNo];
 252:	fc 01       	movw	r30, r24
 254:	26 81       	ldd	r18, Z+6	; 0x06
 256:	37 81       	ldd	r19, Z+7	; 0x07
 258:	f1 e1       	ldi	r31, 0x11	; 17
 25a:	6f 9f       	mul	r22, r31
 25c:	20 0d       	add	r18, r0
 25e:	31 1d       	adc	r19, r1
 260:	11 24       	eor	r1, r1
}
 262:	c9 01       	movw	r24, r18
 264:	08 95       	ret

Sabertooth.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000026e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002a2  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000002a2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000e2c  00000000  00000000  000002a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000032f  00000000  00000000  000010d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000647  00000000  00000000  00001401  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001a48  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000048  00000000  00000000  00001a68  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001fa  00000000  00000000  00001ab0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000635  00000000  00000000  00001caa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000022df  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000c0  00000000  00000000  0000230c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__saberOutput>:

#include "../../core.h"
#include "../../timer.h"

// speed is 0 to 127
static void __saberOutput(SABERTOOTH_MOTOR* remote, boolean fwd, uint8_t speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	8c 01       	movw	r16, r24
  10:	f6 2e       	mov	r15, r22
  12:	e4 2e       	mov	r14, r20

	UART* uart = remote->driver->uart;
  14:	dc 01       	movw	r26, r24
  16:	16 96       	adiw	r26, 0x06	; 6
  18:	ed 91       	ld	r30, X+
  1a:	fc 91       	ld	r31, X
  1c:	17 97       	sbiw	r26, 0x07	; 7
  1e:	c2 81       	ldd	r28, Z+2	; 0x02
  20:	d3 81       	ldd	r29, Z+3	; 0x03

	switch(remote->driver->mode){
  22:	80 85       	ldd	r24, Z+8	; 0x08
  24:	88 23       	and	r24, r24
  26:	01 f0       	breq	.+0      	; 0x28 <__saberOutput+0x28>
  28:	81 30       	cpi	r24, 0x01	; 1
  2a:	01 f0       	breq	.+0      	; 0x2c <__saberOutput+0x2c>
  2c:	00 c0       	rjmp	.+0      	; 0x2e <__saberOutput+0x2e>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <__saberOutput+0x30>
		case PACKETIZED:{
			uint8_t checksum=0;
			checksum += _uartSendByte(uart,remote->address);
  30:	f8 01       	movw	r30, r16
  32:	64 81       	ldd	r22, Z+4	; 0x04
  34:	ce 01       	movw	r24, r28
  36:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  3a:	d8 2e       	mov	r13, r24

			uint8_t cmd;
			if(remote->motorNumber==1){
  3c:	d8 01       	movw	r26, r16
  3e:	15 96       	adiw	r26, 0x05	; 5
  40:	8c 91       	ld	r24, X
  42:	81 30       	cpi	r24, 0x01	; 1
  44:	01 f4       	brne	.+0      	; 0x46 <__saberOutput+0x46>
				// motor 1
				cmd = (fwd) ? 0 : 1;
  46:	61 e0       	ldi	r22, 0x01	; 1
  48:	ff 20       	and	r15, r15
  4a:	01 f0       	breq	.+0      	; 0x4c <__saberOutput+0x4c>
  4c:	60 e0       	ldi	r22, 0x00	; 0
  4e:	00 c0       	rjmp	.+0      	; 0x50 <__saberOutput+0x50>
			}else{
				// motor 2
				cmd = (fwd) ? 4 : 5;
  50:	ff 20       	and	r15, r15
  52:	01 f0       	breq	.+0      	; 0x54 <__saberOutput+0x54>
  54:	64 e0       	ldi	r22, 0x04	; 4
  56:	00 c0       	rjmp	.+0      	; 0x58 <__saberOutput+0x58>
  58:	65 e0       	ldi	r22, 0x05	; 5
			}
			checksum += _uartSendByte(uart,cmd);
  5a:	ce 01       	movw	r24, r28
  5c:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  60:	18 2f       	mov	r17, r24

			checksum += _uartSendByte(uart,speed);
  62:	6e 2d       	mov	r22, r14
  64:	ce 01       	movw	r24, r28
  66:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
				cmd = (fwd) ? 0 : 1;
			}else{
				// motor 2
				cmd = (fwd) ? 4 : 5;
			}
			checksum += _uartSendByte(uart,cmd);
  6a:	61 2f       	mov	r22, r17
  6c:	68 0f       	add	r22, r24

			checksum += _uartSendByte(uart,speed);
  6e:	6d 0d       	add	r22, r13

			_uartSendByte(uart, (checksum &0x7FU));
  70:	6f 77       	andi	r22, 0x7F	; 127
  72:	00 c0       	rjmp	.+0      	; 0x74 <__saberOutput+0x74>
		}
		break;

		case SIMPLE:{
			if(remote->motorNumber==1){
  74:	f8 01       	movw	r30, r16
  76:	85 81       	ldd	r24, Z+5	; 0x05
  78:	81 30       	cpi	r24, 0x01	; 1
  7a:	01 f4       	brne	.+0      	; 0x7c <__saberOutput+0x7c>
				// 1 is full reverse, 64 is stop, 127 is full fwd
				speed = interpolate(speed, 0, 127, 64 , (fwd) ? 127 : 1);
  7c:	66 23       	and	r22, r22
  7e:	01 f0       	breq	.+0      	; 0x80 <__saberOutput+0x80>
  80:	0f e7       	ldi	r16, 0x7F	; 127
  82:	10 e0       	ldi	r17, 0x00	; 0
  84:	00 c0       	rjmp	.+0      	; 0x86 <__saberOutput+0x86>
  86:	01 e0       	ldi	r16, 0x01	; 1
  88:	10 e0       	ldi	r17, 0x00	; 0
  8a:	20 e4       	ldi	r18, 0x40	; 64
  8c:	30 e0       	ldi	r19, 0x00	; 0
  8e:	00 c0       	rjmp	.+0      	; 0x90 <__saberOutput+0x90>
			}else{
				// 128 is full reverse, 192 is stop, 255 is full fwd
				speed = interpolate(speed, 0, 127, 192 , (fwd) ? 255 : 128);
  90:	66 23       	and	r22, r22
  92:	01 f0       	breq	.+0      	; 0x94 <__saberOutput+0x94>
  94:	0f ef       	ldi	r16, 0xFF	; 255
  96:	10 e0       	ldi	r17, 0x00	; 0
  98:	00 c0       	rjmp	.+0      	; 0x9a <__saberOutput+0x9a>
  9a:	00 e8       	ldi	r16, 0x80	; 128
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	20 ec       	ldi	r18, 0xC0	; 192
  a0:	30 e0       	ldi	r19, 0x00	; 0
  a2:	4f e7       	ldi	r20, 0x7F	; 127
  a4:	50 e0       	ldi	r21, 0x00	; 0
  a6:	60 e0       	ldi	r22, 0x00	; 0
  a8:	70 e0       	ldi	r23, 0x00	; 0
  aa:	8e 2d       	mov	r24, r14
  ac:	90 e0       	ldi	r25, 0x00	; 0
  ae:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			}
			_uartSendByte(uart, speed);
  b2:	68 2f       	mov	r22, r24
  b4:	ce 01       	movw	r24, r28
		}
		break;
	}
}
  b6:	df 91       	pop	r29
  b8:	cf 91       	pop	r28
  ba:	1f 91       	pop	r17
  bc:	0f 91       	pop	r16
  be:	ff 90       	pop	r15
  c0:	ef 90       	pop	r14
  c2:	df 90       	pop	r13
				speed = interpolate(speed, 0, 127, 64 , (fwd) ? 127 : 1);
			}else{
				// 128 is full reverse, 192 is stop, 255 is full fwd
				speed = interpolate(speed, 0, 127, 192 , (fwd) ? 255 : 128);
			}
			_uartSendByte(uart, speed);
  c4:	0c 94 00 00 	jmp	0	; 0x0 <__saberOutput>
		}
		break;
	}
}
  c8:	df 91       	pop	r29
  ca:	cf 91       	pop	r28
  cc:	1f 91       	pop	r17
  ce:	0f 91       	pop	r16
  d0:	ff 90       	pop	r15
  d2:	ef 90       	pop	r14
  d4:	df 90       	pop	r13
  d6:	08 95       	ret

000000d8 <setConnected>:

static void setConnected(__ACTUATOR *actuator, boolean connected){
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(connected){
  d8:	66 23       	and	r22, r22
  da:	01 f0       	breq	.+0      	; 0xdc <setConnected+0x4>
		motor->actuator.class=&c_Sabertooth;
		motor->driver = driver;
		act_setSpeed(motor,0);
		act_setConnected(motor,TRUE);
	}
}
  dc:	fc 01       	movw	r30, r24
  de:	62 81       	ldd	r22, Z+2	; 0x02

static void setConnected(__ACTUATOR *actuator, boolean connected){
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(connected){
		DRIVE_SPEED speed = act_getSpeed(remote);
		actuator->required_speed=-128;
  e0:	20 e8       	ldi	r18, 0x80	; 128
  e2:	22 83       	std	Z+2, r18	; 0x02
		act_setSpeed(remote, speed);
  e4:	0c 94 00 00 	jmp	0	; 0x0 <__saberOutput>
	}else{
		// Set speed = 0 in forwards to coast
		__saberOutput(remote, TRUE, 0);
  e8:	40 e0       	ldi	r20, 0x00	; 0
  ea:	6f ef       	ldi	r22, 0xFF	; 255
  ec:	0c 94 00 00 	jmp	0	; 0x0 <__saberOutput>

000000f0 <setSpeed>:
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  f0:	0f 93       	push	r16
  f2:	1f 93       	push	r17
  f4:	cf 93       	push	r28
  f6:	df 93       	push	r29
  f8:	ec 01       	movw	r28, r24
  fa:	86 2f       	mov	r24, r22
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  fc:	9b 81       	ldd	r25, Y+3	; 0x03
  fe:	90 ff       	sbrs	r25, 0
 100:	00 c0       	rjmp	.+0      	; 0x102 <setSpeed+0x12>
 102:	00 c0       	rjmp	.+0      	; 0x104 <setSpeed+0x14>
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);
 104:	0f e7       	ldi	r16, 0x7F	; 127
 106:	10 e0       	ldi	r17, 0x00	; 0
 108:	21 e8       	ldi	r18, 0x81	; 129
 10a:	3f ef       	ldi	r19, 0xFF	; 255
 10c:	4f e7       	ldi	r20, 0x7F	; 127
 10e:	50 e0       	ldi	r21, 0x00	; 0
 110:	61 e8       	ldi	r22, 0x81	; 129
 112:	7f ef       	ldi	r23, 0xFF	; 255
 114:	99 27       	eor	r25, r25
 116:	87 fd       	sbrc	r24, 7
 118:	90 95       	com	r25
 11a:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>

		// If speed is 0 then set reverse to brake
		boolean fwd=TRUE;
		if(s <= 0){
 11e:	18 16       	cp	r1, r24
 120:	04 f0       	brlt	.+0      	; 0x122 <setSpeed+0x32>
			s = -s;
 122:	81 95       	neg	r24
			fwd = FALSE;
 124:	60 e0       	ldi	r22, 0x00	; 0
 126:	00 c0       	rjmp	.+0      	; 0x128 <setSpeed+0x38>
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);

		// If speed is 0 then set reverse to brake
		boolean fwd=TRUE;
 128:	6f ef       	ldi	r22, 0xFF	; 255
		if(s <= 0){
			s = -s;
			fwd = FALSE;
		}

		__saberOutput(remote, fwd,s);
 12a:	48 2f       	mov	r20, r24
 12c:	ce 01       	movw	r24, r28
	}
}
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	1f 91       	pop	r17
 134:	0f 91       	pop	r16
		if(s <= 0){
			s = -s;
			fwd = FALSE;
		}

		__saberOutput(remote, fwd,s);
 136:	0c 94 00 00 	jmp	0	; 0x0 <__saberOutput>
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
 13a:	9a 81       	ldd	r25, Y+2	; 0x02
 13c:	96 13       	cpse	r25, r22
 13e:	00 c0       	rjmp	.+0      	; 0x140 <setSpeed+0x50>
			fwd = FALSE;
		}

		__saberOutput(remote, fwd,s);
	}
}
 140:	df 91       	pop	r29
 142:	cf 91       	pop	r28
 144:	1f 91       	pop	r17
 146:	0f 91       	pop	r16
 148:	08 95       	ret

0000014a <sabertoothInit>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 14a:	af 92       	push	r10
 14c:	bf 92       	push	r11
 14e:	cf 92       	push	r12
 150:	df 92       	push	r13
 152:	ef 92       	push	r14
 154:	ff 92       	push	r15
 156:	0f 93       	push	r16
 158:	1f 93       	push	r17
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	ec 01       	movw	r28, r24


	switch(driver->mode){
 160:	88 85       	ldd	r24, Y+8	; 0x08
 162:	88 23       	and	r24, r24
 164:	01 f0       	breq	.+0      	; 0x166 <sabertoothInit+0x1c>
 166:	81 30       	cpi	r24, 0x01	; 1
 168:	01 f0       	breq	.+0      	; 0x16a <sabertoothInit+0x20>
 16a:	00 c0       	rjmp	.+0      	; 0x16c <sabertoothInit+0x22>
 16c:	00 c0       	rjmp	.+0      	; 0x16e <sabertoothInit+0x24>
		case PACKETIZED:{
			// Pause for 2s from power on
			delay_ms(2000);
 16e:	60 ed       	ldi	r22, 0xD0	; 208
 170:	77 e0       	ldi	r23, 0x07	; 7
 172:	80 e0       	ldi	r24, 0x00	; 0
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			// Set baud rate
			_uartInit(driver->uart,driver->baudRate);
 17a:	4c 81       	ldd	r20, Y+4	; 0x04
 17c:	5d 81       	ldd	r21, Y+5	; 0x05
 17e:	6e 81       	ldd	r22, Y+6	; 0x06
 180:	7f 81       	ldd	r23, Y+7	; 0x07
 182:	8a 81       	ldd	r24, Y+2	; 0x02
 184:	9b 81       	ldd	r25, Y+3	; 0x03
 186:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			// send bauding character
			_uartSendByte(driver->uart,0xaa);
 18a:	6a ea       	ldi	r22, 0xAA	; 170
 18c:	8a 81       	ldd	r24, Y+2	; 0x02
 18e:	9b 81       	ldd	r25, Y+3	; 0x03
 190:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 194:	64 e1       	ldi	r22, 0x14	; 20
 196:	70 e0       	ldi	r23, 0x00	; 0
 198:	80 e0       	ldi	r24, 0x00	; 0
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1a0:	6a ea       	ldi	r22, 0xAA	; 170
 1a2:	8a 81       	ldd	r24, Y+2	; 0x02
 1a4:	9b 81       	ldd	r25, Y+3	; 0x03
 1a6:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1aa:	64 e1       	ldi	r22, 0x14	; 20
 1ac:	70 e0       	ldi	r23, 0x00	; 0
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	90 e0       	ldi	r25, 0x00	; 0
 1b2:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1b6:	6a ea       	ldi	r22, 0xAA	; 170
 1b8:	8a 81       	ldd	r24, Y+2	; 0x02
 1ba:	9b 81       	ldd	r25, Y+3	; 0x03
 1bc:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1c0:	64 e1       	ldi	r22, 0x14	; 20
 1c2:	70 e0       	ldi	r23, 0x00	; 0
 1c4:	80 e0       	ldi	r24, 0x00	; 0
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1cc:	6a ea       	ldi	r22, 0xAA	; 170
 1ce:	8a 81       	ldd	r24, Y+2	; 0x02
 1d0:	9b 81       	ldd	r25, Y+3	; 0x03
 1d2:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1d6:	64 e1       	ldi	r22, 0x14	; 20
 1d8:	70 e0       	ldi	r23, 0x00	; 0
 1da:	80 e0       	ldi	r24, 0x00	; 0
 1dc:	90 e0       	ldi	r25, 0x00	; 0
 1de:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1e2:	6a ea       	ldi	r22, 0xAA	; 170
 1e4:	8a 81       	ldd	r24, Y+2	; 0x02
 1e6:	9b 81       	ldd	r25, Y+3	; 0x03
 1e8:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1ec:	64 e1       	ldi	r22, 0x14	; 20
 1ee:	70 e0       	ldi	r23, 0x00	; 0
 1f0:	80 e0       	ldi	r24, 0x00	; 0
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 1f8:	c1 2c       	mov	r12, r1
 1fa:	d1 2c       	mov	r13, r1
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
		SABERTOOTH_MOTOR* motor = (SABERTOOTH_MOTOR*)pgm_read_word(&driver->motors[i]);
		motor->actuator.class=&c_Sabertooth;
 1fc:	30 e0       	ldi	r19, 0x00	; 0
 1fe:	a3 2e       	mov	r10, r19
 200:	30 e0       	ldi	r19, 0x00	; 0
 202:	b3 2e       	mov	r11, r19
 204:	00 c0       	rjmp	.+0      	; 0x206 <sabertoothInit+0xbc>
			_uartSendByte(driver->uart,0xaa);
			delay_ms(20);
		}
		break;
		case SIMPLE:{
			_uartInit(driver->uart,driver->baudRate);
 206:	4c 81       	ldd	r20, Y+4	; 0x04
 208:	5d 81       	ldd	r21, Y+5	; 0x05
 20a:	6e 81       	ldd	r22, Y+6	; 0x06
 20c:	7f 81       	ldd	r23, Y+7	; 0x07
 20e:	8a 81       	ldd	r24, Y+2	; 0x02
 210:	9b 81       	ldd	r25, Y+3	; 0x03
 212:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		}
		break;
 216:	00 c0       	rjmp	.+0      	; 0x218 <sabertoothInit+0xce>

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 218:	c6 01       	movw	r24, r12
 21a:	88 0f       	add	r24, r24
 21c:	99 1f       	adc	r25, r25
		break;
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
		SABERTOOTH_MOTOR* motor = (SABERTOOTH_MOTOR*)pgm_read_word(&driver->motors[i]);
 21e:	e8 81       	ld	r30, Y
 220:	f9 81       	ldd	r31, Y+1	; 0x01
 222:	e8 0f       	add	r30, r24
 224:	f9 1f       	adc	r31, r25
 226:	e5 90       	lpm	r14, Z+
 228:	f4 90       	lpm	r15, Z
		motor->actuator.class=&c_Sabertooth;
 22a:	f7 01       	movw	r30, r14
 22c:	b1 82       	std	Z+1, r11	; 0x01
 22e:	a0 82       	st	Z, r10
		motor->driver = driver;
 230:	d7 83       	std	Z+7, r29	; 0x07
 232:	c6 83       	std	Z+6, r28	; 0x06
		act_setSpeed(motor,0);
 234:	60 e0       	ldi	r22, 0x00	; 0
 236:	8e 2d       	mov	r24, r14
 238:	9f 2d       	mov	r25, r15
 23a:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		act_setConnected(motor,TRUE);
 23e:	6f ef       	ldi	r22, 0xFF	; 255
 240:	8e 2d       	mov	r24, r14
 242:	9f 2d       	mov	r25, r15
 244:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		}
		break;
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
 248:	ff ef       	ldi	r31, 0xFF	; 255
 24a:	cf 1a       	sub	r12, r31
 24c:	df 0a       	sbc	r13, r31
 24e:	89 85       	ldd	r24, Y+9	; 0x09
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	c8 16       	cp	r12, r24
 254:	d9 06       	cpc	r13, r25
 256:	04 f0       	brlt	.+0      	; 0x258 <sabertoothInit+0x10e>
		motor->actuator.class=&c_Sabertooth;
		motor->driver = driver;
		act_setSpeed(motor,0);
		act_setConnected(motor,TRUE);
	}
}
 258:	df 91       	pop	r29
 25a:	cf 91       	pop	r28
 25c:	1f 91       	pop	r17
 25e:	0f 91       	pop	r16
 260:	ff 90       	pop	r15
 262:	ef 90       	pop	r14
 264:	df 90       	pop	r13
 266:	cf 90       	pop	r12
 268:	bf 90       	pop	r11
 26a:	af 90       	pop	r10
 26c:	08 95       	ret

L293D.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000032c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000360  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000360  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000360  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d96  00000000  00000000  00000364  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000302  00000000  00000000  000010fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000700  00000000  00000000  000013fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001afc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000040  00000000  00000000  00001b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000188  00000000  00000000  00001b5c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000754  00000000  00000000  00001ce4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002438  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000f4  00000000  00000000  00002464  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	1f 92       	push	r1
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  10:	fc 01       	movw	r30, r24
  12:	84 81       	ldd	r24, Z+4	; 0x04
  14:	95 81       	ldd	r25, Z+5	; 0x05
  16:	69 83       	std	Y+1, r22	; 0x01
  18:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	// reverts to default output logic level of low
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  1c:	69 81       	ldd	r22, Y+1	; 0x01
  1e:	66 23       	and	r22, r22
  20:	01 f0       	breq	.+0      	; 0x22 <setConnected+0x22>
  22:	62 e0       	ldi	r22, 0x02	; 2
  24:	00 c0       	rjmp	.+0      	; 0x26 <setConnected+0x26>
  26:	60 e0       	ldi	r22, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	pin_make_output(motor->direction1,FALSE);
  2c:	60 e0       	ldi	r22, 0x00	; 0
  2e:	f8 01       	movw	r30, r16
  30:	86 81       	ldd	r24, Z+6	; 0x06
  32:	97 81       	ldd	r25, Z+7	; 0x07
}
  34:	0f 90       	pop	r0
  36:	df 91       	pop	r29
  38:	cf 91       	pop	r28
  3a:	1f 91       	pop	r17
  3c:	0f 91       	pop	r16
	const TimerCompare* channel = compareFromIOPin(motor->pwm);

	// Turn on/off the pin to start/stop sending PWM
	// reverts to default output logic level of low
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
	pin_make_output(motor->direction1,FALSE);
  3e:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

00000042 <setSpeed>:
#include "../timer.h"
#include "../core.h"


// Call back - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  42:	af 92       	push	r10
  44:	bf 92       	push	r11
  46:	cf 92       	push	r12
  48:	df 92       	push	r13
  4a:	ef 92       	push	r14
  4c:	ff 92       	push	r15
  4e:	0f 93       	push	r16
  50:	1f 93       	push	r17
  52:	cf 93       	push	r28
  54:	df 93       	push	r29
  56:	ec 01       	movw	r28, r24
  58:	f6 2e       	mov	r15, r22
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  5a:	8c 81       	ldd	r24, Y+4	; 0x04
  5c:	9d 81       	ldd	r25, Y+5	; 0x05
  5e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  62:	5c 01       	movw	r10, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  64:	fc 01       	movw	r30, r24
  66:	32 96       	adiw	r30, 0x02	; 2
  68:	84 91       	lpm	r24, Z
	const Timer* timer = compareGetTimer(channel);
  6a:	2c e2       	ldi	r18, 0x2C	; 44
  6c:	82 9f       	mul	r24, r18
  6e:	c0 01       	movw	r24, r0
  70:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  72:	80 50       	subi	r24, 0x00	; 0
  74:	90 40       	sbci	r25, 0x00	; 0
  76:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  7a:	6c 01       	movw	r12, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  7c:	1f 14       	cp	r1, r15
  7e:	04 f4       	brge	.+0      	; 0x80 <setSpeed+0x3e>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  80:	8c 01       	movw	r16, r24
  82:	20 e0       	ldi	r18, 0x00	; 0
  84:	30 e0       	ldi	r19, 0x00	; 0
  86:	4f e7       	ldi	r20, 0x7F	; 127
  88:	50 e0       	ldi	r21, 0x00	; 0
  8a:	60 e0       	ldi	r22, 0x00	; 0
  8c:	70 e0       	ldi	r23, 0x00	; 0
  8e:	8f 2d       	mov	r24, r15
  90:	99 27       	eor	r25, r25
  92:	87 fd       	sbrc	r24, 7
  94:	90 95       	com	r25
  96:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  9a:	7c 01       	movw	r14, r24

		if(motor->direction2==null){
  9c:	88 85       	ldd	r24, Y+8	; 0x08
  9e:	99 85       	ldd	r25, Y+9	; 0x09
  a0:	89 2b       	or	r24, r25
  a2:	01 f4       	brne	.+0      	; 0xa4 <setSpeed+0x62>
			// one wire so delay = top - delay
			delay = top - delay;
  a4:	c6 01       	movw	r24, r12
  a6:	8e 19       	sub	r24, r14
  a8:	9f 09       	sbc	r25, r15
  aa:	7c 01       	movw	r14, r24
		}

		// Set direction1 high, direction2 low (if there is one)
		pin_make_output(motor->direction1,TRUE);
  ac:	6f ef       	ldi	r22, 0xFF	; 255
  ae:	8e 81       	ldd	r24, Y+6	; 0x06
  b0:	9f 81       	ldd	r25, Y+7	; 0x07
  b2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,FALSE);
  b6:	60 e0       	ldi	r22, 0x00	; 0
  b8:	00 c0       	rjmp	.+0      	; 0xba <setSpeed+0x78>
	}else if(speed < 0){
  ba:	ff 20       	and	r15, r15
  bc:	01 f0       	breq	.+0      	; 0xbe <setSpeed+0x7c>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  be:	8c 01       	movw	r16, r24
  c0:	20 e0       	ldi	r18, 0x00	; 0
  c2:	30 e0       	ldi	r19, 0x00	; 0
  c4:	41 e8       	ldi	r20, 0x81	; 129
  c6:	5f ef       	ldi	r21, 0xFF	; 255
  c8:	60 e0       	ldi	r22, 0x00	; 0
  ca:	70 e0       	ldi	r23, 0x00	; 0
  cc:	8f 2d       	mov	r24, r15
  ce:	99 27       	eor	r25, r25
  d0:	87 fd       	sbrc	r24, 7
  d2:	90 95       	com	r25
  d4:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  d8:	7c 01       	movw	r14, r24

		// Set direction1 low, direction2 high (if there is one)
		pin_make_output(motor->direction1,FALSE);
  da:	60 e0       	ldi	r22, 0x00	; 0
  dc:	8e 81       	ldd	r24, Y+6	; 0x06
  de:	9f 81       	ldd	r25, Y+7	; 0x07
  e0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,TRUE);
  e4:	6f ef       	ldi	r22, 0xFF	; 255
  e6:	88 85       	ldd	r24, Y+8	; 0x08
  e8:	99 85       	ldd	r25, Y+9	; 0x09
  ea:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <setSpeed+0xae>
	}else{
		// brake
		if(motor->direction2){
  f0:	28 85       	ldd	r18, Y+8	; 0x08
  f2:	39 85       	ldd	r19, Y+9	; 0x09
  f4:	8e 81       	ldd	r24, Y+6	; 0x06
  f6:	9f 81       	ldd	r25, Y+7	; 0x07
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  f8:	60 e0       	ldi	r22, 0x00	; 0
		// Set direction1 low, direction2 high (if there is one)
		pin_make_output(motor->direction1,FALSE);
		pin_make_output(motor->direction2,TRUE);
	}else{
		// brake
		if(motor->direction2){
  fa:	23 2b       	or	r18, r19
  fc:	01 f0       	breq	.+0      	; 0xfe <setSpeed+0xbc>
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  fe:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2,FALSE);
 102:	60 e0       	ldi	r22, 0x00	; 0
 104:	88 85       	ldd	r24, Y+8	; 0x08
 106:	99 85       	ldd	r25, Y+9	; 0x09
 108:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			delay = top; // full speed brake
 10c:	76 01       	movw	r14, r12
 10e:	00 c0       	rjmp	.+0      	; 0x110 <setSpeed+0xce>
		}else{
			// Only has one direction pin
			// Set direction1 low
			pin_make_output(motor->direction1,FALSE);
 110:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
	const Timer* timer = compareGetTimer(channel);
	uint16_t top = timerGetTOP(timer);

	// New compare threshold
	uint16_t delay=0;
 114:	e1 2c       	mov	r14, r1
 116:	f1 2c       	mov	r15, r1
			// ie both low = brake
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
 118:	b7 01       	movw	r22, r14
 11a:	c5 01       	movw	r24, r10
}
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	bf 90       	pop	r11
 12e:	af 90       	pop	r10
			// ie both low = brake
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
 130:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

00000134 <motorL293Init>:


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 134:	2f 92       	push	r2
 136:	3f 92       	push	r3
 138:	4f 92       	push	r4
 13a:	5f 92       	push	r5
 13c:	6f 92       	push	r6
 13e:	7f 92       	push	r7
 140:	8f 92       	push	r8
 142:	9f 92       	push	r9
 144:	af 92       	push	r10
 146:	bf 92       	push	r11
 148:	cf 92       	push	r12
 14a:	df 92       	push	r13
 14c:	ef 92       	push	r14
 14e:	ff 92       	push	r15
 150:	0f 93       	push	r16
 152:	1f 93       	push	r17
 154:	cf 93       	push	r28
 156:	df 93       	push	r29
 158:	cd b7       	in	r28, 0x3d	; 61
 15a:	de b7       	in	r29, 0x3e	; 62
 15c:	2d 97       	sbiw	r28, 0x0d	; 13
 15e:	0f b6       	in	r0, 0x3f	; 63
 160:	f8 94       	cli
 162:	de bf       	out	0x3e, r29	; 62
 164:	0f be       	out	0x3f, r0	; 63
 166:	cd bf       	out	0x3d, r28	; 61
 168:	4c 01       	movw	r8, r24
	uint32_t deciHertz = 10 * freq;
 16a:	aa e0       	ldi	r26, 0x0A	; 10
 16c:	b0 e0       	ldi	r27, 0x00	; 0
 16e:	9a 01       	movw	r18, r20
 170:	ab 01       	movw	r20, r22
 172:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 176:	6e 83       	std	Y+6, r22	; 0x06
 178:	7f 83       	std	Y+7, r23	; 0x07
 17a:	88 87       	std	Y+8, r24	; 0x08
 17c:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 17e:	d4 01       	movw	r26, r8
 180:	12 96       	adiw	r26, 0x02	; 2
 182:	8c 91       	ld	r24, X
 184:	a1 2c       	mov	r10, r1
 186:	b1 2c       	mov	r11, r1


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	fc 01       	movw	r30, r24
 18c:	31 97       	sbiw	r30, 0x01	; 1
 18e:	fb 87       	std	Y+11, r31	; 0x0b
 190:	ea 87       	std	Y+10, r30	; 0x0a
 192:	9c 01       	movw	r18, r24
 194:	21 50       	subi	r18, 0x01	; 1
 196:	30 48       	sbci	r19, 0x80	; 128
 198:	3d 87       	std	Y+13, r19	; 0x0d
 19a:	2c 87       	std	Y+12, r18	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 19c:	00 c0       	rjmp	.+0      	; 0x19e <motorL293Init+0x6a>


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 19e:	2c 85       	ldd	r18, Y+12	; 0x0c
 1a0:	3d 85       	ldd	r19, Y+13	; 0x0d
 1a2:	2a 19       	sub	r18, r10
 1a4:	3b 09       	sbc	r19, r11
 1a6:	22 0f       	add	r18, r18
 1a8:	33 1f       	adc	r19, r19
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		MOTOR* motor = (MOTOR*)pgm_read_word(&driver->motors[i]);
 1aa:	d4 01       	movw	r26, r8
 1ac:	ed 91       	ld	r30, X+
 1ae:	fc 91       	ld	r31, X
 1b0:	e2 0f       	add	r30, r18
 1b2:	f3 1f       	adc	r31, r19
 1b4:	85 91       	lpm	r24, Z+
 1b6:	94 91       	lpm	r25, Z
 1b8:	3c 01       	movw	r6, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 1ba:	fc 01       	movw	r30, r24
 1bc:	84 81       	ldd	r24, Z+4	; 0x04
 1be:	95 81       	ldd	r25, Z+5	; 0x05
 1c0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1c4:	1c 01       	movw	r2, r24
		if(channel==null){
 1c6:	00 97       	sbiw	r24, 0x00	; 0
 1c8:	01 f4       	brne	.+0      	; 0x1ca <motorL293Init+0x96>
			setError(PWM_PIN_NOT_AVAILABLE);
 1ca:	84 ef       	ldi	r24, 0xF4	; 244
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <motorL293Init+0x9a>
			continue;
		}
		if(compareIsInUse(channel)){
 1ce:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1d2:	88 23       	and	r24, r24
 1d4:	01 f0       	breq	.+0      	; 0x1d6 <motorL293Init+0xa2>
			setError(PWM_PIN_IN_USE);
 1d6:	83 ef       	ldi	r24, 0xF3	; 243
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <motorL293Init+0xa6>
 1da:	f1 01       	movw	r30, r2
 1dc:	32 96       	adiw	r30, 0x02	; 2
 1de:	44 90       	lpm	r4, Z

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 1e0:	fc e2       	ldi	r31, 0x2C	; 44
 1e2:	f4 9d       	mul	r31, r4
 1e4:	20 01       	movw	r4, r0
 1e6:	11 24       	eor	r1, r1
 1e8:	20 e0       	ldi	r18, 0x00	; 0
 1ea:	30 e0       	ldi	r19, 0x00	; 0
 1ec:	42 0e       	add	r4, r18
 1ee:	53 1e       	adc	r5, r19

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1f0:	cc 24       	eor	r12, r12
 1f2:	c3 94       	inc	r12
 1f4:	d1 2c       	mov	r13, r1
 1f6:	cc 0e       	add	r12, r28
 1f8:	dd 1e       	adc	r13, r29
 1fa:	93 e0       	ldi	r25, 0x03	; 3
 1fc:	e9 2e       	mov	r14, r25
 1fe:	f1 2c       	mov	r15, r1
 200:	ec 0e       	add	r14, r28
 202:	fd 1e       	adc	r15, r29
 204:	8e 01       	movw	r16, r28
 206:	0b 5f       	subi	r16, 0xFB	; 251
 208:	1f 4f       	sbci	r17, 0xFF	; 255
 20a:	20 e8       	ldi	r18, 0x80	; 128
 20c:	30 e0       	ldi	r19, 0x00	; 0
 20e:	4e 81       	ldd	r20, Y+6	; 0x06
 210:	5f 81       	ldd	r21, Y+7	; 0x07
 212:	68 85       	ldd	r22, Y+8	; 0x08
 214:	79 85       	ldd	r23, Y+9	; 0x09
 216:	c2 01       	movw	r24, r4
 218:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 21c:	f2 01       	movw	r30, r4
 21e:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 220:	81 11       	cpse	r24, r1
 222:	00 c0       	rjmp	.+0      	; 0x224 <motorL293Init+0xf0>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 224:	85 91       	lpm	r24, Z+
 226:	94 91       	lpm	r25, Z
 228:	fc 01       	movw	r30, r24
 22a:	80 81       	ld	r24, Z
 22c:	87 70       	andi	r24, 0x07	; 7
 22e:	01 f4       	brne	.+0      	; 0x230 <motorL293Init+0xfc>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 230:	83 ee       	ldi	r24, 0xE3	; 227
 232:	00 c0       	rjmp	.+0      	; 0x234 <motorL293Init+0x100>
 234:	82 ef       	ldi	r24, 0xF2	; 242
 236:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <motorL293Init+0x108>
 23c:	85 91       	lpm	r24, Z+
 23e:	94 91       	lpm	r25, Z
 240:	fc 01       	movw	r30, r24
 242:	80 81       	ld	r24, Z
 244:	87 70       	andi	r24, 0x07	; 7
 246:	01 f4       	brne	.+0      	; 0x248 <motorL293Init+0x114>
 248:	00 c0       	rjmp	.+0      	; 0x24a <motorL293Init+0x116>
 24a:	00 c0       	rjmp	.+0      	; 0x24c <motorL293Init+0x118>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 24c:	f2 01       	movw	r30, r4
 24e:	7f 96       	adiw	r30, 0x1f	; 31
 250:	85 91       	lpm	r24, Z+
 252:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 254:	fc 01       	movw	r30, r24
 256:	8b 81       	ldd	r24, Y+3	; 0x03
 258:	9c 81       	ldd	r25, Y+4	; 0x04
 25a:	91 83       	std	Z+1, r25	; 0x01
 25c:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_l293;
 25e:	e0 e0       	ldi	r30, 0x00	; 0
 260:	f0 e0       	ldi	r31, 0x00	; 0
 262:	d3 01       	movw	r26, r6
 264:	11 96       	adiw	r26, 0x01	; 1
 266:	fc 93       	st	X, r31
 268:	ee 93       	st	-X, r30

			// Make sure the motor pins are set as output pins
			pin_make_output(motor->pwm, FALSE);
 26a:	60 e0       	ldi	r22, 0x00	; 0
 26c:	14 96       	adiw	r26, 0x04	; 4
 26e:	8d 91       	ld	r24, X+
 270:	9c 91       	ld	r25, X
 272:	15 97       	sbiw	r26, 0x05	; 5
 274:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction1, FALSE);
 278:	60 e0       	ldi	r22, 0x00	; 0
 27a:	d3 01       	movw	r26, r6
 27c:	16 96       	adiw	r26, 0x06	; 6
 27e:	8d 91       	ld	r24, X+
 280:	9c 91       	ld	r25, X
 282:	17 97       	sbiw	r26, 0x07	; 7
 284:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2, FALSE);
 288:	60 e0       	ldi	r22, 0x00	; 0
 28a:	f3 01       	movw	r30, r6
 28c:	80 85       	ldd	r24, Z+8	; 0x08
 28e:	91 85       	ldd	r25, Z+9	; 0x09
 290:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 294:	20 e0       	ldi	r18, 0x00	; 0
 296:	30 e0       	ldi	r19, 0x00	; 0
 298:	40 e0       	ldi	r20, 0x00	; 0
 29a:	50 e0       	ldi	r21, 0x00	; 0
 29c:	60 e0       	ldi	r22, 0x00	; 0
 29e:	70 e0       	ldi	r23, 0x00	; 0
 2a0:	c1 01       	movw	r24, r2
 2a2:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 2a6:	69 81       	ldd	r22, Y+1	; 0x01
 2a8:	7a 81       	ldd	r23, Y+2	; 0x02
 2aa:	c2 01       	movw	r24, r4
 2ac:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 2b0:	60 e0       	ldi	r22, 0x00	; 0
 2b2:	c3 01       	movw	r24, r6
 2b4:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 2b8:	6f ef       	ldi	r22, 0xFF	; 255
 2ba:	c3 01       	movw	r24, r6
 2bc:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 2c0:	ff ef       	ldi	r31, 0xFF	; 255
 2c2:	af 1a       	sub	r10, r31
 2c4:	bf 0a       	sbc	r11, r31


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 2c6:	8a 85       	ldd	r24, Y+10	; 0x0a
 2c8:	9b 85       	ldd	r25, Y+11	; 0x0b
 2ca:	8a 19       	sub	r24, r10
 2cc:	9b 09       	sbc	r25, r11
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 2ce:	01 96       	adiw	r24, 0x01	; 1
 2d0:	01 f0       	breq	.+0      	; 0x2d2 <motorL293Init+0x19e>
 2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <motorL293Init+0x1a0>
 2d4:	00 c0       	rjmp	.+0      	; 0x2d6 <motorL293Init+0x1a2>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 2d6:	6d 81       	ldd	r22, Y+5	; 0x05
 2d8:	c2 01       	movw	r24, r4
 2da:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 2de:	21 e0       	ldi	r18, 0x01	; 1
 2e0:	30 e0       	ldi	r19, 0x00	; 0
 2e2:	0d 80       	ldd	r0, Y+5	; 0x05
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <motorL293Init+0x1b2>
 2e6:	22 0f       	add	r18, r18
 2e8:	33 1f       	adc	r19, r19
 2ea:	0a 94       	dec	r0
 2ec:	02 f4       	brpl	.+0      	; 0x2ee <motorL293Init+0x1ba>
 2ee:	22 27       	eor	r18, r18
 2f0:	35 75       	andi	r19, 0x55	; 85
 2f2:	23 2b       	or	r18, r19
 2f4:	01 f0       	breq	.+0      	; 0x2f6 <motorL293Init+0x1c2>
 2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <motorL293Init+0x1c4>
 2f8:	00 c0       	rjmp	.+0      	; 0x2fa <motorL293Init+0x1c6>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 2fa:	2d 96       	adiw	r28, 0x0d	; 13
 2fc:	0f b6       	in	r0, 0x3f	; 63
 2fe:	f8 94       	cli
 300:	de bf       	out	0x3e, r29	; 62
 302:	0f be       	out	0x3f, r0	; 63
 304:	cd bf       	out	0x3d, r28	; 61
 306:	df 91       	pop	r29
 308:	cf 91       	pop	r28
 30a:	1f 91       	pop	r17
 30c:	0f 91       	pop	r16
 30e:	ff 90       	pop	r15
 310:	ef 90       	pop	r14
 312:	df 90       	pop	r13
 314:	cf 90       	pop	r12
 316:	bf 90       	pop	r11
 318:	af 90       	pop	r10
 31a:	9f 90       	pop	r9
 31c:	8f 90       	pop	r8
 31e:	7f 90       	pop	r7
 320:	6f 90       	pop	r6
 322:	5f 90       	pop	r5
 324:	4f 90       	pop	r4
 326:	3f 90       	pop	r3
 328:	2f 90       	pop	r2
 32a:	08 95       	ret

DualSerial.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000192  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001c6  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000001c6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d08  00000000  00000000  000001ca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000310  00000000  00000000  00000ed2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000578  00000000  00000000  000011e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000175a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000030  00000000  00000000  0000177a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001a3  00000000  00000000  000017aa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000611  00000000  00000000  0000194d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00001f5e  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000c0  00000000  00000000  00001f88  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__pololuOutput>:
#include "DualSerial.h"
#include "../../core.h"
#include "../../timer.h"


static void __pololuOutput(POLOLU_DS_MOTOR* remote, uint8_t fwd, uint8_t speed){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	1f 92       	push	r1
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	06 2f       	mov	r16, r22
	POLOLU_DS_DRIVER* driver = remote->driver;
  14:	fc 01       	movw	r30, r24
  16:	a4 81       	ldd	r26, Z+4	; 0x04
  18:	b5 81       	ldd	r27, Z+5	; 0x05
	POLOLU_DS_MOTOR* first = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[0]);
  1a:	ed 91       	ld	r30, X+
  1c:	fc 91       	ld	r31, X
  1e:	11 97       	sbiw	r26, 0x01	; 1
  20:	25 91       	lpm	r18, Z+
  22:	34 91       	lpm	r19, Z

	uint8_t motorNo =  remote - first;
  24:	82 1b       	sub	r24, r18
  26:	93 0b       	sbc	r25, r19
  28:	95 95       	asr	r25
  2a:	87 95       	ror	r24
	motorNo += driver->firstMotorNumber;
  2c:	19 96       	adiw	r26, 0x09	; 9
  2e:	1c 91       	ld	r17, X
  30:	19 97       	sbiw	r26, 0x09	; 9
  32:	f5 e5       	ldi	r31, 0x55	; 85
  34:	8f 9f       	mul	r24, r31
  36:	10 19       	sub	r17, r0
  38:	11 24       	eor	r1, r1
	UART* __pololuUART = driver->uart;
  3a:	13 96       	adiw	r26, 0x03	; 3
  3c:	ed 90       	ld	r14, X+
  3e:	fc 90       	ld	r15, X
  40:	14 97       	sbiw	r26, 0x04	; 4

	_uartSendByte(__pololuUART,0x80);
  42:	60 e8       	ldi	r22, 0x80	; 128
  44:	c7 01       	movw	r24, r14
  46:	49 83       	std	Y+1, r20	; 0x01
  48:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,0x0);
  4c:	60 e0       	ldi	r22, 0x00	; 0
  4e:	c7 01       	movw	r24, r14
  50:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,((motorNo<<1) & 0x7fU)|fwd);
  54:	61 2f       	mov	r22, r17
  56:	66 0f       	add	r22, r22
  58:	6f 77       	andi	r22, 0x7F	; 127
  5a:	60 2b       	or	r22, r16
  5c:	c7 01       	movw	r24, r14
  5e:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,(uint8_t)speed);
  62:	49 81       	ldd	r20, Y+1	; 0x01
  64:	64 2f       	mov	r22, r20
  66:	c7 01       	movw	r24, r14
}
  68:	0f 90       	pop	r0
  6a:	df 91       	pop	r29
  6c:	cf 91       	pop	r28
  6e:	1f 91       	pop	r17
  70:	0f 91       	pop	r16
  72:	ff 90       	pop	r15
  74:	ef 90       	pop	r14
	UART* __pololuUART = driver->uart;

	_uartSendByte(__pololuUART,0x80);
	_uartSendByte(__pololuUART,0x0);
	_uartSendByte(__pololuUART,((motorNo<<1) & 0x7fU)|fwd);
	_uartSendByte(__pololuUART,(uint8_t)speed);
  76:	0c 94 00 00 	jmp	0	; 0x0 <__pololuOutput>

0000007a <setConnected>:
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(connected){
  7a:	66 23       	and	r22, r22
  7c:	01 f0       	breq	.+0      	; 0x7e <setConnected+0x4>
		act_setSpeed(act,0);
		act_setConnected(act,TRUE);
	}
	// Pause for 100ms
	delay_ms(100);
}
  7e:	fc 01       	movw	r30, r24
  80:	62 81       	ldd	r22, Z+2	; 0x02

static void setConnected(__ACTUATOR *actuator, boolean connected){
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(connected){
		DRIVE_SPEED speed = act_getSpeed(remote);
		actuator->required_speed=-128;
  82:	20 e8       	ldi	r18, 0x80	; 128
  84:	22 83       	std	Z+2, r18	; 0x02
		act_setSpeed(remote, speed);
  86:	0c 94 00 00 	jmp	0	; 0x0 <__pololuOutput>
	}else{
		// Set speed = 0 in forwards to coast
		__pololuOutput(remote, 1, 0);
  8a:	40 e0       	ldi	r20, 0x00	; 0
  8c:	61 e0       	ldi	r22, 0x01	; 1
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__pololuOutput>

00000092 <setSpeed>:
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  92:	0f 93       	push	r16
  94:	1f 93       	push	r17
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
  9a:	ec 01       	movw	r28, r24
  9c:	86 2f       	mov	r24, r22
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  9e:	9b 81       	ldd	r25, Y+3	; 0x03
  a0:	90 ff       	sbrs	r25, 0
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <setSpeed+0x12>
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <setSpeed+0x14>
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);
  a6:	0f e7       	ldi	r16, 0x7F	; 127
  a8:	10 e0       	ldi	r17, 0x00	; 0
  aa:	21 e8       	ldi	r18, 0x81	; 129
  ac:	3f ef       	ldi	r19, 0xFF	; 255
  ae:	4f e7       	ldi	r20, 0x7F	; 127
  b0:	50 e0       	ldi	r21, 0x00	; 0
  b2:	61 e8       	ldi	r22, 0x81	; 129
  b4:	7f ef       	ldi	r23, 0xFF	; 255
  b6:	99 27       	eor	r25, r25
  b8:	87 fd       	sbrc	r24, 7
  ba:	90 95       	com	r25
  bc:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>

		// If speed is 0 then set reverse to brake
		uint8_t fwd=1;
		if(s <= 0){
  c0:	18 16       	cp	r1, r24
  c2:	04 f0       	brlt	.+0      	; 0xc4 <setSpeed+0x32>
			s = -s;
  c4:	81 95       	neg	r24
			fwd = 0;
  c6:	60 e0       	ldi	r22, 0x00	; 0
  c8:	00 c0       	rjmp	.+0      	; 0xca <setSpeed+0x38>
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);

		// If speed is 0 then set reverse to brake
		uint8_t fwd=1;
  ca:	61 e0       	ldi	r22, 0x01	; 1
		if(s <= 0){
			s = -s;
			fwd = 0;
		}

		__pololuOutput(remote, fwd,s);
  cc:	48 2f       	mov	r20, r24
  ce:	ce 01       	movw	r24, r28
	}
}
  d0:	df 91       	pop	r29
  d2:	cf 91       	pop	r28
  d4:	1f 91       	pop	r17
  d6:	0f 91       	pop	r16
		if(s <= 0){
			s = -s;
			fwd = 0;
		}

		__pololuOutput(remote, fwd,s);
  d8:	0c 94 00 00 	jmp	0	; 0x0 <__pololuOutput>
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
  dc:	9a 81       	ldd	r25, Y+2	; 0x02
  de:	96 13       	cpse	r25, r22
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <setSpeed+0x50>
			fwd = 0;
		}

		__pololuOutput(remote, fwd,s);
	}
}
  e2:	df 91       	pop	r29
  e4:	cf 91       	pop	r28
  e6:	1f 91       	pop	r17
  e8:	0f 91       	pop	r16
  ea:	08 95       	ret

000000ec <pololuDualSerialInit>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
  ec:	af 92       	push	r10
  ee:	bf 92       	push	r11
  f0:	cf 92       	push	r12
  f2:	df 92       	push	r13
  f4:	ef 92       	push	r14
  f6:	ff 92       	push	r15
  f8:	0f 93       	push	r16
  fa:	1f 93       	push	r17
  fc:	cf 93       	push	r28
  fe:	df 93       	push	r29
 100:	8c 01       	movw	r16, r24
	_uartInit(driver->uart,driver->baudRate);
 102:	dc 01       	movw	r26, r24
 104:	15 96       	adiw	r26, 0x05	; 5
 106:	4d 91       	ld	r20, X+
 108:	5d 91       	ld	r21, X+
 10a:	6d 91       	ld	r22, X+
 10c:	7c 91       	ld	r23, X
 10e:	18 97       	sbiw	r26, 0x08	; 8
 110:	13 96       	adiw	r26, 0x03	; 3
 112:	8d 91       	ld	r24, X+
 114:	9c 91       	ld	r25, X
 116:	14 97       	sbiw	r26, 0x04	; 4
 118:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	for(int i=0;i<driver->num_devices;i++){
 11c:	c1 2c       	mov	r12, r1
 11e:	d1 2c       	mov	r13, r1
		POLOLU_DS_MOTOR* act = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[i]);
		act->actuator.class = &c_Pololu_DualSerial;
 120:	40 e0       	ldi	r20, 0x00	; 0
 122:	a4 2e       	mov	r10, r20
 124:	40 e0       	ldi	r20, 0x00	; 0
 126:	b4 2e       	mov	r11, r20
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
 128:	00 c0       	rjmp	.+0      	; 0x12a <pololuDualSerialInit+0x3e>
}

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
 12a:	c6 01       	movw	r24, r12
 12c:	88 0f       	add	r24, r24
 12e:	99 1f       	adc	r25, r25
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
		POLOLU_DS_MOTOR* act = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[i]);
 130:	d8 01       	movw	r26, r16
 132:	ed 91       	ld	r30, X+
 134:	fc 91       	ld	r31, X
 136:	e8 0f       	add	r30, r24
 138:	f9 1f       	adc	r31, r25
 13a:	e5 90       	lpm	r14, Z+
 13c:	f4 90       	lpm	r15, Z
 13e:	ce 2d       	mov	r28, r14
 140:	df 2d       	mov	r29, r15
		act->actuator.class = &c_Pololu_DualSerial;
 142:	b9 82       	std	Y+1, r11	; 0x01
 144:	a8 82       	st	Y, r10
		act->driver = driver;
 146:	1d 83       	std	Y+5, r17	; 0x05
 148:	0c 83       	std	Y+4, r16	; 0x04
		act_setSpeed(act,0);
 14a:	60 e0       	ldi	r22, 0x00	; 0
 14c:	8e 2d       	mov	r24, r14
 14e:	9f 2d       	mov	r25, r15
 150:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
		act_setConnected(act,TRUE);
 154:	6f ef       	ldi	r22, 0xFF	; 255
 156:	8e 2d       	mov	r24, r14
 158:	9f 2d       	mov	r25, r15
 15a:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
 15e:	ff ef       	ldi	r31, 0xFF	; 255
 160:	cf 1a       	sub	r12, r31
 162:	df 0a       	sbc	r13, r31
 164:	d8 01       	movw	r26, r16
 166:	12 96       	adiw	r26, 0x02	; 2
 168:	8c 91       	ld	r24, X
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	c8 16       	cp	r12, r24
 16e:	d9 06       	cpc	r13, r25
 170:	04 f0       	brlt	.+0      	; 0x172 <pololuDualSerialInit+0x86>
		act->driver = driver;
		act_setSpeed(act,0);
		act_setConnected(act,TRUE);
	}
	// Pause for 100ms
	delay_ms(100);
 172:	64 e6       	ldi	r22, 0x64	; 100
 174:	70 e0       	ldi	r23, 0x00	; 0
 176:	80 e0       	ldi	r24, 0x00	; 0
 178:	90 e0       	ldi	r25, 0x00	; 0
}
 17a:	df 91       	pop	r29
 17c:	cf 91       	pop	r28
 17e:	1f 91       	pop	r17
 180:	0f 91       	pop	r16
 182:	ff 90       	pop	r15
 184:	ef 90       	pop	r14
 186:	df 90       	pop	r13
 188:	cf 90       	pop	r12
 18a:	bf 90       	pop	r11
 18c:	af 90       	pop	r10
		act->driver = driver;
		act_setSpeed(act,0);
		act_setConnected(act,TRUE);
	}
	// Pause for 100ms
	delay_ms(100);
 18e:	0c 94 00 00 	jmp	0	; 0x0 <__pololuOutput>

LB1836M.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ac  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003e0  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003e0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000f79  00000000  00000000  000003e4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000035d  00000000  00000000  0000135d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000009a5  00000000  00000000  000016ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000205f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000068  00000000  00000000  0000207f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001b5  00000000  00000000  000020e7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000007b9  00000000  00000000  0000229c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002a55  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000144  00000000  00000000  00002a80  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	d6 2e       	mov	r13, r22
	SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  12:	8c 81       	ldd	r24, Y+4	; 0x04
  14:	9d 81       	ldd	r25, Y+5	; 0x05
  16:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  1a:	7c 01       	movw	r14, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  1c:	8e 81       	ldd	r24, Y+6	; 0x06
  1e:	9f 81       	ldd	r25, Y+7	; 0x07
  20:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  24:	ec 01       	movw	r28, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  26:	1d 14       	cp	r1, r13
  28:	04 f4       	brge	.+0      	; 0x2a <setSpeed+0x2a>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  2a:	fc 01       	movw	r30, r24
  2c:	32 96       	adiw	r30, 0x02	; 2
  2e:	84 91       	lpm	r24, Z
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0, timerGetTOP(compareGetTimer(channel2)));
  30:	2c e2       	ldi	r18, 0x2C	; 44
  32:	82 9f       	mul	r24, r18
  34:	c0 01       	movw	r24, r0
  36:	11 24       	eor	r1, r1
  38:	80 50       	subi	r24, 0x00	; 0
  3a:	90 40       	sbci	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  40:	8c 01       	movw	r16, r24
  42:	20 e0       	ldi	r18, 0x00	; 0
  44:	30 e0       	ldi	r19, 0x00	; 0
  46:	4f e7       	ldi	r20, 0x7F	; 127
  48:	50 e0       	ldi	r21, 0x00	; 0
  4a:	60 e0       	ldi	r22, 0x00	; 0
  4c:	70 e0       	ldi	r23, 0x00	; 0
  4e:	8d 2d       	mov	r24, r13
  50:	99 27       	eor	r25, r25
  52:	87 fd       	sbrc	r24, 7
  54:	90 95       	com	r25
  56:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  5a:	8c 01       	movw	r16, r24
		compareSetThreshold(channel1,0);	    // Keep permanently high
  5c:	60 e0       	ldi	r22, 0x00	; 0
  5e:	70 e0       	ldi	r23, 0x00	; 0
  60:	c7 01       	movw	r24, r14
  62:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,delay);	// pwm channel 2
  66:	b8 01       	movw	r22, r16
  68:	00 c0       	rjmp	.+0      	; 0x6a <setSpeed+0x6a>
	}else if(speed < 0){
  6a:	dd 20       	and	r13, r13
  6c:	01 f0       	breq	.+0      	; 0x6e <setSpeed+0x6e>
  6e:	f7 01       	movw	r30, r14
  70:	32 96       	adiw	r30, 0x02	; 2
  72:	84 91       	lpm	r24, Z
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , timerGetTOP(compareGetTimer(channel1)));
  74:	2c e2       	ldi	r18, 0x2C	; 44
  76:	82 9f       	mul	r24, r18
  78:	c0 01       	movw	r24, r0
  7a:	11 24       	eor	r1, r1
  7c:	80 50       	subi	r24, 0x00	; 0
  7e:	90 40       	sbci	r25, 0x00	; 0
  80:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  84:	8c 01       	movw	r16, r24
  86:	20 e0       	ldi	r18, 0x00	; 0
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	41 e8       	ldi	r20, 0x81	; 129
  8c:	5f ef       	ldi	r21, 0xFF	; 255
  8e:	60 e0       	ldi	r22, 0x00	; 0
  90:	70 e0       	ldi	r23, 0x00	; 0
  92:	8d 2d       	mov	r24, r13
  94:	99 27       	eor	r25, r25
  96:	87 fd       	sbrc	r24, 7
  98:	90 95       	com	r25
  9a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  9e:	8c 01       	movw	r16, r24
		compareSetThreshold(channel2,0);	    // Keep permanently high
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	70 e0       	ldi	r23, 0x00	; 0
  a4:	ce 01       	movw	r24, r28
  a6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel1,delay);	// pwm channel 1
  aa:	b8 01       	movw	r22, r16
  ac:	c7 01       	movw	r24, r14
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <setSpeed+0xb0>
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
  b0:	60 e0       	ldi	r22, 0x00	; 0
  b2:	70 e0       	ldi	r23, 0x00	; 0
  b4:	c7 01       	movw	r24, r14
  b6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,0);	    // Keep permanently high
  ba:	60 e0       	ldi	r22, 0x00	; 0
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	ce 01       	movw	r24, r28
	}
}
  c0:	df 91       	pop	r29
  c2:	cf 91       	pop	r28
  c4:	1f 91       	pop	r17
  c6:	0f 91       	pop	r16
  c8:	ff 90       	pop	r15
  ca:	ef 90       	pop	r14
  cc:	df 90       	pop	r13
		compareSetThreshold(channel1,delay);	// pwm channel 1
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
		compareSetThreshold(channel2,0);	    // Keep permanently high
  ce:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

000000d2 <setConnected>:
	}
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
  d2:	cf 92       	push	r12
  d4:	df 92       	push	r13
  d6:	ef 92       	push	r14
  d8:	ff 92       	push	r15
  da:	0f 93       	push	r16
  dc:	1f 93       	push	r17
  de:	cf 93       	push	r28
  e0:	df 93       	push	r29
  e2:	1f 92       	push	r1
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
  e8:	6c 01       	movw	r12, r24
	SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  ea:	fc 01       	movw	r30, r24
  ec:	84 81       	ldd	r24, Z+4	; 0x04
  ee:	95 81       	ldd	r25, Z+5	; 0x05
  f0:	69 83       	std	Y+1, r22	; 0x01
  f2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  f6:	7c 01       	movw	r14, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  f8:	f6 01       	movw	r30, r12
  fa:	86 81       	ldd	r24, Z+6	; 0x06
  fc:	97 81       	ldd	r25, Z+7	; 0x07
  fe:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 102:	8c 01       	movw	r16, r24

	if(connected){
 104:	69 81       	ldd	r22, Y+1	; 0x01
 106:	66 23       	and	r22, r22
 108:	01 f0       	breq	.+0      	; 0x10a <setConnected+0x38>
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 10a:	f6 01       	movw	r30, r12
 10c:	62 81       	ldd	r22, Z+2	; 0x02
 10e:	c6 01       	movw	r24, r12
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
	}

}
 110:	0f 90       	pop	r0
 112:	df 91       	pop	r29
 114:	cf 91       	pop	r28
 116:	1f 91       	pop	r17
 118:	0f 91       	pop	r16
 11a:	ff 90       	pop	r15
 11c:	ef 90       	pop	r14
 11e:	df 90       	pop	r13
 120:	cf 90       	pop	r12
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);

	if(connected){
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 122:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
 126:	f7 01       	movw	r30, r14
 128:	32 96       	adiw	r30, 0x02	; 2
 12a:	84 91       	lpm	r24, Z
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
 12c:	9c e2       	ldi	r25, 0x2C	; 44
 12e:	d9 2e       	mov	r13, r25
 130:	d8 9e       	mul	r13, r24
 132:	c0 01       	movw	r24, r0
 134:	11 24       	eor	r1, r1
 136:	80 50       	subi	r24, 0x00	; 0
 138:	90 40       	sbci	r25, 0x00	; 0
 13a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 13e:	bc 01       	movw	r22, r24
 140:	c7 01       	movw	r24, r14
 142:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 146:	f8 01       	movw	r30, r16
 148:	32 96       	adiw	r30, 0x02	; 2
 14a:	84 91       	lpm	r24, Z
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 14c:	d8 9e       	mul	r13, r24
 14e:	c0 01       	movw	r24, r0
 150:	11 24       	eor	r1, r1
 152:	80 50       	subi	r24, 0x00	; 0
 154:	90 40       	sbci	r25, 0x00	; 0
 156:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 15a:	bc 01       	movw	r22, r24
 15c:	c8 01       	movw	r24, r16
	}

}
 15e:	0f 90       	pop	r0
 160:	df 91       	pop	r29
 162:	cf 91       	pop	r28
 164:	1f 91       	pop	r17
 166:	0f 91       	pop	r16
 168:	ff 90       	pop	r15
 16a:	ef 90       	pop	r14
 16c:	df 90       	pop	r13
 16e:	cf 90       	pop	r12
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 170:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

00000174 <initPWM>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Return true if valid, false if there is an error
static boolean initPWM(const IOPin* pin, uint32_t deciHertz){
 174:	6f 92       	push	r6
 176:	7f 92       	push	r7
 178:	8f 92       	push	r8
 17a:	9f 92       	push	r9
 17c:	af 92       	push	r10
 17e:	bf 92       	push	r11
 180:	cf 92       	push	r12
 182:	df 92       	push	r13
 184:	ef 92       	push	r14
 186:	ff 92       	push	r15
 188:	0f 93       	push	r16
 18a:	1f 93       	push	r17
 18c:	cf 93       	push	r28
 18e:	df 93       	push	r29
 190:	cd b7       	in	r28, 0x3d	; 61
 192:	de b7       	in	r29, 0x3e	; 62
 194:	29 97       	sbiw	r28, 0x09	; 9
 196:	0f b6       	in	r0, 0x3f	; 63
 198:	f8 94       	cli
 19a:	de bf       	out	0x3e, r29	; 62
 19c:	0f be       	out	0x3f, r0	; 63
 19e:	cd bf       	out	0x3d, r28	; 61
 1a0:	3c 01       	movw	r6, r24
	const TimerCompare* channel = compareFromIOPin(pin);
 1a2:	4e 83       	std	Y+6, r20	; 0x06
 1a4:	5f 83       	std	Y+7, r21	; 0x07
 1a6:	68 87       	std	Y+8, r22	; 0x08
 1a8:	79 87       	std	Y+9, r23	; 0x09
 1aa:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1ae:	4c 01       	movw	r8, r24

	if(channel==null){
 1b0:	4e 81       	ldd	r20, Y+6	; 0x06
 1b2:	5f 81       	ldd	r21, Y+7	; 0x07
 1b4:	68 85       	ldd	r22, Y+8	; 0x08
 1b6:	79 85       	ldd	r23, Y+9	; 0x09
 1b8:	00 97       	sbiw	r24, 0x00	; 0
 1ba:	01 f4       	brne	.+0      	; 0x1bc <initPWM+0x48>
		setError(PWM_PIN_NOT_AVAILABLE);
 1bc:	84 ef       	ldi	r24, 0xF4	; 244
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <initPWM+0x4c>
		return FALSE;
	}
	if(compareIsInUse(channel)){
 1c0:	4e 83       	std	Y+6, r20	; 0x06
 1c2:	5f 83       	std	Y+7, r21	; 0x07
 1c4:	68 87       	std	Y+8, r22	; 0x08
 1c6:	79 87       	std	Y+9, r23	; 0x09
 1c8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1cc:	4e 81       	ldd	r20, Y+6	; 0x06
 1ce:	5f 81       	ldd	r21, Y+7	; 0x07
 1d0:	68 85       	ldd	r22, Y+8	; 0x08
 1d2:	79 85       	ldd	r23, Y+9	; 0x09
 1d4:	88 23       	and	r24, r24
 1d6:	01 f0       	breq	.+0      	; 0x1d8 <initPWM+0x64>
		setError(PWM_PIN_IN_USE);
 1d8:	83 ef       	ldi	r24, 0xF3	; 243
 1da:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		return FALSE;
 1de:	10 e0       	ldi	r17, 0x00	; 0
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <initPWM+0x6e>
 1e2:	f4 01       	movw	r30, r8
 1e4:	32 96       	adiw	r30, 0x02	; 2
 1e6:	a4 90       	lpm	r10, Z

	TIMER_MODE mode;
	uint16_t icr;
	uint16_t prescaler;

	const Timer* timer = compareGetTimer(channel);
 1e8:	8c e2       	ldi	r24, 0x2C	; 44
 1ea:	a8 9e       	mul	r10, r24
 1ec:	50 01       	movw	r10, r0
 1ee:	11 24       	eor	r1, r1
 1f0:	80 e0       	ldi	r24, 0x00	; 0
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	a8 0e       	add	r10, r24
 1f6:	b9 1e       	adc	r11, r25

	// Find the best PWM setting for 10kHz, with 128 steps
	boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1f8:	cc 24       	eor	r12, r12
 1fa:	c3 94       	inc	r12
 1fc:	d1 2c       	mov	r13, r1
 1fe:	cc 0e       	add	r12, r28
 200:	dd 1e       	adc	r13, r29
 202:	33 e0       	ldi	r19, 0x03	; 3
 204:	e3 2e       	mov	r14, r19
 206:	f1 2c       	mov	r15, r1
 208:	ec 0e       	add	r14, r28
 20a:	fd 1e       	adc	r15, r29
 20c:	8e 01       	movw	r16, r28
 20e:	0b 5f       	subi	r16, 0xFB	; 251
 210:	1f 4f       	sbci	r17, 0xFF	; 255
 212:	20 e8       	ldi	r18, 0x80	; 128
 214:	30 e0       	ldi	r19, 0x00	; 0
 216:	c5 01       	movw	r24, r10
 218:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 21c:	18 2f       	mov	r17, r24
 21e:	f5 01       	movw	r30, r10
 220:	34 96       	adiw	r30, 0x04	; 4
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 222:	25 91       	lpm	r18, Z+
 224:	34 91       	lpm	r19, Z
 226:	f9 01       	movw	r30, r18
 228:	80 81       	ld	r24, Z
 22a:	87 70       	andi	r24, 0x07	; 7

	if(!valid){
 22c:	11 11       	cpse	r17, r1
 22e:	00 c0       	rjmp	.+0      	; 0x230 <initPWM+0xbc>
 230:	01 f4       	brne	.+0      	; 0x232 <initPWM+0xbe>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 232:	83 ee       	ldi	r24, 0xE3	; 227
 234:	00 c0       	rjmp	.+0      	; 0x236 <initPWM+0xc2>
 236:	82 ef       	ldi	r24, 0xF2	; 242
 238:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <initPWM+0xca>
 23e:	88 23       	and	r24, r24
 240:	01 f0       	breq	.+0      	; 0x242 <initPWM+0xce>
 242:	00 c0       	rjmp	.+0      	; 0x244 <initPWM+0xd0>
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
			if(modeIsICR(mode)){
				// Set the ICR
				PORT icrPort = pgm_read_word(&timer->pgm_icr);
 244:	f5 01       	movw	r30, r10
 246:	7f 96       	adiw	r30, 0x1f	; 31
 248:	25 91       	lpm	r18, Z+
 24a:	34 91       	lpm	r19, Z
				_SFR_MEM16(icrPort)=icr;
 24c:	f9 01       	movw	r30, r18
 24e:	2b 81       	ldd	r18, Y+3	; 0x03
 250:	3c 81       	ldd	r19, Y+4	; 0x04
 252:	31 83       	std	Z+1, r19	; 0x01
 254:	20 83       	st	Z, r18
			}
		}

		// Make it an output pin and set high for brake
		pin_make_output(pin,TRUE);
 256:	6f ef       	ldi	r22, 0xFF	; 255
 258:	c3 01       	movw	r24, r6
 25a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


		// Use inverting PWM
		compareSetOutputMode(channel,CHANNEL_MODE_INVERTING);
 25e:	63 e0       	ldi	r22, 0x03	; 3
 260:	c4 01       	movw	r24, r8
 262:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


		// Mark the channels as in use
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 266:	20 e0       	ldi	r18, 0x00	; 0
 268:	30 e0       	ldi	r19, 0x00	; 0
 26a:	40 e0       	ldi	r20, 0x00	; 0
 26c:	50 e0       	ldi	r21, 0x00	; 0
 26e:	60 e0       	ldi	r22, 0x00	; 0
 270:	70 e0       	ldi	r23, 0x00	; 0
 272:	c4 01       	movw	r24, r8
 274:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
 278:	69 81       	ldd	r22, Y+1	; 0x01
 27a:	7a 81       	ldd	r23, Y+2	; 0x02
 27c:	c5 01       	movw	r24, r10
 27e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 282:	00 c0       	rjmp	.+0      	; 0x284 <initPWM+0x110>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
	}else{
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
 284:	6d 81       	ldd	r22, Y+5	; 0x05
 286:	c5 01       	movw	r24, r10
 288:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			if(modeIsICR(mode)){
 28c:	21 e0       	ldi	r18, 0x01	; 1
 28e:	30 e0       	ldi	r19, 0x00	; 0
 290:	0d 80       	ldd	r0, Y+5	; 0x05
 292:	00 c0       	rjmp	.+0      	; 0x294 <initPWM+0x120>
 294:	22 0f       	add	r18, r18
 296:	33 1f       	adc	r19, r19
 298:	0a 94       	dec	r0
 29a:	02 f4       	brpl	.+0      	; 0x29c <initPWM+0x128>
 29c:	22 27       	eor	r18, r18
 29e:	35 75       	andi	r19, 0x55	; 85
 2a0:	23 2b       	or	r18, r19
 2a2:	01 f4       	brne	.+0      	; 0x2a4 <initPWM+0x130>
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <initPWM+0x132>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
	}
	return valid;
}
 2a6:	81 2f       	mov	r24, r17
 2a8:	29 96       	adiw	r28, 0x09	; 9
 2aa:	0f b6       	in	r0, 0x3f	; 63
 2ac:	f8 94       	cli
 2ae:	de bf       	out	0x3e, r29	; 62
 2b0:	0f be       	out	0x3f, r0	; 63
 2b2:	cd bf       	out	0x3d, r28	; 61
 2b4:	df 91       	pop	r29
 2b6:	cf 91       	pop	r28
 2b8:	1f 91       	pop	r17
 2ba:	0f 91       	pop	r16
 2bc:	ff 90       	pop	r15
 2be:	ef 90       	pop	r14
 2c0:	df 90       	pop	r13
 2c2:	cf 90       	pop	r12
 2c4:	bf 90       	pop	r11
 2c6:	af 90       	pop	r10
 2c8:	9f 90       	pop	r9
 2ca:	8f 90       	pop	r8
 2cc:	7f 90       	pop	r7
 2ce:	6f 90       	pop	r6
 2d0:	08 95       	ret

000002d2 <sanyoLB1836M_Init>:

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 2d2:	4f 92       	push	r4
 2d4:	5f 92       	push	r5
 2d6:	6f 92       	push	r6
 2d8:	7f 92       	push	r7
 2da:	8f 92       	push	r8
 2dc:	9f 92       	push	r9
 2de:	af 92       	push	r10
 2e0:	bf 92       	push	r11
 2e2:	cf 92       	push	r12
 2e4:	df 92       	push	r13
 2e6:	ef 92       	push	r14
 2e8:	ff 92       	push	r15
 2ea:	0f 93       	push	r16
 2ec:	1f 93       	push	r17
 2ee:	cf 93       	push	r28
 2f0:	df 93       	push	r29
 2f2:	5c 01       	movw	r10, r24
	uint32_t deciHertz = 10 * freq;
 2f4:	aa e0       	ldi	r26, 0x0A	; 10
 2f6:	b0 e0       	ldi	r27, 0x00	; 0
 2f8:	9a 01       	movw	r18, r20
 2fa:	ab 01       	movw	r20, r22
 2fc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 300:	6b 01       	movw	r12, r22
 302:	7c 01       	movw	r14, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 304:	d5 01       	movw	r26, r10
 306:	12 96       	adiw	r26, 0x02	; 2
 308:	8c 91       	ld	r24, X
 30a:	00 e0       	ldi	r16, 0x00	; 0
 30c:	10 e0       	ldi	r17, 0x00	; 0
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	4c 01       	movw	r8, r24
 312:	b1 e0       	ldi	r27, 0x01	; 1
 314:	8b 1a       	sub	r8, r27
 316:	91 08       	sbc	r9, r1
 318:	3c 01       	movw	r6, r24
 31a:	e1 e0       	ldi	r30, 0x01	; 1
 31c:	6e 1a       	sub	r6, r30
 31e:	e0 e8       	ldi	r30, 0x80	; 128
 320:	7e 0a       	sbc	r7, r30


		if( initPWM(motor->pwm1, deciHertz) ){
			if(initPWM(motor->pwm2, deciHertz)){
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 322:	50 e0       	ldi	r21, 0x00	; 0
 324:	45 2e       	mov	r4, r21
 326:	50 e0       	ldi	r21, 0x00	; 0
 328:	55 2e       	mov	r5, r21
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 32a:	00 c0       	rjmp	.+0      	; 0x32c <sanyoLB1836M_Init+0x5a>
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 32c:	93 01       	movw	r18, r6
 32e:	20 1b       	sub	r18, r16
 330:	31 0b       	sbc	r19, r17
 332:	22 0f       	add	r18, r18
 334:	33 1f       	adc	r19, r19
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)pgm_read_word(&driver->motors[i]);
 336:	d5 01       	movw	r26, r10
 338:	ed 91       	ld	r30, X+
 33a:	fc 91       	ld	r31, X
 33c:	e2 0f       	add	r30, r18
 33e:	f3 1f       	adc	r31, r19
 340:	85 91       	lpm	r24, Z+
 342:	94 91       	lpm	r25, Z
 344:	c8 2f       	mov	r28, r24
 346:	d9 2f       	mov	r29, r25


		if( initPWM(motor->pwm1, deciHertz) ){
 348:	b7 01       	movw	r22, r14
 34a:	a6 01       	movw	r20, r12
 34c:	8c 81       	ldd	r24, Y+4	; 0x04
 34e:	9d 81       	ldd	r25, Y+5	; 0x05
 350:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 354:	88 23       	and	r24, r24
 356:	01 f0       	breq	.+0      	; 0x358 <sanyoLB1836M_Init+0x86>
			if(initPWM(motor->pwm2, deciHertz)){
 358:	b7 01       	movw	r22, r14
 35a:	a6 01       	movw	r20, r12
 35c:	8e 81       	ldd	r24, Y+6	; 0x06
 35e:	9f 81       	ldd	r25, Y+7	; 0x07
 360:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 364:	88 23       	and	r24, r24
 366:	01 f0       	breq	.+0      	; 0x368 <sanyoLB1836M_Init+0x96>
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 368:	59 82       	std	Y+1, r5	; 0x01
 36a:	48 82       	st	Y, r4
			}
		}

		// Start off braking
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 36c:	60 e0       	ldi	r22, 0x00	; 0
 36e:	ce 01       	movw	r24, r28
 370:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
 374:	6f ef       	ldi	r22, 0xFF	; 255
 376:	ce 01       	movw	r24, r28
 378:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 37c:	0f 5f       	subi	r16, 0xFF	; 255
 37e:	1f 4f       	sbci	r17, 0xFF	; 255
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 380:	c4 01       	movw	r24, r8
 382:	80 1b       	sub	r24, r16
 384:	91 0b       	sbc	r25, r17
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 386:	01 96       	adiw	r24, 0x01	; 1
 388:	01 f4       	brne	.+0      	; 0x38a <sanyoLB1836M_Init+0xb8>
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
	}
}
 38a:	df 91       	pop	r29
 38c:	cf 91       	pop	r28
 38e:	1f 91       	pop	r17
 390:	0f 91       	pop	r16
 392:	ff 90       	pop	r15
 394:	ef 90       	pop	r14
 396:	df 90       	pop	r13
 398:	cf 90       	pop	r12
 39a:	bf 90       	pop	r11
 39c:	af 90       	pop	r10
 39e:	9f 90       	pop	r9
 3a0:	8f 90       	pop	r8
 3a2:	7f 90       	pop	r7
 3a4:	6f 90       	pop	r6
 3a6:	5f 90       	pop	r5
 3a8:	4f 90       	pop	r4
 3aa:	08 95       	ret

L298.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000030a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000030a  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  0000030a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d72  00000000  00000000  0000030e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002f4  00000000  00000000  00001080  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000687  00000000  00000000  00001374  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000019fb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000040  00000000  00000000  00001a1b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000185  00000000  00000000  00001a5b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000797  00000000  00000000  00001be0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002377  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000d8  00000000  00000000  000023a4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pin);
   a:	fc 01       	movw	r30, r24
   c:	84 81       	ldd	r24, Z+4	; 0x04
   e:	95 81       	ldd	r25, Z+5	; 0x05
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
static void setConnected(__ACTUATOR *actuator, boolean connected){
	SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pin);

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  28:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

0000002c <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2c:	df 92       	push	r13
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	0f 93       	push	r16
  34:	1f 93       	push	r17
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	ec 01       	movw	r28, r24
  3c:	d6 2e       	mov	r13, r22
	SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pin);
  3e:	8c 81       	ldd	r24, Y+4	; 0x04
  40:	9d 81       	ldd	r25, Y+5	; 0x05
  42:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  46:	7c 01       	movw	r14, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  48:	fc 01       	movw	r30, r24
  4a:	32 96       	adiw	r30, 0x02	; 2
  4c:	84 91       	lpm	r24, Z
	const Timer* timer = compareGetTimer(channel);
  4e:	2c e2       	ldi	r18, 0x2C	; 44
  50:	82 9f       	mul	r24, r18
  52:	c0 01       	movw	r24, r0
  54:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  56:	80 50       	subi	r24, 0x00	; 0
  58:	90 40       	sbci	r25, 0x00	; 0
  5a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  5e:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  60:	1d 14       	cp	r1, r13
  62:	04 f4       	brge	.+0      	; 0x64 <setSpeed+0x38>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	30 e0       	ldi	r19, 0x00	; 0
  68:	4f e7       	ldi	r20, 0x7F	; 127
  6a:	50 e0       	ldi	r21, 0x00	; 0
  6c:	60 e0       	ldi	r22, 0x00	; 0
  6e:	70 e0       	ldi	r23, 0x00	; 0
  70:	8d 2d       	mov	r24, r13
  72:	99 27       	eor	r25, r25
  74:	87 fd       	sbrc	r24, 7
  76:	90 95       	com	r25
  78:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  7c:	8c 01       	movw	r16, r24
		// Set pins low and high
		pin_low(motor->enable1);
  7e:	8e 81       	ldd	r24, Y+6	; 0x06
  80:	9f 81       	ldd	r25, Y+7	; 0x07
  82:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_high(motor->enable2);
  86:	88 85       	ldd	r24, Y+8	; 0x08
  88:	99 85       	ldd	r25, Y+9	; 0x09
  8a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <setSpeed+0x64>

	}else if(speed < 0){
  90:	dd 20       	and	r13, r13
  92:	01 f0       	breq	.+0      	; 0x94 <setSpeed+0x68>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  94:	20 e0       	ldi	r18, 0x00	; 0
  96:	30 e0       	ldi	r19, 0x00	; 0
  98:	41 e8       	ldi	r20, 0x81	; 129
  9a:	5f ef       	ldi	r21, 0xFF	; 255
  9c:	60 e0       	ldi	r22, 0x00	; 0
  9e:	70 e0       	ldi	r23, 0x00	; 0
  a0:	8d 2d       	mov	r24, r13
  a2:	99 27       	eor	r25, r25
  a4:	87 fd       	sbrc	r24, 7
  a6:	90 95       	com	r25
  a8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  ac:	8c 01       	movw	r16, r24
		// Set pins high and low
		pin_high(motor->enable1);
  ae:	8e 81       	ldd	r24, Y+6	; 0x06
  b0:	9f 81       	ldd	r25, Y+7	; 0x07
  b2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <setSpeed+0x8c>
	}else{
		// brake
		// Force output to stay high
		delay=top;
		// Set both pins low
		pin_low(motor->enable1);
  b8:	8e 81       	ldd	r24, Y+6	; 0x06
  ba:	9f 81       	ldd	r25, Y+7	; 0x07
  bc:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_low(motor->enable2);
  c0:	88 85       	ldd	r24, Y+8	; 0x08
  c2:	99 85       	ldd	r25, Y+9	; 0x09
  c4:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  c8:	b8 01       	movw	r22, r16
  ca:	c7 01       	movw	r24, r14
}
  cc:	df 91       	pop	r29
  ce:	cf 91       	pop	r28
  d0:	1f 91       	pop	r17
  d2:	0f 91       	pop	r16
  d4:	ff 90       	pop	r15
  d6:	ef 90       	pop	r14
  d8:	df 90       	pop	r13
		pin_low(motor->enable1);
		pin_low(motor->enable2);
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  da:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

000000de <solarL298Init>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
  de:	2f 92       	push	r2
  e0:	3f 92       	push	r3
  e2:	4f 92       	push	r4
  e4:	5f 92       	push	r5
  e6:	6f 92       	push	r6
  e8:	7f 92       	push	r7
  ea:	8f 92       	push	r8
  ec:	9f 92       	push	r9
  ee:	af 92       	push	r10
  f0:	bf 92       	push	r11
  f2:	cf 92       	push	r12
  f4:	df 92       	push	r13
  f6:	ef 92       	push	r14
  f8:	ff 92       	push	r15
  fa:	0f 93       	push	r16
  fc:	1f 93       	push	r17
  fe:	cf 93       	push	r28
 100:	df 93       	push	r29
 102:	cd b7       	in	r28, 0x3d	; 61
 104:	de b7       	in	r29, 0x3e	; 62
 106:	2d 97       	sbiw	r28, 0x0d	; 13
 108:	0f b6       	in	r0, 0x3f	; 63
 10a:	f8 94       	cli
 10c:	de bf       	out	0x3e, r29	; 62
 10e:	0f be       	out	0x3f, r0	; 63
 110:	cd bf       	out	0x3d, r28	; 61
 112:	4c 01       	movw	r8, r24
	uint32_t deciHertz = 10 * freq;
 114:	aa e0       	ldi	r26, 0x0A	; 10
 116:	b0 e0       	ldi	r27, 0x00	; 0
 118:	9a 01       	movw	r18, r20
 11a:	ab 01       	movw	r20, r22
 11c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 120:	6e 83       	std	Y+6, r22	; 0x06
 122:	7f 83       	std	Y+7, r23	; 0x07
 124:	88 87       	std	Y+8, r24	; 0x08
 126:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 128:	d4 01       	movw	r26, r8
 12a:	12 96       	adiw	r26, 0x02	; 2
 12c:	8c 91       	ld	r24, X
 12e:	a1 2c       	mov	r10, r1
 130:	b1 2c       	mov	r11, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	fc 01       	movw	r30, r24
 136:	31 97       	sbiw	r30, 0x01	; 1
 138:	fb 87       	std	Y+11, r31	; 0x0b
 13a:	ea 87       	std	Y+10, r30	; 0x0a
 13c:	9c 01       	movw	r18, r24
 13e:	21 50       	subi	r18, 0x01	; 1
 140:	30 48       	sbci	r19, 0x80	; 128
 142:	3d 87       	std	Y+13, r19	; 0x0d
 144:	2c 87       	std	Y+12, r18	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 146:	00 c0       	rjmp	.+0      	; 0x148 <solarL298Init+0x6a>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 148:	2c 85       	ldd	r18, Y+12	; 0x0c
 14a:	3d 85       	ldd	r19, Y+13	; 0x0d
 14c:	2a 19       	sub	r18, r10
 14e:	3b 09       	sbc	r19, r11
 150:	22 0f       	add	r18, r18
 152:	33 1f       	adc	r19, r19
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)pgm_read_word(&driver->motors[i]);
 154:	d4 01       	movw	r26, r8
 156:	ed 91       	ld	r30, X+
 158:	fc 91       	ld	r31, X
 15a:	e2 0f       	add	r30, r18
 15c:	f3 1f       	adc	r31, r19
 15e:	85 91       	lpm	r24, Z+
 160:	94 91       	lpm	r25, Z
 162:	3c 01       	movw	r6, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pin);
 164:	fc 01       	movw	r30, r24
 166:	84 81       	ldd	r24, Z+4	; 0x04
 168:	95 81       	ldd	r25, Z+5	; 0x05
 16a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 16e:	1c 01       	movw	r2, r24
		if(channel==null){
 170:	00 97       	sbiw	r24, 0x00	; 0
 172:	01 f4       	brne	.+0      	; 0x174 <solarL298Init+0x96>
			setError(PWM_PIN_NOT_AVAILABLE);
 174:	84 ef       	ldi	r24, 0xF4	; 244
 176:	00 c0       	rjmp	.+0      	; 0x178 <solarL298Init+0x9a>
			continue;
		}
		if(compareIsInUse(channel)){
 178:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 17c:	88 23       	and	r24, r24
 17e:	01 f0       	breq	.+0      	; 0x180 <solarL298Init+0xa2>
			setError(PWM_PIN_IN_USE);
 180:	83 ef       	ldi	r24, 0xF3	; 243
 182:	00 c0       	rjmp	.+0      	; 0x184 <solarL298Init+0xa6>
 184:	f1 01       	movw	r30, r2
 186:	32 96       	adiw	r30, 0x02	; 2
 188:	44 90       	lpm	r4, Z

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 18a:	fc e2       	ldi	r31, 0x2C	; 44
 18c:	f4 9d       	mul	r31, r4
 18e:	20 01       	movw	r4, r0
 190:	11 24       	eor	r1, r1
 192:	20 e0       	ldi	r18, 0x00	; 0
 194:	30 e0       	ldi	r19, 0x00	; 0
 196:	42 0e       	add	r4, r18
 198:	53 1e       	adc	r5, r19

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 19a:	cc 24       	eor	r12, r12
 19c:	c3 94       	inc	r12
 19e:	d1 2c       	mov	r13, r1
 1a0:	cc 0e       	add	r12, r28
 1a2:	dd 1e       	adc	r13, r29
 1a4:	93 e0       	ldi	r25, 0x03	; 3
 1a6:	e9 2e       	mov	r14, r25
 1a8:	f1 2c       	mov	r15, r1
 1aa:	ec 0e       	add	r14, r28
 1ac:	fd 1e       	adc	r15, r29
 1ae:	8e 01       	movw	r16, r28
 1b0:	0b 5f       	subi	r16, 0xFB	; 251
 1b2:	1f 4f       	sbci	r17, 0xFF	; 255
 1b4:	20 e8       	ldi	r18, 0x80	; 128
 1b6:	30 e0       	ldi	r19, 0x00	; 0
 1b8:	4e 81       	ldd	r20, Y+6	; 0x06
 1ba:	5f 81       	ldd	r21, Y+7	; 0x07
 1bc:	68 85       	ldd	r22, Y+8	; 0x08
 1be:	79 85       	ldd	r23, Y+9	; 0x09
 1c0:	c2 01       	movw	r24, r4
 1c2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1c6:	f2 01       	movw	r30, r4
 1c8:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 1ca:	81 11       	cpse	r24, r1
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <solarL298Init+0xf0>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 1ce:	85 91       	lpm	r24, Z+
 1d0:	94 91       	lpm	r25, Z
 1d2:	fc 01       	movw	r30, r24
 1d4:	80 81       	ld	r24, Z
 1d6:	87 70       	andi	r24, 0x07	; 7
 1d8:	01 f4       	brne	.+0      	; 0x1da <solarL298Init+0xfc>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 1da:	83 ee       	ldi	r24, 0xE3	; 227
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <solarL298Init+0x100>
 1de:	82 ef       	ldi	r24, 0xF2	; 242
 1e0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <solarL298Init+0x108>
 1e6:	85 91       	lpm	r24, Z+
 1e8:	94 91       	lpm	r25, Z
 1ea:	fc 01       	movw	r30, r24
 1ec:	80 81       	ld	r24, Z
 1ee:	87 70       	andi	r24, 0x07	; 7
 1f0:	01 f4       	brne	.+0      	; 0x1f2 <solarL298Init+0x114>
 1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <solarL298Init+0x116>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <solarL298Init+0x118>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 1f6:	f2 01       	movw	r30, r4
 1f8:	7f 96       	adiw	r30, 0x1f	; 31
 1fa:	85 91       	lpm	r24, Z+
 1fc:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 1fe:	fc 01       	movw	r30, r24
 200:	8b 81       	ldd	r24, Y+3	; 0x03
 202:	9c 81       	ldd	r25, Y+4	; 0x04
 204:	91 83       	std	Z+1, r25	; 0x01
 206:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 208:	e0 e0       	ldi	r30, 0x00	; 0
 20a:	f0 e0       	ldi	r31, 0x00	; 0
 20c:	d3 01       	movw	r26, r6
 20e:	11 96       	adiw	r26, 0x01	; 1
 210:	fc 93       	st	X, r31
 212:	ee 93       	st	-X, r30

			// Make sure the motor pin is an output pin
			pin_make_output(motor->pin, FALSE);
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	14 96       	adiw	r26, 0x04	; 4
 218:	8d 91       	ld	r24, X+
 21a:	9c 91       	ld	r25, X
 21c:	15 97       	sbiw	r26, 0x05	; 5
 21e:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Make sure the direction pin is set as an output pin
			pin_make_output(motor->enable1, FALSE);
 222:	60 e0       	ldi	r22, 0x00	; 0
 224:	d3 01       	movw	r26, r6
 226:	16 96       	adiw	r26, 0x06	; 6
 228:	8d 91       	ld	r24, X+
 22a:	9c 91       	ld	r25, X
 22c:	17 97       	sbiw	r26, 0x07	; 7
 22e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->enable2, FALSE);
 232:	60 e0       	ldi	r22, 0x00	; 0
 234:	f3 01       	movw	r30, r6
 236:	80 85       	ldd	r24, Z+8	; 0x08
 238:	91 85       	ldd	r25, Z+9	; 0x09
 23a:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 23e:	20 e0       	ldi	r18, 0x00	; 0
 240:	30 e0       	ldi	r19, 0x00	; 0
 242:	40 e0       	ldi	r20, 0x00	; 0
 244:	50 e0       	ldi	r21, 0x00	; 0
 246:	60 e0       	ldi	r22, 0x00	; 0
 248:	70 e0       	ldi	r23, 0x00	; 0
 24a:	c1 01       	movw	r24, r2
 24c:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 250:	69 81       	ldd	r22, Y+1	; 0x01
 252:	7a 81       	ldd	r23, Y+2	; 0x02
 254:	c2 01       	movw	r24, r4
 256:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 25a:	60 e0       	ldi	r22, 0x00	; 0
 25c:	c3 01       	movw	r24, r6
 25e:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 262:	6f ef       	ldi	r22, 0xFF	; 255
 264:	c3 01       	movw	r24, r6
 266:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 26a:	ff ef       	ldi	r31, 0xFF	; 255
 26c:	af 1a       	sub	r10, r31
 26e:	bf 0a       	sbc	r11, r31
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 270:	8a 85       	ldd	r24, Y+10	; 0x0a
 272:	9b 85       	ldd	r25, Y+11	; 0x0b
 274:	8a 19       	sub	r24, r10
 276:	9b 09       	sbc	r25, r11
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 278:	01 96       	adiw	r24, 0x01	; 1
 27a:	01 f0       	breq	.+0      	; 0x27c <solarL298Init+0x19e>
 27c:	00 c0       	rjmp	.+0      	; 0x27e <solarL298Init+0x1a0>
 27e:	00 c0       	rjmp	.+0      	; 0x280 <solarL298Init+0x1a2>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 280:	6d 81       	ldd	r22, Y+5	; 0x05
 282:	c2 01       	movw	r24, r4
 284:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 288:	21 e0       	ldi	r18, 0x01	; 1
 28a:	30 e0       	ldi	r19, 0x00	; 0
 28c:	0d 80       	ldd	r0, Y+5	; 0x05
 28e:	00 c0       	rjmp	.+0      	; 0x290 <solarL298Init+0x1b2>
 290:	22 0f       	add	r18, r18
 292:	33 1f       	adc	r19, r19
 294:	0a 94       	dec	r0
 296:	02 f4       	brpl	.+0      	; 0x298 <solarL298Init+0x1ba>
 298:	22 27       	eor	r18, r18
 29a:	35 75       	andi	r19, 0x55	; 85
 29c:	23 2b       	or	r18, r19
 29e:	01 f0       	breq	.+0      	; 0x2a0 <solarL298Init+0x1c2>
 2a0:	00 c0       	rjmp	.+0      	; 0x2a2 <solarL298Init+0x1c4>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <solarL298Init+0x1c6>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 2a4:	2d 96       	adiw	r28, 0x0d	; 13
 2a6:	0f b6       	in	r0, 0x3f	; 63
 2a8:	f8 94       	cli
 2aa:	de bf       	out	0x3e, r29	; 62
 2ac:	0f be       	out	0x3f, r0	; 63
 2ae:	cd bf       	out	0x3d, r28	; 61
 2b0:	df 91       	pop	r29
 2b2:	cf 91       	pop	r28
 2b4:	1f 91       	pop	r17
 2b6:	0f 91       	pop	r16
 2b8:	ff 90       	pop	r15
 2ba:	ef 90       	pop	r14
 2bc:	df 90       	pop	r13
 2be:	cf 90       	pop	r12
 2c0:	bf 90       	pop	r11
 2c2:	af 90       	pop	r10
 2c4:	9f 90       	pop	r9
 2c6:	8f 90       	pop	r8
 2c8:	7f 90       	pop	r7
 2ca:	6f 90       	pop	r6
 2cc:	5f 90       	pop	r5
 2ce:	4f 90       	pop	r4
 2d0:	3f 90       	pop	r3
 2d2:	2f 90       	pop	r2
 2d4:	08 95       	ret

TB6612FNG_2pin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ac  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003e0  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003e0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000f79  00000000  00000000  000003e4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000035d  00000000  00000000  0000135d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000009a5  00000000  00000000  000016ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000205f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000068  00000000  00000000  0000207f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001c0  00000000  00000000  000020e7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000007f8  00000000  00000000  000022a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002a9f  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000144  00000000  00000000  00002acc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	d6 2e       	mov	r13, r22
	TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  12:	8c 81       	ldd	r24, Y+4	; 0x04
  14:	9d 81       	ldd	r25, Y+5	; 0x05
  16:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  1a:	7c 01       	movw	r14, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  1c:	8e 81       	ldd	r24, Y+6	; 0x06
  1e:	9f 81       	ldd	r25, Y+7	; 0x07
  20:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  24:	ec 01       	movw	r28, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  26:	1d 14       	cp	r1, r13
  28:	04 f4       	brge	.+0      	; 0x2a <setSpeed+0x2a>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  2a:	fc 01       	movw	r30, r24
  2c:	32 96       	adiw	r30, 0x02	; 2
  2e:	84 91       	lpm	r24, Z
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0, timerGetTOP(compareGetTimer(channel2)));
  30:	2c e2       	ldi	r18, 0x2C	; 44
  32:	82 9f       	mul	r24, r18
  34:	c0 01       	movw	r24, r0
  36:	11 24       	eor	r1, r1
  38:	80 50       	subi	r24, 0x00	; 0
  3a:	90 40       	sbci	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  40:	8c 01       	movw	r16, r24
  42:	20 e0       	ldi	r18, 0x00	; 0
  44:	30 e0       	ldi	r19, 0x00	; 0
  46:	4f e7       	ldi	r20, 0x7F	; 127
  48:	50 e0       	ldi	r21, 0x00	; 0
  4a:	60 e0       	ldi	r22, 0x00	; 0
  4c:	70 e0       	ldi	r23, 0x00	; 0
  4e:	8d 2d       	mov	r24, r13
  50:	99 27       	eor	r25, r25
  52:	87 fd       	sbrc	r24, 7
  54:	90 95       	com	r25
  56:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  5a:	8c 01       	movw	r16, r24
		compareSetThreshold(channel1,0);	    // Keep permanently high
  5c:	60 e0       	ldi	r22, 0x00	; 0
  5e:	70 e0       	ldi	r23, 0x00	; 0
  60:	c7 01       	movw	r24, r14
  62:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,delay);	// pwm channel 2
  66:	b8 01       	movw	r22, r16
  68:	00 c0       	rjmp	.+0      	; 0x6a <setSpeed+0x6a>
	}else if(speed < 0){
  6a:	dd 20       	and	r13, r13
  6c:	01 f0       	breq	.+0      	; 0x6e <setSpeed+0x6e>
  6e:	f7 01       	movw	r30, r14
  70:	32 96       	adiw	r30, 0x02	; 2
  72:	84 91       	lpm	r24, Z
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , timerGetTOP(compareGetTimer(channel1)));
  74:	2c e2       	ldi	r18, 0x2C	; 44
  76:	82 9f       	mul	r24, r18
  78:	c0 01       	movw	r24, r0
  7a:	11 24       	eor	r1, r1
  7c:	80 50       	subi	r24, 0x00	; 0
  7e:	90 40       	sbci	r25, 0x00	; 0
  80:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  84:	8c 01       	movw	r16, r24
  86:	20 e0       	ldi	r18, 0x00	; 0
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	41 e8       	ldi	r20, 0x81	; 129
  8c:	5f ef       	ldi	r21, 0xFF	; 255
  8e:	60 e0       	ldi	r22, 0x00	; 0
  90:	70 e0       	ldi	r23, 0x00	; 0
  92:	8d 2d       	mov	r24, r13
  94:	99 27       	eor	r25, r25
  96:	87 fd       	sbrc	r24, 7
  98:	90 95       	com	r25
  9a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  9e:	8c 01       	movw	r16, r24
		compareSetThreshold(channel2,0);	    // Keep permanently high
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	70 e0       	ldi	r23, 0x00	; 0
  a4:	ce 01       	movw	r24, r28
  a6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel1,delay);	// pwm channel 1
  aa:	b8 01       	movw	r22, r16
  ac:	c7 01       	movw	r24, r14
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <setSpeed+0xb0>
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
  b0:	60 e0       	ldi	r22, 0x00	; 0
  b2:	70 e0       	ldi	r23, 0x00	; 0
  b4:	c7 01       	movw	r24, r14
  b6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,0);	    // Keep permanently high
  ba:	60 e0       	ldi	r22, 0x00	; 0
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	ce 01       	movw	r24, r28
	}
}
  c0:	df 91       	pop	r29
  c2:	cf 91       	pop	r28
  c4:	1f 91       	pop	r17
  c6:	0f 91       	pop	r16
  c8:	ff 90       	pop	r15
  ca:	ef 90       	pop	r14
  cc:	df 90       	pop	r13
		compareSetThreshold(channel1,delay);	// pwm channel 1
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
		compareSetThreshold(channel2,0);	    // Keep permanently high
  ce:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

000000d2 <setConnected>:
	}
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
  d2:	cf 92       	push	r12
  d4:	df 92       	push	r13
  d6:	ef 92       	push	r14
  d8:	ff 92       	push	r15
  da:	0f 93       	push	r16
  dc:	1f 93       	push	r17
  de:	cf 93       	push	r28
  e0:	df 93       	push	r29
  e2:	1f 92       	push	r1
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
  e8:	6c 01       	movw	r12, r24
	TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  ea:	fc 01       	movw	r30, r24
  ec:	84 81       	ldd	r24, Z+4	; 0x04
  ee:	95 81       	ldd	r25, Z+5	; 0x05
  f0:	69 83       	std	Y+1, r22	; 0x01
  f2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  f6:	7c 01       	movw	r14, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  f8:	f6 01       	movw	r30, r12
  fa:	86 81       	ldd	r24, Z+6	; 0x06
  fc:	97 81       	ldd	r25, Z+7	; 0x07
  fe:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 102:	8c 01       	movw	r16, r24

	if(connected){
 104:	69 81       	ldd	r22, Y+1	; 0x01
 106:	66 23       	and	r22, r22
 108:	01 f0       	breq	.+0      	; 0x10a <setConnected+0x38>
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 10a:	f6 01       	movw	r30, r12
 10c:	62 81       	ldd	r22, Z+2	; 0x02
 10e:	c6 01       	movw	r24, r12
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
	}

}
 110:	0f 90       	pop	r0
 112:	df 91       	pop	r29
 114:	cf 91       	pop	r28
 116:	1f 91       	pop	r17
 118:	0f 91       	pop	r16
 11a:	ff 90       	pop	r15
 11c:	ef 90       	pop	r14
 11e:	df 90       	pop	r13
 120:	cf 90       	pop	r12
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);

	if(connected){
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 122:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
 126:	f7 01       	movw	r30, r14
 128:	32 96       	adiw	r30, 0x02	; 2
 12a:	84 91       	lpm	r24, Z
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
 12c:	9c e2       	ldi	r25, 0x2C	; 44
 12e:	d9 2e       	mov	r13, r25
 130:	d8 9e       	mul	r13, r24
 132:	c0 01       	movw	r24, r0
 134:	11 24       	eor	r1, r1
 136:	80 50       	subi	r24, 0x00	; 0
 138:	90 40       	sbci	r25, 0x00	; 0
 13a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 13e:	bc 01       	movw	r22, r24
 140:	c7 01       	movw	r24, r14
 142:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 146:	f8 01       	movw	r30, r16
 148:	32 96       	adiw	r30, 0x02	; 2
 14a:	84 91       	lpm	r24, Z
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 14c:	d8 9e       	mul	r13, r24
 14e:	c0 01       	movw	r24, r0
 150:	11 24       	eor	r1, r1
 152:	80 50       	subi	r24, 0x00	; 0
 154:	90 40       	sbci	r25, 0x00	; 0
 156:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 15a:	bc 01       	movw	r22, r24
 15c:	c8 01       	movw	r24, r16
	}

}
 15e:	0f 90       	pop	r0
 160:	df 91       	pop	r29
 162:	cf 91       	pop	r28
 164:	1f 91       	pop	r17
 166:	0f 91       	pop	r16
 168:	ff 90       	pop	r15
 16a:	ef 90       	pop	r14
 16c:	df 90       	pop	r13
 16e:	cf 90       	pop	r12
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 170:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

00000174 <initPWM>:
}

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

static boolean initPWM(const IOPin* pin, uint32_t deciHertz){
 174:	6f 92       	push	r6
 176:	7f 92       	push	r7
 178:	8f 92       	push	r8
 17a:	9f 92       	push	r9
 17c:	af 92       	push	r10
 17e:	bf 92       	push	r11
 180:	cf 92       	push	r12
 182:	df 92       	push	r13
 184:	ef 92       	push	r14
 186:	ff 92       	push	r15
 188:	0f 93       	push	r16
 18a:	1f 93       	push	r17
 18c:	cf 93       	push	r28
 18e:	df 93       	push	r29
 190:	cd b7       	in	r28, 0x3d	; 61
 192:	de b7       	in	r29, 0x3e	; 62
 194:	29 97       	sbiw	r28, 0x09	; 9
 196:	0f b6       	in	r0, 0x3f	; 63
 198:	f8 94       	cli
 19a:	de bf       	out	0x3e, r29	; 62
 19c:	0f be       	out	0x3f, r0	; 63
 19e:	cd bf       	out	0x3d, r28	; 61
 1a0:	3c 01       	movw	r6, r24
	const TimerCompare* channel = compareFromIOPin(pin);
 1a2:	4e 83       	std	Y+6, r20	; 0x06
 1a4:	5f 83       	std	Y+7, r21	; 0x07
 1a6:	68 87       	std	Y+8, r22	; 0x08
 1a8:	79 87       	std	Y+9, r23	; 0x09
 1aa:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1ae:	4c 01       	movw	r8, r24

	if(channel==null){
 1b0:	4e 81       	ldd	r20, Y+6	; 0x06
 1b2:	5f 81       	ldd	r21, Y+7	; 0x07
 1b4:	68 85       	ldd	r22, Y+8	; 0x08
 1b6:	79 85       	ldd	r23, Y+9	; 0x09
 1b8:	00 97       	sbiw	r24, 0x00	; 0
 1ba:	01 f4       	brne	.+0      	; 0x1bc <initPWM+0x48>
		setError(PWM_PIN_NOT_AVAILABLE);
 1bc:	84 ef       	ldi	r24, 0xF4	; 244
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <initPWM+0x4c>
		return FALSE;
	}
	if(compareIsInUse(channel)){
 1c0:	4e 83       	std	Y+6, r20	; 0x06
 1c2:	5f 83       	std	Y+7, r21	; 0x07
 1c4:	68 87       	std	Y+8, r22	; 0x08
 1c6:	79 87       	std	Y+9, r23	; 0x09
 1c8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1cc:	4e 81       	ldd	r20, Y+6	; 0x06
 1ce:	5f 81       	ldd	r21, Y+7	; 0x07
 1d0:	68 85       	ldd	r22, Y+8	; 0x08
 1d2:	79 85       	ldd	r23, Y+9	; 0x09
 1d4:	88 23       	and	r24, r24
 1d6:	01 f0       	breq	.+0      	; 0x1d8 <initPWM+0x64>
		setError(PWM_PIN_IN_USE);
 1d8:	83 ef       	ldi	r24, 0xF3	; 243
 1da:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		return FALSE;
 1de:	10 e0       	ldi	r17, 0x00	; 0
 1e0:	00 c0       	rjmp	.+0      	; 0x1e2 <initPWM+0x6e>
 1e2:	f4 01       	movw	r30, r8
 1e4:	32 96       	adiw	r30, 0x02	; 2
 1e6:	a4 90       	lpm	r10, Z

	TIMER_MODE mode;
	uint16_t icr;
	uint16_t prescaler;

	const Timer* timer = compareGetTimer(channel);
 1e8:	8c e2       	ldi	r24, 0x2C	; 44
 1ea:	a8 9e       	mul	r10, r24
 1ec:	50 01       	movw	r10, r0
 1ee:	11 24       	eor	r1, r1
 1f0:	80 e0       	ldi	r24, 0x00	; 0
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	a8 0e       	add	r10, r24
 1f6:	b9 1e       	adc	r11, r25

	// Find the best PWM setting for 10kHz, with 128 steps
	boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1f8:	cc 24       	eor	r12, r12
 1fa:	c3 94       	inc	r12
 1fc:	d1 2c       	mov	r13, r1
 1fe:	cc 0e       	add	r12, r28
 200:	dd 1e       	adc	r13, r29
 202:	33 e0       	ldi	r19, 0x03	; 3
 204:	e3 2e       	mov	r14, r19
 206:	f1 2c       	mov	r15, r1
 208:	ec 0e       	add	r14, r28
 20a:	fd 1e       	adc	r15, r29
 20c:	8e 01       	movw	r16, r28
 20e:	0b 5f       	subi	r16, 0xFB	; 251
 210:	1f 4f       	sbci	r17, 0xFF	; 255
 212:	20 e8       	ldi	r18, 0x80	; 128
 214:	30 e0       	ldi	r19, 0x00	; 0
 216:	c5 01       	movw	r24, r10
 218:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 21c:	18 2f       	mov	r17, r24
 21e:	f5 01       	movw	r30, r10
 220:	34 96       	adiw	r30, 0x04	; 4
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 222:	25 91       	lpm	r18, Z+
 224:	34 91       	lpm	r19, Z
 226:	f9 01       	movw	r30, r18
 228:	80 81       	ld	r24, Z
 22a:	87 70       	andi	r24, 0x07	; 7

	if(!valid){
 22c:	11 11       	cpse	r17, r1
 22e:	00 c0       	rjmp	.+0      	; 0x230 <initPWM+0xbc>
 230:	01 f4       	brne	.+0      	; 0x232 <initPWM+0xbe>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 232:	83 ee       	ldi	r24, 0xE3	; 227
 234:	00 c0       	rjmp	.+0      	; 0x236 <initPWM+0xc2>
 236:	82 ef       	ldi	r24, 0xF2	; 242
 238:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <initPWM+0xca>
 23e:	88 23       	and	r24, r24
 240:	01 f0       	breq	.+0      	; 0x242 <initPWM+0xce>
 242:	00 c0       	rjmp	.+0      	; 0x244 <initPWM+0xd0>
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
			if(modeIsICR(mode)){
				// Set the ICR
				PORT icrPort = pgm_read_word(&timer->pgm_icr);
 244:	f5 01       	movw	r30, r10
 246:	7f 96       	adiw	r30, 0x1f	; 31
 248:	25 91       	lpm	r18, Z+
 24a:	34 91       	lpm	r19, Z
				_SFR_MEM16(icrPort)=icr;
 24c:	f9 01       	movw	r30, r18
 24e:	2b 81       	ldd	r18, Y+3	; 0x03
 250:	3c 81       	ldd	r19, Y+4	; 0x04
 252:	31 83       	std	Z+1, r19	; 0x01
 254:	20 83       	st	Z, r18
			}
		}

		// Make it an output pin and set high for brake
		pin_make_output(pin,TRUE);
 256:	6f ef       	ldi	r22, 0xFF	; 255
 258:	c3 01       	movw	r24, r6
 25a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Use inverting PWM
		compareSetOutputMode(channel,CHANNEL_MODE_INVERTING);
 25e:	63 e0       	ldi	r22, 0x03	; 3
 260:	c4 01       	movw	r24, r8
 262:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Mark the channels as in use
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 266:	20 e0       	ldi	r18, 0x00	; 0
 268:	30 e0       	ldi	r19, 0x00	; 0
 26a:	40 e0       	ldi	r20, 0x00	; 0
 26c:	50 e0       	ldi	r21, 0x00	; 0
 26e:	60 e0       	ldi	r22, 0x00	; 0
 270:	70 e0       	ldi	r23, 0x00	; 0
 272:	c4 01       	movw	r24, r8
 274:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
 278:	69 81       	ldd	r22, Y+1	; 0x01
 27a:	7a 81       	ldd	r23, Y+2	; 0x02
 27c:	c5 01       	movw	r24, r10
 27e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 282:	00 c0       	rjmp	.+0      	; 0x284 <initPWM+0x110>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
	}else{
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
 284:	6d 81       	ldd	r22, Y+5	; 0x05
 286:	c5 01       	movw	r24, r10
 288:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			if(modeIsICR(mode)){
 28c:	21 e0       	ldi	r18, 0x01	; 1
 28e:	30 e0       	ldi	r19, 0x00	; 0
 290:	0d 80       	ldd	r0, Y+5	; 0x05
 292:	00 c0       	rjmp	.+0      	; 0x294 <initPWM+0x120>
 294:	22 0f       	add	r18, r18
 296:	33 1f       	adc	r19, r19
 298:	0a 94       	dec	r0
 29a:	02 f4       	brpl	.+0      	; 0x29c <initPWM+0x128>
 29c:	22 27       	eor	r18, r18
 29e:	35 75       	andi	r19, 0x55	; 85
 2a0:	23 2b       	or	r18, r19
 2a2:	01 f4       	brne	.+0      	; 0x2a4 <initPWM+0x130>
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <initPWM+0x132>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
	}
	return valid;
}
 2a6:	81 2f       	mov	r24, r17
 2a8:	29 96       	adiw	r28, 0x09	; 9
 2aa:	0f b6       	in	r0, 0x3f	; 63
 2ac:	f8 94       	cli
 2ae:	de bf       	out	0x3e, r29	; 62
 2b0:	0f be       	out	0x3f, r0	; 63
 2b2:	cd bf       	out	0x3d, r28	; 61
 2b4:	df 91       	pop	r29
 2b6:	cf 91       	pop	r28
 2b8:	1f 91       	pop	r17
 2ba:	0f 91       	pop	r16
 2bc:	ff 90       	pop	r15
 2be:	ef 90       	pop	r14
 2c0:	df 90       	pop	r13
 2c2:	cf 90       	pop	r12
 2c4:	bf 90       	pop	r11
 2c6:	af 90       	pop	r10
 2c8:	9f 90       	pop	r9
 2ca:	8f 90       	pop	r8
 2cc:	7f 90       	pop	r7
 2ce:	6f 90       	pop	r6
 2d0:	08 95       	ret

000002d2 <toshibaTB6612FNG_2pin_Init>:

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 2d2:	4f 92       	push	r4
 2d4:	5f 92       	push	r5
 2d6:	6f 92       	push	r6
 2d8:	7f 92       	push	r7
 2da:	8f 92       	push	r8
 2dc:	9f 92       	push	r9
 2de:	af 92       	push	r10
 2e0:	bf 92       	push	r11
 2e2:	cf 92       	push	r12
 2e4:	df 92       	push	r13
 2e6:	ef 92       	push	r14
 2e8:	ff 92       	push	r15
 2ea:	0f 93       	push	r16
 2ec:	1f 93       	push	r17
 2ee:	cf 93       	push	r28
 2f0:	df 93       	push	r29
 2f2:	5c 01       	movw	r10, r24
	uint32_t deciHertz = 10 * freq;
 2f4:	aa e0       	ldi	r26, 0x0A	; 10
 2f6:	b0 e0       	ldi	r27, 0x00	; 0
 2f8:	9a 01       	movw	r18, r20
 2fa:	ab 01       	movw	r20, r22
 2fc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 300:	6b 01       	movw	r12, r22
 302:	7c 01       	movw	r14, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 304:	d5 01       	movw	r26, r10
 306:	12 96       	adiw	r26, 0x02	; 2
 308:	8c 91       	ld	r24, X
 30a:	00 e0       	ldi	r16, 0x00	; 0
 30c:	10 e0       	ldi	r17, 0x00	; 0
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 30e:	90 e0       	ldi	r25, 0x00	; 0
 310:	4c 01       	movw	r8, r24
 312:	b1 e0       	ldi	r27, 0x01	; 1
 314:	8b 1a       	sub	r8, r27
 316:	91 08       	sbc	r9, r1
 318:	3c 01       	movw	r6, r24
 31a:	e1 e0       	ldi	r30, 0x01	; 1
 31c:	6e 1a       	sub	r6, r30
 31e:	e0 e8       	ldi	r30, 0x80	; 128
 320:	7e 0a       	sbc	r7, r30


		if(initPWM(motor->pwm1,deciHertz)){
			if(initPWM(motor->pwm2, deciHertz)){
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 322:	50 e0       	ldi	r21, 0x00	; 0
 324:	45 2e       	mov	r4, r21
 326:	50 e0       	ldi	r21, 0x00	; 0
 328:	55 2e       	mov	r5, r21
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 32a:	00 c0       	rjmp	.+0      	; 0x32c <toshibaTB6612FNG_2pin_Init+0x5a>
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 32c:	93 01       	movw	r18, r6
 32e:	20 1b       	sub	r18, r16
 330:	31 0b       	sbc	r19, r17
 332:	22 0f       	add	r18, r18
 334:	33 1f       	adc	r19, r19
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)pgm_read_word(&driver->motors[i]);
 336:	d5 01       	movw	r26, r10
 338:	ed 91       	ld	r30, X+
 33a:	fc 91       	ld	r31, X
 33c:	e2 0f       	add	r30, r18
 33e:	f3 1f       	adc	r31, r19
 340:	85 91       	lpm	r24, Z+
 342:	94 91       	lpm	r25, Z
 344:	c8 2f       	mov	r28, r24
 346:	d9 2f       	mov	r29, r25


		if(initPWM(motor->pwm1,deciHertz)){
 348:	b7 01       	movw	r22, r14
 34a:	a6 01       	movw	r20, r12
 34c:	8c 81       	ldd	r24, Y+4	; 0x04
 34e:	9d 81       	ldd	r25, Y+5	; 0x05
 350:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 354:	88 23       	and	r24, r24
 356:	01 f0       	breq	.+0      	; 0x358 <toshibaTB6612FNG_2pin_Init+0x86>
			if(initPWM(motor->pwm2, deciHertz)){
 358:	b7 01       	movw	r22, r14
 35a:	a6 01       	movw	r20, r12
 35c:	8e 81       	ldd	r24, Y+6	; 0x06
 35e:	9f 81       	ldd	r25, Y+7	; 0x07
 360:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 364:	88 23       	and	r24, r24
 366:	01 f0       	breq	.+0      	; 0x368 <toshibaTB6612FNG_2pin_Init+0x96>
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 368:	59 82       	std	Y+1, r5	; 0x01
 36a:	48 82       	st	Y, r4
			}
		}

		// Start off braking
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 36c:	60 e0       	ldi	r22, 0x00	; 0
 36e:	ce 01       	movw	r24, r28
 370:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
 374:	6f ef       	ldi	r22, 0xFF	; 255
 376:	ce 01       	movw	r24, r28
 378:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 37c:	0f 5f       	subi	r16, 0xFF	; 255
 37e:	1f 4f       	sbci	r17, 0xFF	; 255
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 380:	c4 01       	movw	r24, r8
 382:	80 1b       	sub	r24, r16
 384:	91 0b       	sbc	r25, r17
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 386:	01 96       	adiw	r24, 0x01	; 1
 388:	01 f4       	brne	.+0      	; 0x38a <toshibaTB6612FNG_2pin_Init+0xb8>
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
	}
}
 38a:	df 91       	pop	r29
 38c:	cf 91       	pop	r28
 38e:	1f 91       	pop	r17
 390:	0f 91       	pop	r16
 392:	ff 90       	pop	r15
 394:	ef 90       	pop	r14
 396:	df 90       	pop	r13
 398:	cf 90       	pop	r12
 39a:	bf 90       	pop	r11
 39c:	af 90       	pop	r10
 39e:	9f 90       	pop	r9
 3a0:	8f 90       	pop	r8
 3a2:	7f 90       	pop	r7
 3a4:	6f 90       	pop	r6
 3a6:	5f 90       	pop	r5
 3a8:	4f 90       	pop	r4
 3aa:	08 95       	ret

TB6612FNG_3pin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000328  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000035c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000035c  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  0000035c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000e16  00000000  00000000  00000360  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000311  00000000  00000000  00001176  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000749  00000000  00000000  00001487  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001bd0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000040  00000000  00000000  00001bf0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000190  00000000  00000000  00001c30  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000007f5  00000000  00000000  00001dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000025b5  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000e4  00000000  00000000  000025e0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	d6 2e       	mov	r13, r22
	TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  12:	8c 81       	ldd	r24, Y+4	; 0x04
  14:	9d 81       	ldd	r25, Y+5	; 0x05
  16:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  1a:	7c 01       	movw	r14, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  1c:	fc 01       	movw	r30, r24
  1e:	32 96       	adiw	r30, 0x02	; 2
  20:	84 91       	lpm	r24, Z
	const Timer* timer = compareGetTimer(channel);
  22:	2c e2       	ldi	r18, 0x2C	; 44
  24:	82 9f       	mul	r24, r18
  26:	c0 01       	movw	r24, r0
  28:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  2a:	80 50       	subi	r24, 0x00	; 0
  2c:	90 40       	sbci	r25, 0x00	; 0
  2e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  32:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  34:	1d 14       	cp	r1, r13
  36:	04 f4       	brge	.+0      	; 0x38 <setSpeed+0x38>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	4f e7       	ldi	r20, 0x7F	; 127
  3e:	50 e0       	ldi	r21, 0x00	; 0
  40:	60 e0       	ldi	r22, 0x00	; 0
  42:	70 e0       	ldi	r23, 0x00	; 0
  44:	8d 2d       	mov	r24, r13
  46:	99 27       	eor	r25, r25
  48:	87 fd       	sbrc	r24, 7
  4a:	90 95       	com	r25
  4c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  50:	8c 01       	movw	r16, r24
		// Set pins high and low
		pin_high(motor->enable1);
  52:	8e 81       	ldd	r24, Y+6	; 0x06
  54:	9f 81       	ldd	r25, Y+7	; 0x07
  56:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable2);
  5a:	88 85       	ldd	r24, Y+8	; 0x08
  5c:	99 85       	ldd	r25, Y+9	; 0x09
  5e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  62:	00 c0       	rjmp	.+0      	; 0x64 <setSpeed+0x64>
	}else if(speed < 0){
  64:	dd 20       	and	r13, r13
  66:	01 f0       	breq	.+0      	; 0x68 <setSpeed+0x68>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  68:	20 e0       	ldi	r18, 0x00	; 0
  6a:	30 e0       	ldi	r19, 0x00	; 0
  6c:	41 e8       	ldi	r20, 0x81	; 129
  6e:	5f ef       	ldi	r21, 0xFF	; 255
  70:	60 e0       	ldi	r22, 0x00	; 0
  72:	70 e0       	ldi	r23, 0x00	; 0
  74:	8d 2d       	mov	r24, r13
  76:	99 27       	eor	r25, r25
  78:	87 fd       	sbrc	r24, 7
  7a:	90 95       	com	r25
  7c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  80:	8c 01       	movw	r16, r24
		// Set pins low and high
		pin_low(motor->enable1);
  82:	8e 81       	ldd	r24, Y+6	; 0x06
  84:	9f 81       	ldd	r25, Y+7	; 0x07
  86:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->enable2);
  8a:	88 85       	ldd	r24, Y+8	; 0x08
  8c:	99 85       	ldd	r25, Y+9	; 0x09
  8e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  92:	00 c0       	rjmp	.+0      	; 0x94 <setSpeed+0x94>
	}else{
		// brake
		// Set both pins high, and the PWM to anything
		delay = 0;
		pin_high(motor->enable1);
  94:	8e 81       	ldd	r24, Y+6	; 0x06
  96:	9f 81       	ldd	r25, Y+7	; 0x07
  98:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->enable2);
  9c:	88 85       	ldd	r24, Y+8	; 0x08
  9e:	99 85       	ldd	r25, Y+9	; 0x09
  a0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable1);
		pin_high(motor->enable2);
	}else{
		// brake
		// Set both pins high, and the PWM to anything
		delay = 0;
  a4:	00 e0       	ldi	r16, 0x00	; 0
  a6:	10 e0       	ldi	r17, 0x00	; 0
		pin_high(motor->enable1);
		pin_high(motor->enable2);
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  a8:	b8 01       	movw	r22, r16
  aa:	c7 01       	movw	r24, r14
}
  ac:	df 91       	pop	r29
  ae:	cf 91       	pop	r28
  b0:	1f 91       	pop	r17
  b2:	0f 91       	pop	r16
  b4:	ff 90       	pop	r15
  b6:	ef 90       	pop	r14
  b8:	df 90       	pop	r13
		pin_high(motor->enable1);
		pin_high(motor->enable2);
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  ba:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

000000be <setConnected>:
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
  be:	0f 93       	push	r16
  c0:	1f 93       	push	r17
  c2:	cf 93       	push	r28
  c4:	df 93       	push	r29
  c6:	1f 92       	push	r1
  c8:	cd b7       	in	r28, 0x3d	; 61
  ca:	de b7       	in	r29, 0x3e	; 62
  cc:	8c 01       	movw	r16, r24
	TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  ce:	fc 01       	movw	r30, r24
  d0:	84 81       	ldd	r24, Z+4	; 0x04
  d2:	95 81       	ldd	r25, Z+5	; 0x05
  d4:	69 83       	std	Y+1, r22	; 0x01
  d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

	if(connected){
  da:	69 81       	ldd	r22, Y+1	; 0x01
  dc:	66 23       	and	r22, r22
  de:	01 f0       	breq	.+0      	; 0xe0 <setConnected+0x22>
		// connect
		// turn PWM back on
		compareSetOutputMode(channel, CHANNEL_MODE_NON_INVERTING);
  e0:	62 e0       	ldi	r22, 0x02	; 2
  e2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
  e6:	f8 01       	movw	r30, r16
  e8:	62 81       	ldd	r22, Z+2	; 0x02
  ea:	c8 01       	movw	r24, r16
		// Set both input pins low
		pin_low(motor->enable1);
		pin_low(motor->enable2);
	}

}
  ec:	0f 90       	pop	r0
  ee:	df 91       	pop	r29
  f0:	cf 91       	pop	r28
  f2:	1f 91       	pop	r17
  f4:	0f 91       	pop	r16
	if(connected){
		// connect
		// turn PWM back on
		compareSetOutputMode(channel, CHANNEL_MODE_NON_INVERTING);
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
  f6:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
	}else{
		// coast Set PWM output always high
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
  fa:	60 e0       	ldi	r22, 0x00	; 0
  fc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->pwm);
 100:	f8 01       	movw	r30, r16
 102:	84 81       	ldd	r24, Z+4	; 0x04
 104:	95 81       	ldd	r25, Z+5	; 0x05
 106:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Set both input pins low
		pin_low(motor->enable1);
 10a:	f8 01       	movw	r30, r16
 10c:	86 81       	ldd	r24, Z+6	; 0x06
 10e:	97 81       	ldd	r25, Z+7	; 0x07
 110:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable2);
 114:	f8 01       	movw	r30, r16
 116:	80 85       	ldd	r24, Z+8	; 0x08
 118:	91 85       	ldd	r25, Z+9	; 0x09
	}

}
 11a:	0f 90       	pop	r0
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
		pin_high(motor->pwm);

		// Set both input pins low
		pin_low(motor->enable1);
		pin_low(motor->enable2);
 124:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

00000128 <toshibaTB6612FNG_3pin_Init>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 128:	2f 92       	push	r2
 12a:	3f 92       	push	r3
 12c:	4f 92       	push	r4
 12e:	5f 92       	push	r5
 130:	6f 92       	push	r6
 132:	7f 92       	push	r7
 134:	8f 92       	push	r8
 136:	9f 92       	push	r9
 138:	af 92       	push	r10
 13a:	bf 92       	push	r11
 13c:	cf 92       	push	r12
 13e:	df 92       	push	r13
 140:	ef 92       	push	r14
 142:	ff 92       	push	r15
 144:	0f 93       	push	r16
 146:	1f 93       	push	r17
 148:	cf 93       	push	r28
 14a:	df 93       	push	r29
 14c:	cd b7       	in	r28, 0x3d	; 61
 14e:	de b7       	in	r29, 0x3e	; 62
 150:	2d 97       	sbiw	r28, 0x0d	; 13
 152:	0f b6       	in	r0, 0x3f	; 63
 154:	f8 94       	cli
 156:	de bf       	out	0x3e, r29	; 62
 158:	0f be       	out	0x3f, r0	; 63
 15a:	cd bf       	out	0x3d, r28	; 61
 15c:	4c 01       	movw	r8, r24
	uint32_t deciHertz = 10 * freq;
 15e:	aa e0       	ldi	r26, 0x0A	; 10
 160:	b0 e0       	ldi	r27, 0x00	; 0
 162:	9a 01       	movw	r18, r20
 164:	ab 01       	movw	r20, r22
 166:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 16a:	6e 83       	std	Y+6, r22	; 0x06
 16c:	7f 83       	std	Y+7, r23	; 0x07
 16e:	88 87       	std	Y+8, r24	; 0x08
 170:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 172:	d4 01       	movw	r26, r8
 174:	12 96       	adiw	r26, 0x02	; 2
 176:	8c 91       	ld	r24, X
 178:	a1 2c       	mov	r10, r1
 17a:	b1 2c       	mov	r11, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	fc 01       	movw	r30, r24
 180:	31 97       	sbiw	r30, 0x01	; 1
 182:	fb 87       	std	Y+11, r31	; 0x0b
 184:	ea 87       	std	Y+10, r30	; 0x0a
 186:	9c 01       	movw	r18, r24
 188:	21 50       	subi	r18, 0x01	; 1
 18a:	30 48       	sbci	r19, 0x80	; 128
 18c:	3d 87       	std	Y+13, r19	; 0x0d
 18e:	2c 87       	std	Y+12, r18	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 190:	00 c0       	rjmp	.+0      	; 0x192 <toshibaTB6612FNG_3pin_Init+0x6a>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 192:	2c 85       	ldd	r18, Y+12	; 0x0c
 194:	3d 85       	ldd	r19, Y+13	; 0x0d
 196:	2a 19       	sub	r18, r10
 198:	3b 09       	sbc	r19, r11
 19a:	22 0f       	add	r18, r18
 19c:	33 1f       	adc	r19, r19
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)pgm_read_word(&driver->motors[i]);
 19e:	d4 01       	movw	r26, r8
 1a0:	ed 91       	ld	r30, X+
 1a2:	fc 91       	ld	r31, X
 1a4:	e2 0f       	add	r30, r18
 1a6:	f3 1f       	adc	r31, r19
 1a8:	85 91       	lpm	r24, Z+
 1aa:	94 91       	lpm	r25, Z
 1ac:	3c 01       	movw	r6, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 1ae:	fc 01       	movw	r30, r24
 1b0:	84 81       	ldd	r24, Z+4	; 0x04
 1b2:	95 81       	ldd	r25, Z+5	; 0x05
 1b4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1b8:	1c 01       	movw	r2, r24
		if(channel==null){
 1ba:	00 97       	sbiw	r24, 0x00	; 0
 1bc:	01 f4       	brne	.+0      	; 0x1be <toshibaTB6612FNG_3pin_Init+0x96>
			setError(PWM_PIN_NOT_AVAILABLE);
 1be:	84 ef       	ldi	r24, 0xF4	; 244
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <toshibaTB6612FNG_3pin_Init+0x9a>
			continue;
		}
		if(compareIsInUse(channel)){
 1c2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1c6:	88 23       	and	r24, r24
 1c8:	01 f0       	breq	.+0      	; 0x1ca <toshibaTB6612FNG_3pin_Init+0xa2>
			setError(PWM_PIN_IN_USE);
 1ca:	83 ef       	ldi	r24, 0xF3	; 243
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <toshibaTB6612FNG_3pin_Init+0xa6>
 1ce:	f1 01       	movw	r30, r2
 1d0:	32 96       	adiw	r30, 0x02	; 2
 1d2:	44 90       	lpm	r4, Z

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 1d4:	fc e2       	ldi	r31, 0x2C	; 44
 1d6:	f4 9d       	mul	r31, r4
 1d8:	20 01       	movw	r4, r0
 1da:	11 24       	eor	r1, r1
 1dc:	20 e0       	ldi	r18, 0x00	; 0
 1de:	30 e0       	ldi	r19, 0x00	; 0
 1e0:	42 0e       	add	r4, r18
 1e2:	53 1e       	adc	r5, r19

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1e4:	cc 24       	eor	r12, r12
 1e6:	c3 94       	inc	r12
 1e8:	d1 2c       	mov	r13, r1
 1ea:	cc 0e       	add	r12, r28
 1ec:	dd 1e       	adc	r13, r29
 1ee:	93 e0       	ldi	r25, 0x03	; 3
 1f0:	e9 2e       	mov	r14, r25
 1f2:	f1 2c       	mov	r15, r1
 1f4:	ec 0e       	add	r14, r28
 1f6:	fd 1e       	adc	r15, r29
 1f8:	8e 01       	movw	r16, r28
 1fa:	0b 5f       	subi	r16, 0xFB	; 251
 1fc:	1f 4f       	sbci	r17, 0xFF	; 255
 1fe:	20 e8       	ldi	r18, 0x80	; 128
 200:	30 e0       	ldi	r19, 0x00	; 0
 202:	4e 81       	ldd	r20, Y+6	; 0x06
 204:	5f 81       	ldd	r21, Y+7	; 0x07
 206:	68 85       	ldd	r22, Y+8	; 0x08
 208:	79 85       	ldd	r23, Y+9	; 0x09
 20a:	c2 01       	movw	r24, r4
 20c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 210:	f2 01       	movw	r30, r4
 212:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 214:	81 11       	cpse	r24, r1
 216:	00 c0       	rjmp	.+0      	; 0x218 <toshibaTB6612FNG_3pin_Init+0xf0>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 218:	85 91       	lpm	r24, Z+
 21a:	94 91       	lpm	r25, Z
 21c:	fc 01       	movw	r30, r24
 21e:	80 81       	ld	r24, Z
 220:	87 70       	andi	r24, 0x07	; 7
 222:	01 f4       	brne	.+0      	; 0x224 <toshibaTB6612FNG_3pin_Init+0xfc>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 224:	83 ee       	ldi	r24, 0xE3	; 227
 226:	00 c0       	rjmp	.+0      	; 0x228 <toshibaTB6612FNG_3pin_Init+0x100>
 228:	82 ef       	ldi	r24, 0xF2	; 242
 22a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 22e:	00 c0       	rjmp	.+0      	; 0x230 <toshibaTB6612FNG_3pin_Init+0x108>
 230:	85 91       	lpm	r24, Z+
 232:	94 91       	lpm	r25, Z
 234:	fc 01       	movw	r30, r24
 236:	80 81       	ld	r24, Z
 238:	87 70       	andi	r24, 0x07	; 7
 23a:	01 f4       	brne	.+0      	; 0x23c <toshibaTB6612FNG_3pin_Init+0x114>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <toshibaTB6612FNG_3pin_Init+0x116>
 23e:	00 c0       	rjmp	.+0      	; 0x240 <toshibaTB6612FNG_3pin_Init+0x118>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 240:	f2 01       	movw	r30, r4
 242:	7f 96       	adiw	r30, 0x1f	; 31
 244:	85 91       	lpm	r24, Z+
 246:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 248:	fc 01       	movw	r30, r24
 24a:	8b 81       	ldd	r24, Y+3	; 0x03
 24c:	9c 81       	ldd	r25, Y+4	; 0x04
 24e:	91 83       	std	Z+1, r25	; 0x01
 250:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 252:	e0 e0       	ldi	r30, 0x00	; 0
 254:	f0 e0       	ldi	r31, 0x00	; 0
 256:	d3 01       	movw	r26, r6
 258:	ed 93       	st	X+, r30
 25a:	fc 93       	st	X, r31

			// Use non-inverting PWM
			compareSetOutputMode(channel,CHANNEL_MODE_NON_INVERTING);
 25c:	62 e0       	ldi	r22, 0x02	; 2
 25e:	c1 01       	movw	r24, r2
 260:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Make sure the pwm pin is an output pin
			pin_make_output(motor->pwm, FALSE);
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	d3 01       	movw	r26, r6
 268:	14 96       	adiw	r26, 0x04	; 4
 26a:	8d 91       	ld	r24, X+
 26c:	9c 91       	ld	r25, X
 26e:	15 97       	sbiw	r26, 0x05	; 5
 270:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Make sure the direction pin are set as an output pin and select 'brake'
			pin_make_output(motor->enable1, TRUE);
 274:	6f ef       	ldi	r22, 0xFF	; 255
 276:	f3 01       	movw	r30, r6
 278:	86 81       	ldd	r24, Z+6	; 0x06
 27a:	97 81       	ldd	r25, Z+7	; 0x07
 27c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			pin_make_output(motor->enable2, TRUE);
 280:	6f ef       	ldi	r22, 0xFF	; 255
 282:	d3 01       	movw	r26, r6
 284:	18 96       	adiw	r26, 0x08	; 8
 286:	8d 91       	ld	r24, X+
 288:	9c 91       	ld	r25, X
 28a:	19 97       	sbiw	r26, 0x09	; 9
 28c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 290:	20 e0       	ldi	r18, 0x00	; 0
 292:	30 e0       	ldi	r19, 0x00	; 0
 294:	40 e0       	ldi	r20, 0x00	; 0
 296:	50 e0       	ldi	r21, 0x00	; 0
 298:	60 e0       	ldi	r22, 0x00	; 0
 29a:	70 e0       	ldi	r23, 0x00	; 0
 29c:	c1 01       	movw	r24, r2
 29e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 2a2:	69 81       	ldd	r22, Y+1	; 0x01
 2a4:	7a 81       	ldd	r23, Y+2	; 0x02
 2a6:	c2 01       	movw	r24, r4
 2a8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 2ac:	60 e0       	ldi	r22, 0x00	; 0
 2ae:	c3 01       	movw	r24, r6
 2b0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 2b4:	6f ef       	ldi	r22, 0xFF	; 255
 2b6:	c3 01       	movw	r24, r6
 2b8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2bc:	bf ef       	ldi	r27, 0xFF	; 255
 2be:	ab 1a       	sub	r10, r27
 2c0:	bb 0a       	sbc	r11, r27
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 2c2:	8a 85       	ldd	r24, Y+10	; 0x0a
 2c4:	9b 85       	ldd	r25, Y+11	; 0x0b
 2c6:	8a 19       	sub	r24, r10
 2c8:	9b 09       	sbc	r25, r11
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 2ca:	01 96       	adiw	r24, 0x01	; 1
 2cc:	01 f0       	breq	.+0      	; 0x2ce <toshibaTB6612FNG_3pin_Init+0x1a6>
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <toshibaTB6612FNG_3pin_Init+0x1a8>
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <toshibaTB6612FNG_3pin_Init+0x1aa>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 2d2:	6d 81       	ldd	r22, Y+5	; 0x05
 2d4:	c2 01       	movw	r24, r4
 2d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				if(modeIsICR(mode)){
 2da:	21 e0       	ldi	r18, 0x01	; 1
 2dc:	30 e0       	ldi	r19, 0x00	; 0
 2de:	0d 80       	ldd	r0, Y+5	; 0x05
 2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <toshibaTB6612FNG_3pin_Init+0x1ba>
 2e2:	22 0f       	add	r18, r18
 2e4:	33 1f       	adc	r19, r19
 2e6:	0a 94       	dec	r0
 2e8:	02 f4       	brpl	.+0      	; 0x2ea <toshibaTB6612FNG_3pin_Init+0x1c2>
 2ea:	22 27       	eor	r18, r18
 2ec:	35 75       	andi	r19, 0x55	; 85
 2ee:	23 2b       	or	r18, r19
 2f0:	01 f0       	breq	.+0      	; 0x2f2 <toshibaTB6612FNG_3pin_Init+0x1ca>
 2f2:	00 c0       	rjmp	.+0      	; 0x2f4 <toshibaTB6612FNG_3pin_Init+0x1cc>
 2f4:	00 c0       	rjmp	.+0      	; 0x2f6 <toshibaTB6612FNG_3pin_Init+0x1ce>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 2f6:	2d 96       	adiw	r28, 0x0d	; 13
 2f8:	0f b6       	in	r0, 0x3f	; 63
 2fa:	f8 94       	cli
 2fc:	de bf       	out	0x3e, r29	; 62
 2fe:	0f be       	out	0x3f, r0	; 63
 300:	cd bf       	out	0x3d, r28	; 61
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	1f 91       	pop	r17
 308:	0f 91       	pop	r16
 30a:	ff 90       	pop	r15
 30c:	ef 90       	pop	r14
 30e:	df 90       	pop	r13
 310:	cf 90       	pop	r12
 312:	bf 90       	pop	r11
 314:	af 90       	pop	r10
 316:	9f 90       	pop	r9
 318:	8f 90       	pop	r8
 31a:	7f 90       	pop	r7
 31c:	6f 90       	pop	r6
 31e:	5f 90       	pop	r5
 320:	4f 90       	pop	r4
 322:	3f 90       	pop	r3
 324:	2f 90       	pop	r2
 326:	08 95       	ret

SD21.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000150  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000184  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000184  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000184  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000b3f  00000000  00000000  00000188  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000255  00000000  00000000  00000cc7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000307  00000000  00000000  00000f1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001223  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00001243  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000016e  00000000  00000000  0000125b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000054e  00000000  00000000  000013c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00001917  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000a8  00000000  00000000  00001944  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
 */
#include "SD21.h"
#include "../../core.h"
//#include "../../rprintf.h"

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	00 d0       	rcall	.+0      	; 0x12 <setSpeed+0x12>
  12:	1f 92       	push	r1
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	fc 01       	movw	r30, r24
  1a:	86 2f       	mov	r24, r22
	SERVO* servo = (SERVO*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
  1c:	92 81       	ldd	r25, Z+2	; 0x02
	if(servo->actuator.inverted){
  1e:	23 81       	ldd	r18, Z+3	; 0x03
  20:	21 fd       	sbrc	r18, 1
		current *= -1;
  22:	91 95       	neg	r25
	}


	// Can only cope with 21 servos
	if(speed != current && servo->delay< 21){
  24:	89 17       	cp	r24, r25
  26:	01 f0       	breq	.+0      	; 0x28 <setSpeed+0x28>
  28:	c0 88       	ldd	r12, Z+16	; 0x10
  2a:	d1 88       	ldd	r13, Z+17	; 0x11
  2c:	95 e1       	ldi	r25, 0x15	; 21
  2e:	c9 16       	cp	r12, r25
  30:	d1 04       	cpc	r13, r1
  32:	00 f4       	brcc	.+0      	; 0x34 <setSpeed+0x34>
		uint8_t reg = (servo->delay * 3) + 1;
		uint8_t msg[3];

		struct s_servo_driver* driver = servo->driver;
		const I2C_DEVICE* i2c = &(driver->i2cInfo);
  34:	e4 80       	ldd	r14, Z+4	; 0x04
  36:	f5 80       	ldd	r15, Z+5	; 0x05
  38:	94 e0       	ldi	r25, 0x04	; 4
  3a:	e9 0e       	add	r14, r25
  3c:	f1 1c       	adc	r15, r1

		// Get the pulse length in us
		uint16_t pulse = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->center_us - servo->range_us , servo->center_us + servo->range_us);
  3e:	20 85       	ldd	r18, Z+8	; 0x08
  40:	31 85       	ldd	r19, Z+9	; 0x09
  42:	42 85       	ldd	r20, Z+10	; 0x0a
  44:	53 85       	ldd	r21, Z+11	; 0x0b
  46:	8a 01       	movw	r16, r20
  48:	02 0f       	add	r16, r18
  4a:	13 1f       	adc	r17, r19
  4c:	24 1b       	sub	r18, r20
  4e:	35 0b       	sbc	r19, r21
  50:	4f e7       	ldi	r20, 0x7F	; 127
  52:	50 e0       	ldi	r21, 0x00	; 0
  54:	61 e8       	ldi	r22, 0x81	; 129
  56:	7f ef       	ldi	r23, 0xFF	; 255
  58:	99 27       	eor	r25, r25
  5a:	87 fd       	sbrc	r24, 7
  5c:	90 95       	com	r25
  5e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}


	// Can only cope with 21 servos
	if(speed != current && servo->delay< 21){
		uint8_t reg = (servo->delay * 3) + 1;
  62:	2c 2d       	mov	r18, r12
  64:	22 0f       	add	r18, r18
  66:	2c 0d       	add	r18, r12
  68:	2f 5f       	subi	r18, 0xFF	; 255
		const I2C_DEVICE* i2c = &(driver->i2cInfo);

		// Get the pulse length in us
		uint16_t pulse = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->center_us - servo->range_us , servo->center_us + servo->range_us);

		msg[0] = reg;						// Register
  6a:	29 83       	std	Y+1, r18	; 0x01
		msg[1] = (uint8_t)(pulse & 0xff); 	// lo
  6c:	8a 83       	std	Y+2, r24	; 0x02
		msg[2] = (uint8_t)(pulse >> 8); 	// hi
  6e:	9b 83       	std	Y+3, r25	; 0x03

		// The I2C address is always C2
		i2cMasterSend(i2c, sizeof(msg), msg);
  70:	ae 01       	movw	r20, r28
  72:	4f 5f       	subi	r20, 0xFF	; 255
  74:	5f 4f       	sbci	r21, 0xFF	; 255
  76:	63 e0       	ldi	r22, 0x03	; 3
  78:	70 e0       	ldi	r23, 0x00	; 0
  7a:	c7 01       	movw	r24, r14
  7c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
//		rprintf("%u = %u\n",servo->delay,pulse);
	}
}
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	df 91       	pop	r29
  88:	cf 91       	pop	r28
  8a:	1f 91       	pop	r17
  8c:	0f 91       	pop	r16
  8e:	ff 90       	pop	r15
  90:	ef 90       	pop	r14
  92:	df 90       	pop	r13
  94:	cf 90       	pop	r12
  96:	08 95       	ret

00000098 <sd21Init>:


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  98:	7f 92       	push	r7
  9a:	8f 92       	push	r8
  9c:	9f 92       	push	r9
  9e:	af 92       	push	r10
  a0:	bf 92       	push	r11
  a2:	cf 92       	push	r12
  a4:	df 92       	push	r13
  a6:	ef 92       	push	r14
  a8:	ff 92       	push	r15
  aa:	0f 93       	push	r16
  ac:	1f 93       	push	r17
  ae:	cf 93       	push	r28
  b0:	df 93       	push	r29
  b2:	6c 01       	movw	r12, r24
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
  b4:	dc 01       	movw	r26, r24
  b6:	12 96       	adiw	r26, 0x02	; 2
  b8:	7c 90       	ld	r7, X
  ba:	7a 94       	dec	r7
  bc:	e1 2c       	mov	r14, r1
  be:	f1 2c       	mov	r15, r1


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  c0:	a7 2c       	mov	r10, r7
  c2:	bb 24       	eor	r11, r11
  c4:	a7 fc       	sbrc	r10, 7
  c6:	b0 94       	com	r11
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		if(servo){
			// Connect the servo to this driver
			servo->actuator.class = &c_sd21_servos;
  c8:	50 e0       	ldi	r21, 0x00	; 0
  ca:	85 2e       	mov	r8, r21
  cc:	50 e0       	ldi	r21, 0x00	; 0
  ce:	95 2e       	mov	r9, r21
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <sd21Init+0x3a>


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  d2:	c5 01       	movw	r24, r10
  d4:	8e 19       	sub	r24, r14
  d6:	9f 09       	sbc	r25, r15
  d8:	9c 01       	movw	r18, r24
  da:	22 0f       	add	r18, r18
  dc:	33 1f       	adc	r19, r19
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  de:	d6 01       	movw	r26, r12
  e0:	ed 91       	ld	r30, X+
  e2:	fc 91       	ld	r31, X
  e4:	e2 0f       	add	r30, r18
  e6:	f3 1f       	adc	r31, r19
  e8:	05 91       	lpm	r16, Z+
  ea:	14 91       	lpm	r17, Z
  ec:	c0 2f       	mov	r28, r16
  ee:	d1 2f       	mov	r29, r17
		if(servo){
  f0:	20 97       	sbiw	r28, 0x00	; 0
  f2:	01 f0       	breq	.+0      	; 0xf4 <sd21Init+0x5c>
			// Connect the servo to this driver
			servo->actuator.class = &c_sd21_servos;
  f4:	99 82       	std	Y+1, r9	; 0x01
  f6:	88 82       	st	Y, r8
			servo->driver = driver;
  f8:	dd 82       	std	Y+5, r13	; 0x05
  fa:	cc 82       	std	Y+4, r12	; 0x04
			servo->top = 0;
  fc:	1b 8a       	std	Y+19, r1	; 0x13
  fe:	1a 8a       	std	Y+18, r1	; 0x12
			servo->delay = i; // The servo number in the list
 100:	99 8b       	std	Y+17, r25	; 0x11
 102:	88 8b       	std	Y+16, r24	; 0x10
			servoSetConfig(servo,servo->center_us,servo->range_us);
 104:	4a 85       	ldd	r20, Y+10	; 0x0a
 106:	5b 85       	ldd	r21, Y+11	; 0x0b
 108:	68 85       	ldd	r22, Y+8	; 0x08
 10a:	79 85       	ldd	r23, Y+9	; 0x09
 10c:	ce 01       	movw	r24, r28
 10e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 112:	6f ef       	ldi	r22, 0xFF	; 255
 114:	80 2f       	mov	r24, r16
 116:	91 2f       	mov	r25, r17
 118:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 11c:	60 e0       	ldi	r22, 0x00	; 0
 11e:	80 2f       	mov	r24, r16
 120:	91 2f       	mov	r25, r17
 122:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 126:	ff ef       	ldi	r31, 0xFF	; 255
 128:	ef 1a       	sub	r14, r31
 12a:	ff 0a       	sbc	r15, r31


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
 12c:	87 2d       	mov	r24, r7
 12e:	8e 19       	sub	r24, r14
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 130:	87 ff       	sbrs	r24, 7
 132:	00 c0       	rjmp	.+0      	; 0x134 <sd21Init+0x9c>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}
	}
}
 134:	df 91       	pop	r29
 136:	cf 91       	pop	r28
 138:	1f 91       	pop	r17
 13a:	0f 91       	pop	r16
 13c:	ff 90       	pop	r15
 13e:	ef 90       	pop	r14
 140:	df 90       	pop	r13
 142:	cf 90       	pop	r12
 144:	bf 90       	pop	r11
 146:	af 90       	pop	r10
 148:	9f 90       	pop	r9
 14a:	8f 90       	pop	r8
 14c:	7f 90       	pop	r7
 14e:	08 95       	ret

AX12.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000038c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003c0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003c0  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003c0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000ee8  00000000  00000000  000003c4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000342  00000000  00000000  000012ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000009a1  00000000  00000000  000015ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001f8f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000050  00000000  00000000  00001faf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001d7  00000000  00000000  00001fff  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000575  00000000  00000000  000021d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  0000274b  2**0
                  CONTENTS, READONLY
 12 .debug_frame  0000017c  00000000  00000000  00002778  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <xmitBlock>:
	}
}

// Callback to change the hardware to xmit or receive
// Called with interrupts disabled
static void xmitBlock(void* param, boolean xmit){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	DYNAMIXEL_AX12_DRIVER* driver = (DYNAMIXEL_AX12_DRIVER*)param;

	if(!xmit){
   a:	61 11       	cpse	r22, r1
   c:	00 c0       	rjmp	.+0      	; 0xe <xmitBlock+0xe>
		// We are entering recv mode - turn off receive hardware interrupts
		// as they are just too slow for 1,000,000 baud. We will receive the
		// characters by polling the uart hardware directly instead
		uartReceivePollingMode(driver->ax12uart,TRUE);
   e:	6f ef       	ldi	r22, 0xFF	; 255
  10:	8b 81       	ldd	r24, Y+3	; 0x03
  12:	9c 81       	ldd	r25, Y+4	; 0x04
  14:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}

	// Change the hardware state
	pin_set(driver->directionPin, xmit);
  18:	61 2f       	mov	r22, r17
  1a:	8d 81       	ldd	r24, Y+5	; 0x05
  1c:	9e 81       	ldd	r25, Y+6	; 0x06
}
  1e:	df 91       	pop	r29
  20:	cf 91       	pop	r28
  22:	1f 91       	pop	r17
		// characters by polling the uart hardware directly instead
		uartReceivePollingMode(driver->ax12uart,TRUE);
	}

	// Change the hardware state
	pin_set(driver->directionPin, xmit);
  24:	0c 94 00 00 	jmp	0	; 0x0 <xmitBlock>

00000028 <ax12Send>:

const static __ACTUATOR_DRIVER_CLASS c_ax12;



void ax12Send(const DYNAMIXEL_AX12_DRIVER* driver, uint8_t id, size_t len, uint8_t* data){
  28:	af 92       	push	r10
  2a:	bf 92       	push	r11
  2c:	df 92       	push	r13
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	0f 93       	push	r16
  34:	1f 93       	push	r17
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	00 d0       	rcall	.+0      	; 0x3c <ax12Send+0x14>
  3c:	cd b7       	in	r28, 0x3d	; 61
  3e:	de b7       	in	r29, 0x3e	; 62
  40:	16 2f       	mov	r17, r22
  42:	7a 01       	movw	r14, r20
	HW_UART* uart = driver->ax12uart;
	uartSendByte(uart, 0xff);
  44:	fc 01       	movw	r30, r24
  46:	a3 80       	ldd	r10, Z+3	; 0x03
  48:	b4 80       	ldd	r11, Z+4	; 0x04
  4a:	6f ef       	ldi	r22, 0xFF	; 255
  4c:	c5 01       	movw	r24, r10
  4e:	29 83       	std	Y+1, r18	; 0x01
  50:	3a 83       	std	Y+2, r19	; 0x02
  52:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	uartSendByte(uart, 0xff);
  56:	6f ef       	ldi	r22, 0xFF	; 255
  58:	c5 01       	movw	r24, r10
  5a:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	uint8_t chksum = uartSendByte(uart, id);
  5e:	61 2f       	mov	r22, r17
  60:	c5 01       	movw	r24, r10
  62:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  66:	d8 2e       	mov	r13, r24
	chksum += uartSendByte(uart, len+1);
  68:	6e 2d       	mov	r22, r14
  6a:	6f 5f       	subi	r22, 0xFF	; 255
  6c:	c5 01       	movw	r24, r10
  6e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  72:	d8 0e       	add	r13, r24
  74:	29 81       	ldd	r18, Y+1	; 0x01
  76:	02 2f       	mov	r16, r18
  78:	3a 81       	ldd	r19, Y+2	; 0x02
  7a:	13 2f       	mov	r17, r19

const static __ACTUATOR_DRIVER_CLASS c_ax12;



void ax12Send(const DYNAMIXEL_AX12_DRIVER* driver, uint8_t id, size_t len, uint8_t* data){
  7c:	e0 0e       	add	r14, r16
  7e:	f1 1e       	adc	r15, r17
	uartSendByte(uart, 0xff);
	uartSendByte(uart, 0xff);
	uint8_t chksum = uartSendByte(uart, id);
	chksum += uartSendByte(uart, len+1);

	while(len--){
  80:	00 c0       	rjmp	.+0      	; 0x82 <ax12Send+0x5a>
		chksum += uartSendByte(uart, *data++);
  82:	f8 01       	movw	r30, r16
  84:	61 91       	ld	r22, Z+
  86:	8f 01       	movw	r16, r30
  88:	c5 01       	movw	r24, r10
  8a:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  8e:	d8 0e       	add	r13, r24
	uartSendByte(uart, 0xff);
	uartSendByte(uart, 0xff);
	uint8_t chksum = uartSendByte(uart, id);
	chksum += uartSendByte(uart, len+1);

	while(len--){
  90:	0e 15       	cp	r16, r14
  92:	1f 05       	cpc	r17, r15
  94:	01 f4       	brne	.+0      	; 0x96 <ax12Send+0x6e>
		chksum += uartSendByte(uart, *data++);
	}
	uartSendByte(uart, ~chksum);
  96:	6d 2d       	mov	r22, r13
  98:	60 95       	com	r22
  9a:	c5 01       	movw	r24, r10

}
  9c:	0f 90       	pop	r0
  9e:	0f 90       	pop	r0
  a0:	df 91       	pop	r29
  a2:	cf 91       	pop	r28
  a4:	1f 91       	pop	r17
  a6:	0f 91       	pop	r16
  a8:	ff 90       	pop	r15
  aa:	ef 90       	pop	r14
  ac:	df 90       	pop	r13
  ae:	bf 90       	pop	r11
  b0:	af 90       	pop	r10
	chksum += uartSendByte(uart, len+1);

	while(len--){
		chksum += uartSendByte(uart, *data++);
	}
	uartSendByte(uart, ~chksum);
  b2:	0c 94 00 00 	jmp	0	; 0x0 <xmitBlock>

000000b6 <ax12Write8>:

}

// Send a command expecting no response
void ax12Write8(const DYNAMIXEL_AX12* servo, uint8_t cmd, uint8_t data){
  b6:	cf 93       	push	r28
  b8:	df 93       	push	r29
  ba:	00 d0       	rcall	.+0      	; 0xbc <ax12Write8+0x6>
  bc:	1f 92       	push	r1
  be:	cd b7       	in	r28, 0x3d	; 61
  c0:	de b7       	in	r29, 0x3e	; 62
  c2:	fc 01       	movw	r30, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  c4:	83 81       	ldd	r24, Z+3	; 0x03
  c6:	80 ff       	sbrs	r24, 0
  c8:	00 c0       	rjmp	.+0      	; 0xca <ax12Write8+0x14>
	if(act_isConnected(servo)){
		uint8_t str[] = {servo->driver->writeCmd,cmd,data};
  ca:	84 81       	ldd	r24, Z+4	; 0x04
  cc:	95 81       	ldd	r25, Z+5	; 0x05
  ce:	dc 01       	movw	r26, r24
  d0:	17 96       	adiw	r26, 0x07	; 7
  d2:	2c 91       	ld	r18, X
  d4:	29 83       	std	Y+1, r18	; 0x01
  d6:	6a 83       	std	Y+2, r22	; 0x02
  d8:	4b 83       	std	Y+3, r20	; 0x03
		ax12Send(servo->driver, servo->id, sizeof(str), str);
  da:	9e 01       	movw	r18, r28
  dc:	2f 5f       	subi	r18, 0xFF	; 255
  de:	3f 4f       	sbci	r19, 0xFF	; 255
  e0:	43 e0       	ldi	r20, 0x03	; 3
  e2:	50 e0       	ldi	r21, 0x00	; 0
  e4:	66 81       	ldd	r22, Z+6	; 0x06
  e6:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}
}
  ea:	0f 90       	pop	r0
  ec:	0f 90       	pop	r0
  ee:	0f 90       	pop	r0
  f0:	df 91       	pop	r29
  f2:	cf 91       	pop	r28
  f4:	08 95       	ret

000000f6 <ax12Write16>:

// Send a command expecting no response
void ax12Write16(const DYNAMIXEL_AX12* servo, uint8_t cmd, uint16_t data){
  f6:	cf 93       	push	r28
  f8:	df 93       	push	r29
  fa:	00 d0       	rcall	.+0      	; 0xfc <ax12Write16+0x6>
  fc:	00 d0       	rcall	.+0      	; 0xfe <ax12Write16+0x8>
  fe:	cd b7       	in	r28, 0x3d	; 61
 100:	de b7       	in	r29, 0x3e	; 62
 102:	fc 01       	movw	r30, r24
 104:	83 81       	ldd	r24, Z+3	; 0x03
 106:	80 ff       	sbrs	r24, 0
 108:	00 c0       	rjmp	.+0      	; 0x10a <ax12Write16+0x14>
	if(act_isConnected(servo)){
		uint8_t str[] = {servo->driver->writeCmd,cmd,data & 0xff, (data>>8) & 0xff };
 10a:	84 81       	ldd	r24, Z+4	; 0x04
 10c:	95 81       	ldd	r25, Z+5	; 0x05
 10e:	dc 01       	movw	r26, r24
 110:	17 96       	adiw	r26, 0x07	; 7
 112:	2c 91       	ld	r18, X
 114:	29 83       	std	Y+1, r18	; 0x01
 116:	6a 83       	std	Y+2, r22	; 0x02
 118:	4b 83       	std	Y+3, r20	; 0x03
 11a:	5c 83       	std	Y+4, r21	; 0x04
		ax12Send(servo->driver, servo->id, sizeof(str), str);
 11c:	9e 01       	movw	r18, r28
 11e:	2f 5f       	subi	r18, 0xFF	; 255
 120:	3f 4f       	sbci	r19, 0xFF	; 255
 122:	44 e0       	ldi	r20, 0x04	; 4
 124:	50 e0       	ldi	r21, 0x00	; 0
 126:	66 81       	ldd	r22, Z+6	; 0x06
 128:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}
}
 12c:	0f 90       	pop	r0
 12e:	0f 90       	pop	r0
 130:	0f 90       	pop	r0
 132:	0f 90       	pop	r0
 134:	df 91       	pop	r29
 136:	cf 91       	pop	r28
 138:	08 95       	ret

0000013a <setSpeed>:
	}

}

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
 13a:	ff 92       	push	r15
 13c:	0f 93       	push	r16
 13e:	1f 93       	push	r17
 140:	cf 93       	push	r28
 142:	df 93       	push	r29
 144:	ec 01       	movw	r28, r24
 146:	f6 2e       	mov	r15, r22
	DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
 148:	8a 81       	ldd	r24, Y+2	; 0x02
	if(servo->actuator.inverted){
 14a:	9b 81       	ldd	r25, Y+3	; 0x03
 14c:	91 fd       	sbrc	r25, 1
		current *= -1;
 14e:	81 95       	neg	r24
	}


	// Ignore if it hasn't been changed
	if(speed != current){
 150:	f8 16       	cp	r15, r24
 152:	01 f4       	brne	.+0      	; 0x154 <setSpeed+0x1a>
 154:	00 c0       	rjmp	.+0      	; 0x156 <setSpeed+0x1c>

		// Send command to set speed
		if(servo->continuous){
 156:	2f 81       	ldd	r18, Y+7	; 0x07
 158:	8f 2d       	mov	r24, r15
 15a:	99 27       	eor	r25, r25
 15c:	87 fd       	sbrc	r24, 7
 15e:	90 95       	com	r25
 160:	22 23       	and	r18, r18
 162:	01 f0       	breq	.+0      	; 0x164 <setSpeed+0x2a>
			// Interpolate the values to 0 to 1023

			uint16_t position=interpolateU(ABS(speed), DRIVE_SPEED_BRAKE, DRIVE_SPEED_MAX, 0, 0x3ff);
 164:	97 ff       	sbrs	r25, 7
 166:	00 c0       	rjmp	.+0      	; 0x168 <setSpeed+0x2e>
 168:	91 95       	neg	r25
 16a:	81 95       	neg	r24
 16c:	91 09       	sbc	r25, r1
 16e:	0f ef       	ldi	r16, 0xFF	; 255
 170:	13 e0       	ldi	r17, 0x03	; 3
 172:	20 e0       	ldi	r18, 0x00	; 0
 174:	30 e0       	ldi	r19, 0x00	; 0
 176:	4f e7       	ldi	r20, 0x7F	; 127
 178:	50 e0       	ldi	r21, 0x00	; 0
 17a:	60 e0       	ldi	r22, 0x00	; 0
 17c:	70 e0       	ldi	r23, 0x00	; 0
 17e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			if(speed<0){
 182:	f7 fe       	sbrs	r15, 7
 184:	00 c0       	rjmp	.+0      	; 0x186 <setSpeed+0x4c>
				position |= 0x400;
 186:	94 60       	ori	r25, 0x04	; 4
 188:	00 c0       	rjmp	.+0      	; 0x18a <setSpeed+0x50>
			}
			ax12SetMOVING_SPEED(servo,position);
 18a:	00 97       	sbiw	r24, 0x00	; 0
 18c:	01 f0       	breq	.+0      	; 0x18e <setSpeed+0x54>
 18e:	ac 01       	movw	r20, r24
 190:	41 15       	cp	r20, r1
 192:	88 e0       	ldi	r24, 0x08	; 8
 194:	58 07       	cpc	r21, r24
 196:	00 f0       	brcs	.+0      	; 0x198 <setSpeed+0x5e>
 198:	4f ef       	ldi	r20, 0xFF	; 255
 19a:	57 e0       	ldi	r21, 0x07	; 7
 19c:	00 c0       	rjmp	.+0      	; 0x19e <setSpeed+0x64>
 19e:	40 e0       	ldi	r20, 0x00	; 0
 1a0:	50 e0       	ldi	r21, 0x00	; 0
 1a2:	60 e2       	ldi	r22, 0x20	; 32
 1a4:	00 c0       	rjmp	.+0      	; 0x1a6 <setSpeed+0x6c>
		}else{
			// Interpolate the values to 0 to 1023
			uint16_t position=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, 0, 1023);
 1a6:	0f ef       	ldi	r16, 0xFF	; 255
 1a8:	13 e0       	ldi	r17, 0x03	; 3
 1aa:	20 e0       	ldi	r18, 0x00	; 0
 1ac:	30 e0       	ldi	r19, 0x00	; 0
 1ae:	4f e7       	ldi	r20, 0x7F	; 127
 1b0:	50 e0       	ldi	r21, 0x00	; 0
 1b2:	61 e8       	ldi	r22, 0x81	; 129
 1b4:	7f ef       	ldi	r23, 0xFF	; 255
 1b6:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetGOAL_POSITION(servo,position);
 1ba:	00 97       	sbiw	r24, 0x00	; 0
 1bc:	01 f0       	breq	.+0      	; 0x1be <setSpeed+0x84>
 1be:	ac 01       	movw	r20, r24
 1c0:	41 15       	cp	r20, r1
 1c2:	84 e0       	ldi	r24, 0x04	; 4
 1c4:	58 07       	cpc	r21, r24
 1c6:	00 f0       	brcs	.+0      	; 0x1c8 <setSpeed+0x8e>
 1c8:	4f ef       	ldi	r20, 0xFF	; 255
 1ca:	53 e0       	ldi	r21, 0x03	; 3
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <setSpeed+0x94>
 1ce:	40 e0       	ldi	r20, 0x00	; 0
 1d0:	50 e0       	ldi	r21, 0x00	; 0
 1d2:	6e e1       	ldi	r22, 0x1E	; 30
 1d4:	ce 01       	movw	r24, r28
		}
	}

}
 1d6:	df 91       	pop	r29
 1d8:	cf 91       	pop	r28
 1da:	1f 91       	pop	r17
 1dc:	0f 91       	pop	r16
 1de:	ff 90       	pop	r15
			}
			ax12SetMOVING_SPEED(servo,position);
		}else{
			// Interpolate the values to 0 to 1023
			uint16_t position=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, 0, 1023);
			ax12SetGOAL_POSITION(servo,position);
 1e0:	0c 94 00 00 	jmp	0	; 0x0 <xmitBlock>
		}
	}

}
 1e4:	df 91       	pop	r29
 1e6:	cf 91       	pop	r28
 1e8:	1f 91       	pop	r17
 1ea:	0f 91       	pop	r16
 1ec:	ff 90       	pop	r15
 1ee:	08 95       	ret

000001f0 <ax12Begin>:
	// Change the hardware state
	pin_set(driver->directionPin, xmit);
}

void ax12Begin(DYNAMIXEL_AX12_DRIVER* driver){
	driver->writeCmd = ax12_REG_WRITE; // queue cmd
 1f0:	24 e0       	ldi	r18, 0x04	; 4
 1f2:	fc 01       	movw	r30, r24
 1f4:	27 83       	std	Z+7, r18	; 0x07
 1f6:	08 95       	ret

000001f8 <ax12End>:
}

void ax12End(DYNAMIXEL_AX12_DRIVER* driver){
 1f8:	cf 93       	push	r28
 1fa:	df 93       	push	r29
 1fc:	1f 92       	push	r1
 1fe:	cd b7       	in	r28, 0x3d	; 61
 200:	de b7       	in	r29, 0x3e	; 62
	driver->writeCmd = ax12_WRITE;    // don't queue cmds
 202:	23 e0       	ldi	r18, 0x03	; 3
 204:	fc 01       	movw	r30, r24
 206:	27 83       	std	Z+7, r18	; 0x07

	// Broadcast an ACTION cmd
	uint8_t status[] = {ax12_ACTION};
 208:	25 e0       	ldi	r18, 0x05	; 5
 20a:	29 83       	std	Y+1, r18	; 0x01
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
 20c:	9e 01       	movw	r18, r28
 20e:	2f 5f       	subi	r18, 0xFF	; 255
 210:	3f 4f       	sbci	r19, 0xFF	; 255
 212:	41 e0       	ldi	r20, 0x01	; 1
 214:	50 e0       	ldi	r21, 0x00	; 0
 216:	6e ef       	ldi	r22, 0xFE	; 254
 218:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
}
 21c:	0f 90       	pop	r0
 21e:	df 91       	pop	r29
 220:	cf 91       	pop	r28
 222:	08 95       	ret

00000224 <ax12Init>:


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 224:	4f 92       	push	r4
 226:	5f 92       	push	r5
 228:	6f 92       	push	r6
 22a:	7f 92       	push	r7
 22c:	8f 92       	push	r8
 22e:	9f 92       	push	r9
 230:	af 92       	push	r10
 232:	bf 92       	push	r11
 234:	cf 92       	push	r12
 236:	df 92       	push	r13
 238:	ef 92       	push	r14
 23a:	ff 92       	push	r15
 23c:	0f 93       	push	r16
 23e:	1f 93       	push	r17
 240:	cf 93       	push	r28
 242:	df 93       	push	r29
 244:	00 d0       	rcall	.+0      	; 0x246 <ax12Init+0x22>
 246:	1f 92       	push	r1
 248:	cd b7       	in	r28, 0x3d	; 61
 24a:	de b7       	in	r29, 0x3e	; 62
 24c:	8c 01       	movw	r16, r24
 24e:	6a 01       	movw	r12, r20
 250:	7b 01       	movw	r14, r22
	// Set the callback if there is a direction pin
	if(driver->directionPin){
 252:	dc 01       	movw	r26, r24
 254:	15 96       	adiw	r26, 0x05	; 5
 256:	8d 91       	ld	r24, X+
 258:	9c 91       	ld	r25, X
 25a:	16 97       	sbiw	r26, 0x06	; 6
 25c:	00 97       	sbiw	r24, 0x00	; 0
 25e:	01 f0       	breq	.+0      	; 0x260 <ax12Init+0x3c>
		pin_make_output(driver->directionPin, FALSE);// put into receive mode
 260:	60 e0       	ldi	r22, 0x00	; 0
 262:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
		driver->ax12uart->_uart_.xmitCallback = &xmitBlock;
 266:	d8 01       	movw	r26, r16
 268:	13 96       	adiw	r26, 0x03	; 3
 26a:	ed 91       	ld	r30, X+
 26c:	fc 91       	ld	r31, X
 26e:	14 97       	sbiw	r26, 0x04	; 4
 270:	80 e0       	ldi	r24, 0x00	; 0
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	97 8b       	std	Z+23, r25	; 0x17
 276:	86 8b       	std	Z+22, r24	; 0x16
		driver->ax12uart->_uart_.callbackParam = driver;
 278:	11 8f       	std	Z+25, r17	; 0x19
 27a:	00 8f       	std	Z+24, r16	; 0x18
 27c:	00 c0       	rjmp	.+0      	; 0x27e <ax12Init+0x5a>
	}else{
		if(driver->ax12uart->_uart_.class == &c_hw_uart){
 27e:	d8 01       	movw	r26, r16
 280:	13 96       	adiw	r26, 0x03	; 3
 282:	ed 91       	ld	r30, X+
 284:	fc 91       	ld	r31, X
 286:	14 97       	sbiw	r26, 0x04	; 4
 288:	81 85       	ldd	r24, Z+9	; 0x09
 28a:	92 85       	ldd	r25, Z+10	; 0x0a
 28c:	80 50       	subi	r24, 0x00	; 0
 28e:	90 40       	sbci	r25, 0x00	; 0
 290:	01 f4       	brne	.+0      	; 0x292 <ax12Init+0x6e>
			// Its a hardware UART - so make it one wire before initialising
			driver->ax12uart->_uart_.oneWire = TRUE;
 292:	8f ef       	ldi	r24, 0xFF	; 255
 294:	85 8b       	std	Z+21, r24	; 0x15
		}
	}


	// Set the baud rate
	uartInit(driver->ax12uart, baud);
 296:	b7 01       	movw	r22, r14
 298:	a6 01       	movw	r20, r12
 29a:	f8 01       	movw	r30, r16
 29c:	83 81       	ldd	r24, Z+3	; 0x03
 29e:	94 81       	ldd	r25, Z+4	; 0x04
 2a0:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


	// Tell all servos to only respond to READ commands
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
 2a4:	83 e0       	ldi	r24, 0x03	; 3
 2a6:	89 83       	std	Y+1, r24	; 0x01
 2a8:	80 e1       	ldi	r24, 0x10	; 16
 2aa:	8a 83       	std	Y+2, r24	; 0x02
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	8b 83       	std	Y+3, r24	; 0x03
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
 2b0:	9e 01       	movw	r18, r28
 2b2:	2f 5f       	subi	r18, 0xFF	; 255
 2b4:	3f 4f       	sbci	r19, 0xFF	; 255
 2b6:	43 e0       	ldi	r20, 0x03	; 3
 2b8:	50 e0       	ldi	r21, 0x00	; 0
 2ba:	6e ef       	ldi	r22, 0xFE	; 254
 2bc:	c8 01       	movw	r24, r16
 2be:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 2c2:	d8 01       	movw	r26, r16
 2c4:	12 96       	adiw	r26, 0x02	; 2
 2c6:	8c 91       	ld	r24, X
 2c8:	c1 2c       	mov	r12, r1
 2ca:	d1 2c       	mov	r13, r1
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 2cc:	90 e0       	ldi	r25, 0x00	; 0
 2ce:	5c 01       	movw	r10, r24
 2d0:	b1 e0       	ldi	r27, 0x01	; 1
 2d2:	ab 1a       	sub	r10, r27
 2d4:	b1 08       	sbc	r11, r1
 2d6:	4c 01       	movw	r8, r24
 2d8:	e1 e0       	ldi	r30, 0x01	; 1
 2da:	8e 1a       	sub	r8, r30
 2dc:	e0 e8       	ldi	r30, 0x80	; 128
 2de:	9e 0a       	sbc	r9, r30
	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);

		// Connect the servo to this driver
		servo->actuator.class = &c_ax12;
 2e0:	30 e0       	ldi	r19, 0x00	; 0
 2e2:	63 2e       	mov	r6, r19
 2e4:	30 e0       	ldi	r19, 0x00	; 0
 2e6:	73 2e       	mov	r7, r19
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <ax12Init+0xc6>
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 2ea:	c4 01       	movw	r24, r8
 2ec:	8c 19       	sub	r24, r12
 2ee:	9d 09       	sbc	r25, r13
 2f0:	88 0f       	add	r24, r24
 2f2:	99 1f       	adc	r25, r25
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
 2f4:	d8 01       	movw	r26, r16
 2f6:	ed 91       	ld	r30, X+
 2f8:	fc 91       	ld	r31, X
 2fa:	e8 0f       	add	r30, r24
 2fc:	f9 1f       	adc	r31, r25
 2fe:	25 91       	lpm	r18, Z+
 300:	34 91       	lpm	r19, Z
 302:	79 01       	movw	r14, r18

		// Connect the servo to this driver
		servo->actuator.class = &c_ax12;
 304:	f9 01       	movw	r30, r18
 306:	71 82       	std	Z+1, r7	; 0x01
 308:	60 82       	st	Z, r6
		servo->driver = driver;
 30a:	15 83       	std	Z+5, r17	; 0x05
 30c:	04 83       	std	Z+4, r16	; 0x04

		// Set it as connected
		act_setConnected(servo,TRUE);
 30e:	42 2e       	mov	r4, r18
 310:	53 2e       	mov	r5, r19
 312:	6f ef       	ldi	r22, 0xFF	; 255
 314:	82 2f       	mov	r24, r18
 316:	93 2f       	mov	r25, r19
 318:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


		if(servo->continuous){
 31c:	d7 01       	movw	r26, r14
 31e:	17 96       	adiw	r26, 0x07	; 7
 320:	8c 91       	ld	r24, X
			// Put into continuous rotation mode
			ax12SetCW_ANGLE_LIMIT(servo,0);
 322:	40 e0       	ldi	r20, 0x00	; 0
 324:	50 e0       	ldi	r21, 0x00	; 0
 326:	66 e0       	ldi	r22, 0x06	; 6

		// Set it as connected
		act_setConnected(servo,TRUE);


		if(servo->continuous){
 328:	88 23       	and	r24, r24
 32a:	01 f0       	breq	.+0      	; 0x32c <ax12Init+0x108>
			// Put into continuous rotation mode
			ax12SetCW_ANGLE_LIMIT(servo,0);
 32c:	c7 01       	movw	r24, r14
 32e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetCCW_ANGLE_LIMIT(servo,0);
 332:	40 e0       	ldi	r20, 0x00	; 0
 334:	50 e0       	ldi	r21, 0x00	; 0
 336:	00 c0       	rjmp	.+0      	; 0x338 <ax12Init+0x114>
		}else{
			// Put into servo mode
			ax12SetCW_ANGLE_LIMIT(servo,0);
 338:	c7 01       	movw	r24, r14
 33a:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetCCW_ANGLE_LIMIT(servo,1023);
 33e:	4f ef       	ldi	r20, 0xFF	; 255
 340:	53 e0       	ldi	r21, 0x03	; 3
 342:	68 e0       	ldi	r22, 0x08	; 8
 344:	c7 01       	movw	r24, r14
 346:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
		}

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 34a:	60 e0       	ldi	r22, 0x00	; 0
 34c:	c2 01       	movw	r24, r4
 34e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
 352:	bf ef       	ldi	r27, 0xFF	; 255
 354:	cb 1a       	sub	r12, r27
 356:	db 0a       	sbc	r13, r27
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 358:	c5 01       	movw	r24, r10
 35a:	8c 19       	sub	r24, r12
 35c:	9d 09       	sbc	r25, r13
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 35e:	01 96       	adiw	r24, 0x01	; 1
 360:	01 f0       	breq	.+0      	; 0x362 <ax12Init+0x13e>
 362:	00 c0       	rjmp	.+0      	; 0x364 <ax12Init+0x140>

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
	}

}
 364:	0f 90       	pop	r0
 366:	0f 90       	pop	r0
 368:	0f 90       	pop	r0
 36a:	df 91       	pop	r29
 36c:	cf 91       	pop	r28
 36e:	1f 91       	pop	r17
 370:	0f 91       	pop	r16
 372:	ff 90       	pop	r15
 374:	ef 90       	pop	r14
 376:	df 90       	pop	r13
 378:	cf 90       	pop	r12
 37a:	bf 90       	pop	r11
 37c:	af 90       	pop	r10
 37e:	9f 90       	pop	r9
 380:	8f 90       	pop	r8
 382:	7f 90       	pop	r7
 384:	6f 90       	pop	r6
 386:	5f 90       	pop	r5
 388:	4f 90       	pop	r4
 38a:	08 95       	ret

AX12dump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ea  2**0
                  ALLOC
  3 .progmem.data 0000005f  00000000  00000000  000000ea  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000006e9  00000000  00000000  00000149  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000138  00000000  00000000  00000832  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000019b  00000000  00000000  0000096a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000b05  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000013f  00000000  00000000  00000b25  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000435  00000000  00000000  00000c64  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001099  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000084  00000000  00000000  000010c4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12Dump>:
 */
#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12Dump(DYNAMIXEL_AX12* servo){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24

	uint16_t  status = ax12GetInfo(servo);
   6:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
	if(status == 0){
   a:	00 97       	sbiw	r24, 0x00	; 0
   c:	01 f4       	brne	.+0      	; 0xe <ax12Dump+0xe>
		rprintf("AX12 ID%u: Pos:%d, Speed:%d, Load:%d, Volts:%u.%c, Temp:%uC, Moving:%c\n",
   e:	88 89       	ldd	r24, Y+16	; 0x10
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <ax12Dump+0x14>
  14:	29 e5       	ldi	r18, 0x59	; 89
  16:	30 e0       	ldi	r19, 0x00	; 0
  18:	00 c0       	rjmp	.+0      	; 0x1a <ax12Dump+0x1a>
  1a:	2e e4       	ldi	r18, 0x4E	; 78
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	8d 85       	ldd	r24, Y+13	; 0x0d
  20:	3f 93       	push	r19
  22:	2f 93       	push	r18
  24:	9e 85       	ldd	r25, Y+14	; 0x0e
  26:	1f 92       	push	r1
  28:	9f 93       	push	r25
  2a:	6a e0       	ldi	r22, 0x0A	; 10
  2c:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  30:	29 2f       	mov	r18, r25
  32:	30 e0       	ldi	r19, 0x00	; 0
  34:	20 5d       	subi	r18, 0xD0	; 208
  36:	3f 4f       	sbci	r19, 0xFF	; 255
  38:	3f 93       	push	r19
  3a:	2f 93       	push	r18
  3c:	1f 92       	push	r1
  3e:	8f 93       	push	r24
  40:	8c 85       	ldd	r24, Y+12	; 0x0c
  42:	8f 93       	push	r24
  44:	8b 85       	ldd	r24, Y+11	; 0x0b
  46:	8f 93       	push	r24
  48:	8a 85       	ldd	r24, Y+10	; 0x0a
  4a:	8f 93       	push	r24
  4c:	89 85       	ldd	r24, Y+9	; 0x09
  4e:	8f 93       	push	r24
  50:	28 85       	ldd	r18, Y+8	; 0x08
  52:	82 2f       	mov	r24, r18
  54:	99 27       	eor	r25, r25
  56:	87 fd       	sbrc	r24, 7
  58:	90 95       	com	r25
  5a:	9f 93       	push	r25
  5c:	2f 93       	push	r18
  5e:	8e 81       	ldd	r24, Y+6	; 0x06
  60:	1f 92       	push	r1
  62:	8f 93       	push	r24
  64:	80 e0       	ldi	r24, 0x00	; 0
  66:	90 e0       	ldi	r25, 0x00	; 0
  68:	9f 93       	push	r25
  6a:	8f 93       	push	r24
  6c:	81 e0       	ldi	r24, 0x01	; 1
  6e:	8f 93       	push	r24
  70:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  74:	8d b7       	in	r24, 0x3d	; 61
  76:	9e b7       	in	r25, 0x3e	; 62
  78:	43 96       	adiw	r24, 0x13	; 19
  7a:	0f b6       	in	r0, 0x3f	; 63
  7c:	f8 94       	cli
  7e:	9e bf       	out	0x3e, r25	; 62
  80:	0f be       	out	0x3f, r0	; 63
  82:	8d bf       	out	0x3d, r24	; 61
  84:	00 c0       	rjmp	.+0      	; 0x86 <ax12Dump+0x86>
			(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
			(uint16_t)servo->info.temperature,
			(servo->info.moving) ? 'Y' : 'N');

	}else{
		rprintf("AX12 ID%u: Status: %u\n",(uint16_t)servo->id,status);
  86:	9f 93       	push	r25
  88:	8f 93       	push	r24
  8a:	8e 81       	ldd	r24, Y+6	; 0x06
  8c:	1f 92       	push	r1
  8e:	8f 93       	push	r24
  90:	80 e0       	ldi	r24, 0x00	; 0
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	9f 93       	push	r25
  96:	8f 93       	push	r24
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	8f 93       	push	r24
  9c:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  a0:	8d b7       	in	r24, 0x3d	; 61
  a2:	9e b7       	in	r25, 0x3e	; 62
  a4:	07 96       	adiw	r24, 0x07	; 7
  a6:	0f b6       	in	r0, 0x3f	; 63
  a8:	f8 94       	cli
  aa:	9e bf       	out	0x3e, r25	; 62
  ac:	0f be       	out	0x3f, r0	; 63
  ae:	8d bf       	out	0x3d, r24	; 61
	}
}
  b0:	df 91       	pop	r29
  b2:	cf 91       	pop	r28
  b4:	08 95       	ret

AX12dumpAll.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000132  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000166  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000166  2**0
                  ALLOC
  3 .progmem.data 00000066  00000000  00000000  00000166  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000075c  00000000  00000000  000001cc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000166  00000000  00000000  00000928  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000251  00000000  00000000  00000a8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000cdf  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00000cff  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000159  00000000  00000000  00000d17  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000463  00000000  00000000  00000e70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000012d3  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000c0  00000000  00000000  00001300  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12DumpAll>:

#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	7c 01       	movw	r14, r24
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
  1a:	80 e0       	ldi	r24, 0x00	; 0
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	9f 93       	push	r25
  20:	8f 93       	push	r24
  22:	81 e0       	ldi	r24, 0x01	; 1
  24:	8f 93       	push	r24
  26:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
	for(int i=0; i<driver->num_servos; i++){
  2a:	0f 90       	pop	r0
  2c:	0f 90       	pop	r0
  2e:	0f 90       	pop	r0
  30:	00 e0       	ldi	r16, 0x00	; 0
  32:	10 e0       	ldi	r17, 0x00	; 0
				(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
				(uint16_t)servo->info.temperature,
				(servo->info.moving) ? 'Y' : 'N');

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	c3 2e       	mov	r12, r19
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	d3 2e       	mov	r13, r19
  3c:	99 24       	eor	r9, r9
  3e:	93 94       	inc	r9
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
		uint16_t  status = ax12GetInfo(servo);
		if(status == 0){
			rprintf("%7u %6d %6d %5d %2u.%c %5u      %c\n",
  40:	4a e0       	ldi	r20, 0x0A	; 10
  42:	84 2e       	mov	r8, r20
  44:	50 e0       	ldi	r21, 0x00	; 0
  46:	a5 2e       	mov	r10, r21
  48:	50 e0       	ldi	r21, 0x00	; 0
  4a:	b5 2e       	mov	r11, r21
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
  4c:	00 c0       	rjmp	.+0      	; 0x4e <ax12DumpAll+0x4e>

#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
  4e:	c8 01       	movw	r24, r16
  50:	88 0f       	add	r24, r24
  52:	99 1f       	adc	r25, r25
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
  54:	d7 01       	movw	r26, r14
  56:	ed 91       	ld	r30, X+
  58:	fc 91       	ld	r31, X
  5a:	e8 0f       	add	r30, r24
  5c:	f9 1f       	adc	r31, r25
  5e:	85 91       	lpm	r24, Z+
  60:	94 91       	lpm	r25, Z
  62:	c8 2f       	mov	r28, r24
  64:	d9 2f       	mov	r29, r25
		uint16_t  status = ax12GetInfo(servo);
  66:	ce 01       	movw	r24, r28
  68:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
		if(status == 0){
  6c:	00 97       	sbiw	r24, 0x00	; 0
  6e:	01 f4       	brne	.+0      	; 0x70 <ax12DumpAll+0x70>
			rprintf("%7u %6d %6d %5d %2u.%c %5u      %c\n",
  70:	88 89       	ldd	r24, Y+16	; 0x10
  72:	88 23       	and	r24, r24
  74:	01 f0       	breq	.+0      	; 0x76 <ax12DumpAll+0x76>
  76:	29 e5       	ldi	r18, 0x59	; 89
  78:	30 e0       	ldi	r19, 0x00	; 0
  7a:	00 c0       	rjmp	.+0      	; 0x7c <ax12DumpAll+0x7c>
  7c:	2e e4       	ldi	r18, 0x4E	; 78
  7e:	30 e0       	ldi	r19, 0x00	; 0
  80:	8d 85       	ldd	r24, Y+13	; 0x0d
  82:	3f 93       	push	r19
  84:	2f 93       	push	r18
  86:	9e 85       	ldd	r25, Y+14	; 0x0e
  88:	1f 92       	push	r1
  8a:	9f 93       	push	r25
  8c:	68 2d       	mov	r22, r8
  8e:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
  92:	29 2f       	mov	r18, r25
  94:	30 e0       	ldi	r19, 0x00	; 0
  96:	20 5d       	subi	r18, 0xD0	; 208
  98:	3f 4f       	sbci	r19, 0xFF	; 255
  9a:	3f 93       	push	r19
  9c:	2f 93       	push	r18
  9e:	1f 92       	push	r1
  a0:	8f 93       	push	r24
  a2:	8c 85       	ldd	r24, Y+12	; 0x0c
  a4:	8f 93       	push	r24
  a6:	8b 85       	ldd	r24, Y+11	; 0x0b
  a8:	8f 93       	push	r24
  aa:	8a 85       	ldd	r24, Y+10	; 0x0a
  ac:	8f 93       	push	r24
  ae:	89 85       	ldd	r24, Y+9	; 0x09
  b0:	8f 93       	push	r24
  b2:	28 85       	ldd	r18, Y+8	; 0x08
  b4:	82 2f       	mov	r24, r18
  b6:	99 27       	eor	r25, r25
  b8:	87 fd       	sbrc	r24, 7
  ba:	90 95       	com	r25
  bc:	9f 93       	push	r25
  be:	2f 93       	push	r18
  c0:	8e 81       	ldd	r24, Y+6	; 0x06
  c2:	1f 92       	push	r1
  c4:	8f 93       	push	r24
  c6:	bf 92       	push	r11
  c8:	af 92       	push	r10
  ca:	9f 92       	push	r9
  cc:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
  d0:	8d b7       	in	r24, 0x3d	; 61
  d2:	9e b7       	in	r25, 0x3e	; 62
  d4:	43 96       	adiw	r24, 0x13	; 19
  d6:	0f b6       	in	r0, 0x3f	; 63
  d8:	f8 94       	cli
  da:	9e bf       	out	0x3e, r25	; 62
  dc:	0f be       	out	0x3f, r0	; 63
  de:	8d bf       	out	0x3d, r24	; 61
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <ax12DumpAll+0xe2>
				(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
				(uint16_t)servo->info.temperature,
				(servo->info.moving) ? 'Y' : 'N');

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
  e2:	9f 93       	push	r25
  e4:	8f 93       	push	r24
  e6:	8e 81       	ldd	r24, Y+6	; 0x06
  e8:	1f 92       	push	r1
  ea:	8f 93       	push	r24
  ec:	df 92       	push	r13
  ee:	cf 92       	push	r12
  f0:	9f 92       	push	r9
  f2:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
  f6:	ad b7       	in	r26, 0x3d	; 61
  f8:	be b7       	in	r27, 0x3e	; 62
  fa:	17 96       	adiw	r26, 0x07	; 7
  fc:	0f b6       	in	r0, 0x3f	; 63
  fe:	f8 94       	cli
 100:	be bf       	out	0x3e, r27	; 62
 102:	0f be       	out	0x3f, r0	; 63
 104:	ad bf       	out	0x3d, r26	; 61
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
 106:	0f 5f       	subi	r16, 0xFF	; 255
 108:	1f 4f       	sbci	r17, 0xFF	; 255
 10a:	f7 01       	movw	r30, r14
 10c:	82 81       	ldd	r24, Z+2	; 0x02
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	08 17       	cp	r16, r24
 112:	19 07       	cpc	r17, r25
 114:	04 f4       	brge	.+0      	; 0x116 <ax12DumpAll+0x116>
 116:	00 c0       	rjmp	.+0      	; 0x118 <ax12DumpAll+0x118>

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
		}
	}
}
 118:	df 91       	pop	r29
 11a:	cf 91       	pop	r28
 11c:	1f 91       	pop	r17
 11e:	0f 91       	pop	r16
 120:	ff 90       	pop	r15
 122:	ef 90       	pop	r14
 124:	df 90       	pop	r13
 126:	cf 90       	pop	r12
 128:	bf 90       	pop	r11
 12a:	af 90       	pop	r10
 12c:	9f 90       	pop	r9
 12e:	8f 90       	pop	r8
 130:	08 95       	ret

AX12info.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001fe  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000232  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000232  2**0
                  ALLOC
  3 .debug_info   00000965  00000000  00000000  00000232  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000254  00000000  00000000  00000b97  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000357  00000000  00000000  00000deb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001142  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  00001162  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001c3  00000000  00000000  00001192  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004b9  00000000  00000000  00001355  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  0000180e  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000005c  00000000  00000000  00001838  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12GetInfo>:
#include "../../core.h"

// The number of bytes to read from the ax12
#define INFO_LENGTH (ax12_LOCK - ax12_PRESENT_POSITION)

uint16_t ax12GetInfo(DYNAMIXEL_AX12* servo){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	64 97       	sbiw	r28, 0x14	; 20
  1a:	0f b6       	in	r0, 0x3f	; 63
  1c:	f8 94       	cli
  1e:	de bf       	out	0x3e, r29	; 62
  20:	0f be       	out	0x3f, r0	; 63
  22:	cd bf       	out	0x3d, r28	; 61
  24:	7c 01       	movw	r14, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  26:	fc 01       	movw	r30, r24
  28:	83 81       	ldd	r24, Z+3	; 0x03
  2a:	80 fd       	sbrc	r24, 0
  2c:	00 c0       	rjmp	.+0      	; 0x2e <ax12GetInfo+0x2e>
	uint16_t rtn = 0;
  2e:	c1 2c       	mov	r12, r1
  30:	d1 2c       	mov	r13, r1
  32:	00 c0       	rjmp	.+0      	; 0x34 <ax12GetInfo+0x34>
int __uartGetByte(UART* uart);

// Is the UART busy doing something?
#define uartIsBusy(uart) __uartIsBusy(&((uart)->_uart_))
static __inline__ boolean __uartIsBusy(UART* uart){
	return (uart->readyTx) ? FALSE : TRUE;
  34:	f8 01       	movw	r30, r16
  36:	80 85       	ldd	r24, Z+8	; 0x08
  38:	80 fd       	sbrc	r24, 0
  3a:	00 c0       	rjmp	.+0      	; 0x3c <ax12GetInfo+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <ax12GetInfo+0x3e>
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
		while(replyPos < sizeof(reply)){
			int ch = uartPollByte(uart);
  3e:	c8 01       	movw	r24, r16
  40:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>

			if(ch != -1){
  44:	8f 3f       	cpi	r24, 0xFF	; 255
  46:	ff ef       	ldi	r31, 0xFF	; 255
  48:	9f 07       	cpc	r25, r31
  4a:	01 f0       	breq	.+0      	; 0x4c <ax12GetInfo+0x4c>
				reply[replyPos++] = (uint8_t)(ch & 0xff);
  4c:	e1 e0       	ldi	r30, 0x01	; 1
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	ec 0f       	add	r30, r28
  52:	fd 1f       	adc	r31, r29
  54:	eb 0d       	add	r30, r11
  56:	f1 1d       	adc	r31, r1
  58:	80 83       	st	Z, r24
  5a:	b3 94       	inc	r11
				now = 0;
  5c:	c1 2c       	mov	r12, r1
  5e:	d1 2c       	mov	r13, r1
  60:	00 c0       	rjmp	.+0      	; 0x62 <ax12GetInfo+0x62>
			}else if(--now == 0){					// Timeout after a while
  62:	21 e0       	ldi	r18, 0x01	; 1
  64:	c2 1a       	sub	r12, r18
  66:	d1 08       	sbc	r13, r1
  68:	01 f0       	breq	.+0      	; 0x6a <ax12GetInfo+0x6a>
		while(uartIsBusy(uart)){
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
		while(replyPos < sizeof(reply)){
  6a:	80 e1       	ldi	r24, 0x10	; 16
  6c:	8b 15       	cp	r24, r11
  6e:	00 f4       	brcc	.+0      	; 0x70 <ax12GetInfo+0x70>

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
		uint16_t now=0;
		boolean timeOut = FALSE;
  70:	80 e0       	ldi	r24, 0x00	; 0
  72:	00 c0       	rjmp	.+0      	; 0x74 <ax12GetInfo+0x74>

			if(ch != -1){
				reply[replyPos++] = (uint8_t)(ch & 0xff);
				now = 0;
			}else if(--now == 0){					// Timeout after a while
				timeOut = TRUE;
  74:	8f ef       	ldi	r24, 0xFF	; 255
				break;
			}
		}
		CRITICAL_SECTION_END;
  76:	af be       	out	0x3f, r10	; 63

		// Check to see if we timed out
		if(timeOut){
  78:	88 23       	and	r24, r24
  7a:	01 f0       	breq	.+0      	; 0x7c <ax12GetInfo+0x7c>
			return AX12_RECV_TIMEOUT;
  7c:	c1 2c       	mov	r12, r1
  7e:	dd 24       	eor	r13, r13
  80:	d3 94       	inc	r13
  82:	00 c0       	rjmp	.+0      	; 0x84 <ax12GetInfo+0x84>
		}

		// Now validate the response
		if(reply[0]==0xff && reply[1]==0xff){
  84:	89 81       	ldd	r24, Y+1	; 0x01
  86:	8f 3f       	cpi	r24, 0xFF	; 255
  88:	01 f0       	breq	.+0      	; 0x8a <ax12GetInfo+0x8a>
  8a:	00 c0       	rjmp	.+0      	; 0x8c <ax12GetInfo+0x8c>
  8c:	8a 81       	ldd	r24, Y+2	; 0x02
  8e:	8f 3f       	cpi	r24, 0xFF	; 255
  90:	01 f0       	breq	.+0      	; 0x92 <ax12GetInfo+0x92>
  92:	00 c0       	rjmp	.+0      	; 0x94 <ax12GetInfo+0x94>
			// Got a valid header
			if(reply[2]==servo->id){
  94:	9b 81       	ldd	r25, Y+3	; 0x03
  96:	f7 01       	movw	r30, r14
  98:	86 81       	ldd	r24, Z+6	; 0x06
  9a:	98 13       	cpse	r25, r24
  9c:	00 c0       	rjmp	.+0      	; 0x9e <ax12GetInfo+0x9e>
				// From the correct servo
				if(reply[3]==sizeof(reply)-4){
  9e:	8c 81       	ldd	r24, Y+4	; 0x04
  a0:	8d 30       	cpi	r24, 0x0D	; 13
  a2:	01 f0       	breq	.+0      	; 0xa4 <ax12GetInfo+0xa4>
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <ax12GetInfo+0xa6>
  a6:	fe 01       	movw	r30, r28
  a8:	33 96       	adiw	r30, 0x03	; 3
#include "../../core.h"

// The number of bytes to read from the ax12
#define INFO_LENGTH (ax12_LOCK - ax12_PRESENT_POSITION)

uint16_t ax12GetInfo(DYNAMIXEL_AX12* servo){
  aa:	ce 01       	movw	r24, r28
  ac:	42 96       	adiw	r24, 0x12	; 18
  ae:	20 e0       	ldi	r18, 0x00	; 0
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <ax12GetInfo+0xb2>
				// From the correct servo
				if(reply[3]==sizeof(reply)-4){
					// it is the correct length
					uint8_t chksum = 0;
					for(int i=2; i<sizeof(reply);i++){
						chksum+=reply[i];
  b2:	31 91       	ld	r19, Z+
  b4:	23 0f       	add	r18, r19
			if(reply[2]==servo->id){
				// From the correct servo
				if(reply[3]==sizeof(reply)-4){
					// it is the correct length
					uint8_t chksum = 0;
					for(int i=2; i<sizeof(reply);i++){
  b6:	e8 17       	cp	r30, r24
  b8:	f9 07       	cpc	r31, r25
  ba:	01 f4       	brne	.+0      	; 0xbc <ax12GetInfo+0xbc>
						chksum+=reply[i];
					}
					if(chksum==0xff){
  bc:	2f 3f       	cpi	r18, 0xFF	; 255
  be:	01 f0       	breq	.+0      	; 0xc0 <ax12GetInfo+0xc0>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <ax12GetInfo+0xc2>
						// The checksum is correct
						rtn = reply[4];
  c2:	cd 80       	ldd	r12, Y+5	; 0x05
  c4:	d1 2c       	mov	r13, r1
						if(rtn == 0){
  c6:	c1 14       	cp	r12, r1
  c8:	d1 04       	cpc	r13, r1
  ca:	01 f0       	breq	.+0      	; 0xcc <ax12GetInfo+0xcc>
  cc:	00 c0       	rjmp	.+0      	; 0xce <ax12GetInfo+0xce>
							// Copy data out
							uint16_t pos = reply[5] | (reply[6]<<8); // 0...1023
  ce:	9f 81       	ldd	r25, Y+7	; 0x07
  d0:	80 e0       	ldi	r24, 0x00	; 0
  d2:	ee 81       	ldd	r30, Y+6	; 0x06
							servo->info.position=interpolate(pos, 0, 1023, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX);
  d4:	0f e7       	ldi	r16, 0x7F	; 127
  d6:	10 e0       	ldi	r17, 0x00	; 0
  d8:	21 e8       	ldi	r18, 0x81	; 129
  da:	3f ef       	ldi	r19, 0xFF	; 255
  dc:	4f ef       	ldi	r20, 0xFF	; 255
  de:	53 e0       	ldi	r21, 0x03	; 3
  e0:	60 e0       	ldi	r22, 0x00	; 0
  e2:	70 e0       	ldi	r23, 0x00	; 0
  e4:	8e 2b       	or	r24, r30
  e6:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>
  ea:	f7 01       	movw	r30, r14
  ec:	80 87       	std	Z+8, r24	; 0x08


							servo->info.speed = reply[7] | (reply[8]<<8);
  ee:	39 85       	ldd	r19, Y+9	; 0x09
  f0:	20 e0       	ldi	r18, 0x00	; 0
  f2:	98 85       	ldd	r25, Y+8	; 0x08
  f4:	29 2b       	or	r18, r25
  f6:	32 87       	std	Z+10, r19	; 0x0a
  f8:	21 87       	std	Z+9, r18	; 0x09
							if(servo->info.speed & 0x400){
  fa:	32 ff       	sbrs	r19, 2
  fc:	00 c0       	rjmp	.+0      	; 0xfe <ax12GetInfo+0xfe>
								servo->info.speed = - (servo->info.speed & 0x3ff);
  fe:	33 70       	andi	r19, 0x03	; 3
 100:	31 95       	neg	r19
 102:	21 95       	neg	r18
 104:	31 09       	sbc	r19, r1
 106:	32 87       	std	Z+10, r19	; 0x0a
 108:	21 87       	std	Z+9, r18	; 0x09
							}

							servo->info.load = reply[9] | (reply[10]<<8);
 10a:	3b 85       	ldd	r19, Y+11	; 0x0b
 10c:	20 e0       	ldi	r18, 0x00	; 0
 10e:	9a 85       	ldd	r25, Y+10	; 0x0a
 110:	29 2b       	or	r18, r25
 112:	f7 01       	movw	r30, r14
 114:	34 87       	std	Z+12, r19	; 0x0c
 116:	23 87       	std	Z+11, r18	; 0x0b
							if(servo->info.load & 0x400){
 118:	32 ff       	sbrs	r19, 2
 11a:	00 c0       	rjmp	.+0      	; 0x11c <ax12GetInfo+0x11c>
								servo->info.load = - (servo->info.load & 0x3ff);
 11c:	33 70       	andi	r19, 0x03	; 3
 11e:	31 95       	neg	r19
 120:	21 95       	neg	r18
 122:	31 09       	sbc	r19, r1
 124:	34 87       	std	Z+12, r19	; 0x0c
 126:	23 87       	std	Z+11, r18	; 0x0b
							}

							if(servo->actuator.inverted){
 128:	f7 01       	movw	r30, r14
 12a:	93 81       	ldd	r25, Z+3	; 0x03
 12c:	91 ff       	sbrs	r25, 1
 12e:	00 c0       	rjmp	.+0      	; 0x130 <ax12GetInfo+0x130>
								servo->info.position *= -1;
 130:	81 95       	neg	r24
 132:	80 87       	std	Z+8, r24	; 0x08
								servo->info.load *= -1;
 134:	83 85       	ldd	r24, Z+11	; 0x0b
 136:	94 85       	ldd	r25, Z+12	; 0x0c
 138:	91 95       	neg	r25
 13a:	81 95       	neg	r24
 13c:	91 09       	sbc	r25, r1
 13e:	94 87       	std	Z+12, r25	; 0x0c
 140:	83 87       	std	Z+11, r24	; 0x0b
								servo->info.speed *= -1;
 142:	81 85       	ldd	r24, Z+9	; 0x09
 144:	92 85       	ldd	r25, Z+10	; 0x0a
 146:	91 95       	neg	r25
 148:	81 95       	neg	r24
 14a:	91 09       	sbc	r25, r1
 14c:	92 87       	std	Z+10, r25	; 0x0a
 14e:	81 87       	std	Z+9, r24	; 0x09
							}
							servo->info.voltage = reply[11];
 150:	8c 85       	ldd	r24, Y+12	; 0x0c
 152:	f7 01       	movw	r30, r14
 154:	85 87       	std	Z+13, r24	; 0x0d
							servo->info.temperature = reply[12];
 156:	8d 85       	ldd	r24, Y+13	; 0x0d
 158:	86 87       	std	Z+14, r24	; 0x0e
							servo->info.batch = (reply[13]) ? TRUE : FALSE;
 15a:	8e 85       	ldd	r24, Y+14	; 0x0e
 15c:	88 23       	and	r24, r24
 15e:	01 f0       	breq	.+0      	; 0x160 <ax12GetInfo+0x160>
 160:	8f ef       	ldi	r24, 0xFF	; 255
 162:	00 c0       	rjmp	.+0      	; 0x164 <ax12GetInfo+0x164>
 164:	80 e0       	ldi	r24, 0x00	; 0
 166:	f7 01       	movw	r30, r14
 168:	87 87       	std	Z+15, r24	; 0x0f
							// byte14 is the reserved value
							servo->info.moving = (reply[15]) ? TRUE : FALSE;
 16a:	88 89       	ldd	r24, Y+16	; 0x10
 16c:	88 23       	and	r24, r24
 16e:	01 f0       	breq	.+0      	; 0x170 <ax12GetInfo+0x170>
 170:	8f ef       	ldi	r24, 0xFF	; 255
 172:	00 c0       	rjmp	.+0      	; 0x174 <ax12GetInfo+0x174>
 174:	80 e0       	ldi	r24, 0x00	; 0
 176:	f7 01       	movw	r30, r14
 178:	80 8b       	std	Z+16, r24	; 0x10
 17a:	00 c0       	rjmp	.+0      	; 0x17c <ax12GetInfo+0x17c>
				}
			}else{
				rtn = AX12_RECV_ID;
			}
		}else{
			rtn = AX12_RECV_HEADER;
 17c:	c1 2c       	mov	r12, r1
 17e:	34 e0       	ldi	r19, 0x04	; 4
 180:	d3 2e       	mov	r13, r19
 182:	00 c0       	rjmp	.+0      	; 0x184 <ax12GetInfo+0x184>
					}
				}else{
					rtn = AX12_RECV_LEN;
				}
			}else{
				rtn = AX12_RECV_ID;
 184:	c1 2c       	mov	r12, r1
 186:	28 e0       	ldi	r18, 0x08	; 8
 188:	d2 2e       	mov	r13, r18
 18a:	00 c0       	rjmp	.+0      	; 0x18c <ax12GetInfo+0x18c>
						}
					}else{
						rtn = AX12_RECV_CHECKSUM;
					}
				}else{
					rtn = AX12_RECV_LEN;
 18c:	c1 2c       	mov	r12, r1
 18e:	90 e1       	ldi	r25, 0x10	; 16
 190:	d9 2e       	mov	r13, r25
 192:	00 c0       	rjmp	.+0      	; 0x194 <ax12GetInfo+0x194>
							servo->info.batch = (reply[13]) ? TRUE : FALSE;
							// byte14 is the reserved value
							servo->info.moving = (reply[15]) ? TRUE : FALSE;
						}
					}else{
						rtn = AX12_RECV_CHECKSUM;
 194:	c1 2c       	mov	r12, r1
 196:	82 e0       	ldi	r24, 0x02	; 2
 198:	d8 2e       	mov	r13, r24
 19a:	00 c0       	rjmp	.+0      	; 0x19c <ax12GetInfo+0x19c>
#define INFO_LENGTH (ax12_LOCK - ax12_PRESENT_POSITION)

uint16_t ax12GetInfo(DYNAMIXEL_AX12* servo){
	uint16_t rtn = 0;
	if(act_isConnected(servo)){
		HW_UART* uart = servo->driver->ax12uart;
 19c:	f7 01       	movw	r30, r14
 19e:	84 81       	ldd	r24, Z+4	; 0x04
 1a0:	95 81       	ldd	r25, Z+5	; 0x05
 1a2:	fc 01       	movw	r30, r24
 1a4:	03 81       	ldd	r16, Z+3	; 0x03
 1a6:	14 81       	ldd	r17, Z+4	; 0x04
		uint8_t str[] = {ax12_READ,			// Read
 1a8:	22 e0       	ldi	r18, 0x02	; 2
 1aa:	2a 8b       	std	Y+18, r18	; 0x12
 1ac:	24 e2       	ldi	r18, 0x24	; 36
 1ae:	2b 8b       	std	Y+19, r18	; 0x13
 1b0:	2b e0       	ldi	r18, 0x0B	; 11
 1b2:	2c 8b       	std	Y+20, r18	; 0x14
		uint8_t replyPos = 0;
		uint16_t now=0;
		boolean timeOut = FALSE;

		// Send the request
		ax12Send(servo->driver, servo->id, sizeof(str), str);
 1b4:	9e 01       	movw	r18, r28
 1b6:	2e 5e       	subi	r18, 0xEE	; 238
 1b8:	3f 4f       	sbci	r19, 0xFF	; 255
 1ba:	43 e0       	ldi	r20, 0x03	; 3
 1bc:	50 e0       	ldi	r21, 0x00	; 0
 1be:	f7 01       	movw	r30, r14
 1c0:	66 81       	ldd	r22, Z+6	; 0x06
 1c2:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>

		// Wait till xmit is done
		while(uartIsBusy(uart)){
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <ax12GetInfo+0x1c8>
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
 1c8:	af b6       	in	r10, 0x3f	; 63
 1ca:	f8 94       	cli
//		uartFlushReceiveBuffer(uart);

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
		uint16_t now=0;
 1cc:	c1 2c       	mov	r12, r1
 1ce:	d1 2c       	mov	r13, r1
// Doesn't use an input buffer
//		uartFlushReceiveBuffer(uart);

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
 1d0:	b1 2c       	mov	r11, r1
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <ax12GetInfo+0x1d4>
		// Send the request
		ax12Send(servo->driver, servo->id, sizeof(str), str);

		// Wait till xmit is done
		while(uartIsBusy(uart)){
			breathe();
 1d4:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <ax12GetInfo+0x1da>
		}else{
			rtn = AX12_RECV_HEADER;
		}
	}
	return rtn;
}
 1da:	c6 01       	movw	r24, r12
 1dc:	64 96       	adiw	r28, 0x14	; 20
 1de:	0f b6       	in	r0, 0x3f	; 63
 1e0:	f8 94       	cli
 1e2:	de bf       	out	0x3e, r29	; 62
 1e4:	0f be       	out	0x3f, r0	; 63
 1e6:	cd bf       	out	0x3d, r28	; 61
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	1f 91       	pop	r17
 1ee:	0f 91       	pop	r16
 1f0:	ff 90       	pop	r15
 1f2:	ef 90       	pop	r14
 1f4:	df 90       	pop	r13
 1f6:	cf 90       	pop	r12
 1f8:	bf 90       	pop	r11
 1fa:	af 90       	pop	r10
 1fc:	08 95       	ret

serialServo.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001ce  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000202  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000202  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000202  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000c02  00000000  00000000  00000206  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000024b  00000000  00000000  00000e08  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000003e4  00000000  00000000  00001053  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001437  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000060  00000000  00000000  00001457  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000016d  00000000  00000000  000014b7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000573  00000000  00000000  00001624  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00001b97  2**0
                  CONTENTS, READONLY
 12 .debug_frame  0000009c  00000000  00000000  00001bc4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
 */

#include "../servos.h"
#include "../core.h"

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	7c 01       	movw	r14, r24
  10:	d6 2e       	mov	r13, r22
	SERVO* servo = (SERVO*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	8c 91       	ld	r24, X
  18:	12 97       	sbiw	r26, 0x02	; 2
	if(servo->actuator.inverted){
  1a:	13 96       	adiw	r26, 0x03	; 3
  1c:	9c 91       	ld	r25, X
  1e:	91 fd       	sbrc	r25, 1
		current *= -1;
  20:	81 95       	neg	r24
	}


	if(speed != current){
  22:	d8 16       	cp	r13, r24
  24:	01 f4       	brne	.+0      	; 0x26 <setSpeed+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <setSpeed+0x28>
		// Speed has changed
		UART* uart = servo->driver->specific.serial.uart;
  28:	d7 01       	movw	r26, r14
  2a:	14 96       	adiw	r26, 0x04	; 4
  2c:	ed 91       	ld	r30, X+
  2e:	fc 91       	ld	r31, X
  30:	15 97       	sbiw	r26, 0x05	; 5
  32:	c7 81       	ldd	r28, Z+7	; 0x07
  34:	d0 85       	ldd	r29, Z+8	; 0x08
		if(uart){
  36:	20 97       	sbiw	r28, 0x00	; 0
  38:	01 f4       	brne	.+0      	; 0x3a <setSpeed+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <setSpeed+0x3c>
			SERVO_PROTOCOL protocol = servo->driver->specific.serial.protocol;
  3c:	81 85       	ldd	r24, Z+9	; 0x09
			if(protocol==MINI_SSC){
  3e:	81 11       	cpse	r24, r1
  40:	00 c0       	rjmp	.+0      	; 0x42 <setSpeed+0x42>
				}else{
					// Need to interpolate
					speedByte = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, 0, 254);
				}

				_uartSendByte(uart, 0xff);
  42:	6f ef       	ldi	r22, 0xFF	; 255
  44:	ce 01       	movw	r24, r28
  46:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, servo->delay & 0x7f);
  4a:	f7 01       	movw	r30, r14
  4c:	60 89       	ldd	r22, Z+16	; 0x10
  4e:	71 89       	ldd	r23, Z+17	; 0x11
  50:	6f 77       	andi	r22, 0x7F	; 127
  52:	77 27       	eor	r23, r23
  54:	ce 01       	movw	r24, r28
  56:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				uint8_t speedByte;

				// Send 0xff, servo#, speed
				// where speed 0x7f=CENTER, 0x00=Left, 0xfe=Right
				if(DRIVE_SPEED_MIN == -127 && DRIVE_SPEED_MAX == 127){
					speedByte = speed + 127;
  5a:	6d 2d       	mov	r22, r13
  5c:	61 58       	subi	r22, 0x81	; 129
  5e:	00 c0       	rjmp	.+0      	; 0x60 <setSpeed+0x60>
				}

				_uartSendByte(uart, 0xff);
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
  60:	81 30       	cpi	r24, 0x01	; 1
  62:	01 f0       	breq	.+0      	; 0x64 <setSpeed+0x64>
  64:	00 c0       	rjmp	.+0      	; 0x66 <setSpeed+0x66>
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
						4*(servo->center_us - servo->range_us),
						4*(servo->center_us + servo->range_us) );
  66:	d7 01       	movw	r26, r14
  68:	18 96       	adiw	r26, 0x08	; 8
  6a:	2d 91       	ld	r18, X+
  6c:	3c 91       	ld	r19, X
  6e:	19 97       	sbiw	r26, 0x09	; 9
  70:	1a 96       	adiw	r26, 0x0a	; 10
  72:	4d 91       	ld	r20, X+
  74:	5c 91       	ld	r21, X
  76:	1b 97       	sbiw	r26, 0x0b	; 11
  78:	8a 01       	movw	r16, r20
  7a:	02 0f       	add	r16, r18
  7c:	13 1f       	adc	r17, r19
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
  7e:	00 0f       	add	r16, r16
  80:	11 1f       	adc	r17, r17
  82:	00 0f       	add	r16, r16
  84:	11 1f       	adc	r17, r17
						4*(servo->center_us - servo->range_us),
  86:	24 1b       	sub	r18, r20
  88:	35 0b       	sbc	r19, r21
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
  8a:	22 0f       	add	r18, r18
  8c:	33 1f       	adc	r19, r19
  8e:	22 0f       	add	r18, r18
  90:	33 1f       	adc	r19, r19
  92:	4f e7       	ldi	r20, 0x7F	; 127
  94:	50 e0       	ldi	r21, 0x00	; 0
  96:	61 e8       	ldi	r22, 0x81	; 129
  98:	7f ef       	ldi	r23, 0xFF	; 255
  9a:	8d 2d       	mov	r24, r13
  9c:	99 27       	eor	r25, r25
  9e:	87 fd       	sbrc	r24, 7
  a0:	90 95       	com	r25
  a2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  a6:	8c 01       	movw	r16, r24
						4*(servo->center_us - servo->range_us),
						4*(servo->center_us + servo->range_us) );
				_uartSendByte(uart, 0x84);
  a8:	64 e8       	ldi	r22, 0x84	; 132
  aa:	ce 01       	movw	r24, r28
  ac:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, servo->delay & 0x7f);
  b0:	f7 01       	movw	r30, r14
  b2:	60 89       	ldd	r22, Z+16	; 0x10
  b4:	71 89       	ldd	r23, Z+17	; 0x11
  b6:	6f 77       	andi	r22, 0x7F	; 127
  b8:	77 27       	eor	r23, r23
  ba:	ce 01       	movw	r24, r28
  bc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, speedWord & 0x7f);
  c0:	b8 01       	movw	r22, r16
  c2:	6f 77       	andi	r22, 0x7F	; 127
  c4:	77 27       	eor	r23, r23
  c6:	ce 01       	movw	r24, r28
  c8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, (speedWord>>7) & 0x7f );
  cc:	b8 01       	movw	r22, r16
  ce:	66 0f       	add	r22, r22
  d0:	67 2f       	mov	r22, r23
  d2:	66 1f       	adc	r22, r22
  d4:	77 0b       	sbc	r23, r23
  d6:	71 95       	neg	r23
  d8:	6f 77       	andi	r22, 0x7F	; 127
  da:	77 27       	eor	r23, r23
  dc:	ce 01       	movw	r24, r28
			}
		}
	}
}
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	1f 91       	pop	r17
  e4:	0f 91       	pop	r16
  e6:	ff 90       	pop	r15
  e8:	ef 90       	pop	r14
  ea:	df 90       	pop	r13
						4*(servo->center_us - servo->range_us),
						4*(servo->center_us + servo->range_us) );
				_uartSendByte(uart, 0x84);
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedWord & 0x7f);
				_uartSendByte(uart, (speedWord>>7) & 0x7f );
  ec:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
			}
		}
	}
}
  f0:	df 91       	pop	r29
  f2:	cf 91       	pop	r28
  f4:	1f 91       	pop	r17
  f6:	0f 91       	pop	r16
  f8:	ff 90       	pop	r15
  fa:	ef 90       	pop	r14
  fc:	df 90       	pop	r13
  fe:	08 95       	ret

00000100 <_servoSerialInit>:


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 100:	7f 92       	push	r7
 102:	8f 92       	push	r8
 104:	9f 92       	push	r9
 106:	af 92       	push	r10
 108:	bf 92       	push	r11
 10a:	cf 92       	push	r12
 10c:	df 92       	push	r13
 10e:	ef 92       	push	r14
 110:	ff 92       	push	r15
 112:	0f 93       	push	r16
 114:	1f 93       	push	r17
 116:	cf 93       	push	r28
 118:	df 93       	push	r29
 11a:	7c 01       	movw	r14, r24
 11c:	cb 01       	movw	r24, r22
 11e:	ba 01       	movw	r22, r20
 120:	a9 01       	movw	r20, r18
	driver->specific.serial.uart = uart;
 122:	d7 01       	movw	r26, r14
 124:	18 96       	adiw	r26, 0x08	; 8
 126:	9c 93       	st	X, r25
 128:	8e 93       	st	-X, r24
 12a:	17 97       	sbiw	r26, 0x07	; 7
	driver->specific.serial.protocol = protocol;
 12c:	19 96       	adiw	r26, 0x09	; 9
 12e:	0c 93       	st	X, r16
	// Set the baud rate
	_uartInit(uart, baud);
 130:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 134:	f7 01       	movw	r30, r14
 136:	72 80       	ldd	r7, Z+2	; 0x02
 138:	7a 94       	dec	r7
 13a:	c1 2c       	mov	r12, r1
 13c:	d1 2c       	mov	r13, r1


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 13e:	a7 2c       	mov	r10, r7
 140:	bb 24       	eor	r11, r11
 142:	a7 fc       	sbrc	r10, 7
 144:	b0 94       	com	r11
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		if(servo){
			// Connect the servo to this driver
			servo->actuator.class = &c_miniSSC_servos;
 146:	50 e0       	ldi	r21, 0x00	; 0
 148:	85 2e       	mov	r8, r21
 14a:	50 e0       	ldi	r21, 0x00	; 0
 14c:	95 2e       	mov	r9, r21
	driver->specific.serial.protocol = protocol;
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 14e:	00 c0       	rjmp	.+0      	; 0x150 <_servoSerialInit+0x50>


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 150:	c5 01       	movw	r24, r10
 152:	8c 19       	sub	r24, r12
 154:	9d 09       	sbc	r25, r13
 156:	9c 01       	movw	r18, r24
 158:	22 0f       	add	r18, r18
 15a:	33 1f       	adc	r19, r19
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 15c:	d7 01       	movw	r26, r14
 15e:	ed 91       	ld	r30, X+
 160:	fc 91       	ld	r31, X
 162:	e2 0f       	add	r30, r18
 164:	f3 1f       	adc	r31, r19
 166:	05 91       	lpm	r16, Z+
 168:	14 91       	lpm	r17, Z
 16a:	c0 2f       	mov	r28, r16
 16c:	d1 2f       	mov	r29, r17
		if(servo){
 16e:	20 97       	sbiw	r28, 0x00	; 0
 170:	01 f0       	breq	.+0      	; 0x172 <_servoSerialInit+0x72>
			// Connect the servo to this driver
			servo->actuator.class = &c_miniSSC_servos;
 172:	99 82       	std	Y+1, r9	; 0x01
 174:	88 82       	st	Y, r8
			servo->driver = driver;
 176:	fd 82       	std	Y+5, r15	; 0x05
 178:	ec 82       	std	Y+4, r14	; 0x04
			servo->top = 0;
 17a:	1b 8a       	std	Y+19, r1	; 0x13
 17c:	1a 8a       	std	Y+18, r1	; 0x12
			servo->delay = i; // The servo number in the list
 17e:	99 8b       	std	Y+17, r25	; 0x11
 180:	88 8b       	std	Y+16, r24	; 0x10
			servoSetConfig(servo,servo->center_us,servo->range_us);
 182:	4a 85       	ldd	r20, Y+10	; 0x0a
 184:	5b 85       	ldd	r21, Y+11	; 0x0b
 186:	68 85       	ldd	r22, Y+8	; 0x08
 188:	79 85       	ldd	r23, Y+9	; 0x09
 18a:	ce 01       	movw	r24, r28
 18c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 190:	6f ef       	ldi	r22, 0xFF	; 255
 192:	80 2f       	mov	r24, r16
 194:	91 2f       	mov	r25, r17
 196:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 19a:	60 e0       	ldi	r22, 0x00	; 0
 19c:	80 2f       	mov	r24, r16
 19e:	91 2f       	mov	r25, r17
 1a0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1a4:	ff ef       	ldi	r31, 0xFF	; 255
 1a6:	cf 1a       	sub	r12, r31
 1a8:	df 0a       	sbc	r13, r31


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 1aa:	87 2d       	mov	r24, r7
 1ac:	8c 19       	sub	r24, r12
	driver->specific.serial.protocol = protocol;
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 1ae:	87 ff       	sbrs	r24, 7
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <_servoSerialInit+0xb2>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}
	}
}
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	1f 91       	pop	r17
 1b8:	0f 91       	pop	r16
 1ba:	ff 90       	pop	r15
 1bc:	ef 90       	pop	r14
 1be:	df 90       	pop	r13
 1c0:	cf 90       	pop	r12
 1c2:	bf 90       	pop	r11
 1c4:	af 90       	pop	r10
 1c6:	9f 90       	pop	r9
 1c8:	8f 90       	pop	r8
 1ca:	7f 90       	pop	r7
 1cc:	08 95       	ret

FATImpl.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f6e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00001fa2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00001fa2  2**0
                  ALLOC
  3 .rodata       00000054  00000000  00000000  00001fa2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000039cc  00000000  00000000  00001ff6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000004ea  00000000  00000000  000059c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00004aa4  00000000  00000000  00005eac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000a950  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 000002e8  00000000  00000000  0000a970  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000733  00000000  00000000  0000ac58  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000cf3  00000000  00000000  0000b38b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  0000c07e  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000008c8  00000000  00000000  0000c0a8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_bufferIsWritable>:
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
       0:	fc 01       	movw	r30, r24
       2:	21 81       	ldd	r18, Z+1	; 0x01
}
static void _bufferSetNotWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 0;
}
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
       4:	36 e0       	ldi	r19, 0x06	; 6
       6:	23 9f       	mul	r18, r19
       8:	e0 0d       	add	r30, r0
       a:	f1 1d       	adc	r31, r1
       c:	11 24       	eor	r1, r1
       e:	87 81       	ldd	r24, Z+7	; 0x07
      10:	81 ff       	sbrs	r24, 1
      12:	00 c0       	rjmp	.+0      	; 0x14 <_bufferIsWritable+0x14>
      14:	8f ef       	ldi	r24, 0xFF	; 255
      16:	08 95       	ret
      18:	80 e0       	ldi	r24, 0x00	; 0
}
      1a:	08 95       	ret

0000001c <_bufferFindUnused>:
}

static BUFFER* _bufferFindUnused(const DISK* disc){
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      1c:	dc 01       	movw	r26, r24
      1e:	d4 96       	adiw	r26, 0x34	; 52
      20:	ed 91       	ld	r30, X+
      22:	fc 91       	ld	r31, X
      24:	d5 97       	sbiw	r26, 0x35	; 53
      26:	d3 96       	adiw	r26, 0x33	; 51
      28:	9c 91       	ld	r25, X
      2a:	80 e0       	ldi	r24, 0x00	; 0

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
      2c:	26 e0       	ldi	r18, 0x06	; 6
}

static BUFFER* _bufferFindUnused(const DISK* disc){
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      2e:	00 c0       	rjmp	.+0      	; 0x30 <_bufferFindUnused+0x14>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
      30:	31 81       	ldd	r19, Z+1	; 0x01

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
      32:	df 01       	movw	r26, r30
      34:	23 9f       	mul	r18, r19
      36:	a0 0d       	add	r26, r0
      38:	b1 1d       	adc	r27, r1
      3a:	11 24       	eor	r1, r1
      3c:	17 96       	adiw	r26, 0x07	; 7
      3e:	3c 91       	ld	r19, X
      40:	30 ff       	sbrs	r19, 0
      42:	00 c0       	rjmp	.+0      	; 0x44 <_bufferFindUnused+0x28>
      44:	00 c0       	rjmp	.+0      	; 0x46 <_bufferFindUnused+0x2a>
}

static BUFFER* _bufferFindUnused(const DISK* disc){
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      46:	89 13       	cpse	r24, r25
      48:	00 c0       	rjmp	.+0      	; 0x4a <_bufferFindUnused+0x2e>
		if(!_bufferIsValid(buffer)){
			return(buffer);
		}
	}
	return(null);
      4a:	e0 e0       	ldi	r30, 0x00	; 0
      4c:	f0 e0       	ldi	r31, 0x00	; 0
      4e:	00 c0       	rjmp	.+0      	; 0x50 <_bufferFindUnused+0x34>
}

static BUFFER* _bufferFindUnused(const DISK* disc){
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      50:	8f 5f       	subi	r24, 0xFF	; 255
      52:	e6 5e       	subi	r30, 0xE6	; 230
      54:	fd 4f       	sbci	r31, 0xFD	; 253
      56:	00 c0       	rjmp	.+0      	; 0x58 <_bufferFindUnused+0x3c>
		if(!_bufferIsValid(buffer)){
			return(buffer);
		}
	}
	return(null);
}
      58:	cf 01       	movw	r24, r30
      5a:	08 95       	ret

0000005c <_ioFindSectorInCache>:
		}
	}
	return(null);
}

static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
      5c:	0f 93       	push	r16
      5e:	1f 93       	push	r17
      60:	cf 93       	push	r28
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      62:	dc 01       	movw	r26, r24
      64:	d4 96       	adiw	r26, 0x34	; 52
      66:	ed 91       	ld	r30, X+
      68:	fc 91       	ld	r31, X
      6a:	d5 97       	sbiw	r26, 0x35	; 53
      6c:	d3 96       	adiw	r26, 0x33	; 51
      6e:	9c 91       	ld	r25, X
      70:	80 e0       	ldi	r24, 0x00	; 0
		const SECTOR_BUFFER * secbuf = _bufferCurrentStackEntry(buffer);
      72:	c6 e0       	ldi	r28, 0x06	; 6

static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      74:	00 c0       	rjmp	.+0      	; 0x76 <_ioFindSectorInCache+0x1a>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
      76:	21 81       	ldd	r18, Z+1	; 0x01
static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		const SECTOR_BUFFER * secbuf = _bufferCurrentStackEntry(buffer);
      78:	df 01       	movw	r26, r30
      7a:	c2 9f       	mul	r28, r18
      7c:	a0 0d       	add	r26, r0
      7e:	b1 1d       	adc	r27, r1
      80:	11 24       	eor	r1, r1
      82:	12 96       	adiw	r26, 0x02	; 2
		if(secbuf->isValid && secbuf->sector==absSector){
      84:	15 96       	adiw	r26, 0x05	; 5
      86:	2c 91       	ld	r18, X
      88:	15 97       	sbiw	r26, 0x05	; 5
      8a:	20 ff       	sbrs	r18, 0
      8c:	00 c0       	rjmp	.+0      	; 0x8e <_ioFindSectorInCache+0x32>
      8e:	0d 91       	ld	r16, X+
      90:	1d 91       	ld	r17, X+
      92:	2d 91       	ld	r18, X+
      94:	3c 91       	ld	r19, X
      96:	04 17       	cp	r16, r20
      98:	15 07       	cpc	r17, r21
      9a:	26 07       	cpc	r18, r22
      9c:	37 07       	cpc	r19, r23
      9e:	01 f0       	breq	.+0      	; 0xa0 <_ioFindSectorInCache+0x44>

static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      a0:	8f 5f       	subi	r24, 0xFF	; 255
      a2:	e6 5e       	subi	r30, 0xE6	; 230
      a4:	fd 4f       	sbci	r31, 0xFD	; 253
      a6:	89 13       	cpse	r24, r25
      a8:	00 c0       	rjmp	.+0      	; 0xaa <_ioFindSectorInCache+0x4e>
		const SECTOR_BUFFER * secbuf = _bufferCurrentStackEntry(buffer);
		if(secbuf->isValid && secbuf->sector==absSector){
			return buffer;
		}
	}
	return(null);
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f0 e0       	ldi	r31, 0x00	; 0
}
      ae:	cf 01       	movw	r24, r30
      b0:	cf 91       	pop	r28
      b2:	1f 91       	pop	r17
      b4:	0f 91       	pop	r16
      b6:	08 95       	ret

000000b8 <_fatGetSectorAddressFatEntry>:
/*					FAT Table Management								  */
/*------------------------------------------------------------------------*/

// Find the sector inside the FAT table which holds the given cluster
// Return value: Sector, or 0.
static SECTOR _fatGetSectorAddressFatEntry(const DISK *disk,CLUSTER cluster_addr){
      b8:	cf 92       	push	r12
      ba:	df 92       	push	r13
      bc:	ef 92       	push	r14
      be:	ff 92       	push	r15
      c0:	0f 93       	push	r16
      c2:	1f 93       	push	r17
      c4:	fc 01       	movw	r30, r24
	SECTOR_COUNT res;

	switch(disk->fatType){
      c6:	86 a1       	ldd	r24, Z+38	; 0x26
      c8:	80 31       	cpi	r24, 0x10	; 16
      ca:	01 f0       	breq	.+0      	; 0xcc <_fatGetSectorAddressFatEntry+0x14>
      cc:	80 32       	cpi	r24, 0x20	; 32
      ce:	01 f0       	breq	.+0      	; 0xd0 <_fatGetSectorAddressFatEntry+0x18>
      d0:	8c 30       	cpi	r24, 0x0C	; 12
      d2:	01 f4       	brne	.+0      	; 0xd4 <_fatGetSectorAddressFatEntry+0x1c>
		case 12:
			res=(cluster_addr * 3 / 1024);
      d4:	a3 e0       	ldi	r26, 0x03	; 3
      d6:	b0 e0       	ldi	r27, 0x00	; 0
      d8:	9a 01       	movw	r18, r20
      da:	ab 01       	movw	r20, r22
      dc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
      e0:	4a e0       	ldi	r20, 0x0A	; 10
      e2:	96 95       	lsr	r25
      e4:	87 95       	ror	r24
      e6:	77 95       	ror	r23
      e8:	67 95       	ror	r22
      ea:	4a 95       	dec	r20
      ec:	01 f4       	brne	.+0      	; 0xee <_fatGetSectorAddressFatEntry+0x36>
			break;
      ee:	00 c0       	rjmp	.+0      	; 0xf0 <_fatGetSectorAddressFatEntry+0x38>
		case 16:
			res=cluster_addr / 256;
      f0:	99 27       	eor	r25, r25
      f2:	87 2f       	mov	r24, r23
      f4:	76 2f       	mov	r23, r22
      f6:	65 2f       	mov	r22, r21
			break;
      f8:	00 c0       	rjmp	.+0      	; 0xfa <_fatGetSectorAddressFatEntry+0x42>
		case 32:
			res=cluster_addr / 128;
      fa:	cb 01       	movw	r24, r22
      fc:	ba 01       	movw	r22, r20
      fe:	27 e0       	ldi	r18, 0x07	; 7
     100:	96 95       	lsr	r25
     102:	87 95       	ror	r24
     104:	77 95       	ror	r23
     106:	67 95       	ror	r22
     108:	2a 95       	dec	r18
     10a:	01 f4       	brne	.+0      	; 0x10c <_fatGetSectorAddressFatEntry+0x54>
			break;
		default:
			return 0;
	}
	if(res >= disk->fatSectorCount){
     10c:	02 8d       	ldd	r16, Z+26	; 0x1a
     10e:	13 8d       	ldd	r17, Z+27	; 0x1b
     110:	24 8d       	ldd	r18, Z+28	; 0x1c
     112:	35 8d       	ldd	r19, Z+29	; 0x1d
     114:	60 17       	cp	r22, r16
     116:	71 07       	cpc	r23, r17
     118:	82 07       	cpc	r24, r18
     11a:	93 07       	cpc	r25, r19
     11c:	00 f4       	brcc	.+0      	; 0x11e <_fatGetSectorAddressFatEntry+0x66>
		return(0);
	}
	return(disk->volume.reservedSectorCount + res);
     11e:	21 89       	ldd	r18, Z+17	; 0x11
     120:	32 89       	ldd	r19, Z+18	; 0x12
     122:	6b 01       	movw	r12, r22
     124:	7c 01       	movw	r14, r24
     126:	c2 0e       	add	r12, r18
     128:	d3 1e       	adc	r13, r19
     12a:	e1 1c       	adc	r14, r1
     12c:	f1 1c       	adc	r15, r1
     12e:	97 01       	movw	r18, r14
     130:	86 01       	movw	r16, r12
     132:	00 c0       	rjmp	.+0      	; 0x134 <_fatGetSectorAddressFatEntry+0x7c>
			break;
		default:
			return 0;
	}
	if(res >= disk->fatSectorCount){
		return(0);
     134:	00 e0       	ldi	r16, 0x00	; 0
     136:	10 e0       	ldi	r17, 0x00	; 0
     138:	98 01       	movw	r18, r16
	}
	return(disk->volume.reservedSectorCount + res);
}
     13a:	b8 01       	movw	r22, r16
     13c:	c9 01       	movw	r24, r18
     13e:	1f 91       	pop	r17
     140:	0f 91       	pop	r16
     142:	ff 90       	pop	r15
     144:	ef 90       	pop	r14
     146:	df 90       	pop	r13
     148:	cf 90       	pop	r12
     14a:	08 95       	ret

0000014c <_dirFindFreeEntryinRAM>:


// This function searches for a free entry in a given directory sector buffer.
// It will put the offset into the loc->Offset field, given that loc is not 0.
// Return value: TRUE when it found a free spot, FALSE if it hasn't.
static uint32_t _dirFindFreeEntryinRAM(const DIR_ENTRY *fileEntry, DIR_POSITION *loc){
     14c:	0f 93       	push	r16
     14e:	1f 93       	push	r17
	for(uint8_t c=0;c<16;c++,fileEntry++){
     150:	20 e0       	ldi	r18, 0x00	; 0
		if( (fileEntry->attribute.bits & 0x0F) != 0x0F ){	// If its not a long filename entry
     152:	fc 01       	movw	r30, r24
     154:	33 85       	ldd	r19, Z+11	; 0x0b
     156:	3f 70       	andi	r19, 0x0F	; 15
     158:	3f 30       	cpi	r19, 0x0F	; 15
     15a:	01 f0       	breq	.+0      	; 0x15c <_dirFindFreeEntryinRAM+0x10>
			if(fileEntry->filename[0] == 0x00 ||		// And is unused or
     15c:	30 81       	ld	r19, Z
     15e:	31 11       	cpse	r19, r1
     160:	00 c0       	rjmp	.+0      	; 0x162 <_dirFindFreeEntryinRAM+0x16>
			   fileEntry->filename[0] == 0xE5 ){		// The file is deleted
				if(loc){
     162:	61 15       	cp	r22, r1
     164:	71 05       	cpc	r23, r1
     166:	01 f4       	brne	.+0      	; 0x168 <_dirFindFreeEntryinRAM+0x1c>
     168:	00 c0       	rjmp	.+0      	; 0x16a <_dirFindFreeEntryinRAM+0x1e>
// It will put the offset into the loc->Offset field, given that loc is not 0.
// Return value: TRUE when it found a free spot, FALSE if it hasn't.
static uint32_t _dirFindFreeEntryinRAM(const DIR_ENTRY *fileEntry, DIR_POSITION *loc){
	for(uint8_t c=0;c<16;c++,fileEntry++){
		if( (fileEntry->attribute.bits & 0x0F) != 0x0F ){	// If its not a long filename entry
			if(fileEntry->filename[0] == 0x00 ||		// And is unused or
     16a:	35 3e       	cpi	r19, 0xE5	; 229
     16c:	01 f4       	brne	.+0      	; 0x16e <_dirFindFreeEntryinRAM+0x22>
     16e:	00 c0       	rjmp	.+0      	; 0x170 <_dirFindFreeEntryinRAM+0x24>
			   fileEntry->filename[0] == 0xE5 ){		// The file is deleted
				if(loc){
					loc->entryInSector=c;
     170:	fb 01       	movw	r30, r22
     172:	24 83       	std	Z+4, r18	; 0x04
				}
				return(1);								// We can use it
     174:	01 e0       	ldi	r16, 0x01	; 1
     176:	10 e0       	ldi	r17, 0x00	; 0
     178:	20 e0       	ldi	r18, 0x00	; 0
     17a:	30 e0       	ldi	r19, 0x00	; 0
     17c:	00 c0       	rjmp	.+0      	; 0x17e <_dirFindFreeEntryinRAM+0x32>

// This function searches for a free entry in a given directory sector buffer.
// It will put the offset into the loc->Offset field, given that loc is not 0.
// Return value: TRUE when it found a free spot, FALSE if it hasn't.
static uint32_t _dirFindFreeEntryinRAM(const DIR_ENTRY *fileEntry, DIR_POSITION *loc){
	for(uint8_t c=0;c<16;c++,fileEntry++){
     17e:	2f 5f       	subi	r18, 0xFF	; 255
     180:	80 96       	adiw	r24, 0x20	; 32
     182:	20 31       	cpi	r18, 0x10	; 16
     184:	01 f4       	brne	.+0      	; 0x186 <_dirFindFreeEntryinRAM+0x3a>
				}
				return(1);								// We can use it
			}
		}
	}
	return(0);
     186:	00 e0       	ldi	r16, 0x00	; 0
     188:	10 e0       	ldi	r17, 0x00	; 0
     18a:	98 01       	movw	r18, r16
}
     18c:	b8 01       	movw	r22, r16
     18e:	c9 01       	movw	r24, r18
     190:	1f 91       	pop	r17
     192:	0f 91       	pop	r16
     194:	08 95       	ret

00000196 <_bufferReset>:
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     196:	dc 01       	movw	r26, r24
     198:	11 96       	adiw	r26, 0x01	; 1
     19a:	2c 91       	ld	r18, X
     19c:	46 e0       	ldi	r20, 0x06	; 6
     19e:	fc 01       	movw	r30, r24
     1a0:	42 9f       	mul	r20, r18
     1a2:	e0 0d       	add	r30, r0
     1a4:	f1 1d       	adc	r31, r1
     1a6:	11 24       	eor	r1, r1
     1a8:	9f 01       	movw	r18, r30
     1aa:	2e 5f       	subi	r18, 0xFE	; 254
     1ac:	3f 4f       	sbci	r19, 0xFF	; 255
	return buffer->depth;
}

static void _bufferReset(BUFFER* buffer){
	SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
	memclr(current,sizeof(SECTOR_BUFFER));
     1ae:	d9 01       	movw	r26, r18
     1b0:	1d 92       	st	X+, r1
     1b2:	4a 95       	dec	r20
     1b4:	01 f4       	brne	.+0      	; 0x1b6 <_bufferReset+0x20>
	buffer->reference = 0;
     1b6:	fc 01       	movw	r30, r24
     1b8:	10 82       	st	Z, r1
     1ba:	08 95       	ret

000001bc <_dirFindFileInSector>:
/*					Directory Entry Management	  						  */
/*------------------------------------------------------------------------*/

// Attempt to locate a given filename in a director sector
// Return: 0 if not found, else the starting cluster for the file data
static CLUSTER _dirFindFileInSector(const DIR_ENTRY *fileEntry,const  char *fatname, DIR_POSITION *loc){
     1bc:	df 92       	push	r13
     1be:	ef 92       	push	r14
     1c0:	ff 92       	push	r15
     1c2:	0f 93       	push	r16
     1c4:	1f 93       	push	r17
     1c6:	cf 93       	push	r28
     1c8:	df 93       	push	r29
     1ca:	ec 01       	movw	r28, r24
     1cc:	7b 01       	movw	r14, r22
     1ce:	8a 01       	movw	r16, r20

	for(uint8_t c=0; c<16; c++,fileEntry++){
     1d0:	d1 2c       	mov	r13, r1
		/* Check if the entry is for short filenames */
		if( (fileEntry->attribute.bits & 0x0F) != 0x0F ){
     1d2:	8b 85       	ldd	r24, Y+11	; 0x0b
     1d4:	8f 70       	andi	r24, 0x0F	; 15
     1d6:	8f 30       	cpi	r24, 0x0F	; 15
     1d8:	01 f0       	breq	.+0      	; 0x1da <_dirFindFileInSector+0x1e>
			if( memcmp((const char*)fileEntry->filename,fatname,sizeof(fileEntry->filename)) == 0 ){
     1da:	4b e0       	ldi	r20, 0x0B	; 11
     1dc:	50 e0       	ldi	r21, 0x00	; 0
     1de:	b7 01       	movw	r22, r14
     1e0:	ce 01       	movw	r24, r28
     1e2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     1e6:	00 97       	sbiw	r24, 0x00	; 0
     1e8:	01 f4       	brne	.+0      	; 0x1ea <_dirFindFileInSector+0x2e>
				/* The entry has been found, return the location in the dir */
				if(loc){
     1ea:	01 15       	cp	r16, r1
     1ec:	11 05       	cpc	r17, r1
     1ee:	01 f0       	breq	.+0      	; 0x1f0 <_dirFindFileInSector+0x34>
					loc->entryInSector = c;
     1f0:	f8 01       	movw	r30, r16
     1f2:	d4 82       	std	Z+4, r13	; 0x04
					loc->attrib = fileEntry->attribute;
     1f4:	8b 85       	ldd	r24, Y+11	; 0x0b
     1f6:	85 83       	std	Z+5, r24	; 0x05
				}

				CLUSTER firstCluster=(((CLUSTER )fileEntry->firstClusterHigh)<<16)+ fileEntry->firstClusterLow;
     1f8:	0c 89       	ldd	r16, Y+20	; 0x14
     1fa:	1d 89       	ldd	r17, Y+21	; 0x15
     1fc:	20 e0       	ldi	r18, 0x00	; 0
     1fe:	30 e0       	ldi	r19, 0x00	; 0
     200:	98 01       	movw	r18, r16
     202:	11 27       	eor	r17, r17
     204:	00 27       	eor	r16, r16
     206:	8a 8d       	ldd	r24, Y+26	; 0x1a
     208:	9b 8d       	ldd	r25, Y+27	; 0x1b
     20a:	08 0f       	add	r16, r24
     20c:	19 1f       	adc	r17, r25
     20e:	21 1d       	adc	r18, r1
     210:	31 1d       	adc	r19, r1

				if(firstCluster==0){
     212:	01 15       	cp	r16, r1
     214:	11 05       	cpc	r17, r1
     216:	21 05       	cpc	r18, r1
     218:	31 05       	cpc	r19, r1
     21a:	01 f0       	breq	.+0      	; 0x21c <_dirFindFileInSector+0x60>
     21c:	00 c0       	rjmp	.+0      	; 0x21e <_dirFindFileInSector+0x62>

// Attempt to locate a given filename in a director sector
// Return: 0 if not found, else the starting cluster for the file data
static CLUSTER _dirFindFileInSector(const DIR_ENTRY *fileEntry,const  char *fatname, DIR_POSITION *loc){

	for(uint8_t c=0; c<16; c++,fileEntry++){
     21e:	d3 94       	inc	r13
     220:	a0 96       	adiw	r28, 0x20	; 32
     222:	f0 e1       	ldi	r31, 0x10	; 16
     224:	df 12       	cpse	r13, r31
     226:	00 c0       	rjmp	.+0      	; 0x228 <_dirFindFileInSector+0x6c>
					return firstCluster;
				}
			}
		}
	}
	return(0);
     228:	00 e0       	ldi	r16, 0x00	; 0
     22a:	10 e0       	ldi	r17, 0x00	; 0
     22c:	98 01       	movw	r18, r16
     22e:	00 c0       	rjmp	.+0      	; 0x230 <_dirFindFileInSector+0x74>
				}

				CLUSTER firstCluster=(((CLUSTER )fileEntry->firstClusterHigh)<<16)+ fileEntry->firstClusterLow;

				if(firstCluster==0){
					return(1); /* Lie about cluster, 0 means not found! */
     230:	01 e0       	ldi	r16, 0x01	; 1
     232:	10 e0       	ldi	r17, 0x00	; 0
     234:	20 e0       	ldi	r18, 0x00	; 0
     236:	30 e0       	ldi	r19, 0x00	; 0
				}
			}
		}
	}
	return(0);
}
     238:	b8 01       	movw	r22, r16
     23a:	c9 01       	movw	r24, r18
     23c:	df 91       	pop	r29
     23e:	cf 91       	pop	r28
     240:	1f 91       	pop	r17
     242:	0f 91       	pop	r16
     244:	ff 90       	pop	r15
     246:	ef 90       	pop	r14
     248:	df 90       	pop	r13
     24a:	08 95       	ret

0000024c <_ioFlushSector>:
	return(null);
}

// Write sector to physical device and mark as non-writeable
// if its no longer used
static boolean _ioFlushSector(const DISK *disc, BUFFER* buffer){
     24c:	ff 92       	push	r15
     24e:	0f 93       	push	r16
     250:	1f 93       	push	r17
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	8c 01       	movw	r16, r24
     258:	eb 01       	movw	r28, r22

	// Make sure the buffer is writeable
	if(!_bufferIsWritable(buffer)){
     25a:	cb 01       	movw	r24, r22
     25c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     260:	81 11       	cpse	r24, r1
     262:	00 c0       	rjmp	.+0      	; 0x264 <_ioFlushSector+0x18>
		// Trying to write readonly data
		return(FALSE);
     264:	80 e0       	ldi	r24, 0x00	; 0
     266:	00 c0       	rjmp	.+0      	; 0x268 <_ioFlushSector+0x1c>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("[w%lu]",absSector);
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);
     268:	d8 01       	movw	r26, r16
     26a:	ed 91       	ld	r30, X+
     26c:	fc 91       	ld	r31, X
     26e:	32 96       	adiw	r30, 0x02	; 2
     270:	a5 91       	lpm	r26, Z+
     272:	b4 91       	lpm	r27, Z
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     274:	9e 01       	movw	r18, r28
     276:	26 5e       	subi	r18, 0xE6	; 230
     278:	3f 4f       	sbci	r19, 0xFF	; 255
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     27a:	89 81       	ldd	r24, Y+1	; 0x01
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     27c:	66 e0       	ldi	r22, 0x06	; 6
     27e:	f6 2e       	mov	r15, r22
     280:	fe 01       	movw	r30, r28
     282:	f8 9e       	mul	r15, r24
     284:	e0 0d       	add	r30, r0
     286:	f1 1d       	adc	r31, r1
     288:	11 24       	eor	r1, r1
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);

	return write(disc->device,absSector,dta);
     28a:	42 81       	ldd	r20, Z+2	; 0x02
     28c:	53 81       	ldd	r21, Z+3	; 0x03
     28e:	64 81       	ldd	r22, Z+4	; 0x04
     290:	75 81       	ldd	r23, Z+5	; 0x05
     292:	f8 01       	movw	r30, r16
     294:	82 81       	ldd	r24, Z+2	; 0x02
     296:	93 81       	ldd	r25, Z+3	; 0x03
     298:	fd 01       	movw	r30, r26
     29a:	09 95       	icall
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     29c:	88 23       	and	r24, r24
     29e:	01 f0       	breq	.+0      	; 0x2a0 <_ioFlushSector+0x54>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     2a2:	f8 9e       	mul	r15, r24
     2a4:	c0 0d       	add	r28, r0
     2a6:	d1 1d       	adc	r29, r1
     2a8:	11 24       	eor	r1, r1
     2aa:	22 96       	adiw	r28, 0x02	; 2
		// Write error
		return(FALSE);
	}

	// If its no longer used then no need to write it later
	if(_bufferGetUsageCount(buffer) == 0){
     2ac:	8c 81       	ldd	r24, Y+4	; 0x04
     2ae:	81 11       	cpse	r24, r1
     2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <_ioFlushSector+0x66>
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
}
static void _bufferSetNotWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 0;
     2b2:	8d 81       	ldd	r24, Y+5	; 0x05
     2b4:	8d 7f       	andi	r24, 0xFD	; 253
     2b6:	8d 83       	std	Y+5, r24	; 0x05
		// Write error
		return(FALSE);
	}

	// If its no longer used then no need to write it later
	if(_bufferGetUsageCount(buffer) == 0){
     2b8:	8f ef       	ldi	r24, 0xFF	; 255
		_bufferSetNotWritable(buffer);
	}
	return(TRUE);
}
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	1f 91       	pop	r17
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
     2c4:	08 95       	ret

000002c6 <_fileValidateChar.part.6>:
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
		return (c-'a'+'A');

    if(c=='-' || c=='_' || c=='~' || (c>='0' && c<='9') || (c>='A' && c<='Z')){
     2c6:	8d 32       	cpi	r24, 0x2D	; 45
     2c8:	01 f0       	breq	.+0      	; 0x2ca <_fileValidateChar.part.6+0x4>
     2ca:	8f 35       	cpi	r24, 0x5F	; 95
     2cc:	01 f0       	breq	.+0      	; 0x2ce <_fileValidateChar.part.6+0x8>
     2ce:	8e 37       	cpi	r24, 0x7E	; 126
     2d0:	01 f0       	breq	.+0      	; 0x2d2 <_fileValidateChar.part.6+0xc>
     2d2:	98 2f       	mov	r25, r24
     2d4:	90 53       	subi	r25, 0x30	; 48
     2d6:	9a 30       	cpi	r25, 0x0A	; 10
     2d8:	00 f0       	brcs	.+0      	; 0x2da <_fileValidateChar.part.6+0x14>
     2da:	91 51       	subi	r25, 0x11	; 17
     2dc:	9a 31       	cpi	r25, 0x1A	; 26
     2de:	00 f0       	brcs	.+0      	; 0x2e0 <_fileValidateChar.part.6+0x1a>
    	return c;
    }

	return('_');
     2e0:	8f e5       	ldi	r24, 0x5F	; 95
}
     2e2:	08 95       	ret

000002e4 <_fileUserToFatName>:

// Convert a filename into how it would appear on disk
// Returns the string following the filenane
static const char* _fileUserToFatName(const char* filename,char* fatfilename){
     2e4:	af 92       	push	r10
     2e6:	bf 92       	push	r11
     2e8:	cf 92       	push	r12
     2ea:	df 92       	push	r13
     2ec:	ef 92       	push	r14
     2ee:	ff 92       	push	r15
     2f0:	0f 93       	push	r16
     2f2:	1f 93       	push	r17
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	1f 92       	push	r1
     2fa:	cd b7       	in	r28, 0x3d	; 61
     2fc:	de b7       	in	r29, 0x3e	; 62
     2fe:	8c 01       	movw	r16, r24
     300:	5b 01       	movw	r10, r22
	boolean inXtn=FALSE; // are we doing the file extension
	boolean valid=FALSE; // is the file valid

	// Zap the filename
	memset(fatfilename,' ',11);
     302:	4b e0       	ldi	r20, 0x0B	; 11
     304:	50 e0       	ldi	r21, 0x00	; 0
     306:	60 e2       	ldi	r22, 0x20	; 32
     308:	70 e0       	ldi	r23, 0x00	; 0
     30a:	c5 01       	movw	r24, r10
     30c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

	uint8_t c=0;		// offset to write into the filename

	if(*filename == '.'){
     310:	d8 01       	movw	r26, r16
     312:	8c 91       	ld	r24, X
     314:	8e 32       	cpi	r24, 0x2E	; 46
     316:	01 f0       	breq	.+0      	; 0x318 <_fileUserToFatName+0x34>
     318:	d1 2c       	mov	r13, r1
     31a:	c1 2c       	mov	r12, r1
     31c:	90 e0       	ldi	r25, 0x00	; 0
     31e:	00 c0       	rjmp	.+0      	; 0x320 <_fileUserToFatName+0x3c>
		// Check for '.' or '..'
		fatfilename[0]='.';
     320:	f5 01       	movw	r30, r10
     322:	80 83       	st	Z, r24
		valid=TRUE;
		if(*(filename+1) == '.'){
     324:	d8 01       	movw	r26, r16
     326:	11 96       	adiw	r26, 0x01	; 1
     328:	8c 91       	ld	r24, X
     32a:	8e 32       	cpi	r24, 0x2E	; 46
     32c:	01 f4       	brne	.+0      	; 0x32e <_fileUserToFatName+0x4a>
			fatfilename[1]='.';
     32e:	81 83       	std	Z+1, r24	; 0x01
			filename+=2;
     330:	f8 01       	movw	r30, r16
     332:	32 96       	adiw	r30, 0x02	; 2
     334:	00 c0       	rjmp	.+0      	; 0x336 <_fileUserToFatName+0x52>
		}else{
			filename++;
     336:	f8 01       	movw	r30, r16
     338:	31 96       	adiw	r30, 0x01	; 1
     33a:	00 c0       	rjmp	.+0      	; 0x33c <_fileUserToFatName+0x58>
		}
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
			if(*filename=='.' && !inXtn){
     33c:	8e 32       	cpi	r24, 0x2E	; 46
     33e:	01 f4       	brne	.+0      	; 0x340 <_fileUserToFatName+0x5c>
     340:	99 23       	and	r25, r25
     342:	01 f0       	breq	.+0      	; 0x344 <_fileUserToFatName+0x60>
     344:	00 c0       	rjmp	.+0      	; 0x346 <_fileUserToFatName+0x62>
				// If we've found the first dot then move to extension
				inXtn=TRUE;
				c=8;
			}else{
				if(inXtn){
     346:	99 23       	and	r25, r25
     348:	01 f0       	breq	.+0      	; 0x34a <_fileUserToFatName+0x66>
					if(c<=10){
     34a:	ba e0       	ldi	r27, 0x0A	; 10
     34c:	bd 15       	cp	r27, r13
     34e:	00 f0       	brcs	.+0      	; 0x350 <_fileUserToFatName+0x6c>
						fatfilename[c]=_fileValidateChar(*filename);
     350:	75 01       	movw	r14, r10
     352:	ed 0c       	add	r14, r13
     354:	f1 1c       	adc	r15, r1

// Convert a character into a valid uppercase character for a filename
// Invalid characters are changed to an '_'
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
     356:	98 2f       	mov	r25, r24
     358:	91 56       	subi	r25, 0x61	; 97
     35a:	9a 31       	cpi	r25, 0x1A	; 26
     35c:	00 f4       	brcc	.+0      	; 0x35e <_fileUserToFatName+0x7a>
		return (c-'a'+'A');
     35e:	80 52       	subi	r24, 0x20	; 32
     360:	00 c0       	rjmp	.+0      	; 0x362 <_fileUserToFatName+0x7e>
     362:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				inXtn=TRUE;
				c=8;
			}else{
				if(inXtn){
					if(c<=10){
						fatfilename[c]=_fileValidateChar(*filename);
     366:	f7 01       	movw	r30, r14
     368:	80 83       	st	Z, r24
						c++;
     36a:	d3 94       	inc	r13
     36c:	00 c0       	rjmp	.+0      	; 0x36e <_fileUserToFatName+0x8a>
					}
				}else{
					if(c<=7){
     36e:	f7 e0       	ldi	r31, 0x07	; 7
     370:	fd 15       	cp	r31, r13
     372:	00 f0       	brcs	.+0      	; 0x374 <_fileUserToFatName+0x90>
						fatfilename[c]=_fileValidateChar(*filename);
     374:	75 01       	movw	r14, r10
     376:	ed 0c       	add	r14, r13
     378:	f1 1c       	adc	r15, r1

// Convert a character into a valid uppercase character for a filename
// Invalid characters are changed to an '_'
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
     37a:	28 2f       	mov	r18, r24
     37c:	21 56       	subi	r18, 0x61	; 97
     37e:	2a 31       	cpi	r18, 0x1A	; 26
     380:	00 f4       	brcc	.+0      	; 0x382 <_fileUserToFatName+0x9e>
		return (c-'a'+'A');
     382:	80 52       	subi	r24, 0x20	; 32
     384:	00 c0       	rjmp	.+0      	; 0x386 <_fileUserToFatName+0xa2>
     386:	99 83       	std	Y+1, r25	; 0x01
     388:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     38c:	99 81       	ldd	r25, Y+1	; 0x01
						fatfilename[c]=_fileValidateChar(*filename);
						c++;
					}
				}else{
					if(c<=7){
						fatfilename[c]=_fileValidateChar(*filename);
     38e:	d7 01       	movw	r26, r14
     390:	8c 93       	st	X, r24
						c++;
     392:	d3 94       	inc	r13
						valid=TRUE;
     394:	cc 24       	eor	r12, r12
     396:	ca 94       	dec	r12
     398:	00 c0       	rjmp	.+0      	; 0x39a <_fileUserToFatName+0xb6>
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
			if(*filename=='.' && !inXtn){
				// If we've found the first dot then move to extension
				inXtn=TRUE;
				c=8;
     39a:	78 e0       	ldi	r23, 0x08	; 8
     39c:	d7 2e       	mov	r13, r23
			}else{
				if(inXtn){
					if(c<=10){
     39e:	9f ef       	ldi	r25, 0xFF	; 255
     3a0:	f8 01       	movw	r30, r16
			filename+=2;
		}else{
			filename++;
		}
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
     3a2:	d8 01       	movw	r26, r16
     3a4:	8d 91       	ld	r24, X+
     3a6:	8d 01       	movw	r16, r26
     3a8:	81 11       	cpse	r24, r1
     3aa:	00 c0       	rjmp	.+0      	; 0x3ac <_fileUserToFatName+0xc8>
			}
			filename++;
		}
	}

	if(valid){
     3ac:	c1 10       	cpse	r12, r1
     3ae:	00 c0       	rjmp	.+0      	; 0x3b0 <_fileUserToFatName+0xcc>
			return(filename);
		}else{
			return(filename+1);
		}
	}else{
		return(0);
     3b0:	e0 e0       	ldi	r30, 0x00	; 0
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	00 c0       	rjmp	.+0      	; 0x3b6 <_fileUserToFatName+0xd2>
			filename+=2;
		}else{
			filename++;
		}
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
     3b6:	80 32       	cpi	r24, 0x20	; 32
     3b8:	01 f0       	breq	.+0      	; 0x3ba <_fileUserToFatName+0xd6>
     3ba:	8f 32       	cpi	r24, 0x2F	; 47
     3bc:	01 f0       	breq	.+0      	; 0x3be <_fileUserToFatName+0xda>
     3be:	00 c0       	rjmp	.+0      	; 0x3c0 <_fileUserToFatName+0xdc>
     3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <_fileUserToFatName+0xde>
			filename++;
		}
	}

	if(valid){
		if(*filename=='\0'){
     3c2:	80 81       	ld	r24, Z
     3c4:	81 11       	cpse	r24, r1
			return(filename);
		}else{
			return(filename+1);
     3c6:	31 96       	adiw	r30, 0x01	; 1
		}
	}else{
		return(0);
	}
}
     3c8:	cf 01       	movw	r24, r30
     3ca:	0f 90       	pop	r0
     3cc:	df 91       	pop	r29
     3ce:	cf 91       	pop	r28
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	08 95       	ret

000003e2 <_ioPutSectorInCache>:
		_bufferSetNotWritable(buffer);
	}
	return(TRUE);
}

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){
     3e2:	cf 92       	push	r12
     3e4:	df 92       	push	r13
     3e6:	ef 92       	push	r14
     3e8:	ff 92       	push	r15
     3ea:	0f 93       	push	r16
     3ec:	1f 93       	push	r17
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	dc 01       	movw	r26, r24
     3f4:	eb 01       	movw	r28, r22
     3f6:	69 01       	movw	r12, r18
     3f8:	7a 01       	movw	r14, r20
		rprintf("[r%lu]",absSector);
		rprintfInit(old);}
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);
     3fa:	ed 91       	ld	r30, X+
     3fc:	fc 91       	ld	r31, X
     3fe:	11 97       	sbiw	r26, 0x01	; 1
     400:	05 91       	lpm	r16, Z+
     402:	14 91       	lpm	r17, Z
}

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
     404:	9b 01       	movw	r18, r22
     406:	26 5e       	subi	r18, 0xE6	; 230
     408:	3f 4f       	sbci	r19, 0xFF	; 255
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);

	return read(disc->device,absSector,dta);
     40a:	b7 01       	movw	r22, r14
     40c:	a6 01       	movw	r20, r12
     40e:	12 96       	adiw	r26, 0x02	; 2
     410:	8d 91       	ld	r24, X+
     412:	9c 91       	ld	r25, X
     414:	13 97       	sbiw	r26, 0x03	; 3
     416:	f8 01       	movw	r30, r16
     418:	09 95       	icall
}

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
     41a:	88 23       	and	r24, r24
     41c:	01 f0       	breq	.+0      	; 0x41e <_ioPutSectorInCache+0x3c>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     41e:	99 81       	ldd	r25, Y+1	; 0x01
}

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
     420:	86 e0       	ldi	r24, 0x06	; 6
     422:	fe 01       	movw	r30, r28
     424:	89 9f       	mul	r24, r25
     426:	e0 0d       	add	r30, r0
     428:	f1 1d       	adc	r31, r1
     42a:	11 24       	eor	r1, r1
     42c:	32 96       	adiw	r30, 0x02	; 2
     42e:	95 81       	ldd	r25, Z+5	; 0x05
     430:	91 60       	ori	r25, 0x01	; 1
     432:	95 83       	std	Z+5, r25	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     434:	99 81       	ldd	r25, Y+1	; 0x01

	// Indicate the buffer is 'in-use'
	_bufferSetValid(buffer);

	// And remember its sector address
	_bufferCurrentStackEntry(buffer)->sector = absSector;
     436:	89 9f       	mul	r24, r25
     438:	c0 0d       	add	r28, r0
     43a:	d1 1d       	adc	r29, r1
     43c:	11 24       	eor	r1, r1
     43e:	ca 82       	std	Y+2, r12	; 0x02
     440:	db 82       	std	Y+3, r13	; 0x03
     442:	ec 82       	std	Y+4, r14	; 0x04
     444:	fd 82       	std	Y+5, r15	; 0x05
     446:	8f ef       	ldi	r24, 0xFF	; 255
     448:	00 c0       	rjmp	.+0      	; 0x44a <_ioPutSectorInCache+0x68>

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
		return(FALSE);
     44a:	80 e0       	ldi	r24, 0x00	; 0

	// And remember its sector address
	_bufferCurrentStackEntry(buffer)->sector = absSector;

	return(TRUE);
}
     44c:	df 91       	pop	r29
     44e:	cf 91       	pop	r28
     450:	1f 91       	pop	r17
     452:	0f 91       	pop	r16
     454:	ff 90       	pop	r15
     456:	ef 90       	pop	r14
     458:	df 90       	pop	r13
     45a:	cf 90       	pop	r12
     45c:	08 95       	ret

0000045e <_ioGetSector>:
// and return its address.
// Each call should have its own matching releaseSector command
// disc 		- The disc
// absSector	- The absolute sector on the entire disc
// mode			- The mode in which the sector will be used
static void* _ioGetSector(const DISK* disc,SECTOR absSector, uint8_t mode){
     45e:	3f 92       	push	r3
     460:	4f 92       	push	r4
     462:	5f 92       	push	r5
     464:	6f 92       	push	r6
     466:	7f 92       	push	r7
     468:	8f 92       	push	r8
     46a:	9f 92       	push	r9
     46c:	af 92       	push	r10
     46e:	bf 92       	push	r11
     470:	cf 92       	push	r12
     472:	df 92       	push	r13
     474:	ef 92       	push	r14
     476:	ff 92       	push	r15
     478:	0f 93       	push	r16
     47a:	1f 93       	push	r17
     47c:	cf 93       	push	r28
     47e:	df 93       	push	r29
     480:	00 d0       	rcall	.+0      	; 0x482 <_ioGetSector+0x24>
     482:	00 d0       	rcall	.+0      	; 0x484 <_ioGetSector+0x26>
     484:	1f 92       	push	r1
     486:	cd b7       	in	r28, 0x3d	; 61
     488:	de b7       	in	r29, 0x3e	; 62
     48a:	5c 01       	movw	r10, r24
     48c:	6a 01       	movw	r12, r20
     48e:	7b 01       	movw	r14, r22
     490:	52 2e       	mov	r5, r18
	BUFFER* buffer;

	// Find the buffer containing the sector
	buffer = _ioFindSectorInCache(disc,absSector);
     492:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     496:	9b 83       	std	Y+3, r25	; 0x03
     498:	8a 83       	std	Y+2, r24	; 0x02

	if(buffer){
     49a:	89 2b       	or	r24, r25
     49c:	01 f0       	breq	.+0      	; 0x49e <_ioGetSector+0x40>
     49e:	00 c0       	rjmp	.+0      	; 0x4a0 <_ioGetSector+0x42>
		// Its already in memory
		goto inRAM;
	}

	// Find an unused buffer or flush the most recently used
	buffer = _bufferFindUnused(disc);
     4a0:	c5 01       	movw	r24, r10
     4a2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     4a6:	8c 01       	movw	r16, r24
	if(!buffer){
     4a8:	00 97       	sbiw	r24, 0x00	; 0
     4aa:	01 f0       	breq	.+0      	; 0x4ac <_ioGetSector+0x4e>
     4ac:	00 c0       	rjmp	.+0      	; 0x4ae <_ioGetSector+0x50>
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     4ae:	f5 01       	movw	r30, r10
     4b0:	84 a8       	ldd	r8, Z+52	; 0x34
     4b2:	95 a8       	ldd	r9, Z+53	; 0x35
     4b4:	63 a8       	ldd	r6, Z+51	; 0x33
     4b6:	a4 01       	movw	r20, r8
     4b8:	41 2c       	mov	r4, r1

// Find the least recently used buffer - giving preference to any read only entries
static BUFFER* _ioFindLeastRecentlyUsedBuffer(const DISK* disc){
	BUFFER* rtn=null;
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
     4ba:	77 24       	eor	r7, r7
     4bc:	7a 94       	dec	r7


// Find the least recently used buffer - giving preference to any read only entries
static BUFFER* _ioFindLeastRecentlyUsedBuffer(const DISK* disc){
	BUFFER* rtn=null;
	boolean foundAReadOnly=FALSE;
     4be:	30 e0       	ldi	r19, 0x00	; 0
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     4c0:	f6 e0       	ldi	r31, 0x06	; 6
     4c2:	3f 2e       	mov	r3, r31
     4c4:	00 c0       	rjmp	.+0      	; 0x4c6 <_ioGetSector+0x68>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     4c6:	fa 01       	movw	r30, r20
     4c8:	81 81       	ldd	r24, Z+1	; 0x01
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     4ca:	38 9e       	mul	r3, r24
     4cc:	e0 0d       	add	r30, r0
     4ce:	f1 1d       	adc	r31, r1
     4d0:	11 24       	eor	r1, r1
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
		if(_bufferGetUsageCount(buffer)==0){
     4d2:	86 81       	ldd	r24, Z+6	; 0x06
     4d4:	81 11       	cpse	r24, r1
     4d6:	00 c0       	rjmp	.+0      	; 0x4d8 <_ioGetSector+0x7a>
			// Nothing uses the data in this buffer

			if(!_bufferIsWritable(buffer)){
     4d8:	ca 01       	movw	r24, r20
     4da:	3d 83       	std	Y+5, r19	; 0x05
     4dc:	49 83       	std	Y+1, r20	; 0x01
     4de:	5c 83       	std	Y+4, r21	; 0x04
     4e0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     4e4:	3d 81       	ldd	r19, Y+5	; 0x05
     4e6:	49 81       	ldd	r20, Y+1	; 0x01
     4e8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ea:	81 11       	cpse	r24, r1
     4ec:	00 c0       	rjmp	.+0      	; 0x4ee <_ioGetSector+0x90>
				// This is a readonly buffer
				if(!foundAReadOnly || _bufferGetReferenceCount(buffer)<=refCount ){
     4ee:	33 23       	and	r19, r19
     4f0:	01 f0       	breq	.+0      	; 0x4f2 <_ioGetSector+0x94>
     4f2:	fa 01       	movw	r30, r20
     4f4:	80 81       	ld	r24, Z
     4f6:	78 16       	cp	r7, r24
     4f8:	00 f0       	brcs	.+0      	; 0x4fa <_ioGetSector+0x9c>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     4fa:	fa 01       	movw	r30, r20
     4fc:	70 80       	ld	r7, Z
			if(!_bufferIsWritable(buffer)){
				// This is a readonly buffer
				if(!foundAReadOnly || _bufferGetReferenceCount(buffer)<=refCount ){
					// This is the best so far
					foundAReadOnly=TRUE;
					rtn=buffer;
     4fe:	8a 01       	movw	r16, r20
     500:	00 c0       	rjmp	.+0      	; 0x502 <_ioGetSector+0xa4>
					refCount=_bufferGetReferenceCount(buffer);
				}
			}else{
				// This is a writable buffer
				if(!foundAReadOnly && _bufferGetReferenceCount(buffer)<=refCount){
     502:	31 11       	cpse	r19, r1
     504:	00 c0       	rjmp	.+0      	; 0x506 <_ioGetSector+0xa8>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     506:	fa 01       	movw	r30, r20
     508:	80 81       	ld	r24, Z
					rtn=buffer;
					refCount=_bufferGetReferenceCount(buffer);
				}
			}else{
				// This is a writable buffer
				if(!foundAReadOnly && _bufferGetReferenceCount(buffer)<=refCount){
     50a:	78 16       	cp	r7, r24
     50c:	00 f4       	brcc	.+0      	; 0x50e <_ioGetSector+0xb0>
     50e:	00 c0       	rjmp	.+0      	; 0x510 <_ioGetSector+0xb2>
     510:	3f ef       	ldi	r19, 0xFF	; 255
     512:	00 c0       	rjmp	.+0      	; 0x514 <_ioGetSector+0xb6>
     514:	78 2e       	mov	r7, r24
					// This is the best writable buffer
					rtn=buffer;
     516:	8a 01       	movw	r16, r20
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     518:	43 94       	inc	r4
     51a:	46 5e       	subi	r20, 0xE6	; 230
     51c:	5d 4f       	sbci	r21, 0xFD	; 253
     51e:	46 10       	cpse	r4, r6
     520:	00 c0       	rjmp	.+0      	; 0x522 <_ioGetSector+0xc4>
     522:	1b 83       	std	Y+3, r17	; 0x03
     524:	0a 83       	std	Y+2, r16	; 0x02
		// All buffers are in use

		// Find the least recently used buffer which has no references to it
		buffer = _ioFindLeastRecentlyUsedBuffer(disc);

		if(buffer && _bufferIsWritable(buffer)){
     526:	01 15       	cp	r16, r1
     528:	11 05       	cpc	r17, r1
     52a:	01 f0       	breq	.+0      	; 0x52c <_ioGetSector+0xce>
     52c:	c8 01       	movw	r24, r16
     52e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     532:	88 23       	and	r24, r24
     534:	01 f4       	brne	.+0      	; 0x536 <_ioGetSector+0xd8>
     536:	00 c0       	rjmp	.+0      	; 0x538 <_ioGetSector+0xda>
			// Write it to the physical device
			_ioFlushSector(disc,buffer);
     538:	b8 01       	movw	r22, r16
     53a:	c5 01       	movw	r24, r10
     53c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     540:	00 c0       	rjmp	.+0      	; 0x542 <_ioGetSector+0xe4>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     542:	f4 01       	movw	r30, r8
     544:	31 80       	ldd	r3, Z+1	; 0x01
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		uint8_t stackDepth = _bufferGetStackDepth(buffer);
		if( stackDepth < MAX_STACK_DEPTH){
     546:	f3 e0       	ldi	r31, 0x03	; 3
     548:	f3 15       	cp	r31, r3
     54a:	00 f0       	brcs	.+0      	; 0x54c <_ioGetSector+0xee>
			// Calc the score for this buffer
			uint8_t points = 0;

			// Give it a 50% score if writable so that read only
			// buffers will always be selected in preference
			if(_bufferIsWritable(buffer)){
     54c:	c4 01       	movw	r24, r8
     54e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     552:	81 11       	cpse	r24, r1
     554:	00 c0       	rjmp	.+0      	; 0x556 <_ioGetSector+0xf8>

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		uint8_t stackDepth = _bufferGetStackDepth(buffer);
		if( stackDepth < MAX_STACK_DEPTH){
			// Calc the score for this buffer
			uint8_t points = 0;
     556:	20 e0       	ldi	r18, 0x00	; 0
     558:	00 c0       	rjmp	.+0      	; 0x55a <_ioGetSector+0xfc>

			// Give it a 50% score if writable so that read only
			// buffers will always be selected in preference
			if(_bufferIsWritable(buffer)){
				points+=0x7F;
     55a:	2f e7       	ldi	r18, 0x7F	; 127
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     55c:	f4 01       	movw	r30, r8
     55e:	80 81       	ld	r24, Z
			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     560:	f3 e3       	ldi	r31, 0x33	; 51
     562:	8f 9f       	mul	r24, r31
     564:	c0 01       	movw	r24, r0
     566:	11 24       	eor	r1, r1
     568:	b8 01       	movw	r22, r16
     56a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				points+=0x7F;
			}

			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);
     56e:	3d e4       	ldi	r19, 0x4D	; 77
     570:	33 9e       	mul	r3, r19
     572:	c0 01       	movw	r24, r0
     574:	11 24       	eor	r1, r1
     576:	96 95       	lsr	r25
     578:	87 95       	ror	r24
     57a:	96 95       	lsr	r25
     57c:	87 95       	ror	r24
     57e:	86 0f       	add	r24, r22

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     580:	82 0f       	add	r24, r18

			// Keep the smallest score
			if(points<leastPoint){
     582:	84 15       	cp	r24, r4
     584:	00 f4       	brcc	.+0      	; 0x586 <_ioGetSector+0x128>
				leastPoint=points;
				rtn=buffer;
     586:	9b 82       	std	Y+3, r9	; 0x03
     588:	8a 82       	std	Y+2, r8	; 0x02

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;

			// Keep the smallest score
			if(points<leastPoint){
     58a:	48 2e       	mov	r4, r24
	uint8_t leastPoint=MAX_U08;
	uint8_t bufferNum;
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
     58c:	73 94       	inc	r7
     58e:	86 ee       	ldi	r24, 0xE6	; 230
     590:	88 1a       	sub	r8, r24
     592:	8d ef       	ldi	r24, 0xFD	; 253
     594:	98 0a       	sbc	r9, r24
     596:	00 c0       	rjmp	.+0      	; 0x598 <_ioGetSector+0x13a>
		// All buffers are in use

		// Find the least recently used buffer which has no references to it
		buffer = _ioFindLeastRecentlyUsedBuffer(disc);

		if(buffer && _bufferIsWritable(buffer)){
     598:	71 2c       	mov	r7, r1
     59a:	44 24       	eor	r4, r4
     59c:	4a 94       	dec	r4
			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     59e:	0f ef       	ldi	r16, 0xFF	; 255
     5a0:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t leastPoint=MAX_U08;
	uint8_t bufferNum;
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
     5a2:	76 10       	cpse	r7, r6
     5a4:	00 c0       	rjmp	.+0      	; 0x5a6 <_ioGetSector+0x148>
		goto readIt;
	}

	// All buffers are currently used and referenced by code
	buffer=_ioFindStackableBuffer(disc);
	if(buffer){
     5a6:	ea 81       	ldd	r30, Y+2	; 0x02
     5a8:	fb 81       	ldd	r31, Y+3	; 0x03
     5aa:	ef 2b       	or	r30, r31
     5ac:	01 f4       	brne	.+0      	; 0x5ae <_ioGetSector+0x150>
		// Return address of sector in RAM
		return(buffer->dta);
	}

	// No memory available
	return null;
     5ae:	80 e0       	ldi	r24, 0x00	; 0
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	00 c0       	rjmp	.+0      	; 0x5b4 <_ioGetSector+0x156>
	}

	// All buffers are currently used and referenced by code
	buffer=_ioFindStackableBuffer(disc);
	if(buffer){
		if(_bufferIsWritable(buffer)){
     5b4:	8a 81       	ldd	r24, Y+2	; 0x02
     5b6:	9b 81       	ldd	r25, Y+3	; 0x03
     5b8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     5bc:	88 23       	and	r24, r24
     5be:	01 f0       	breq	.+0      	; 0x5c0 <_ioGetSector+0x162>
			_ioFlushSector(disc,buffer);
     5c0:	6a 81       	ldd	r22, Y+2	; 0x02
     5c2:	7b 81       	ldd	r23, Y+3	; 0x03
     5c4:	c5 01       	movw	r24, r10
     5c6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	memclr(current,sizeof(SECTOR_BUFFER));
	buffer->reference = 0;
}

static boolean _bufferPush(BUFFER* buffer){
	if(buffer->depth >= MAX_STACK_DEPTH){
     5ca:	ea 81       	ldd	r30, Y+2	; 0x02
     5cc:	fb 81       	ldd	r31, Y+3	; 0x03
     5ce:	81 81       	ldd	r24, Z+1	; 0x01
     5d0:	84 30       	cpi	r24, 0x04	; 4
     5d2:	00 f4       	brcc	.+0      	; 0x5d4 <_ioGetSector+0x176>
		// The iteration number is invalid
		return(FALSE);
	}

	// Increment the stack position and reset the current data
	buffer->depth++;
     5d4:	8f 5f       	subi	r24, 0xFF	; 255
     5d6:	81 83       	std	Z+1, r24	; 0x01
	_bufferReset(buffer);
     5d8:	cf 01       	movw	r24, r30
     5da:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		if(!_bufferPush(buffer)){
			return null;
		}
readIt:
		// Read from physical device into buffer
		if(! _ioPutSectorInCache(disc, buffer,absSector) ){
     5de:	a7 01       	movw	r20, r14
     5e0:	96 01       	movw	r18, r12
     5e2:	6a 81       	ldd	r22, Y+2	; 0x02
     5e4:	7b 81       	ldd	r23, Y+3	; 0x03
     5e6:	c5 01       	movw	r24, r10
     5e8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     5ec:	88 23       	and	r24, r24
     5ee:	01 f0       	breq	.+0      	; 0x5f0 <_ioGetSector+0x192>
			return null;
		}
inRAM:
		// Mark as writable if required
		if(iomgr_isReqRw(mode)){
     5f0:	51 fe       	sbrs	r5, 1
     5f2:	00 c0       	rjmp	.+0      	; 0x5f4 <_ioGetSector+0x196>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     5f4:	ea 81       	ldd	r30, Y+2	; 0x02
     5f6:	fb 81       	ldd	r31, Y+3	; 0x03
     5f8:	81 81       	ldd	r24, Z+1	; 0x01
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
     5fa:	36 e0       	ldi	r19, 0x06	; 6
     5fc:	83 9f       	mul	r24, r19
     5fe:	e0 0d       	add	r30, r0
     600:	f1 1d       	adc	r31, r1
     602:	11 24       	eor	r1, r1
     604:	32 96       	adiw	r30, 0x02	; 2
     606:	85 81       	ldd	r24, Z+5	; 0x05
     608:	82 60       	ori	r24, 0x02	; 2
     60a:	85 83       	std	Z+5, r24	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     60c:	ea 81       	ldd	r30, Y+2	; 0x02
     60e:	fb 81       	ldd	r31, Y+3	; 0x03
     610:	81 81       	ldd	r24, Z+1	; 0x01
		if(iomgr_isReqRw(mode)){
			_bufferSetWritable(buffer);
		}

		// Increment usage count
		SECTOR_BUFFER* sb = _bufferCurrentStackEntry(buffer);
     612:	36 e0       	ldi	r19, 0x06	; 6
     614:	83 9f       	mul	r24, r19
     616:	e0 0d       	add	r30, r0
     618:	f1 1d       	adc	r31, r1
     61a:	11 24       	eor	r1, r1
     61c:	32 96       	adiw	r30, 0x02	; 2
		if(++(sb->usage) == 0){
     61e:	84 81       	ldd	r24, Z+4	; 0x04
     620:	8f 5f       	subi	r24, 0xFF	; 255
     622:	01 f0       	breq	.+0      	; 0x624 <_ioGetSector+0x1c6>
     624:	84 83       	std	Z+4, r24	; 0x04
			(sb->usage)--;
		}


		// increment ref count
		if(++(buffer->reference) == 0){
     626:	ea 81       	ldd	r30, Y+2	; 0x02
     628:	fb 81       	ldd	r31, Y+3	; 0x03
     62a:	80 81       	ld	r24, Z
     62c:	8f 5f       	subi	r24, 0xFF	; 255
     62e:	01 f0       	breq	.+0      	; 0x630 <_ioGetSector+0x1d2>
     630:	80 83       	st	Z, r24
			(buffer->reference)--;
		}


		// Return address of sector in RAM
		return(buffer->dta);
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	4a 96       	adiw	r24, 0x1a	; 26
     638:	00 c0       	rjmp	.+0      	; 0x63a <_ioGetSector+0x1dc>
		}
	}

	if(buffer){
		// Mark buffer as unused
		_bufferReset(buffer);
     63a:	c8 01       	movw	r24, r16
     63c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		goto readIt;
     640:	1b 83       	std	Y+3, r17	; 0x03
     642:	0a 83       	std	Y+2, r16	; 0x02
     644:	00 c0       	rjmp	.+0      	; 0x646 <_ioGetSector+0x1e8>
		return(buffer->dta);
	}

	// No memory available
	return null;
}
     646:	0f 90       	pop	r0
     648:	0f 90       	pop	r0
     64a:	0f 90       	pop	r0
     64c:	0f 90       	pop	r0
     64e:	0f 90       	pop	r0
     650:	df 91       	pop	r29
     652:	cf 91       	pop	r28
     654:	1f 91       	pop	r17
     656:	0f 91       	pop	r16
     658:	ff 90       	pop	r15
     65a:	ef 90       	pop	r14
     65c:	df 90       	pop	r13
     65e:	cf 90       	pop	r12
     660:	bf 90       	pop	r11
     662:	af 90       	pop	r10
     664:	9f 90       	pop	r9
     666:	8f 90       	pop	r8
     668:	7f 90       	pop	r7
     66a:	6f 90       	pop	r6
     66c:	5f 90       	pop	r5
     66e:	4f 90       	pop	r4
     670:	3f 90       	pop	r3
     672:	08 95       	ret

00000674 <_diskClusterToSector>:
	disc->initialised = rtn;
	return rtn;
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
     674:	8f 92       	push	r8
     676:	9f 92       	push	r9
     678:	af 92       	push	r10
     67a:	bf 92       	push	r11
     67c:	cf 92       	push	r12
     67e:	df 92       	push	r13
     680:	ef 92       	push	r14
     682:	ff 92       	push	r15
     684:	0f 93       	push	r16
     686:	1f 93       	push	r17
     688:	fc 01       	movw	r30, r24
     68a:	4a 01       	movw	r8, r20
     68c:	5b 01       	movw	r10, r22
	SECTOR base=
		disk->volume.reservedSectorCount+
		disk->fatSectorCount * disk->volume.numberOfFats;
     68e:	a3 89       	ldd	r26, Z+19	; 0x13
     690:	22 8d       	ldd	r18, Z+26	; 0x1a
     692:	33 8d       	ldd	r19, Z+27	; 0x1b
     694:	44 8d       	ldd	r20, Z+28	; 0x1c
     696:	55 8d       	ldd	r21, Z+29	; 0x1d
     698:	b0 e0       	ldi	r27, 0x00	; 0
     69a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     69e:	6b 01       	movw	r12, r22
     6a0:	7c 01       	movw	r14, r24
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
	SECTOR base=
		disk->volume.reservedSectorCount+
     6a2:	81 89       	ldd	r24, Z+17	; 0x11
     6a4:	92 89       	ldd	r25, Z+18	; 0x12
	return rtn;
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
	SECTOR base=
     6a6:	c8 0e       	add	r12, r24
     6a8:	d9 1e       	adc	r13, r25
     6aa:	e1 1c       	adc	r14, r1
     6ac:	f1 1c       	adc	r15, r1
		disk->volume.reservedSectorCount+
		disk->fatSectorCount * disk->volume.numberOfFats;

	if(disk->fatType!=32)	{
     6ae:	86 a1       	ldd	r24, Z+38	; 0x26
     6b0:	80 32       	cpi	r24, 0x20	; 32
     6b2:	01 f0       	breq	.+0      	; 0x6b4 <_diskClusterToSector+0x40>
		base += disk->volume.rootDirEntryCount/16;
     6b4:	84 89       	ldd	r24, Z+20	; 0x14
     6b6:	95 89       	ldd	r25, Z+21	; 0x15
     6b8:	a4 e0       	ldi	r26, 0x04	; 4
     6ba:	96 95       	lsr	r25
     6bc:	87 95       	ror	r24
     6be:	aa 95       	dec	r26
     6c0:	01 f4       	brne	.+0      	; 0x6c2 <_diskClusterToSector+0x4e>
     6c2:	c8 0e       	add	r12, r24
     6c4:	d9 1e       	adc	r13, r25
     6c6:	e1 1c       	adc	r14, r1
     6c8:	f1 1c       	adc	r15, r1
	}

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
     6ca:	a5 01       	movw	r20, r10
     6cc:	94 01       	movw	r18, r8
     6ce:	22 50       	subi	r18, 0x02	; 2
     6d0:	31 09       	sbc	r19, r1
     6d2:	41 09       	sbc	r20, r1
     6d4:	51 09       	sbc	r21, r1
     6d6:	a0 89       	ldd	r26, Z+16	; 0x10
     6d8:	b0 e0       	ldi	r27, 0x00	; 0
     6da:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     6de:	8b 01       	movw	r16, r22
     6e0:	9c 01       	movw	r18, r24
     6e2:	0c 0d       	add	r16, r12
     6e4:	1d 1d       	adc	r17, r13
     6e6:	2e 1d       	adc	r18, r14
     6e8:	3f 1d       	adc	r19, r15
}
     6ea:	b8 01       	movw	r22, r16
     6ec:	c9 01       	movw	r24, r18
     6ee:	1f 91       	pop	r17
     6f0:	0f 91       	pop	r16
     6f2:	ff 90       	pop	r15
     6f4:	ef 90       	pop	r14
     6f6:	df 90       	pop	r13
     6f8:	cf 90       	pop	r12
     6fa:	bf 90       	pop	r11
     6fc:	af 90       	pop	r10
     6fe:	9f 90       	pop	r9
     700:	8f 90       	pop	r8
     702:	08 95       	ret

00000704 <diskFlush>:
static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
}

// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
     704:	5f 92       	push	r5
     706:	6f 92       	push	r6
     708:	7f 92       	push	r7
     70a:	8f 92       	push	r8
     70c:	9f 92       	push	r9
     70e:	af 92       	push	r10
     710:	bf 92       	push	r11
     712:	cf 92       	push	r12
     714:	df 92       	push	r13
     716:	ef 92       	push	r14
     718:	ff 92       	push	r15
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	cf 93       	push	r28
     720:	df 93       	push	r29
     722:	8c 01       	movw	r16, r24
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
}

static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
     724:	fc 01       	movw	r30, r24
     726:	c6 80       	ldd	r12, Z+6	; 0x06
     728:	d7 80       	ldd	r13, Z+7	; 0x07
     72a:	e0 84       	ldd	r14, Z+8	; 0x08
     72c:	f1 84       	ldd	r15, Z+9	; 0x09
     72e:	86 8c       	ldd	r8, Z+30	; 0x1e
     730:	97 8c       	ldd	r9, Z+31	; 0x1f
     732:	a0 a0       	ldd	r10, Z+32	; 0x20
     734:	b1 a0       	ldd	r11, Z+33	; 0x21
     736:	8c 0c       	add	r8, r12
     738:	9d 1c       	adc	r9, r13
     73a:	ae 1c       	adc	r10, r14
     73c:	bf 1c       	adc	r11, r15

static boolean _ioFlushRange(const DISK* disk,SECTOR address_low, SECTOR address_high){
	boolean rtn = TRUE;

	// Swap the high/low values if needed
	if(address_low>address_high){
     73e:	8c 14       	cp	r8, r12
     740:	9d 04       	cpc	r9, r13
     742:	ae 04       	cpc	r10, r14
     744:	bf 04       	cpc	r11, r15
     746:	00 f0       	brcs	.+0      	; 0x748 <diskFlush+0x44>
     748:	38 2d       	mov	r19, r8
     74a:	29 2d       	mov	r18, r9
     74c:	9a 2d       	mov	r25, r10
     74e:	8b 2d       	mov	r24, r11
     750:	46 01       	movw	r8, r12
     752:	57 01       	movw	r10, r14
     754:	c3 2e       	mov	r12, r19
     756:	d2 2e       	mov	r13, r18
     758:	e9 2e       	mov	r14, r25
     75a:	f8 2e       	mov	r15, r24
		address_low=address_high;
		address_high=swap;
	}


	BUFFER* buffer = disk->buffers;
     75c:	f8 01       	movw	r30, r16
     75e:	c4 a9       	ldd	r28, Z+52	; 0x34
     760:	d5 a9       	ldd	r29, Z+53	; 0x35
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
     762:	61 2c       	mov	r6, r1
	// Cache is full so write the sector directly from user ram to the physical device
	return _ioWriteSector(disk,address,buf);
}

static boolean _ioFlushRange(const DISK* disk,SECTOR address_low, SECTOR address_high){
	boolean rtn = TRUE;
     764:	77 24       	eor	r7, r7
     766:	7a 94       	dec	r7
	}


	BUFFER* buffer = disk->buffers;
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
		SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
     768:	b6 e0       	ldi	r27, 0x06	; 6
     76a:	5b 2e       	mov	r5, r27
     76c:	00 c0       	rjmp	.+0      	; 0x76e <diskFlush+0x6a>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     76e:	89 81       	ldd	r24, Y+1	; 0x01
	}


	BUFFER* buffer = disk->buffers;
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
		SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
     770:	fe 01       	movw	r30, r28
     772:	58 9e       	mul	r5, r24
     774:	e0 0d       	add	r30, r0
     776:	f1 1d       	adc	r31, r1
     778:	11 24       	eor	r1, r1
		if((current->sector >= address_low) && (current->sector <= address_high) && (_bufferIsWritable(buffer))){
     77a:	42 81       	ldd	r20, Z+2	; 0x02
     77c:	53 81       	ldd	r21, Z+3	; 0x03
     77e:	64 81       	ldd	r22, Z+4	; 0x04
     780:	75 81       	ldd	r23, Z+5	; 0x05
     782:	48 15       	cp	r20, r8
     784:	59 05       	cpc	r21, r9
     786:	6a 05       	cpc	r22, r10
     788:	7b 05       	cpc	r23, r11
     78a:	00 f0       	brcs	.+0      	; 0x78c <diskFlush+0x88>
     78c:	c4 16       	cp	r12, r20
     78e:	d5 06       	cpc	r13, r21
     790:	e6 06       	cpc	r14, r22
     792:	f7 06       	cpc	r15, r23
     794:	00 f0       	brcs	.+0      	; 0x796 <diskFlush+0x92>
     796:	ce 01       	movw	r24, r28
     798:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     79c:	88 23       	and	r24, r24
     79e:	01 f0       	breq	.+0      	; 0x7a0 <diskFlush+0x9c>
			// Flush to the physical device
			rtn &= _ioFlushSector(disk,buffer);
     7a0:	be 01       	movw	r22, r28
     7a2:	c8 01       	movw	r24, r16
     7a4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     7a8:	78 22       	and	r7, r24
		address_high=swap;
	}


	BUFFER* buffer = disk->buffers;
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
     7aa:	63 94       	inc	r6
     7ac:	c6 5e       	subi	r28, 0xE6	; 230
     7ae:	dd 4f       	sbci	r29, 0xFD	; 253
     7b0:	f8 01       	movw	r30, r16
     7b2:	83 a9       	ldd	r24, Z+51	; 0x33
     7b4:	68 16       	cp	r6, r24
     7b6:	00 f0       	brcs	.+0      	; 0x7b8 <diskFlush+0xb4>
}

// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}
     7b8:	87 2d       	mov	r24, r7
     7ba:	df 91       	pop	r29
     7bc:	cf 91       	pop	r28
     7be:	1f 91       	pop	r17
     7c0:	0f 91       	pop	r16
     7c2:	ff 90       	pop	r15
     7c4:	ef 90       	pop	r14
     7c6:	df 90       	pop	r13
     7c8:	cf 90       	pop	r12
     7ca:	bf 90       	pop	r11
     7cc:	af 90       	pop	r10
     7ce:	9f 90       	pop	r9
     7d0:	8f 90       	pop	r8
     7d2:	7f 90       	pop	r7
     7d4:	6f 90       	pop	r6
     7d6:	5f 90       	pop	r5
     7d8:	08 95       	ret

000007da <_ioReleaseSector>:
	// No memory available
	return null;
}

// Indicate that a given sector buffer is no longer required
void _ioReleaseSector(const DISK* disc,const void* buf){
     7da:	0f 93       	push	r16
     7dc:	1f 93       	push	r17
     7de:	cf 93       	push	r28
     7e0:	df 93       	push	r29
     7e2:	8c 01       	movw	r16, r24


static BUFFER* _ioGetBuffer(const DISK* disc, const void* buf){
	uint8_t i;
	BUFFER* buffer;
	for(i=0,buffer=disc->buffers; i<disc->numbuf; i++,buffer++){
     7e4:	fc 01       	movw	r30, r24
     7e6:	c4 a9       	ldd	r28, Z+52	; 0x34
     7e8:	d5 a9       	ldd	r29, Z+53	; 0x35
     7ea:	33 a9       	ldd	r19, Z+51	; 0x33
     7ec:	20 e0       	ldi	r18, 0x00	; 0
     7ee:	00 c0       	rjmp	.+0      	; 0x7f0 <_ioReleaseSector+0x16>
	// No memory available
	return null;
}

// Indicate that a given sector buffer is no longer required
void _ioReleaseSector(const DISK* disc,const void* buf){
     7f0:	ce 01       	movw	r24, r28
     7f2:	4a 96       	adiw	r24, 0x1a	; 26

static BUFFER* _ioGetBuffer(const DISK* disc, const void* buf){
	uint8_t i;
	BUFFER* buffer;
	for(i=0,buffer=disc->buffers; i<disc->numbuf; i++,buffer++){
		if(buf == buffer->dta){
     7f4:	68 17       	cp	r22, r24
     7f6:	79 07       	cpc	r23, r25
     7f8:	01 f0       	breq	.+0      	; 0x7fa <_ioReleaseSector+0x20>


static BUFFER* _ioGetBuffer(const DISK* disc, const void* buf){
	uint8_t i;
	BUFFER* buffer;
	for(i=0,buffer=disc->buffers; i<disc->numbuf; i++,buffer++){
     7fa:	2f 5f       	subi	r18, 0xFF	; 255
     7fc:	c6 5e       	subi	r28, 0xE6	; 230
     7fe:	dd 4f       	sbci	r29, 0xFD	; 253
     800:	23 13       	cpse	r18, r19
     802:	00 c0       	rjmp	.+0      	; 0x804 <_ioReleaseSector+0x2a>
		if(buf == buffer->dta){
			return buffer;
		}
	}
	return(null);
     804:	c0 e0       	ldi	r28, 0x00	; 0
     806:	d0 e0       	ldi	r29, 0x00	; 0
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     808:	89 81       	ldd	r24, Y+1	; 0x01

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
}
static void _bufferDecrementUsageCount(BUFFER* buffer){
	SECTOR_BUFFER* sb = _bufferCurrentStackEntry(buffer);
     80a:	fe 01       	movw	r30, r28
     80c:	96 e0       	ldi	r25, 0x06	; 6
     80e:	89 9f       	mul	r24, r25
     810:	e0 0d       	add	r30, r0
     812:	f1 1d       	adc	r31, r1
     814:	11 24       	eor	r1, r1
     816:	32 96       	adiw	r30, 0x02	; 2
	if(sb->usage != 0){
     818:	84 81       	ldd	r24, Z+4	; 0x04
     81a:	88 23       	and	r24, r24
     81c:	01 f0       	breq	.+0      	; 0x81e <_ioReleaseSector+0x44>
		sb->usage--;
     81e:	81 50       	subi	r24, 0x01	; 1
     820:	84 83       	std	Z+4, r24	; 0x04
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     822:	89 81       	ldd	r24, Y+1	; 0x01
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     824:	fe 01       	movw	r30, r28
     826:	96 e0       	ldi	r25, 0x06	; 6
     828:	89 9f       	mul	r24, r25
     82a:	e0 0d       	add	r30, r0
     82c:	f1 1d       	adc	r31, r1
     82e:	11 24       	eor	r1, r1
	BUFFER* buffer = _ioGetBuffer(disc,buf);

	// Decrement the usage count
	_bufferDecrementUsageCount(buffer);

	if(_bufferGetUsageCount(buffer)==0 && buffer->depth!=0){
     830:	96 81       	ldd	r25, Z+6	; 0x06
     832:	91 11       	cpse	r25, r1
     834:	00 c0       	rjmp	.+0      	; 0x836 <_ioReleaseSector+0x5c>
     836:	88 23       	and	r24, r24
     838:	01 f0       	breq	.+0      	; 0x83a <_ioReleaseSector+0x60>
		// buffer is no longer used - so restore previous

		// Write sector to physical device
		if(_bufferIsWritable(buffer)){
     83a:	ce 01       	movw	r24, r28
     83c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     840:	88 23       	and	r24, r24
     842:	01 f0       	breq	.+0      	; 0x844 <_ioReleaseSector+0x6a>
			_ioFlushSector(disc,buffer);
     844:	be 01       	movw	r22, r28
     846:	c8 01       	movw	r24, r16
     848:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	return(TRUE);
}

static boolean _bufferPop(BUFFER* buffer){
	// Make sure there is something on the stack
	if(buffer->depth==0 || buffer->depth>MAX_STACK_DEPTH){
     84c:	89 81       	ldd	r24, Y+1	; 0x01
     84e:	81 50       	subi	r24, 0x01	; 1
     850:	84 30       	cpi	r24, 0x04	; 4
     852:	00 f4       	brcc	.+0      	; 0x854 <_ioReleaseSector+0x7a>
		return(FALSE);
	}

	// Decrement the stack pointer
	buffer->depth--;
     854:	89 83       	std	Y+1, r24	; 0x01
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     856:	89 81       	ldd	r24, Y+1	; 0x01

		// pop data from the stack
		_bufferPop(buffer);

		// re-read the data for the buffer from the physical device
		_ioPutSectorInCache(disc, buffer, _bufferCurrentStackEntry(buffer)->sector);
     858:	fe 01       	movw	r30, r28
     85a:	96 e0       	ldi	r25, 0x06	; 6
     85c:	89 9f       	mul	r24, r25
     85e:	e0 0d       	add	r30, r0
     860:	f1 1d       	adc	r31, r1
     862:	11 24       	eor	r1, r1
     864:	22 81       	ldd	r18, Z+2	; 0x02
     866:	33 81       	ldd	r19, Z+3	; 0x03
     868:	44 81       	ldd	r20, Z+4	; 0x04
     86a:	55 81       	ldd	r21, Z+5	; 0x05
     86c:	be 01       	movw	r22, r28
     86e:	c8 01       	movw	r24, r16
	}
}
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16

		// pop data from the stack
		_bufferPop(buffer);

		// re-read the data for the buffer from the physical device
		_ioPutSectorInCache(disc, buffer, _bufferCurrentStackEntry(buffer)->sector);
     878:	0c 94 00 00 	jmp	0	; 0x0 <_bufferIsWritable>
	}
}
     87c:	df 91       	pop	r29
     87e:	cf 91       	pop	r28
     880:	1f 91       	pop	r17
     882:	0f 91       	pop	r16
     884:	08 95       	ret

00000886 <_partitionGetSector>:
/*------------------------------------------------------------------------*/
/*					Partition Management								  */
/*------------------------------------------------------------------------*/

// Read a sector from inside a partition
void* _partitionGetSector(const DISK* disk, SECTOR partSector, uint8_t mode){
     886:	0f 93       	push	r16
     888:	1f 93       	push	r17
     88a:	e2 2f       	mov	r30, r18
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
     88c:	dc 01       	movw	r26, r24
     88e:	16 96       	adiw	r26, 0x06	; 6
     890:	0d 91       	ld	r16, X+
     892:	1d 91       	ld	r17, X+
     894:	2d 91       	ld	r18, X+
     896:	3c 91       	ld	r19, X
     898:	19 97       	sbiw	r26, 0x09	; 9
     89a:	40 0f       	add	r20, r16
     89c:	51 1f       	adc	r21, r17
     89e:	62 1f       	adc	r22, r18
     8a0:	73 1f       	adc	r23, r19
     8a2:	2e 2f       	mov	r18, r30
}
     8a4:	1f 91       	pop	r17
     8a6:	0f 91       	pop	r16
/*					Partition Management								  */
/*------------------------------------------------------------------------*/

// Read a sector from inside a partition
void* _partitionGetSector(const DISK* disk, SECTOR partSector, uint8_t mode){
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
     8a8:	0c 94 00 00 	jmp	0	; 0x0 <_bufferIsWritable>

000008ac <_fatGetNextClusterAddressInRAM>:
	}
	return(disk->volume.reservedSectorCount + res);
}

// Look in a FAT table sector to find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddressInRAM(const DISK *disk,CLUSTER cluster_addr, uint8_t* buf){
     8ac:	cf 92       	push	r12
     8ae:	df 92       	push	r13
     8b0:	ef 92       	push	r14
     8b2:	ff 92       	push	r15
     8b4:	0f 93       	push	r16
     8b6:	1f 93       	push	r17
     8b8:	cf 93       	push	r28
     8ba:	df 93       	push	r29
     8bc:	8c 01       	movw	r16, r24
     8be:	6a 01       	movw	r12, r20
     8c0:	7b 01       	movw	r14, r22
     8c2:	f9 01       	movw	r30, r18
	uint16_t offset;
	CLUSTER nextcluster=0;
	uint8_t hb,lb;

	switch(disk->fatType){
     8c4:	dc 01       	movw	r26, r24
     8c6:	96 96       	adiw	r26, 0x26	; 38
     8c8:	8c 91       	ld	r24, X
     8ca:	80 31       	cpi	r24, 0x10	; 16
     8cc:	01 f4       	brne	.+0      	; 0x8ce <_fatGetNextClusterAddressInRAM+0x22>
     8ce:	00 c0       	rjmp	.+0      	; 0x8d0 <_fatGetNextClusterAddressInRAM+0x24>
     8d0:	80 32       	cpi	r24, 0x20	; 32
     8d2:	01 f4       	brne	.+0      	; 0x8d4 <_fatGetNextClusterAddressInRAM+0x28>
     8d4:	00 c0       	rjmp	.+0      	; 0x8d6 <_fatGetNextClusterAddressInRAM+0x2a>
     8d6:	8c 30       	cpi	r24, 0x0C	; 12
     8d8:	01 f0       	breq	.+0      	; 0x8da <_fatGetNextClusterAddressInRAM+0x2e>
     8da:	00 c0       	rjmp	.+0      	; 0x8dc <_fatGetNextClusterAddressInRAM+0x30>
		case 12:
			offset = ((cluster_addr % 1024) * 3 / 2) % 512;
     8dc:	9a 01       	movw	r18, r20
     8de:	ab 01       	movw	r20, r22
     8e0:	33 70       	andi	r19, 0x03	; 3
     8e2:	44 27       	eor	r20, r20
     8e4:	55 27       	eor	r21, r21
     8e6:	a3 e0       	ldi	r26, 0x03	; 3
     8e8:	b0 e0       	ldi	r27, 0x00	; 0
     8ea:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     8ee:	96 95       	lsr	r25
     8f0:	87 95       	ror	r24
     8f2:	77 95       	ror	r23
     8f4:	67 95       	ror	r22
     8f6:	71 70       	andi	r23, 0x01	; 1
     8f8:	88 27       	eor	r24, r24
     8fa:	99 27       	eor	r25, r25
			hb = buf[offset];
     8fc:	e6 0f       	add	r30, r22
     8fe:	f7 1f       	adc	r31, r23
     900:	d0 81       	ld	r29, Z
			if(offset == 511){
     902:	6f 3f       	cpi	r22, 0xFF	; 255
     904:	71 40       	sbci	r23, 0x01	; 1
     906:	01 f4       	brne	.+0      	; 0x908 <_fatGetNextClusterAddressInRAM+0x5c>
				// Next byte is in the next sector
				uint8_t* buf2=_partitionGetSector(disk,_fatGetSectorAddressFatEntry(disk,cluster_addr)+1,BUFFER_MODE_READONLY);
     908:	b7 01       	movw	r22, r14
     90a:	a6 01       	movw	r20, r12
     90c:	c8 01       	movw	r24, r16
     90e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     912:	ab 01       	movw	r20, r22
     914:	bc 01       	movw	r22, r24
     916:	4f 5f       	subi	r20, 0xFF	; 255
     918:	5f 4f       	sbci	r21, 0xFF	; 255
     91a:	6f 4f       	sbci	r22, 0xFF	; 255
     91c:	7f 4f       	sbci	r23, 0xFF	; 255
     91e:	21 e0       	ldi	r18, 0x01	; 1
     920:	c8 01       	movw	r24, r16
     922:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				lb = buf2[0];
     926:	fc 01       	movw	r30, r24
     928:	c0 81       	ld	r28, Z

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
     92a:	bc 01       	movw	r22, r24
     92c:	c8 01       	movw	r24, r16
     92e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     932:	00 c0       	rjmp	.+0      	; 0x934 <_fatGetNextClusterAddressInRAM+0x88>
				partition_releaseSector(disk,buf2);
			}else{
				lb = buf[offset + 1];
     934:	c1 81       	ldd	r28, Z+1	; 0x01
			}
			if(cluster_addr % 2 == 0){
     936:	c0 fc       	sbrc	r12, 0
     938:	00 c0       	rjmp	.+0      	; 0x93a <_fatGetNextClusterAddressInRAM+0x8e>
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
     93a:	1c 2f       	mov	r17, r28
     93c:	1f 70       	andi	r17, 0x0F	; 15
     93e:	00 e0       	ldi	r16, 0x00	; 0
     940:	0d 0f       	add	r16, r29
     942:	11 1d       	adc	r17, r1
     944:	00 c0       	rjmp	.+0      	; 0x946 <_fatGetNextClusterAddressInRAM+0x9a>
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
     946:	d2 95       	swap	r29
     948:	df 70       	andi	r29, 0x0F	; 15
     94a:	0d 2f       	mov	r16, r29
     94c:	10 e0       	ldi	r17, 0x00	; 0
     94e:	f0 e1       	ldi	r31, 0x10	; 16
     950:	cf 9f       	mul	r28, r31
     952:	00 0d       	add	r16, r0
     954:	11 1d       	adc	r17, r1
     956:	11 24       	eor	r1, r1
     958:	22 27       	eor	r18, r18
     95a:	17 fd       	sbrc	r17, 7
     95c:	20 95       	com	r18
     95e:	32 2f       	mov	r19, r18
     960:	00 c0       	rjmp	.+0      	; 0x962 <_fatGetNextClusterAddressInRAM+0xb6>
			}
			break;
		case 16:
			offset=cluster_addr % 256;
     962:	dd 24       	eor	r13, r13
     964:	ee 24       	eor	r14, r14
     966:	ff 24       	eor	r15, r15
			nextcluster = *((uint16_t*)buf + offset);
     968:	d6 01       	movw	r26, r12
     96a:	aa 0f       	add	r26, r26
     96c:	bb 1f       	adc	r27, r27
     96e:	a2 0f       	add	r26, r18
     970:	b3 1f       	adc	r27, r19
     972:	0d 91       	ld	r16, X+
     974:	1c 91       	ld	r17, X
     976:	20 e0       	ldi	r18, 0x00	; 0
     978:	30 e0       	ldi	r19, 0x00	; 0
			break;
     97a:	00 c0       	rjmp	.+0      	; 0x97c <_fatGetNextClusterAddressInRAM+0xd0>
		case 32:
			offset=cluster_addr % 128;
     97c:	e8 94       	clt
     97e:	c7 f8       	bld	r12, 7
     980:	dd 24       	eor	r13, r13
     982:	ee 24       	eor	r14, r14
     984:	ff 24       	eor	r15, r15
			nextcluster = *((uint32_t*)buf + offset);
     986:	d6 01       	movw	r26, r12
     988:	aa 0f       	add	r26, r26
     98a:	bb 1f       	adc	r27, r27
     98c:	aa 0f       	add	r26, r26
     98e:	bb 1f       	adc	r27, r27
     990:	a2 0f       	add	r26, r18
     992:	b3 1f       	adc	r27, r19
     994:	0d 91       	ld	r16, X+
     996:	1d 91       	ld	r17, X+
     998:	2d 91       	ld	r18, X+
     99a:	3c 91       	ld	r19, X
			break;
     99c:	00 c0       	rjmp	.+0      	; 0x99e <_fatGetNextClusterAddressInRAM+0xf2>
}

// Look in a FAT table sector to find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddressInRAM(const DISK *disk,CLUSTER cluster_addr, uint8_t* buf){
	uint16_t offset;
	CLUSTER nextcluster=0;
     99e:	00 e0       	ldi	r16, 0x00	; 0
     9a0:	10 e0       	ldi	r17, 0x00	; 0
     9a2:	98 01       	movw	r18, r16
			offset=cluster_addr % 128;
			nextcluster = *((uint32_t*)buf + offset);
			break;
	}
	return(nextcluster);
}
     9a4:	b8 01       	movw	r22, r16
     9a6:	c9 01       	movw	r24, r18
     9a8:	df 91       	pop	r29
     9aa:	cf 91       	pop	r28
     9ac:	1f 91       	pop	r17
     9ae:	0f 91       	pop	r16
     9b0:	ff 90       	pop	r15
     9b2:	ef 90       	pop	r14
     9b4:	df 90       	pop	r13
     9b6:	cf 90       	pop	r12
     9b8:	08 95       	ret

000009ba <_fatGetNextClusterChain>:


// Scan one sector of the FAT table to find the number of contiguous clusters
// Return value: TRUE on success, or FALSE when end of chain has been hit in which
//				case the chain has the LastCluster field set
static boolean _fatGetNextClusterChain(const DISK *disk, CLUSTER_NAV *chain){
     9ba:	2f 92       	push	r2
     9bc:	3f 92       	push	r3
     9be:	4f 92       	push	r4
     9c0:	5f 92       	push	r5
     9c2:	6f 92       	push	r6
     9c4:	7f 92       	push	r7
     9c6:	8f 92       	push	r8
     9c8:	9f 92       	push	r9
     9ca:	af 92       	push	r10
     9cc:	bf 92       	push	r11
     9ce:	cf 92       	push	r12
     9d0:	df 92       	push	r13
     9d2:	ef 92       	push	r14
     9d4:	ff 92       	push	r15
     9d6:	0f 93       	push	r16
     9d8:	1f 93       	push	r17
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
     9de:	8c 01       	movw	r16, r24
     9e0:	eb 01       	movw	r28, r22

	if(chain->currentCluster==0){
     9e2:	48 85       	ldd	r20, Y+8	; 0x08
     9e4:	59 85       	ldd	r21, Y+9	; 0x09
     9e6:	6a 85       	ldd	r22, Y+10	; 0x0a
     9e8:	7b 85       	ldd	r23, Y+11	; 0x0b
     9ea:	41 15       	cp	r20, r1
     9ec:	51 05       	cpc	r21, r1
     9ee:	61 05       	cpc	r22, r1
     9f0:	71 05       	cpc	r23, r1
     9f2:	01 f4       	brne	.+0      	; 0x9f4 <_fatGetNextClusterChain+0x3a>
     9f4:	00 c0       	rjmp	.+0      	; 0x9f6 <_fatGetNextClusterChain+0x3c>
		return(FALSE);
	}

	SECTOR sect=_fatGetSectorAddressFatEntry(disk,chain->currentCluster);
     9f6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     9fa:	2b 01       	movw	r4, r22
     9fc:	3c 01       	movw	r6, r24

	// Read the FAT
	void* buf=_partitionGetSector(disk,sect,BUFFER_MODE_READONLY);
     9fe:	21 e0       	ldi	r18, 0x01	; 1
     a00:	ab 01       	movw	r20, r22
     a02:	bc 01       	movw	r22, r24
     a04:	c8 01       	movw	r24, r16
     a06:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     a0a:	1c 01       	movw	r2, r24


	CLUSTER dc=_fatGetNextClusterAddressInRAM(disk,chain->currentCluster,buf);
     a0c:	48 85       	ldd	r20, Y+8	; 0x08
     a0e:	59 85       	ldd	r21, Y+9	; 0x09
     a10:	6a 85       	ldd	r22, Y+10	; 0x0a
     a12:	7b 85       	ldd	r23, Y+11	; 0x0b
     a14:	9c 01       	movw	r18, r24
     a16:	c8 01       	movw	r24, r16
     a18:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
}


// Return true if the cluster number represents the end of a cluster chain
static boolean _fatIsEndMarker(const DISK* disk, CLUSTER cluster){
	switch(disk->fatType){
     a1c:	f8 01       	movw	r30, r16
     a1e:	26 a1       	ldd	r18, Z+38	; 0x26
     a20:	20 31       	cpi	r18, 0x10	; 16
     a22:	01 f0       	breq	.+0      	; 0xa24 <_fatGetNextClusterChain+0x6a>
     a24:	20 32       	cpi	r18, 0x20	; 32
     a26:	01 f0       	breq	.+0      	; 0xa28 <_fatGetNextClusterChain+0x6e>
     a28:	2c 30       	cpi	r18, 0x0C	; 12
     a2a:	01 f0       	breq	.+0      	; 0xa2c <_fatGetNextClusterChain+0x72>
     a2c:	00 c0       	rjmp	.+0      	; 0xa2e <_fatGetNextClusterChain+0x74>
		case 12:
			if(cluster < 0xFF8){
     a2e:	68 3f       	cpi	r22, 0xF8	; 248
     a30:	ff e0       	ldi	r31, 0x0F	; 15
     a32:	7f 07       	cpc	r23, r31
     a34:	81 05       	cpc	r24, r1
     a36:	91 05       	cpc	r25, r1
     a38:	00 f4       	brcc	.+0      	; 0xa3a <_fatGetNextClusterChain+0x80>
     a3a:	00 c0       	rjmp	.+0      	; 0xa3c <_fatGetNextClusterChain+0x82>
     a3c:	00 c0       	rjmp	.+0      	; 0xa3e <_fatGetNextClusterChain+0x84>
				return(FALSE);
			}
			break;
		case 16:
			if(cluster < 0xFFF8){
     a3e:	68 3f       	cpi	r22, 0xF8	; 248
     a40:	2f ef       	ldi	r18, 0xFF	; 255
     a42:	72 07       	cpc	r23, r18
     a44:	81 05       	cpc	r24, r1
     a46:	91 05       	cpc	r25, r1
     a48:	00 f4       	brcc	.+0      	; 0xa4a <_fatGetNextClusterChain+0x90>
     a4a:	00 c0       	rjmp	.+0      	; 0xa4c <_fatGetNextClusterChain+0x92>
     a4c:	00 c0       	rjmp	.+0      	; 0xa4e <_fatGetNextClusterChain+0x94>
				return(FALSE);
			}
			break;
		case 32:
			if((cluster & 0x0FFFFFFF) < 0xFFFFFF8){
     a4e:	cc 24       	eor	r12, r12
     a50:	ca 94       	dec	r12
     a52:	dc 2c       	mov	r13, r12
     a54:	ec 2c       	mov	r14, r12
     a56:	3f e0       	ldi	r19, 0x0F	; 15
     a58:	f3 2e       	mov	r15, r19
     a5a:	c6 22       	and	r12, r22
     a5c:	d7 22       	and	r13, r23
     a5e:	e8 22       	and	r14, r24
     a60:	f9 22       	and	r15, r25
     a62:	e8 ef       	ldi	r30, 0xF8	; 248
     a64:	ce 16       	cp	r12, r30
     a66:	ef ef       	ldi	r30, 0xFF	; 255
     a68:	de 06       	cpc	r13, r30
     a6a:	ee 06       	cpc	r14, r30
     a6c:	ef e0       	ldi	r30, 0x0F	; 15
     a6e:	fe 06       	cpc	r15, r30
     a70:	00 f4       	brcc	.+0      	; 0xa72 <_fatGetNextClusterChain+0xb8>
     a72:	00 c0       	rjmp	.+0      	; 0xa74 <_fatGetNextClusterChain+0xba>
     a74:	00 c0       	rjmp	.+0      	; 0xa76 <_fatGetNextClusterChain+0xbc>
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
		  _fatGetSectorAddressFatEntry(disk,next)==sect){

		last=next;											// last cluster = next cluster
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
     a76:	91 01       	movw	r18, r2
     a78:	b7 01       	movw	r22, r14
     a7a:	a6 01       	movw	r20, r12
     a7c:	c8 01       	movw	r24, r16
     a7e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		contiguous++;										// One more cluster in the chain
     a82:	ff ef       	ldi	r31, 0xFF	; 255
     a84:	8f 1a       	sub	r8, r31
     a86:	9f 0a       	sbc	r9, r31
     a88:	af 0a       	sbc	r10, r31
     a8a:	bf 0a       	sbc	r11, r31
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
		  _fatGetSectorAddressFatEntry(disk,next)==sect){

		last=next;											// last cluster = next cluster
     a8c:	a7 01       	movw	r20, r14
     a8e:	96 01       	movw	r18, r12
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
     a90:	6b 01       	movw	r12, r22
     a92:	7c 01       	movw	r14, r24
	chain->relativeCluster++;								// We have moved forward one

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
     a94:	d7 01       	movw	r26, r14
     a96:	c6 01       	movw	r24, r12
     a98:	01 97       	sbiw	r24, 0x01	; 1
     a9a:	a1 09       	sbc	r26, r1
     a9c:	b1 09       	sbc	r27, r1
     a9e:	82 17       	cp	r24, r18
     aa0:	93 07       	cpc	r25, r19
     aa2:	a4 07       	cpc	r26, r20
     aa4:	b5 07       	cpc	r27, r21
     aa6:	01 f0       	breq	.+0      	; 0xaa8 <_fatGetNextClusterChain+0xee>
		last=next;											// last cluster = next cluster
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
		contiguous++;										// One more cluster in the chain
	}

	chain->contiguousCount= (contiguous==0) ? 0 : contiguous-1;// Set the number of clusters in chain
     aa8:	81 14       	cp	r8, r1
     aaa:	91 04       	cpc	r9, r1
     aac:	a1 04       	cpc	r10, r1
     aae:	b1 04       	cpc	r11, r1
     ab0:	01 f4       	brne	.+0      	; 0xab2 <_fatGetNextClusterChain+0xf8>
     ab2:	81 2c       	mov	r8, r1
     ab4:	91 2c       	mov	r9, r1
     ab6:	54 01       	movw	r10, r8
     ab8:	00 c0       	rjmp	.+0      	; 0xaba <_fatGetNextClusterChain+0x100>

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
		  _fatGetSectorAddressFatEntry(disk,next)==sect){
     aba:	b7 01       	movw	r22, r14
     abc:	a6 01       	movw	r20, r12
     abe:	c8 01       	movw	r24, r16
     ac0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	chain->relativeCluster++;								// We have moved forward one

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
     ac4:	64 15       	cp	r22, r4
     ac6:	75 05       	cpc	r23, r5
     ac8:	86 05       	cpc	r24, r6
     aca:	97 05       	cpc	r25, r7
     acc:	01 f0       	breq	.+0      	; 0xace <_fatGetNextClusterChain+0x114>
     ace:	00 c0       	rjmp	.+0      	; 0xad0 <_fatGetNextClusterChain+0x116>
		last=next;											// last cluster = next cluster
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
		contiguous++;										// One more cluster in the chain
	}

	chain->contiguousCount= (contiguous==0) ? 0 : contiguous-1;// Set the number of clusters in chain
     ad0:	21 e0       	ldi	r18, 0x01	; 1
     ad2:	82 1a       	sub	r8, r18
     ad4:	91 08       	sbc	r9, r1
     ad6:	a1 08       	sbc	r10, r1
     ad8:	b1 08       	sbc	r11, r1
     ada:	88 82       	st	Y, r8
     adc:	99 82       	std	Y+1, r9	; 0x01
     ade:	aa 82       	std	Y+2, r10	; 0x02
     ae0:	bb 82       	std	Y+3, r11	; 0x03
     ae2:	b1 01       	movw	r22, r2
     ae4:	c8 01       	movw	r24, r16
     ae6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		rprintf("NextChain: Rel=%lu, Actual=%lu, Contig=%lu\n",chain->relativeCluster,chain->currentCluster,chain->contiguousCount);
		rprintfInit(old);}
#endif


	return(TRUE);
     aea:	8f ef       	ldi	r24, 0xFF	; 255
     aec:	00 c0       	rjmp	.+0      	; 0xaee <_fatGetNextClusterChain+0x134>
	void* buf=_partitionGetSector(disk,sect,BUFFER_MODE_READONLY);


	CLUSTER dc=_fatGetNextClusterAddressInRAM(disk,chain->currentCluster,buf);
	if(_fatIsEndMarker(disk,dc)){							// If its the end of the file?
		chain->endCluster=chain->currentCluster;			// Set the last cluster
     aee:	88 85       	ldd	r24, Y+8	; 0x08
     af0:	99 85       	ldd	r25, Y+9	; 0x09
     af2:	aa 85       	ldd	r26, Y+10	; 0x0a
     af4:	bb 85       	ldd	r27, Y+11	; 0x0b
     af6:	88 8b       	std	Y+16, r24	; 0x10
     af8:	99 8b       	std	Y+17, r25	; 0x11
     afa:	aa 8b       	std	Y+18, r26	; 0x12
     afc:	bb 8b       	std	Y+19, r27	; 0x13
     afe:	b1 01       	movw	r22, r2
     b00:	c8 01       	movw	r24, r16
     b02:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		partition_releaseSector(disk,buf);					// Release the FAT
		return(FALSE);										// Return END
     b06:	80 e0       	ldi	r24, 0x00	; 0
     b08:	00 c0       	rjmp	.+0      	; 0xb0a <_fatGetNextClusterChain+0x150>
	}

	chain->currentCluster=dc;								// Move to next cluster
     b0a:	68 87       	std	Y+8, r22	; 0x08
     b0c:	79 87       	std	Y+9, r23	; 0x09
     b0e:	8a 87       	std	Y+10, r24	; 0x0a
     b10:	9b 87       	std	Y+11, r25	; 0x0b
	chain->relativeCluster++;								// We have moved forward one
     b12:	8c 80       	ldd	r8, Y+4	; 0x04
     b14:	9d 80       	ldd	r9, Y+5	; 0x05
     b16:	ae 80       	ldd	r10, Y+6	; 0x06
     b18:	bf 80       	ldd	r11, Y+7	; 0x07
     b1a:	ef ef       	ldi	r30, 0xFF	; 255
     b1c:	8e 1a       	sub	r8, r30
     b1e:	9e 0a       	sbc	r9, r30
     b20:	ae 0a       	sbc	r10, r30
     b22:	be 0a       	sbc	r11, r30
     b24:	8c 82       	std	Y+4, r8	; 0x04
     b26:	9d 82       	std	Y+5, r9	; 0x05
     b28:	ae 82       	std	Y+6, r10	; 0x06
     b2a:	bf 82       	std	Y+7, r11	; 0x07

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
     b2c:	9b 01       	movw	r18, r22
     b2e:	ac 01       	movw	r20, r24
     b30:	21 50       	subi	r18, 0x01	; 1
     b32:	31 09       	sbc	r19, r1
     b34:	41 09       	sbc	r20, r1
     b36:	51 09       	sbc	r21, r1

	// Read the FAT
	void* buf=_partitionGetSector(disk,sect,BUFFER_MODE_READONLY);


	CLUSTER dc=_fatGetNextClusterAddressInRAM(disk,chain->currentCluster,buf);
     b38:	6b 01       	movw	r12, r22
     b3a:	7c 01       	movw	r14, r24
	chain->currentCluster=dc;								// Move to next cluster
	chain->relativeCluster++;								// We have moved forward one

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
     b3c:	81 2c       	mov	r8, r1
     b3e:	91 2c       	mov	r9, r1
     b40:	54 01       	movw	r10, r8
	while(next-1==last &&									// While we are in the same FAT sector
     b42:	00 c0       	rjmp	.+0      	; 0xb44 <_fatGetNextClusterChain+0x18a>
		rprintfInit(old);}
#endif


	return(TRUE);
}
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	ff 90       	pop	r15
     b4e:	ef 90       	pop	r14
     b50:	df 90       	pop	r13
     b52:	cf 90       	pop	r12
     b54:	bf 90       	pop	r11
     b56:	af 90       	pop	r10
     b58:	9f 90       	pop	r9
     b5a:	8f 90       	pop	r8
     b5c:	7f 90       	pop	r7
     b5e:	6f 90       	pop	r6
     b60:	5f 90       	pop	r5
     b62:	4f 90       	pop	r4
     b64:	3f 90       	pop	r3
     b66:	2f 90       	pop	r2
     b68:	08 95       	ret

00000b6a <_navGetLastCluster>:
/*------------------------------------------------------------------------*/
/*					Cluster Navigation Management  						  */
/*------------------------------------------------------------------------*/

// Find the last cluster in a cluster chain and store it in the cache
static CLUSTER _navGetLastCluster(const DISK* disk,CLUSTER_NAV *nav){
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	7c 01       	movw	r14, r24
     b78:	eb 01       	movw	r28, r22
	// If not initialised then go to start of file
	if(nav->currentCluster==0){
     b7a:	88 85       	ldd	r24, Y+8	; 0x08
     b7c:	99 85       	ldd	r25, Y+9	; 0x09
     b7e:	aa 85       	ldd	r26, Y+10	; 0x0a
     b80:	bb 85       	ldd	r27, Y+11	; 0x0b
     b82:	89 2b       	or	r24, r25
     b84:	8a 2b       	or	r24, r26
     b86:	8b 2b       	or	r24, r27
     b88:	01 f4       	brne	.+0      	; 0xb8a <_navGetLastCluster+0x20>
		nav->currentCluster=nav->startCluster;
     b8a:	4c 85       	ldd	r20, Y+12	; 0x0c
     b8c:	5d 85       	ldd	r21, Y+13	; 0x0d
     b8e:	6e 85       	ldd	r22, Y+14	; 0x0e
     b90:	7f 85       	ldd	r23, Y+15	; 0x0f
     b92:	48 87       	std	Y+8, r20	; 0x08
     b94:	59 87       	std	Y+9, r21	; 0x09
     b96:	6a 87       	std	Y+10, r22	; 0x0a
     b98:	7b 87       	std	Y+11, r23	; 0x0b
		nav->relativeCluster=0;
     b9a:	1c 82       	std	Y+4, r1	; 0x04
     b9c:	1d 82       	std	Y+5, r1	; 0x05
     b9e:	1e 82       	std	Y+6, r1	; 0x06
     ba0:	1f 82       	std	Y+7, r1	; 0x07
	}

	// If we haven't found the last cluster yet then find it now
	if(nav->endCluster==0){
     ba2:	48 89       	ldd	r20, Y+16	; 0x10
     ba4:	59 89       	ldd	r21, Y+17	; 0x11
     ba6:	6a 89       	ldd	r22, Y+18	; 0x12
     ba8:	7b 89       	ldd	r23, Y+19	; 0x13
     baa:	45 2b       	or	r20, r21
     bac:	46 2b       	or	r20, r22
     bae:	47 2b       	or	r20, r23
     bb0:	01 f0       	breq	.+0      	; 0xbb2 <_navGetLastCluster+0x48>
			nav->relativeCluster+=nav->contiguousCount;
			nav->currentCluster+=nav->contiguousCount;
			nav->contiguousCount=0;
		}
	}
	return(nav->endCluster);
     bb2:	68 89       	ldd	r22, Y+16	; 0x10
     bb4:	79 89       	ldd	r23, Y+17	; 0x11
     bb6:	8a 89       	ldd	r24, Y+18	; 0x12
     bb8:	9b 89       	ldd	r25, Y+19	; 0x13
     bba:	00 c0       	rjmp	.+0      	; 0xbbc <_navGetLastCluster+0x52>
	}

	// If we haven't found the last cluster yet then find it now
	if(nav->endCluster==0){
		while(_fatGetNextClusterChain(disk, nav)){
			nav->relativeCluster+=nav->contiguousCount;
     bbc:	08 81       	ld	r16, Y
     bbe:	19 81       	ldd	r17, Y+1	; 0x01
     bc0:	2a 81       	ldd	r18, Y+2	; 0x02
     bc2:	3b 81       	ldd	r19, Y+3	; 0x03
     bc4:	4c 81       	ldd	r20, Y+4	; 0x04
     bc6:	5d 81       	ldd	r21, Y+5	; 0x05
     bc8:	6e 81       	ldd	r22, Y+6	; 0x06
     bca:	7f 81       	ldd	r23, Y+7	; 0x07
     bcc:	40 0f       	add	r20, r16
     bce:	51 1f       	adc	r21, r17
     bd0:	62 1f       	adc	r22, r18
     bd2:	73 1f       	adc	r23, r19
     bd4:	4c 83       	std	Y+4, r20	; 0x04
     bd6:	5d 83       	std	Y+5, r21	; 0x05
     bd8:	6e 83       	std	Y+6, r22	; 0x06
     bda:	7f 83       	std	Y+7, r23	; 0x07
			nav->currentCluster+=nav->contiguousCount;
     bdc:	48 85       	ldd	r20, Y+8	; 0x08
     bde:	59 85       	ldd	r21, Y+9	; 0x09
     be0:	6a 85       	ldd	r22, Y+10	; 0x0a
     be2:	7b 85       	ldd	r23, Y+11	; 0x0b
     be4:	40 0f       	add	r20, r16
     be6:	51 1f       	adc	r21, r17
     be8:	62 1f       	adc	r22, r18
     bea:	73 1f       	adc	r23, r19
     bec:	48 87       	std	Y+8, r20	; 0x08
     bee:	59 87       	std	Y+9, r21	; 0x09
     bf0:	6a 87       	std	Y+10, r22	; 0x0a
     bf2:	7b 87       	std	Y+11, r23	; 0x0b
			nav->contiguousCount=0;
     bf4:	18 82       	st	Y, r1
     bf6:	19 82       	std	Y+1, r1	; 0x01
     bf8:	1a 82       	std	Y+2, r1	; 0x02
     bfa:	1b 82       	std	Y+3, r1	; 0x03
		nav->relativeCluster=0;
	}

	// If we haven't found the last cluster yet then find it now
	if(nav->endCluster==0){
		while(_fatGetNextClusterChain(disk, nav)){
     bfc:	be 01       	movw	r22, r28
     bfe:	c7 01       	movw	r24, r14
     c00:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     c04:	81 11       	cpse	r24, r1
     c06:	00 c0       	rjmp	.+0      	; 0xc08 <_navGetLastCluster+0x9e>
     c08:	00 c0       	rjmp	.+0      	; 0xc0a <_navGetLastCluster+0xa0>
			nav->currentCluster+=nav->contiguousCount;
			nav->contiguousCount=0;
		}
	}
	return(nav->endCluster);
}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	ff 90       	pop	r15
     c14:	ef 90       	pop	r14
     c16:	08 95       	ret

00000c18 <diskFreeSpace>:
// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}

uint32_t diskFreeSpace(const DISK* disk){
     c18:	2f 92       	push	r2
     c1a:	3f 92       	push	r3
     c1c:	4f 92       	push	r4
     c1e:	5f 92       	push	r5
     c20:	6f 92       	push	r6
     c22:	7f 92       	push	r7
     c24:	8f 92       	push	r8
     c26:	9f 92       	push	r9
     c28:	af 92       	push	r10
     c2a:	bf 92       	push	r11
     c2c:	cf 92       	push	r12
     c2e:	df 92       	push	r13
     c30:	ef 92       	push	r14
     c32:	ff 92       	push	r15
     c34:	0f 93       	push	r16
     c36:	1f 93       	push	r17
     c38:	cf 93       	push	r28
     c3a:	df 93       	push	r29
     c3c:	cd b7       	in	r28, 0x3d	; 61
     c3e:	de b7       	in	r29, 0x3e	; 62
     c40:	2c 97       	sbiw	r28, 0x0c	; 12
     c42:	0f b6       	in	r0, 0x3f	; 63
     c44:	f8 94       	cli
     c46:	de bf       	out	0x3e, r29	; 62
     c48:	0f be       	out	0x3f, r0	; 63
     c4a:	cd bf       	out	0x3d, r28	; 61
     c4c:	8c 01       	movw	r16, r24
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;
     c4e:	dc 01       	movw	r26, r24
     c50:	50 96       	adiw	r26, 0x10	; 16
     c52:	4c 90       	ld	r4, X

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     c54:	c1 2c       	mov	r12, r1
     c56:	d1 2c       	mov	r13, r1
     c58:	76 01       	movw	r14, r12
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}

uint32_t diskFreeSpace(const DISK* disk){
	SECTOR_COUNT free=0;
     c5a:	81 2c       	mov	r8, r1
     c5c:	91 2c       	mov	r9, r1
     c5e:	54 01       	movw	r10, r8
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
		next=_fatGetNextClusterAddress(disk,cluster);
		if(next == 0){
			free += secPerClust;
     c60:	84 2d       	mov	r24, r4
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	a0 e0       	ldi	r26, 0x00	; 0
     c66:	b0 e0       	ldi	r27, 0x00	; 0
     c68:	89 87       	std	Y+9, r24	; 0x09
     c6a:	9a 87       	std	Y+10, r25	; 0x0a
     c6c:	ab 87       	std	Y+11, r26	; 0x0b
     c6e:	bc 87       	std	Y+12, r27	; 0x0c
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     c70:	00 c0       	rjmp	.+0      	; 0xc72 <diskFreeSpace+0x5a>

// Given a cluster - find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddress(const DISK* disk,CLUSTER cluster){
	uint32_t nextcluster=0;

	SECTOR sector=_fatGetSectorAddressFatEntry(disk,cluster);
     c72:	b7 01       	movw	r22, r14
     c74:	a6 01       	movw	r20, r12
     c76:	c8 01       	movw	r24, r16
     c78:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     c7c:	ab 01       	movw	r20, r22
     c7e:	bc 01       	movw	r22, r24
	if( (disk->fatSectorCount > (sector - disk->volume.reservedSectorCount)) && sector!=0 ){
     c80:	d8 01       	movw	r26, r16
     c82:	51 96       	adiw	r26, 0x11	; 17
     c84:	2d 91       	ld	r18, X+
     c86:	3c 91       	ld	r19, X
     c88:	52 97       	sbiw	r26, 0x12	; 18
     c8a:	2a 01       	movw	r4, r20
     c8c:	3b 01       	movw	r6, r22
     c8e:	42 1a       	sub	r4, r18
     c90:	53 0a       	sbc	r5, r19
     c92:	61 08       	sbc	r6, r1
     c94:	71 08       	sbc	r7, r1
     c96:	5a 96       	adiw	r26, 0x1a	; 26
     c98:	8d 91       	ld	r24, X+
     c9a:	9d 91       	ld	r25, X+
     c9c:	0d 90       	ld	r0, X+
     c9e:	bc 91       	ld	r27, X
     ca0:	a0 2d       	mov	r26, r0
     ca2:	48 16       	cp	r4, r24
     ca4:	59 06       	cpc	r5, r25
     ca6:	6a 06       	cpc	r6, r26
     ca8:	7b 06       	cpc	r7, r27
     caa:	00 f0       	brcs	.+0      	; 0xcac <diskFreeSpace+0x94>
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
		next=_fatGetNextClusterAddress(disk,cluster);
		if(next == 0){
			free += secPerClust;
     cac:	49 84       	ldd	r4, Y+9	; 0x09
     cae:	5a 84       	ldd	r5, Y+10	; 0x0a
     cb0:	6b 84       	ldd	r6, Y+11	; 0x0b
     cb2:	7c 84       	ldd	r7, Y+12	; 0x0c
     cb4:	84 0c       	add	r8, r4
     cb6:	95 1c       	adc	r9, r5
     cb8:	a6 1c       	adc	r10, r6
     cba:	b7 1c       	adc	r11, r7
     cbc:	00 c0       	rjmp	.+0      	; 0xcbe <diskFreeSpace+0xa6>
// Given a cluster - find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddress(const DISK* disk,CLUSTER cluster){
	uint32_t nextcluster=0;

	SECTOR sector=_fatGetSectorAddressFatEntry(disk,cluster);
	if( (disk->fatSectorCount > (sector - disk->volume.reservedSectorCount)) && sector!=0 ){
     cbe:	41 15       	cp	r20, r1
     cc0:	51 05       	cpc	r21, r1
     cc2:	61 05       	cpc	r22, r1
     cc4:	71 05       	cpc	r23, r1
     cc6:	01 f0       	breq	.+0      	; 0xcc8 <diskFreeSpace+0xb0>
		void* buf=_partitionGetSector(disk,sector,BUFFER_MODE_READONLY);
     cc8:	21 e0       	ldi	r18, 0x01	; 1
     cca:	c8 01       	movw	r24, r16
     ccc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     cd0:	1c 01       	movw	r2, r24
		nextcluster = _fatGetNextClusterAddressInRAM(disk, cluster, buf);
     cd2:	9c 01       	movw	r18, r24
     cd4:	b7 01       	movw	r22, r14
     cd6:	a6 01       	movw	r20, r12
     cd8:	c8 01       	movw	r24, r16
     cda:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     cde:	2b 01       	movw	r4, r22
     ce0:	3c 01       	movw	r6, r24
     ce2:	b1 01       	movw	r22, r2
     ce4:	c8 01       	movw	r24, r16
     ce6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
		next=_fatGetNextClusterAddress(disk,cluster);
		if(next == 0){
     cea:	45 28       	or	r4, r5
     cec:	46 28       	or	r4, r6
     cee:	47 28       	or	r4, r7
     cf0:	01 f0       	breq	.+0      	; 0xcf2 <diskFreeSpace+0xda>
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     cf2:	8f ef       	ldi	r24, 0xFF	; 255
     cf4:	c8 1a       	sub	r12, r24
     cf6:	d8 0a       	sbc	r13, r24
     cf8:	e8 0a       	sbc	r14, r24
     cfa:	f8 0a       	sbc	r15, r24
     cfc:	d8 01       	movw	r26, r16
     cfe:	92 96       	adiw	r26, 0x22	; 34
     d00:	4d 91       	ld	r20, X+
     d02:	5d 91       	ld	r21, X+
     d04:	6d 91       	ld	r22, X+
     d06:	7c 91       	ld	r23, X
     d08:	95 97       	sbiw	r26, 0x25	; 37
     d0a:	c4 16       	cp	r12, r20
     d0c:	d5 06       	cpc	r13, r21
     d0e:	e6 06       	cpc	r14, r22
     d10:	f7 06       	cpc	r15, r23
     d12:	00 f4       	brcc	.+0      	; 0xd14 <diskFreeSpace+0xfc>
     d14:	00 c0       	rjmp	.+0      	; 0xd16 <diskFreeSpace+0xfe>
		if(next == 0){
			free += secPerClust;
		}
	}

	return (free >> 1);
     d16:	75 01       	movw	r14, r10
     d18:	64 01       	movw	r12, r8
     d1a:	f6 94       	lsr	r15
     d1c:	e7 94       	ror	r14
     d1e:	d7 94       	ror	r13
     d20:	c7 94       	ror	r12
}
     d22:	b6 01       	movw	r22, r12
     d24:	c7 01       	movw	r24, r14
     d26:	2c 96       	adiw	r28, 0x0c	; 12
     d28:	0f b6       	in	r0, 0x3f	; 63
     d2a:	f8 94       	cli
     d2c:	de bf       	out	0x3e, r29	; 62
     d2e:	0f be       	out	0x3f, r0	; 63
     d30:	cd bf       	out	0x3d, r28	; 61
     d32:	df 91       	pop	r29
     d34:	cf 91       	pop	r28
     d36:	1f 91       	pop	r17
     d38:	0f 91       	pop	r16
     d3a:	ff 90       	pop	r15
     d3c:	ef 90       	pop	r14
     d3e:	df 90       	pop	r13
     d40:	cf 90       	pop	r12
     d42:	bf 90       	pop	r11
     d44:	af 90       	pop	r10
     d46:	9f 90       	pop	r9
     d48:	8f 90       	pop	r8
     d4a:	7f 90       	pop	r7
     d4c:	6f 90       	pop	r6
     d4e:	5f 90       	pop	r5
     d50:	4f 90       	pop	r4
     d52:	3f 90       	pop	r3
     d54:	2f 90       	pop	r2
     d56:	08 95       	ret

00000d58 <diskInit>:
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     d58:	2f 92       	push	r2
     d5a:	3f 92       	push	r3
     d5c:	4f 92       	push	r4
     d5e:	5f 92       	push	r5
     d60:	6f 92       	push	r6
     d62:	7f 92       	push	r7
     d64:	8f 92       	push	r8
     d66:	9f 92       	push	r9
     d68:	af 92       	push	r10
     d6a:	bf 92       	push	r11
     d6c:	cf 92       	push	r12
     d6e:	df 92       	push	r13
     d70:	ef 92       	push	r14
     d72:	ff 92       	push	r15
     d74:	0f 93       	push	r16
     d76:	1f 93       	push	r17
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <diskInit+0x26>
     d7e:	00 d0       	rcall	.+0      	; 0xd80 <diskInit+0x28>
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	1c 01       	movw	r2, r24
     d86:	86 2f       	mov	r24, r22
	boolean rtn = FALSE;

	disc->sclass = class;
     d88:	d1 01       	movw	r26, r2
     d8a:	11 96       	adiw	r26, 0x01	; 1
     d8c:	5c 93       	st	X, r21
     d8e:	4e 93       	st	-X, r20
	disc->device = device;
     d90:	13 96       	adiw	r26, 0x03	; 3
     d92:	3c 93       	st	X, r19
     d94:	2e 93       	st	-X, r18
     d96:	12 97       	sbiw	r26, 0x02	; 2
	disc->partitionType = 0;
     d98:	15 96       	adiw	r26, 0x05	; 5
     d9a:	1c 92       	st	X, r1
     d9c:	15 97       	sbiw	r26, 0x05	; 5

	// Allocate memory for the buffers
	if(disc->buffers==null){
     d9e:	d4 96       	adiw	r26, 0x34	; 52
     da0:	2d 91       	ld	r18, X+
     da2:	3c 91       	ld	r19, X
     da4:	d5 97       	sbiw	r26, 0x35	; 53
     da6:	23 2b       	or	r18, r19
     da8:	01 f4       	brne	.+0      	; 0xdaa <diskInit+0x52>
		disc->numbuf = numBuffers;
     daa:	d3 96       	adiw	r26, 0x33	; 51
     dac:	6c 93       	st	X, r22
		disc->buffers = calloc(numBuffers,sizeof(BUFFER));
     dae:	6a e1       	ldi	r22, 0x1A	; 26
     db0:	72 e0       	ldi	r23, 0x02	; 2
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     db8:	f1 01       	movw	r30, r2
     dba:	84 ab       	std	Z+52, r24	; 0x34
     dbc:	95 ab       	std	Z+53, r25	; 0x35
	}

	// Load the master boot record
	uint8_t* buf=_ioGetSector(disc, 0, BUFFER_MODE_READONLY);
     dbe:	21 e0       	ldi	r18, 0x01	; 1
     dc0:	40 e0       	ldi	r20, 0x00	; 0
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	ba 01       	movw	r22, r20
     dc6:	c1 01       	movw	r24, r2
     dc8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     dcc:	7c 01       	movw	r14, r24

	if(buf){
     dce:	00 97       	sbiw	r24, 0x00	; 0
     dd0:	01 f4       	brne	.+0      	; 0xdd2 <diskInit+0x7a>
     dd2:	00 c0       	rjmp	.+0      	; 0xdd4 <diskInit+0x7c>
     dd4:	9c 01       	movw	r18, r24
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     dd6:	80 54       	subi	r24, 0x40	; 64
     dd8:	91 09       	sbc	r25, r1
	boolean rtn = FALSE;
     dda:	50 e0       	ldi	r21, 0x00	; 0
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     ddc:	f9 01       	movw	r30, r18
     dde:	ee 50       	subi	r30, 0x0E	; 14
     de0:	fe 4f       	sbci	r31, 0xFE	; 254
	if(buf){
		// Find the active partition
		PartitionEntry* partitions = (PartitionEntry*)(&buf[0x1BE]);
		for(int p=3; p>=0; p--){
			PartitionEntry* partition = &partitions[p];
			uint8_t type = partition->type;
     de2:	40 81       	ld	r20, Z
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
     de4:	41 30       	cpi	r20, 0x01	; 1
     de6:	01 f0       	breq	.+0      	; 0xde8 <diskInit+0x90>
     de8:	44 30       	cpi	r20, 0x04	; 4
     dea:	01 f0       	breq	.+0      	; 0xdec <diskInit+0x94>
     dec:	46 30       	cpi	r20, 0x06	; 6
     dee:	01 f0       	breq	.+0      	; 0xdf0 <diskInit+0x98>
     df0:	4b 30       	cpi	r20, 0x0B	; 11
     df2:	01 f0       	breq	.+0      	; 0xdf4 <diskInit+0x9c>
     df4:	4c 35       	cpi	r20, 0x5C	; 92
     df6:	01 f0       	breq	.+0      	; 0xdf8 <diskInit+0xa0>
     df8:	4e 35       	cpi	r20, 0x5E	; 94
     dfa:	01 f4       	brne	.+0      	; 0xdfc <diskInit+0xa4>
				// This is a recognised partition type
				disc->partitionType = type;
     dfc:	d1 01       	movw	r26, r2
     dfe:	15 96       	adiw	r26, 0x05	; 5
     e00:	4c 93       	st	X, r20
     e02:	15 97       	sbiw	r26, 0x05	; 5
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e04:	f9 01       	movw	r30, r18
     e06:	ea 50       	subi	r30, 0x0A	; 10
     e08:	fe 4f       	sbci	r31, 0xFE	; 254
			PartitionEntry* partition = &partitions[p];
			uint8_t type = partition->type;
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
				// This is a recognised partition type
				disc->partitionType = type;
				disc->partitionStartSector = partition->LBA_begin;
     e0a:	40 81       	ld	r20, Z
     e0c:	51 81       	ldd	r21, Z+1	; 0x01
     e0e:	62 81       	ldd	r22, Z+2	; 0x02
     e10:	73 81       	ldd	r23, Z+3	; 0x03
     e12:	f1 01       	movw	r30, r2
     e14:	46 83       	std	Z+6, r20	; 0x06
     e16:	57 83       	std	Z+7, r21	; 0x07
     e18:	60 87       	std	Z+8, r22	; 0x08
     e1a:	71 87       	std	Z+9, r23	; 0x09
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e1c:	f9 01       	movw	r30, r18
     e1e:	e6 50       	subi	r30, 0x06	; 6
     e20:	fe 4f       	sbci	r31, 0xFE	; 254
			uint8_t type = partition->type;
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
				// This is a recognised partition type
				disc->partitionType = type;
				disc->partitionStartSector = partition->LBA_begin;
				disc->partitionNumSectors = partition->numSectors;
     e22:	40 81       	ld	r20, Z
     e24:	51 81       	ldd	r21, Z+1	; 0x01
     e26:	62 81       	ldd	r22, Z+2	; 0x02
     e28:	73 81       	ldd	r23, Z+3	; 0x03
     e2a:	1a 96       	adiw	r26, 0x0a	; 10
     e2c:	4d 93       	st	X+, r20
     e2e:	5d 93       	st	X+, r21
     e30:	6d 93       	st	X+, r22
     e32:	7c 93       	st	X, r23
     e34:	1d 97       	sbiw	r26, 0x0d	; 13
				rtn = TRUE;
     e36:	5f ef       	ldi	r21, 0xFF	; 255
     e38:	20 51       	subi	r18, 0x10	; 16
     e3a:	31 09       	sbc	r19, r1
	uint8_t* buf=_ioGetSector(disc, 0, BUFFER_MODE_READONLY);

	if(buf){
		// Find the active partition
		PartitionEntry* partitions = (PartitionEntry*)(&buf[0x1BE]);
		for(int p=3; p>=0; p--){
     e3c:	28 17       	cp	r18, r24
     e3e:	39 07       	cpc	r19, r25
     e40:	01 f4       	brne	.+0      	; 0xe42 <diskInit+0xea>
				disc->partitionStartSector = partition->LBA_begin;
				disc->partitionNumSectors = partition->numSectors;
				rtn = TRUE;
			}
		}
		if(!rtn){
     e42:	51 11       	cpse	r21, r1
     e44:	00 c0       	rjmp	.+0      	; 0xe46 <diskInit+0xee>
			// No partition - so assume whole disk is FAT32
			const STORAGE_CLASS* class = disc->sclass;
     e46:	d1 01       	movw	r26, r2
     e48:	ed 91       	ld	r30, X+
     e4a:	fc 91       	ld	r31, X
     e4c:	11 97       	sbiw	r26, 0x01	; 1

			disc->partitionType = PT_FAT32;
     e4e:	8b e0       	ldi	r24, 0x0B	; 11
     e50:	15 96       	adiw	r26, 0x05	; 5
     e52:	8c 93       	st	X, r24
     e54:	15 97       	sbiw	r26, 0x05	; 5
			disc->partitionStartSector = 0;
     e56:	16 96       	adiw	r26, 0x06	; 6
     e58:	1d 92       	st	X+, r1
     e5a:	1d 92       	st	X+, r1
     e5c:	1d 92       	st	X+, r1
     e5e:	1c 92       	st	X, r1
     e60:	19 97       	sbiw	r26, 0x09	; 9

			SECTOR_COUNT (*getTotalSectors)(void*) = (SECTOR_COUNT (*)(void*))pgm_read_word(&class->getTotalSectors);
     e62:	34 96       	adiw	r30, 0x04	; 4
     e64:	65 91       	lpm	r22, Z+
     e66:	74 91       	lpm	r23, Z
			disc->partitionNumSectors = getTotalSectors(disc->device);
     e68:	12 96       	adiw	r26, 0x02	; 2
     e6a:	8d 91       	ld	r24, X+
     e6c:	9c 91       	ld	r25, X
     e6e:	13 97       	sbiw	r26, 0x03	; 3
     e70:	fb 01       	movw	r30, r22
     e72:	09 95       	icall
     e74:	d1 01       	movw	r26, r2
     e76:	1a 96       	adiw	r26, 0x0a	; 10
     e78:	6d 93       	st	X+, r22
     e7a:	7d 93       	st	X+, r23
     e7c:	8d 93       	st	X+, r24
     e7e:	9c 93       	st	X, r25
     e80:	1d 97       	sbiw	r26, 0x0d	; 13
			rtn = TRUE;
		}
		// release the sector
		_ioReleaseSector(disc,buf);
     e82:	b7 01       	movw	r22, r14
     e84:	c1 01       	movw	r24, r2
     e86:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	return(TRUE);
}

static boolean _fatInit(DISK* disk){

	void* buf=_partitionGetSector(disk,0,BUFFER_MODE_READONLY); /* Load Volume label */
     e8a:	21 e0       	ldi	r18, 0x01	; 1
     e8c:	40 e0       	ldi	r20, 0x00	; 0
     e8e:	50 e0       	ldi	r21, 0x00	; 0
     e90:	ba 01       	movw	r22, r20
     e92:	c1 01       	movw	r24, r2
     e94:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     e98:	5c 01       	movw	r10, r24
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     e9a:	fc 01       	movw	r30, r24
     e9c:	83 85       	ldd	r24, Z+11	; 0x0b
     e9e:	94 85       	ldd	r25, Z+12	; 0x0c

	// Load the volume info
	disk->volume.bytesPerSector=get_uint16(buf,0x0B);
     ea0:	d1 01       	movw	r26, r2
     ea2:	1f 96       	adiw	r26, 0x0f	; 15
     ea4:	9c 93       	st	X, r25
     ea6:	8e 93       	st	-X, r24
     ea8:	1e 97       	sbiw	r26, 0x0e	; 14
	disk->volume.sectorsPerCluster=*((char*)(buf+0x0D));
     eaa:	85 85       	ldd	r24, Z+13	; 0x0d
     eac:	50 96       	adiw	r26, 0x10	; 16
     eae:	8c 93       	st	X, r24
     eb0:	50 97       	sbiw	r26, 0x10	; 16
     eb2:	86 85       	ldd	r24, Z+14	; 0x0e
     eb4:	97 85       	ldd	r25, Z+15	; 0x0f
	disk->volume.reservedSectorCount=get_uint16(buf,0x0E);
     eb6:	52 96       	adiw	r26, 0x12	; 18
     eb8:	9c 93       	st	X, r25
     eba:	8e 93       	st	-X, r24
     ebc:	51 97       	sbiw	r26, 0x11	; 17
	disk->volume.numberOfFats=*((char*)(buf+0x10));
     ebe:	80 89       	ldd	r24, Z+16	; 0x10
     ec0:	53 96       	adiw	r26, 0x13	; 19
     ec2:	8c 93       	st	X, r24
     ec4:	53 97       	sbiw	r26, 0x13	; 19
     ec6:	81 89       	ldd	r24, Z+17	; 0x11
     ec8:	92 89       	ldd	r25, Z+18	; 0x12
	disk->volume.rootDirEntryCount=get_uint16(buf,0x11);
     eca:	55 96       	adiw	r26, 0x15	; 21
     ecc:	9c 93       	st	X, r25
     ece:	8e 93       	st	-X, r24
     ed0:	54 97       	sbiw	r26, 0x14	; 20
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     ed2:	44 a5       	ldd	r20, Z+44	; 0x2c
     ed4:	55 a5       	ldd	r21, Z+45	; 0x2d
     ed6:	66 a5       	ldd	r22, Z+46	; 0x2e
     ed8:	77 a5       	ldd	r23, Z+47	; 0x2f
	disk->volume.rootDirCluster=get_uint32(buf,0x2C);
     eda:	f1 01       	movw	r30, r2
     edc:	46 8b       	std	Z+22, r20	; 0x16
     ede:	57 8b       	std	Z+23, r21	; 0x17
     ee0:	60 8f       	std	Z+24, r22	; 0x18
     ee2:	71 8f       	std	Z+25, r23	; 0x19
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     ee4:	d5 01       	movw	r26, r10
     ee6:	56 96       	adiw	r26, 0x16	; 22
     ee8:	6d 90       	ld	r6, X+
     eea:	7c 90       	ld	r7, X
     eec:	57 97       	sbiw	r26, 0x17	; 23
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     eee:	94 96       	adiw	r26, 0x24	; 36
     ef0:	2d 91       	ld	r18, X+
     ef2:	3d 91       	ld	r19, X+
     ef4:	4d 91       	ld	r20, X+
     ef6:	5c 91       	ld	r21, X
     ef8:	97 97       	sbiw	r26, 0x27	; 39
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     efa:	53 96       	adiw	r26, 0x13	; 19
     efc:	0d 91       	ld	r16, X+
     efe:	1c 91       	ld	r17, X
     f00:	54 97       	sbiw	r26, 0x14	; 20
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     f02:	90 96       	adiw	r26, 0x20	; 32
     f04:	cd 90       	ld	r12, X+
     f06:	dd 90       	ld	r13, X+
     f08:	ed 90       	ld	r14, X+
     f0a:	fc 90       	ld	r15, X
     f0c:	93 97       	sbiw	r26, 0x23	; 35
     f0e:	b5 01       	movw	r22, r10
     f10:	c1 01       	movw	r24, r2
     f12:	29 83       	std	Y+1, r18	; 0x01
     f14:	3a 83       	std	Y+2, r19	; 0x02
     f16:	4b 83       	std	Y+3, r20	; 0x03
     f18:	5c 83       	std	Y+4, r21	; 0x04
     f1a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     f1e:	f5 01       	movw	r30, r10
     f20:	e2 50       	subi	r30, 0x02	; 2
     f22:	fe 4f       	sbci	r31, 0xFE	; 254
	uint32_t SectorCount32=get_uint32(buf,0x20);

	partition_releaseSector(disk,buf);

	// Check we have a valid FAT marker
	if( get_uint16(buf,0x1FE) != 0xAA55 ){
     f24:	80 81       	ld	r24, Z
     f26:	91 81       	ldd	r25, Z+1	; 0x01
     f28:	29 81       	ldd	r18, Y+1	; 0x01
     f2a:	3a 81       	ldd	r19, Y+2	; 0x02
     f2c:	4b 81       	ldd	r20, Y+3	; 0x03
     f2e:	5c 81       	ldd	r21, Y+4	; 0x04
     f30:	85 35       	cpi	r24, 0x55	; 85
     f32:	9a 4a       	sbci	r25, 0xAA	; 170
     f34:	01 f0       	breq	.+0      	; 0xf36 <diskInit+0x1de>
     f36:	00 c0       	rjmp	.+0      	; 0xf38 <diskInit+0x1e0>
		return FALSE;
	}


	/* Can only handle 512 byte sectors */
	if(disk->volume.bytesPerSector!=512)
     f38:	f1 01       	movw	r30, r2
     f3a:	86 85       	ldd	r24, Z+14	; 0x0e
     f3c:	97 85       	ldd	r25, Z+15	; 0x0f
     f3e:	81 15       	cp	r24, r1
     f40:	92 40       	sbci	r25, 0x02	; 2
     f42:	01 f0       	breq	.+0      	; 0xf44 <diskInit+0x1ec>
     f44:	00 c0       	rjmp	.+0      	; 0xf46 <diskInit+0x1ee>
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
     f46:	d1 01       	movw	r26, r2
     f48:	50 96       	adiw	r26, 0x10	; 16
     f4a:	ec 91       	ld	r30, X
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
     f4c:	61 e0       	ldi	r22, 0x01	; 1
     f4e:	e8 30       	cpi	r30, 0x08	; 8
     f50:	01 f0       	breq	.+0      	; 0xf52 <diskInit+0x1fa>
     f52:	60 e0       	ldi	r22, 0x00	; 0
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	e4 30       	cpi	r30, 0x04	; 4
     f58:	01 f0       	breq	.+0      	; 0xf5a <diskInit+0x202>
     f5a:	80 e0       	ldi	r24, 0x00	; 0
	if(disk->volume.bytesPerSector!=512)
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
     f5c:	86 2b       	or	r24, r22
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
     f5e:	61 e0       	ldi	r22, 0x01	; 1
     f60:	e0 31       	cpi	r30, 0x10	; 16
     f62:	01 f0       	breq	.+0      	; 0xf64 <diskInit+0x20c>
     f64:	60 e0       	ldi	r22, 0x00	; 0
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
     f66:	68 2b       	or	r22, r24
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
	     (disk->volume.sectorsPerCluster == 32) |
     f68:	91 e0       	ldi	r25, 0x01	; 1
     f6a:	e0 32       	cpi	r30, 0x20	; 32
     f6c:	01 f0       	breq	.+0      	; 0xf6e <diskInit+0x216>
     f6e:	90 e0       	ldi	r25, 0x00	; 0

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
     f70:	96 2b       	or	r25, r22
	     (disk->volume.sectorsPerCluster == 16) |
	     (disk->volume.sectorsPerCluster == 32) |
	     (disk->volume.sectorsPerCluster == 64) ))
     f72:	81 e0       	ldi	r24, 0x01	; 1
     f74:	e0 34       	cpi	r30, 0x40	; 64
     f76:	01 f0       	breq	.+0      	; 0xf78 <diskInit+0x220>
     f78:	80 e0       	ldi	r24, 0x00	; 0
	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
     f7a:	89 2b       	or	r24, r25
	/* Can only handle 512 byte sectors */
	if(disk->volume.bytesPerSector!=512)
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
     f7c:	01 f4       	brne	.+0      	; 0xf7e <diskInit+0x226>
     f7e:	8e 2f       	mov	r24, r30
     f80:	81 50       	subi	r24, 0x01	; 1
     f82:	82 30       	cpi	r24, 0x02	; 2
     f84:	00 f0       	brcs	.+0      	; 0xf86 <diskInit+0x22e>
     f86:	00 c0       	rjmp	.+0      	; 0xf88 <diskInit+0x230>
	     (disk->volume.sectorsPerCluster == 32) |
	     (disk->volume.sectorsPerCluster == 64) ))
		return FALSE;

	/* There should be at least 1 reserved sector */
	if(disk->volume.reservedSectorCount==0)
     f88:	d1 01       	movw	r26, r2
     f8a:	51 96       	adiw	r26, 0x11	; 17
     f8c:	8d 90       	ld	r8, X+
     f8e:	9c 90       	ld	r9, X
     f90:	52 97       	sbiw	r26, 0x12	; 18
     f92:	81 14       	cp	r8, r1
     f94:	91 04       	cpc	r9, r1
     f96:	01 f4       	brne	.+0      	; 0xf98 <diskInit+0x240>
     f98:	00 c0       	rjmp	.+0      	; 0xf9a <diskInit+0x242>
		return FALSE;

	/* Find the number of sectors per FAT */
	disk->fatSectorCount = (FatSectorCount16 != 0) ? FatSectorCount16 : FatSectorCount32;
     f9a:	61 14       	cp	r6, r1
     f9c:	71 04       	cpc	r7, r1
     f9e:	01 f0       	breq	.+0      	; 0xfa0 <diskInit+0x248>
     fa0:	93 01       	movw	r18, r6
     fa2:	40 e0       	ldi	r20, 0x00	; 0
     fa4:	50 e0       	ldi	r21, 0x00	; 0
     fa6:	d1 01       	movw	r26, r2
     fa8:	5a 96       	adiw	r26, 0x1a	; 26
     faa:	2d 93       	st	X+, r18
     fac:	3d 93       	st	X+, r19
     fae:	4d 93       	st	X+, r20
     fb0:	5c 93       	st	X, r21
     fb2:	5d 97       	sbiw	r26, 0x1d	; 29
	if(disk->fatSectorCount > disk->partitionNumSectors){
     fb4:	1a 96       	adiw	r26, 0x0a	; 10
     fb6:	4d 90       	ld	r4, X+
     fb8:	5d 90       	ld	r5, X+
     fba:	6d 90       	ld	r6, X+
     fbc:	7c 90       	ld	r7, X
     fbe:	1d 97       	sbiw	r26, 0x0d	; 13
     fc0:	42 16       	cp	r4, r18
     fc2:	53 06       	cpc	r5, r19
     fc4:	64 06       	cpc	r6, r20
     fc6:	75 06       	cpc	r7, r21
     fc8:	00 f4       	brcc	.+0      	; 0xfca <diskInit+0x272>
     fca:	00 c0       	rjmp	.+0      	; 0xfcc <diskInit+0x274>
		return FALSE;
	}

	// Get the sector count
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;
     fcc:	01 15       	cp	r16, r1
     fce:	11 05       	cpc	r17, r1
     fd0:	01 f0       	breq	.+0      	; 0xfd2 <diskInit+0x27a>
     fd2:	68 01       	movw	r12, r16
     fd4:	e1 2c       	mov	r14, r1
     fd6:	f1 2c       	mov	r15, r1
     fd8:	d1 01       	movw	r26, r2
     fda:	5e 96       	adiw	r26, 0x1e	; 30
     fdc:	cd 92       	st	X+, r12
     fde:	dd 92       	st	X+, r13
     fe0:	ed 92       	st	X+, r14
     fe2:	fc 92       	st	X, r15
     fe4:	91 97       	sbiw	r26, 0x21	; 33

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
				 (disk->volume.bytesPerSector - 1)) /
				 disk->volume.bytesPerSector;
	SECTOR dataSectorCount = disk->sectorCount - (
			disk->volume.reservedSectorCount +
     fe6:	a1 2c       	mov	r10, r1
     fe8:	b1 2c       	mov	r11, r1
			(disk->volume.numberOfFats * disk->fatSectorCount) +
     fea:	53 96       	adiw	r26, 0x13	; 19
     fec:	8c 91       	ld	r24, X
     fee:	a8 2f       	mov	r26, r24
     ff0:	b0 e0       	ldi	r27, 0x00	; 0
     ff2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     ff6:	2b 01       	movw	r4, r22
     ff8:	3c 01       	movw	r6, r24
	}

	// Get the sector count
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
     ffa:	d1 01       	movw	r26, r2
     ffc:	54 96       	adiw	r26, 0x14	; 20
     ffe:	8d 91       	ld	r24, X+
    1000:	9c 91       	ld	r25, X
    1002:	55 97       	sbiw	r26, 0x15	; 21
    1004:	65 e0       	ldi	r22, 0x05	; 5
    1006:	88 0f       	add	r24, r24
    1008:	99 1f       	adc	r25, r25
    100a:	6a 95       	dec	r22
    100c:	01 f4       	brne	.+0      	; 0x100e <diskInit+0x2b6>
    100e:	81 50       	subi	r24, 0x01	; 1
    1010:	9e 4f       	sbci	r25, 0xFE	; 254
				 (disk->volume.bytesPerSector - 1)) /
    1012:	89 2f       	mov	r24, r25
    1014:	99 27       	eor	r25, r25
    1016:	86 95       	lsr	r24
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
    1018:	a5 01       	movw	r20, r10
    101a:	94 01       	movw	r18, r8
    101c:	28 0f       	add	r18, r24
    101e:	39 1f       	adc	r19, r25
    1020:	41 1d       	adc	r20, r1
    1022:	51 1d       	adc	r21, r1
    1024:	da 01       	movw	r26, r20
    1026:	c9 01       	movw	r24, r18
    1028:	84 0d       	add	r24, r4
    102a:	95 1d       	adc	r25, r5
    102c:	a6 1d       	adc	r26, r6
    102e:	b7 1d       	adc	r27, r7
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
				 (disk->volume.bytesPerSector - 1)) /
				 disk->volume.bytesPerSector;
	SECTOR dataSectorCount = disk->sectorCount - (
    1030:	a7 01       	movw	r20, r14
    1032:	96 01       	movw	r18, r12
    1034:	28 1b       	sub	r18, r24
    1036:	39 0b       	sbc	r19, r25
    1038:	4a 0b       	sbc	r20, r26
    103a:	5b 0b       	sbc	r21, r27
    103c:	ca 01       	movw	r24, r20
    103e:	b9 01       	movw	r22, r18
			disk->volume.reservedSectorCount +
			(disk->volume.numberOfFats * disk->fatSectorCount) +
			rootDirSectors);

	disk->dataClusterCount = dataSectorCount / disk->volume.sectorsPerCluster;
    1040:	2e 2f       	mov	r18, r30
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	40 e0       	ldi	r20, 0x00	; 0
    1046:	50 e0       	ldi	r21, 0x00	; 0
    1048:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    104c:	d1 01       	movw	r26, r2
    104e:	92 96       	adiw	r26, 0x22	; 34
    1050:	2d 93       	st	X+, r18
    1052:	3d 93       	st	X+, r19
    1054:	4d 93       	st	X+, r20
    1056:	5c 93       	st	X, r21
    1058:	95 97       	sbiw	r26, 0x25	; 37

	// Calculate the type of FAT
	if(disk->dataClusterCount < 4085){			// 2^12 - 11
    105a:	25 3f       	cpi	r18, 0xF5	; 245
    105c:	bf e0       	ldi	r27, 0x0F	; 15
    105e:	3b 07       	cpc	r19, r27
    1060:	41 05       	cpc	r20, r1
    1062:	51 05       	cpc	r21, r1
    1064:	00 f4       	brcc	.+0      	; 0x1066 <diskInit+0x30e>
		disk->fatType=12;
    1066:	8c e0       	ldi	r24, 0x0C	; 12
    1068:	00 c0       	rjmp	.+0      	; 0x106a <diskInit+0x312>
		disk->volume.rootDirCluster=0;
	}else if(disk->dataClusterCount < 65525){	// 2^16 - 11
    106a:	25 3f       	cpi	r18, 0xF5	; 245
    106c:	3f 4f       	sbci	r19, 0xFF	; 255
    106e:	41 05       	cpc	r20, r1
    1070:	51 05       	cpc	r21, r1
    1072:	00 f4       	brcc	.+0      	; 0x1074 <diskInit+0x31c>
		disk->fatType=16;
    1074:	80 e1       	ldi	r24, 0x10	; 16
    1076:	f1 01       	movw	r30, r2
    1078:	86 a3       	std	Z+38, r24	; 0x26
		disk->volume.rootDirCluster=0;
    107a:	16 8a       	std	Z+22, r1	; 0x16
    107c:	17 8a       	std	Z+23, r1	; 0x17
    107e:	10 8e       	std	Z+24, r1	; 0x18
    1080:	11 8e       	std	Z+25, r1	; 0x19
    1082:	00 c0       	rjmp	.+0      	; 0x1084 <diskInit+0x32c>
	}else{
		disk->fatType=32;
    1084:	80 e2       	ldi	r24, 0x20	; 32
    1086:	f1 01       	movw	r30, r2
    1088:	86 a3       	std	Z+38, r24	; 0x26
	}

	// Find the first sector for the root directory
	disk->firstSectorRootDir = disk->volume.reservedSectorCount +
    108a:	84 0c       	add	r8, r4
    108c:	95 1c       	adc	r9, r5
    108e:	a6 1c       	adc	r10, r6
    1090:	b7 1c       	adc	r11, r7
    1092:	d1 01       	movw	r26, r2
    1094:	97 96       	adiw	r26, 0x27	; 39
    1096:	8d 92       	st	X+, r8
    1098:	9d 92       	st	X+, r9
    109a:	ad 92       	st	X+, r10
    109c:	bc 92       	st	X, r11
    109e:	9a 97       	sbiw	r26, 0x2a	; 42
	                         (disk->volume.numberOfFats * disk->fatSectorCount);
	if(disk->fatType==32){
    10a0:	96 96       	adiw	r26, 0x26	; 38
    10a2:	8c 91       	ld	r24, X
    10a4:	96 97       	sbiw	r26, 0x26	; 38
    10a6:	80 32       	cpi	r24, 0x20	; 32
    10a8:	01 f4       	brne	.+0      	; 0x10aa <diskInit+0x352>
		disk->firstSectorRootDir += (disk->volume.rootDirCluster-2) * disk->volume.sectorsPerCluster;
    10aa:	56 96       	adiw	r26, 0x16	; 22
    10ac:	cd 90       	ld	r12, X+
    10ae:	dd 90       	ld	r13, X+
    10b0:	ed 90       	ld	r14, X+
    10b2:	fc 90       	ld	r15, X
    10b4:	59 97       	sbiw	r26, 0x19	; 25
    10b6:	50 96       	adiw	r26, 0x10	; 16
    10b8:	ac 91       	ld	r26, X
    10ba:	a7 01       	movw	r20, r14
    10bc:	96 01       	movw	r18, r12
    10be:	22 50       	subi	r18, 0x02	; 2
    10c0:	31 09       	sbc	r19, r1
    10c2:	41 09       	sbc	r20, r1
    10c4:	51 09       	sbc	r21, r1
    10c6:	b0 e0       	ldi	r27, 0x00	; 0
    10c8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    10cc:	68 0d       	add	r22, r8
    10ce:	79 1d       	adc	r23, r9
    10d0:	8a 1d       	adc	r24, r10
    10d2:	9b 1d       	adc	r25, r11
    10d4:	f1 01       	movw	r30, r2
    10d6:	67 a3       	std	Z+39, r22	; 0x27
    10d8:	70 a7       	std	Z+40, r23	; 0x28
    10da:	81 a7       	std	Z+41, r24	; 0x29
    10dc:	92 a7       	std	Z+42, r25	; 0x2a
    10de:	00 c0       	rjmp	.+0      	; 0x10e0 <diskInit+0x388>

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    10e0:	c1 2c       	mov	r12, r1
    10e2:	d1 2c       	mov	r13, r1
    10e4:	76 01       	movw	r14, r12
    10e6:	c3 94       	inc	r12
	if(disk->fatType==32){
		disk->firstSectorRootDir += (disk->volume.rootDirCluster-2) * disk->volume.sectorsPerCluster;
	}

	// Initialise the current directory as root
	disk->firstClusterCurrentDir = _diskGetFirstClusterRootDir(disk);
    10e8:	d1 01       	movw	r26, r2
    10ea:	9b 96       	adiw	r26, 0x2b	; 43
    10ec:	cd 92       	st	X+, r12
    10ee:	dd 92       	st	X+, r13
    10f0:	ed 92       	st	X+, r14
    10f2:	fc 92       	st	X, r15
    10f4:	9e 97       	sbiw	r26, 0x2e	; 46
		rprintf("Root@%lu\n",disk->firstSectorRootDir);
		rprintf("Sec/Cluster=%u\n",disk->volume.sectorsPerCluster);
		rprintfInit(old);}
#endif

	return(TRUE);
    10f6:	8f ef       	ldi	r24, 0xFF	; 255
    10f8:	00 c0       	rjmp	.+0      	; 0x10fa <diskInit+0x3a2>

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
	boolean rtn = FALSE;
    10fa:	80 e0       	ldi	r24, 0x00	; 0
		_ioReleaseSector(disc,buf);

		// Initialise the file system
		rtn &= _fatInit(disc);
	}
	disc->initialised = rtn;
    10fc:	f1 01       	movw	r30, r2
    10fe:	84 83       	std	Z+4, r24	; 0x04
	return rtn;
}
    1100:	0f 90       	pop	r0
    1102:	0f 90       	pop	r0
    1104:	0f 90       	pop	r0
    1106:	0f 90       	pop	r0
    1108:	df 91       	pop	r29
    110a:	cf 91       	pop	r28
    110c:	1f 91       	pop	r17
    110e:	0f 91       	pop	r16
    1110:	ff 90       	pop	r15
    1112:	ef 90       	pop	r14
    1114:	df 90       	pop	r13
    1116:	cf 90       	pop	r12
    1118:	bf 90       	pop	r11
    111a:	af 90       	pop	r10
    111c:	9f 90       	pop	r9
    111e:	8f 90       	pop	r8
    1120:	7f 90       	pop	r7
    1122:	6f 90       	pop	r6
    1124:	5f 90       	pop	r5
    1126:	4f 90       	pop	r4
    1128:	3f 90       	pop	r3
    112a:	2f 90       	pop	r2
    112c:	08 95       	ret

0000112e <_partitionDirectSectorRead>:
// Read a sector from inside a partition
void* _partitionGetSector(const DISK* disk, SECTOR partSector, uint8_t mode){
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
}

boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
    112e:	af 92       	push	r10
    1130:	bf 92       	push	r11
    1132:	cf 92       	push	r12
    1134:	df 92       	push	r13
    1136:	ef 92       	push	r14
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
    1144:	6a 01       	movw	r12, r20
    1146:	7b 01       	movw	r14, r22
    1148:	59 01       	movw	r10, r18
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
    114a:	4e 81       	ldd	r20, Y+6	; 0x06
    114c:	5f 81       	ldd	r21, Y+7	; 0x07
    114e:	68 85       	ldd	r22, Y+8	; 0x08
    1150:	79 85       	ldd	r23, Y+9	; 0x09
    1152:	c4 0e       	add	r12, r20
    1154:	d5 1e       	adc	r13, r21
    1156:	e6 1e       	adc	r14, r22
    1158:	f7 1e       	adc	r15, r23
// Return TRUE if done or FALSE if error
static boolean _ioDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	BUFFER* buffer;

	// See if its already in the cache
	buffer=_ioFindSectorInCache(disk,address);
    115a:	b7 01       	movw	r22, r14
    115c:	a6 01       	movw	r20, r12
    115e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1162:	8c 01       	movw	r16, r24
	if(!buffer){
    1164:	00 97       	sbiw	r24, 0x00	; 0
    1166:	01 f4       	brne	.+0      	; 0x1168 <_partitionDirectSectorRead+0x3a>
		// Try to find an unused cache area
		buffer=_bufferFindUnused(disk);
    1168:	ce 01       	movw	r24, r28
    116a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    116e:	8c 01       	movw	r16, r24
		if(buffer){
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	01 f0       	breq	.+0      	; 0x1174 <_partitionDirectSectorRead+0x46>
			// Read the sector into the cache
			if(!_ioPutSectorInCache(disk,buffer,address)){
    1174:	a7 01       	movw	r20, r14
    1176:	96 01       	movw	r18, r12
    1178:	bc 01       	movw	r22, r24
    117a:	ce 01       	movw	r24, r28
    117c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1180:	81 11       	cpse	r24, r1
    1182:	00 c0       	rjmp	.+0      	; 0x1184 <_partitionDirectSectorRead+0x56>
				return(FALSE);
    1184:	80 e0       	ldi	r24, 0x00	; 0
    1186:	00 c0       	rjmp	.+0      	; 0x1188 <_partitionDirectSectorRead+0x5a>
		rprintf("[r%lu]",absSector);
		rprintfInit(old);}
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);
    1188:	e8 81       	ld	r30, Y
    118a:	f9 81       	ldd	r31, Y+1	; 0x01
    118c:	a5 91       	lpm	r26, Z+
    118e:	b4 91       	lpm	r27, Z

	return read(disc->device,absSector,dta);
    1190:	95 01       	movw	r18, r10
    1192:	b7 01       	movw	r22, r14
    1194:	a6 01       	movw	r20, r12
    1196:	8a 81       	ldd	r24, Y+2	; 0x02
    1198:	9b 81       	ldd	r25, Y+3	; 0x03
    119a:	fd 01       	movw	r30, r26
    119c:	09 95       	icall
	if(buffer){
		// If its now in the cache then copy out the data
		memcpy(buf,buffer->dta,512);
	}else{
		// Read it straight into user memory
		if(!_ioReadSector(disk,address,buf)){
    119e:	88 23       	and	r24, r24
    11a0:	01 f0       	breq	.+0      	; 0x11a2 <_partitionDirectSectorRead+0x74>
    11a2:	00 c0       	rjmp	.+0      	; 0x11a4 <_partitionDirectSectorRead+0x76>
		}
	}

	if(buffer){
		// If its now in the cache then copy out the data
		memcpy(buf,buffer->dta,512);
    11a4:	f8 01       	movw	r30, r16
    11a6:	7a 96       	adiw	r30, 0x1a	; 26
    11a8:	80 e0       	ldi	r24, 0x00	; 0
    11aa:	92 e0       	ldi	r25, 0x02	; 2
    11ac:	d5 01       	movw	r26, r10
    11ae:	01 90       	ld	r0, Z+
    11b0:	0d 92       	st	X+, r0
    11b2:	01 97       	sbiw	r24, 0x01	; 1
    11b4:	01 f4       	brne	.+0      	; 0x11b6 <_partitionDirectSectorRead+0x88>
		if(!_ioReadSector(disk,address,buf)){
			return(FALSE);
		}
	}

	return(TRUE);
    11b6:	8f ef       	ldi	r24, 0xFF	; 255
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
}

boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	08 95       	ret

000011ce <_partitionDirectSectorWrite>:
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
    11ce:	af 92       	push	r10
    11d0:	bf 92       	push	r11
    11d2:	cf 92       	push	r12
    11d4:	df 92       	push	r13
    11d6:	ef 92       	push	r14
    11d8:	ff 92       	push	r15
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
    11e2:	8c 01       	movw	r16, r24
    11e4:	6a 01       	movw	r12, r20
    11e6:	7b 01       	movw	r14, r22
    11e8:	59 01       	movw	r10, r18
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
    11ea:	dc 01       	movw	r26, r24
    11ec:	16 96       	adiw	r26, 0x06	; 6
    11ee:	4d 91       	ld	r20, X+
    11f0:	5d 91       	ld	r21, X+
    11f2:	6d 91       	ld	r22, X+
    11f4:	7c 91       	ld	r23, X
    11f6:	19 97       	sbiw	r26, 0x09	; 9
    11f8:	c4 0e       	add	r12, r20
    11fa:	d5 1e       	adc	r13, r21
    11fc:	e6 1e       	adc	r14, r22
    11fe:	f7 1e       	adc	r15, r23

static boolean _ioDirectSectorWrite(const DISK* disk,SECTOR address, const void* buf){
	BUFFER* buffer;

	// If it exists in the cache
	buffer=_ioFindSectorInCache(disk,address);
    1200:	b7 01       	movw	r22, r14
    1202:	a6 01       	movw	r20, r12
    1204:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	if(buffer){
    1208:	00 97       	sbiw	r24, 0x00	; 0
    120a:	01 f0       	breq	.+0      	; 0x120c <_partitionDirectSectorWrite+0x3e>
		// copy it to the cache
		memcpy(buffer->dta,buf,512);
    120c:	dc 01       	movw	r26, r24
    120e:	5a 96       	adiw	r26, 0x1a	; 26
    1210:	20 e0       	ldi	r18, 0x00	; 0
    1212:	32 e0       	ldi	r19, 0x02	; 2
    1214:	f5 01       	movw	r30, r10
    1216:	01 90       	ld	r0, Z+
    1218:	0d 92       	st	X+, r0
    121a:	21 50       	subi	r18, 0x01	; 1
    121c:	30 40       	sbci	r19, 0x00	; 0
    121e:	01 f4       	brne	.+0      	; 0x1220 <_partitionDirectSectorWrite+0x52>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    1220:	fc 01       	movw	r30, r24
    1222:	21 81       	ldd	r18, Z+1	; 0x01
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
    1224:	36 e0       	ldi	r19, 0x06	; 6
    1226:	23 9f       	mul	r18, r19
    1228:	e0 0d       	add	r30, r0
    122a:	f1 1d       	adc	r31, r1
    122c:	11 24       	eor	r1, r1
    122e:	32 96       	adiw	r30, 0x02	; 2
    1230:	85 81       	ldd	r24, Z+5	; 0x05
    1232:	82 60       	ori	r24, 0x02	; 2
    1234:	85 83       	std	Z+5, r24	; 0x05
    1236:	00 c0       	rjmp	.+0      	; 0x1238 <_partitionDirectSectorWrite+0x6a>
		_bufferSetWritable(buffer);
		return(TRUE);
	}

	// Try to find an available cache buffer entry
	buffer=_bufferFindUnused(disk);
    1238:	c8 01       	movw	r24, r16
    123a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    123e:	ec 01       	movw	r28, r24
	if(buffer){
    1240:	00 97       	sbiw	r24, 0x00	; 0
    1242:	01 f0       	breq	.+0      	; 0x1244 <_partitionDirectSectorWrite+0x76>
		// copy it into the cache
		memcpy(buffer->dta,buf,512);
    1244:	dc 01       	movw	r26, r24
    1246:	5a 96       	adiw	r26, 0x1a	; 26
    1248:	80 e0       	ldi	r24, 0x00	; 0
    124a:	92 e0       	ldi	r25, 0x02	; 2
    124c:	f5 01       	movw	r30, r10
    124e:	01 90       	ld	r0, Z+
    1250:	0d 92       	st	X+, r0
    1252:	01 97       	sbiw	r24, 0x01	; 1
    1254:	01 f4       	brne	.+0      	; 0x1256 <_partitionDirectSectorWrite+0x88>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    1256:	89 81       	ldd	r24, Y+1	; 0x01
	// Try to find an available cache buffer entry
	buffer=_bufferFindUnused(disk);
	if(buffer){
		// copy it into the cache
		memcpy(buffer->dta,buf,512);
		SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
    1258:	e6 e0       	ldi	r30, 0x06	; 6
    125a:	be 2e       	mov	r11, r30
    125c:	8e 01       	movw	r16, r28
    125e:	b8 9e       	mul	r11, r24
    1260:	00 0d       	add	r16, r0
    1262:	11 1d       	adc	r17, r1
    1264:	11 24       	eor	r1, r1
    1266:	0e 5f       	subi	r16, 0xFE	; 254
    1268:	1f 4f       	sbci	r17, 0xFF	; 255
		// Set cache entry to indicate it needs writing
		_bufferReset(buffer);
    126a:	ce 01       	movw	r24, r28
    126c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		current->sector = address;
    1270:	d8 01       	movw	r26, r16
    1272:	cd 92       	st	X+, r12
    1274:	dd 92       	st	X+, r13
    1276:	ed 92       	st	X+, r14
    1278:	fc 92       	st	X, r15
    127a:	13 97       	sbiw	r26, 0x03	; 3
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    127c:	89 81       	ldd	r24, Y+1	; 0x01
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
    127e:	fe 01       	movw	r30, r28
    1280:	b8 9e       	mul	r11, r24
    1282:	e0 0d       	add	r30, r0
    1284:	f1 1d       	adc	r31, r1
    1286:	11 24       	eor	r1, r1
    1288:	32 96       	adiw	r30, 0x02	; 2
    128a:	85 81       	ldd	r24, Z+5	; 0x05
    128c:	82 60       	ori	r24, 0x02	; 2
    128e:	85 83       	std	Z+5, r24	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    1290:	89 81       	ldd	r24, Y+1	; 0x01
}

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
    1292:	b8 9e       	mul	r11, r24
    1294:	c0 0d       	add	r28, r0
    1296:	d1 1d       	adc	r29, r1
    1298:	11 24       	eor	r1, r1
    129a:	22 96       	adiw	r28, 0x02	; 2
    129c:	8d 81       	ldd	r24, Y+5	; 0x05
    129e:	81 60       	ori	r24, 0x01	; 1
    12a0:	8d 83       	std	Y+5, r24	; 0x05
    12a2:	00 c0       	rjmp	.+0      	; 0x12a4 <_partitionDirectSectorWrite+0xd6>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("[w%lu]",absSector);
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);
    12a4:	d8 01       	movw	r26, r16
    12a6:	ed 91       	ld	r30, X+
    12a8:	fc 91       	ld	r31, X
    12aa:	32 96       	adiw	r30, 0x02	; 2
    12ac:	a5 91       	lpm	r26, Z+
    12ae:	b4 91       	lpm	r27, Z

	return write(disc->device,absSector,dta);
    12b0:	95 01       	movw	r18, r10
    12b2:	b7 01       	movw	r22, r14
    12b4:	a6 01       	movw	r20, r12
    12b6:	f8 01       	movw	r30, r16
    12b8:	82 81       	ldd	r24, Z+2	; 0x02
    12ba:	93 81       	ldd	r25, Z+3	; 0x03
    12bc:	fd 01       	movw	r30, r26
boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
}
    12be:	df 91       	pop	r29
    12c0:	cf 91       	pop	r28
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	ff 90       	pop	r15
    12c8:	ef 90       	pop	r14
    12ca:	df 90       	pop	r13
    12cc:	cf 90       	pop	r12
    12ce:	bf 90       	pop	r11
    12d0:	af 90       	pop	r10
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);

	return write(disc->device,absSector,dta);
    12d2:	09 94       	ijmp
boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
}
    12d4:	8f ef       	ldi	r24, 0xFF	; 255
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	1f 91       	pop	r17
    12dc:	0f 91       	pop	r16
    12de:	ff 90       	pop	r15
    12e0:	ef 90       	pop	r14
    12e2:	df 90       	pop	r13
    12e4:	cf 90       	pop	r12
    12e6:	bf 90       	pop	r11
    12e8:	af 90       	pop	r10
    12ea:	08 95       	ret

000012ec <_partitionClearCluster>:
static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
    12ec:	bf 92       	push	r11
    12ee:	cf 92       	push	r12
    12f0:	df 92       	push	r13
    12f2:	ef 92       	push	r14
    12f4:	ff 92       	push	r15
    12f6:	0f 93       	push	r16
    12f8:	1f 93       	push	r17
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ec 01       	movw	r28, r24
	SECTOR sector = _diskClusterToSector(disk,cluster);
    1300:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1304:	b6 2e       	mov	r11, r22
    1306:	c6 2e       	mov	r12, r22
    1308:	d7 2e       	mov	r13, r23
    130a:	7c 01       	movw	r14, r24
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
		memclr(buf,512);
    130c:	00 e0       	ldi	r16, 0x00	; 0
    130e:	12 e0       	ldi	r17, 0x02	; 2
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    1310:	00 c0       	rjmp	.+0      	; 0x1312 <_partitionClearCluster+0x26>
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
    1312:	22 e0       	ldi	r18, 0x02	; 2
    1314:	b7 01       	movw	r22, r14
    1316:	a6 01       	movw	r20, r12
    1318:	ce 01       	movw	r24, r28
    131a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		memclr(buf,512);
    131e:	dc 01       	movw	r26, r24
    1320:	98 01       	movw	r18, r16
    1322:	1d 92       	st	X+, r1
    1324:	21 50       	subi	r18, 0x01	; 1
    1326:	30 40       	sbci	r19, 0x00	; 0
    1328:	01 f4       	brne	.+0      	; 0x132a <_partitionClearCluster+0x3e>
    132a:	bc 01       	movw	r22, r24
    132c:	ce 01       	movw	r24, r28
    132e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    1332:	3f ef       	ldi	r19, 0xFF	; 255
    1334:	c3 1a       	sub	r12, r19
    1336:	d3 0a       	sbc	r13, r19
    1338:	e3 0a       	sbc	r14, r19
    133a:	f3 0a       	sbc	r15, r19
static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
    133c:	9c 2d       	mov	r25, r12
    133e:	9b 19       	sub	r25, r11
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    1340:	88 89       	ldd	r24, Y+16	; 0x10
    1342:	98 17       	cp	r25, r24
    1344:	00 f0       	brcs	.+0      	; 0x1346 <_partitionClearCluster+0x5a>
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
		memclr(buf,512);
		partition_releaseSector(disk,buf);
	}
}
    1346:	df 91       	pop	r29
    1348:	cf 91       	pop	r28
    134a:	1f 91       	pop	r17
    134c:	0f 91       	pop	r16
    134e:	ff 90       	pop	r15
    1350:	ef 90       	pop	r14
    1352:	df 90       	pop	r13
    1354:	cf 90       	pop	r12
    1356:	bf 90       	pop	r11
    1358:	08 95       	ret

0000135a <_fatGiveEndMarker>:
	return(TRUE);
}

// Return the cluster number that represent the end of chain marker

CLUSTER _fatGiveEndMarker(const DISK* disk){
    135a:	0f 93       	push	r16
    135c:	1f 93       	push	r17
    135e:	dc 01       	movw	r26, r24
    1360:	96 96       	adiw	r26, 0x26	; 38
    1362:	ec 91       	ld	r30, X
    1364:	ec 50       	subi	r30, 0x0C	; 12
    1366:	e5 31       	cpi	r30, 0x15	; 21
    1368:	00 f4       	brcc	.+0      	; 0x136a <_fatGiveEndMarker+0x10>
    136a:	b4 e0       	ldi	r27, 0x04	; 4
    136c:	eb 9f       	mul	r30, r27
    136e:	f0 01       	movw	r30, r0
    1370:	11 24       	eor	r1, r1
    1372:	e0 50       	subi	r30, 0x00	; 0
    1374:	f0 40       	sbci	r31, 0x00	; 0
    1376:	00 81       	ld	r16, Z
    1378:	11 81       	ldd	r17, Z+1	; 0x01
    137a:	22 81       	ldd	r18, Z+2	; 0x02
    137c:	33 81       	ldd	r19, Z+3	; 0x03
    137e:	00 c0       	rjmp	.+0      	; 0x1380 <_fatGiveEndMarker+0x26>
	switch(disk->fatType){
    1380:	00 e0       	ldi	r16, 0x00	; 0
    1382:	10 e0       	ldi	r17, 0x00	; 0
    1384:	98 01       	movw	r18, r16
			return(CLUSTER)0xFFFFUL;
		case 32:
			return(CLUSTER)0x0FFFFFFFUL;
	}
	return(CLUSTER)0UL;
}
    1386:	b8 01       	movw	r22, r16
    1388:	c9 01       	movw	r24, r18
    138a:	1f 91       	pop	r17
    138c:	0f 91       	pop	r16
    138e:	08 95       	ret

00001390 <_fatNavigateTo>:
	return(TRUE);
}

// Attempt to find the given relative cluster starting at the current CLUSTER_NAV entry
// Return value: TRUE on success and FALSE if its not part of the cluster chain
boolean _fatNavigateTo(const DISK *disk, CLUSTER_NAV *nav,CLUSTER_COUNT relativeCluster){
    1390:	6f 92       	push	r6
    1392:	7f 92       	push	r7
    1394:	8f 92       	push	r8
    1396:	9f 92       	push	r9
    1398:	af 92       	push	r10
    139a:	bf 92       	push	r11
    139c:	cf 92       	push	r12
    139e:	df 92       	push	r13
    13a0:	ef 92       	push	r14
    13a2:	ff 92       	push	r15
    13a4:	0f 93       	push	r16
    13a6:	1f 93       	push	r17
    13a8:	cf 93       	push	r28
    13aa:	df 93       	push	r29
    13ac:	00 d0       	rcall	.+0      	; 0x13ae <_fatNavigateTo+0x1e>
    13ae:	00 d0       	rcall	.+0      	; 0x13b0 <_fatNavigateTo+0x20>
    13b0:	cd b7       	in	r28, 0x3d	; 61
    13b2:	de b7       	in	r29, 0x3e	; 62
    13b4:	8c 01       	movw	r16, r24
    13b6:	3b 01       	movw	r6, r22

	// If we've gone backwards then start from the beginning
	if(relativeCluster<nav->relativeCluster || nav->currentCluster==0){
    13b8:	fb 01       	movw	r30, r22
    13ba:	84 81       	ldd	r24, Z+4	; 0x04
    13bc:	95 81       	ldd	r25, Z+5	; 0x05
    13be:	a6 81       	ldd	r26, Z+6	; 0x06
    13c0:	b7 81       	ldd	r27, Z+7	; 0x07
    13c2:	28 17       	cp	r18, r24
    13c4:	39 07       	cpc	r19, r25
    13c6:	4a 07       	cpc	r20, r26
    13c8:	5b 07       	cpc	r21, r27
    13ca:	00 f0       	brcs	.+0      	; 0x13cc <_fatNavigateTo+0x3c>
    13cc:	80 85       	ldd	r24, Z+8	; 0x08
    13ce:	91 85       	ldd	r25, Z+9	; 0x09
    13d0:	a2 85       	ldd	r26, Z+10	; 0x0a
    13d2:	b3 85       	ldd	r27, Z+11	; 0x0b
    13d4:	89 2b       	or	r24, r25
    13d6:	8a 2b       	or	r24, r26
    13d8:	8b 2b       	or	r24, r27
    13da:	01 f4       	brne	.+0      	; 0x13dc <_fatNavigateTo+0x4c>
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav From start\n");
		rprintfInit(old);}
#endif

		nav->relativeCluster=0;
    13dc:	f3 01       	movw	r30, r6
    13de:	14 82       	std	Z+4, r1	; 0x04
    13e0:	15 82       	std	Z+5, r1	; 0x05
    13e2:	16 82       	std	Z+6, r1	; 0x06
    13e4:	17 82       	std	Z+7, r1	; 0x07
		nav->currentCluster=nav->startCluster;
    13e6:	84 85       	ldd	r24, Z+12	; 0x0c
    13e8:	95 85       	ldd	r25, Z+13	; 0x0d
    13ea:	a6 85       	ldd	r26, Z+14	; 0x0e
    13ec:	b7 85       	ldd	r27, Z+15	; 0x0f
    13ee:	80 87       	std	Z+8, r24	; 0x08
    13f0:	91 87       	std	Z+9, r25	; 0x09
    13f2:	a2 87       	std	Z+10, r26	; 0x0a
    13f4:	b3 87       	std	Z+11, r27	; 0x0b
		nav->contiguousCount=0;
    13f6:	10 82       	st	Z, r1
    13f8:	11 82       	std	Z+1, r1	; 0x01
    13fa:	12 82       	std	Z+2, r1	; 0x02
    13fc:	13 82       	std	Z+3, r1	; 0x03
	}

	if(nav->relativeCluster==relativeCluster){
    13fe:	f3 01       	movw	r30, r6
    1400:	84 81       	ldd	r24, Z+4	; 0x04
    1402:	95 81       	ldd	r25, Z+5	; 0x05
    1404:	a6 81       	ldd	r26, Z+6	; 0x06
    1406:	b7 81       	ldd	r27, Z+7	; 0x07
    1408:	82 17       	cp	r24, r18
    140a:	93 07       	cpc	r25, r19
    140c:	a4 07       	cpc	r26, r20
    140e:	b5 07       	cpc	r27, r21
    1410:	01 f4       	brne	.+0      	; 0x1412 <_fatNavigateTo+0x82>
		return TRUE;
    1412:	8f ef       	ldi	r24, 0xFF	; 255
    1414:	00 c0       	rjmp	.+0      	; 0x1416 <_fatNavigateTo+0x86>
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav find %lu, seek %lu, @%lu\n",nav->relativeCluster,relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif

		if(nav->contiguousCount!=0){
    1416:	f3 01       	movw	r30, r6
    1418:	80 80       	ld	r8, Z
    141a:	91 80       	ldd	r9, Z+1	; 0x01
    141c:	a2 80       	ldd	r10, Z+2	; 0x02
    141e:	b3 80       	ldd	r11, Z+3	; 0x03
    1420:	81 14       	cp	r8, r1
    1422:	91 04       	cpc	r9, r1
    1424:	a1 04       	cpc	r10, r1
    1426:	b1 04       	cpc	r11, r1
    1428:	01 f0       	breq	.+0      	; 0x142a <_fatNavigateTo+0x9a>
			// We already know the next one is contiguous
			nav->contiguousCount--;
    142a:	f1 e0       	ldi	r31, 0x01	; 1
    142c:	8f 1a       	sub	r8, r31
    142e:	91 08       	sbc	r9, r1
    1430:	a1 08       	sbc	r10, r1
    1432:	b1 08       	sbc	r11, r1
    1434:	f3 01       	movw	r30, r6
    1436:	80 82       	st	Z, r8
    1438:	91 82       	std	Z+1, r9	; 0x01
    143a:	a2 82       	std	Z+2, r10	; 0x02
    143c:	b3 82       	std	Z+3, r11	; 0x03
			nav->relativeCluster++;
    143e:	ff ef       	ldi	r31, 0xFF	; 255
    1440:	cf 1a       	sub	r12, r31
    1442:	df 0a       	sbc	r13, r31
    1444:	ef 0a       	sbc	r14, r31
    1446:	ff 0a       	sbc	r15, r31
    1448:	f3 01       	movw	r30, r6
    144a:	c4 82       	std	Z+4, r12	; 0x04
    144c:	d5 82       	std	Z+5, r13	; 0x05
    144e:	e6 82       	std	Z+6, r14	; 0x06
    1450:	f7 82       	std	Z+7, r15	; 0x07
			nav->currentCluster++;
    1452:	c0 84       	ldd	r12, Z+8	; 0x08
    1454:	d1 84       	ldd	r13, Z+9	; 0x09
    1456:	e2 84       	ldd	r14, Z+10	; 0x0a
    1458:	f3 84       	ldd	r15, Z+11	; 0x0b
    145a:	ff ef       	ldi	r31, 0xFF	; 255
    145c:	cf 1a       	sub	r12, r31
    145e:	df 0a       	sbc	r13, r31
    1460:	ef 0a       	sbc	r14, r31
    1462:	ff 0a       	sbc	r15, r31
    1464:	f3 01       	movw	r30, r6
    1466:	c0 86       	std	Z+8, r12	; 0x08
    1468:	d1 86       	std	Z+9, r13	; 0x09
    146a:	e2 86       	std	Z+10, r14	; 0x0a
    146c:	f3 86       	std	Z+11, r15	; 0x0b
    146e:	00 c0       	rjmp	.+0      	; 0x1470 <_fatNavigateTo+0xe0>
		}else{
			// Get the next cluster chain
			if( !_fatGetNextClusterChain(disk,nav)){
    1470:	b3 01       	movw	r22, r6
    1472:	c8 01       	movw	r24, r16
    1474:	29 83       	std	Y+1, r18	; 0x01
    1476:	3a 83       	std	Y+2, r19	; 0x02
    1478:	4b 83       	std	Y+3, r20	; 0x03
    147a:	5c 83       	std	Y+4, r21	; 0x04
    147c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1480:	29 81       	ldd	r18, Y+1	; 0x01
    1482:	3a 81       	ldd	r19, Y+2	; 0x02
    1484:	4b 81       	ldd	r20, Y+3	; 0x03
    1486:	5c 81       	ldd	r21, Y+4	; 0x04
    1488:	88 23       	and	r24, r24
    148a:	01 f0       	breq	.+0      	; 0x148c <_fatNavigateTo+0xfc>

	if(nav->relativeCluster==relativeCluster){
		return TRUE;
	}

	while(nav->relativeCluster!=relativeCluster){
    148c:	f3 01       	movw	r30, r6
    148e:	c4 80       	ldd	r12, Z+4	; 0x04
    1490:	d5 80       	ldd	r13, Z+5	; 0x05
    1492:	e6 80       	ldd	r14, Z+6	; 0x06
    1494:	f7 80       	ldd	r15, Z+7	; 0x07
    1496:	c2 16       	cp	r12, r18
    1498:	d3 06       	cpc	r13, r19
    149a:	e4 06       	cpc	r14, r20
    149c:	f5 06       	cpc	r15, r21
    149e:	01 f0       	breq	.+0      	; 0x14a0 <_fatNavigateTo+0x110>
    14a0:	00 c0       	rjmp	.+0      	; 0x14a2 <_fatNavigateTo+0x112>
    14a2:	00 c0       	rjmp	.+0      	; 0x14a4 <_fatNavigateTo+0x114>
#ifdef FAT_DEBUG
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav end %lu, seek %lu, @%lu\n",nav->relativeCluster,relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif
				return(FALSE);
    14a4:	80 e0       	ldi	r24, 0x00	; 0
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav @%lu => %lu\n",nav->relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif
	return(TRUE);
}
    14a6:	0f 90       	pop	r0
    14a8:	0f 90       	pop	r0
    14aa:	0f 90       	pop	r0
    14ac:	0f 90       	pop	r0
    14ae:	df 91       	pop	r29
    14b0:	cf 91       	pop	r28
    14b2:	1f 91       	pop	r17
    14b4:	0f 91       	pop	r16
    14b6:	ff 90       	pop	r15
    14b8:	ef 90       	pop	r14
    14ba:	df 90       	pop	r13
    14bc:	cf 90       	pop	r12
    14be:	bf 90       	pop	r11
    14c0:	af 90       	pop	r10
    14c2:	9f 90       	pop	r9
    14c4:	8f 90       	pop	r8
    14c6:	7f 90       	pop	r7
    14c8:	6f 90       	pop	r6
    14ca:	08 95       	ret

000014cc <_fatSetNextClusterAddress>:
// Update the FAT to indicate that cluster_addr is followed by next_cluster_addr
void _fatSetNextClusterAddress(const DISK* disk,CLUSTER cluster_addr,CLUSTER next_cluster_addr){
    14cc:	4f 92       	push	r4
    14ce:	5f 92       	push	r5
    14d0:	6f 92       	push	r6
    14d2:	7f 92       	push	r7
    14d4:	8f 92       	push	r8
    14d6:	9f 92       	push	r9
    14d8:	af 92       	push	r10
    14da:	bf 92       	push	r11
    14dc:	cf 92       	push	r12
    14de:	df 92       	push	r13
    14e0:	ef 92       	push	r14
    14e2:	ff 92       	push	r15
    14e4:	0f 93       	push	r16
    14e6:	1f 93       	push	r17
    14e8:	cf 93       	push	r28
    14ea:	df 93       	push	r29
    14ec:	ec 01       	movw	r28, r24
    14ee:	4a 01       	movw	r8, r20
    14f0:	5b 01       	movw	r10, r22
    14f2:	68 01       	movw	r12, r16
    14f4:	79 01       	movw	r14, r18
	SECTOR sector=_fatGetSectorAddressFatEntry(disk,cluster_addr);
    14f6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    14fa:	ab 01       	movw	r20, r22
    14fc:	bc 01       	movw	r22, r24

	if(( disk->fatSectorCount <= (sector - disk->volume.reservedSectorCount )||(sector==0))){
    14fe:	89 89       	ldd	r24, Y+17	; 0x11
    1500:	9a 89       	ldd	r25, Y+18	; 0x12
    1502:	8a 01       	movw	r16, r20
    1504:	9b 01       	movw	r18, r22
    1506:	08 1b       	sub	r16, r24
    1508:	19 0b       	sbc	r17, r25
    150a:	21 09       	sbc	r18, r1
    150c:	31 09       	sbc	r19, r1
    150e:	d9 01       	movw	r26, r18
    1510:	c8 01       	movw	r24, r16
    1512:	0a 8d       	ldd	r16, Y+26	; 0x1a
    1514:	1b 8d       	ldd	r17, Y+27	; 0x1b
    1516:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1518:	3d 8d       	ldd	r19, Y+29	; 0x1d
    151a:	80 17       	cp	r24, r16
    151c:	91 07       	cpc	r25, r17
    151e:	a2 07       	cpc	r26, r18
    1520:	b3 07       	cpc	r27, r19
    1522:	00 f0       	brcs	.+0      	; 0x1524 <_fatSetNextClusterAddress+0x58>
    1524:	00 c0       	rjmp	.+0      	; 0x1526 <_fatSetNextClusterAddress+0x5a>
    1526:	41 15       	cp	r20, r1
    1528:	51 05       	cpc	r21, r1
    152a:	61 05       	cpc	r22, r1
    152c:	71 05       	cpc	r23, r1
    152e:	01 f4       	brne	.+0      	; 0x1530 <_fatSetNextClusterAddress+0x64>
    1530:	00 c0       	rjmp	.+0      	; 0x1532 <_fatSetNextClusterAddress+0x66>
	    return;
	}

	uint8_t* buf=_partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
    1532:	22 e0       	ldi	r18, 0x02	; 2
    1534:	ce 01       	movw	r24, r28
    1536:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    153a:	8c 01       	movw	r16, r24
	size_t offset;

	switch(disk->fatType){
    153c:	8e a1       	ldd	r24, Y+38	; 0x26
    153e:	80 31       	cpi	r24, 0x10	; 16
    1540:	01 f4       	brne	.+0      	; 0x1542 <_fatSetNextClusterAddress+0x76>
    1542:	00 c0       	rjmp	.+0      	; 0x1544 <_fatSetNextClusterAddress+0x78>
    1544:	80 32       	cpi	r24, 0x20	; 32
    1546:	01 f4       	brne	.+0      	; 0x1548 <_fatSetNextClusterAddress+0x7c>
    1548:	00 c0       	rjmp	.+0      	; 0x154a <_fatSetNextClusterAddress+0x7e>
    154a:	8c 30       	cpi	r24, 0x0C	; 12
    154c:	01 f0       	breq	.+0      	; 0x154e <_fatSetNextClusterAddress+0x82>
    154e:	00 c0       	rjmp	.+0      	; 0x1550 <_fatSetNextClusterAddress+0x84>
		case 12:
			offset = ((cluster_addr%1024)*3/2)%512;
    1550:	a5 01       	movw	r20, r10
    1552:	94 01       	movw	r18, r8
    1554:	33 70       	andi	r19, 0x03	; 3
    1556:	44 27       	eor	r20, r20
    1558:	55 27       	eor	r21, r21
    155a:	a3 e0       	ldi	r26, 0x03	; 3
    155c:	b0 e0       	ldi	r27, 0x00	; 0
    155e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1562:	96 95       	lsr	r25
    1564:	87 95       	ror	r24
    1566:	77 95       	ror	r23
    1568:	67 95       	ror	r22
    156a:	71 70       	andi	r23, 0x01	; 1
    156c:	88 27       	eor	r24, r24
    156e:	99 27       	eor	r25, r25
    1570:	41 2c       	mov	r4, r1
    1572:	51 2c       	mov	r5, r1
    1574:	32 01       	movw	r6, r4
    1576:	43 94       	inc	r4
    1578:	48 20       	and	r4, r8
    157a:	59 20       	and	r5, r9
    157c:	6a 20       	and	r6, r10
    157e:	7b 20       	and	r7, r11
    1580:	f8 01       	movw	r30, r16
			if(offset == 511){
    1582:	6f 3f       	cpi	r22, 0xFF	; 255
    1584:	21 e0       	ldi	r18, 0x01	; 1
    1586:	72 07       	cpc	r23, r18
    1588:	01 f4       	brne	.+0      	; 0x158a <_fatSetNextClusterAddress+0xbe>
    158a:	e1 50       	subi	r30, 0x01	; 1
    158c:	fe 4f       	sbci	r31, 0xFE	; 254
				if(cluster_addr%2==0){
    158e:	41 14       	cp	r4, r1
    1590:	51 04       	cpc	r5, r1
    1592:	61 04       	cpc	r6, r1
    1594:	71 04       	cpc	r7, r1
    1596:	01 f4       	brne	.+0      	; 0x1598 <_fatSetNextClusterAddress+0xcc>
					buf[offset] = next_cluster_addr & 0xFF;
    1598:	c0 82       	st	Z, r12
    159a:	00 c0       	rjmp	.+0      	; 0x159c <_fatSetNextClusterAddress+0xd0>
				}else{
					buf[offset] = (buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
    159c:	80 81       	ld	r24, Z
    159e:	8f 70       	andi	r24, 0x0F	; 15
    15a0:	30 e1       	ldi	r19, 0x10	; 16
    15a2:	c3 9e       	mul	r12, r19
    15a4:	80 0d       	add	r24, r0
    15a6:	11 24       	eor	r1, r1
    15a8:	80 83       	st	Z, r24
				}
				// Read second sector
				uint8_t* buf2=_partitionGetSector(disk,_fatGetSectorAddressFatEntry(disk,cluster_addr)+1,BUFFER_MODE_READWRITE);
    15aa:	b5 01       	movw	r22, r10
    15ac:	a4 01       	movw	r20, r8
    15ae:	ce 01       	movw	r24, r28
    15b0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    15b4:	ab 01       	movw	r20, r22
    15b6:	bc 01       	movw	r22, r24
    15b8:	4f 5f       	subi	r20, 0xFF	; 255
    15ba:	5f 4f       	sbci	r21, 0xFF	; 255
    15bc:	6f 4f       	sbci	r22, 0xFF	; 255
    15be:	7f 4f       	sbci	r23, 0xFF	; 255
    15c0:	22 e0       	ldi	r18, 0x02	; 2
    15c2:	ce 01       	movw	r24, r28
    15c4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    15c8:	fc 01       	movw	r30, r24
				if(cluster_addr%2==0){
    15ca:	45 28       	or	r4, r5
    15cc:	46 28       	or	r4, r6
    15ce:	47 28       	or	r4, r7
    15d0:	01 f4       	brne	.+0      	; 0x15d2 <_fatSetNextClusterAddress+0x106>
					buf2[0]=(buf2[0]&0xF0)+((next_cluster_addr>>8)&0xF);
    15d2:	90 81       	ld	r25, Z
    15d4:	90 7f       	andi	r25, 0xF0	; 240
    15d6:	8d 2d       	mov	r24, r13
    15d8:	8f 70       	andi	r24, 0x0F	; 15
    15da:	89 0f       	add	r24, r25
    15dc:	80 83       	st	Z, r24
    15de:	00 c0       	rjmp	.+0      	; 0x15e0 <_fatSetNextClusterAddress+0x114>
				}else{
					buf2[0]=(next_cluster_addr>>4)&0xFF;
    15e0:	94 e0       	ldi	r25, 0x04	; 4
    15e2:	f6 94       	lsr	r15
    15e4:	e7 94       	ror	r14
    15e6:	d7 94       	ror	r13
    15e8:	c7 94       	ror	r12
    15ea:	9a 95       	dec	r25
    15ec:	01 f4       	brne	.+0      	; 0x15ee <_fatSetNextClusterAddress+0x122>
    15ee:	c0 82       	st	Z, r12
    15f0:	bf 01       	movw	r22, r30
    15f2:	ce 01       	movw	r24, r28
    15f4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    15f8:	00 c0       	rjmp	.+0      	; 0x15fa <_fatSetNextClusterAddress+0x12e>
    15fa:	e6 0f       	add	r30, r22
    15fc:	f7 1f       	adc	r31, r23
				}
				// Write second sector
				partition_releaseSector(disk,buf2);
			}else{
				if(cluster_addr%2==0){
    15fe:	45 28       	or	r4, r5
    1600:	46 28       	or	r4, r6
    1602:	47 28       	or	r4, r7
    1604:	01 f4       	brne	.+0      	; 0x1606 <_fatSetNextClusterAddress+0x13a>
					buf[offset]=next_cluster_addr&0xFF;
    1606:	c0 82       	st	Z, r12
					buf[offset+1]=(buf[offset+1]&0xF0)+((next_cluster_addr>>8)&0xF);
    1608:	fb 01       	movw	r30, r22
    160a:	31 96       	adiw	r30, 0x01	; 1
    160c:	e0 0f       	add	r30, r16
    160e:	f1 1f       	adc	r31, r17
    1610:	90 81       	ld	r25, Z
    1612:	90 7f       	andi	r25, 0xF0	; 240
    1614:	8d 2d       	mov	r24, r13
    1616:	8f 70       	andi	r24, 0x0F	; 15
    1618:	89 0f       	add	r24, r25
    161a:	80 83       	st	Z, r24
    161c:	00 c0       	rjmp	.+0      	; 0x161e <_fatSetNextClusterAddress+0x152>
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
    161e:	80 81       	ld	r24, Z
    1620:	8f 70       	andi	r24, 0x0F	; 15
    1622:	90 e1       	ldi	r25, 0x10	; 16
    1624:	c9 9e       	mul	r12, r25
    1626:	80 0d       	add	r24, r0
    1628:	11 24       	eor	r1, r1
    162a:	80 83       	st	Z, r24
					buf[offset+1]=(next_cluster_addr>>4)&0xFF;
    162c:	84 e0       	ldi	r24, 0x04	; 4
    162e:	f6 94       	lsr	r15
    1630:	e7 94       	ror	r14
    1632:	d7 94       	ror	r13
    1634:	c7 94       	ror	r12
    1636:	8a 95       	dec	r24
    1638:	01 f4       	brne	.+0      	; 0x163a <_fatSetNextClusterAddress+0x16e>
    163a:	c1 82       	std	Z+1, r12	; 0x01
    163c:	00 c0       	rjmp	.+0      	; 0x163e <_fatSetNextClusterAddress+0x172>
				}
			}
			break;
		case 16:
			offset=cluster_addr%256;
    163e:	99 24       	eor	r9, r9
    1640:	aa 24       	eor	r10, r10
    1642:	bb 24       	eor	r11, r11
			*((uint16_t*)buf+offset)=next_cluster_addr;
    1644:	f4 01       	movw	r30, r8
    1646:	ee 0f       	add	r30, r30
    1648:	ff 1f       	adc	r31, r31
    164a:	e0 0f       	add	r30, r16
    164c:	f1 1f       	adc	r31, r17
    164e:	d1 82       	std	Z+1, r13	; 0x01
    1650:	c0 82       	st	Z, r12
			break;
    1652:	00 c0       	rjmp	.+0      	; 0x1654 <_fatSetNextClusterAddress+0x188>
		case 32:
			offset=cluster_addr%128;
    1654:	e8 94       	clt
    1656:	87 f8       	bld	r8, 7
    1658:	99 24       	eor	r9, r9
    165a:	aa 24       	eor	r10, r10
    165c:	bb 24       	eor	r11, r11
			*((uint32_t*)buf+offset)=next_cluster_addr;
    165e:	f4 01       	movw	r30, r8
    1660:	ee 0f       	add	r30, r30
    1662:	ff 1f       	adc	r31, r31
    1664:	ee 0f       	add	r30, r30
    1666:	ff 1f       	adc	r31, r31
    1668:	e0 0f       	add	r30, r16
    166a:	f1 1f       	adc	r31, r17
    166c:	c0 82       	st	Z, r12
    166e:	d1 82       	std	Z+1, r13	; 0x01
    1670:	e2 82       	std	Z+2, r14	; 0x02
    1672:	f3 82       	std	Z+3, r15	; 0x03
    1674:	b8 01       	movw	r22, r16
    1676:	ce 01       	movw	r24, r28
			break;
	}
	partition_releaseSector(disk,buf);
}
    1678:	df 91       	pop	r29
    167a:	cf 91       	pop	r28
    167c:	1f 91       	pop	r17
    167e:	0f 91       	pop	r16
    1680:	ff 90       	pop	r15
    1682:	ef 90       	pop	r14
    1684:	df 90       	pop	r13
    1686:	cf 90       	pop	r12
    1688:	bf 90       	pop	r11
    168a:	af 90       	pop	r10
    168c:	9f 90       	pop	r9
    168e:	8f 90       	pop	r8
    1690:	7f 90       	pop	r7
    1692:	6f 90       	pop	r6
    1694:	5f 90       	pop	r5
    1696:	4f 90       	pop	r4
    1698:	0c 94 00 00 	jmp	0	; 0x0 <_bufferIsWritable>
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	1f 91       	pop	r17
    16a2:	0f 91       	pop	r16
    16a4:	ff 90       	pop	r15
    16a6:	ef 90       	pop	r14
    16a8:	df 90       	pop	r13
    16aa:	cf 90       	pop	r12
    16ac:	bf 90       	pop	r11
    16ae:	af 90       	pop	r10
    16b0:	9f 90       	pop	r9
    16b2:	8f 90       	pop	r8
    16b4:	7f 90       	pop	r7
    16b6:	6f 90       	pop	r6
    16b8:	5f 90       	pop	r5
    16ba:	4f 90       	pop	r4
    16bc:	08 95       	ret

000016be <_fatGetFreeCluster>:

// Find a free cluster on the disk
// Return the cluster or 0 if the disk is full
CLUSTER _fatGetFreeCluster(DISK* disk){
    16be:	2f 92       	push	r2
    16c0:	3f 92       	push	r3
    16c2:	4f 92       	push	r4
    16c4:	5f 92       	push	r5
    16c6:	6f 92       	push	r6
    16c8:	7f 92       	push	r7
    16ca:	8f 92       	push	r8
    16cc:	9f 92       	push	r9
    16ce:	af 92       	push	r10
    16d0:	bf 92       	push	r11
    16d2:	cf 92       	push	r12
    16d4:	df 92       	push	r13
    16d6:	ef 92       	push	r14
    16d8:	ff 92       	push	r15
    16da:	0f 93       	push	r16
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	00 d0       	rcall	.+0      	; 0x16e4 <_fatGetFreeCluster+0x26>
    16e4:	00 d0       	rcall	.+0      	; 0x16e6 <_fatGetFreeCluster+0x28>
    16e6:	cd b7       	in	r28, 0x3d	; 61
    16e8:	de b7       	in	r29, 0x3e	; 62
    16ea:	1c 01       	movw	r2, r24
	CLUSTER start = disk->freeClusterHint;
    16ec:	dc 01       	movw	r26, r24
    16ee:	9f 96       	adiw	r26, 0x2f	; 47
    16f0:	8d 90       	ld	r8, X+
    16f2:	9d 90       	ld	r9, X+
    16f4:	ad 90       	ld	r10, X+
    16f6:	bc 90       	ld	r11, X
    16f8:	d2 97       	sbiw	r26, 0x32	; 50
	if(start < 2 || start > disk->dataClusterCount){
    16fa:	b2 e0       	ldi	r27, 0x02	; 2
    16fc:	8b 16       	cp	r8, r27
    16fe:	91 04       	cpc	r9, r1
    1700:	a1 04       	cpc	r10, r1
    1702:	b1 04       	cpc	r11, r1
    1704:	00 f0       	brcs	.+0      	; 0x1706 <_fatGetFreeCluster+0x48>
    1706:	fc 01       	movw	r30, r24
    1708:	82 a1       	ldd	r24, Z+34	; 0x22
    170a:	93 a1       	ldd	r25, Z+35	; 0x23
    170c:	a4 a1       	ldd	r26, Z+36	; 0x24
    170e:	b5 a1       	ldd	r27, Z+37	; 0x25
    1710:	88 15       	cp	r24, r8
    1712:	99 05       	cpc	r25, r9
    1714:	aa 05       	cpc	r26, r10
    1716:	bb 05       	cpc	r27, r11
    1718:	00 f0       	brcs	.+0      	; 0x171a <_fatGetFreeCluster+0x5c>
    171a:	00 c0       	rjmp	.+0      	; 0x171c <_fatGetFreeCluster+0x5e>
		start = 2;
    171c:	52 e0       	ldi	r21, 0x02	; 2
    171e:	85 2e       	mov	r8, r21
    1720:	91 2c       	mov	r9, r1
    1722:	a1 2c       	mov	r10, r1
    1724:	b1 2c       	mov	r11, r1
#endif


	SECTOR fatSector=0;
	void*  fatBuf=null;
	CLUSTER current = start;
    1726:	75 01       	movw	r14, r10
    1728:	64 01       	movw	r12, r8
		rprintfInit(old);}
#endif


	SECTOR fatSector=0;
	void*  fatBuf=null;
    172a:	00 e0       	ldi	r16, 0x00	; 0
    172c:	10 e0       	ldi	r17, 0x00	; 0
		rprintf("Start Get Free Cluster\n");
		rprintfInit(old);}
#endif


	SECTOR fatSector=0;
    172e:	19 82       	std	Y+1, r1	; 0x01
    1730:	1a 82       	std	Y+2, r1	; 0x02
    1732:	1b 82       	std	Y+3, r1	; 0x03
    1734:	1c 82       	std	Y+4, r1	; 0x04
	void*  fatBuf=null;
	CLUSTER current = start;
	CLUSTER rtn = 0;
	while(rtn==0){
		SECTOR sector=_fatGetSectorAddressFatEntry(disk,current);
    1736:	b7 01       	movw	r22, r14
    1738:	a6 01       	movw	r20, r12
    173a:	c1 01       	movw	r24, r2
    173c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1740:	2b 01       	movw	r4, r22
    1742:	3c 01       	movw	r6, r24

		if(sector != fatSector ){
    1744:	89 81       	ldd	r24, Y+1	; 0x01
    1746:	9a 81       	ldd	r25, Y+2	; 0x02
    1748:	ab 81       	ldd	r26, Y+3	; 0x03
    174a:	bc 81       	ldd	r27, Y+4	; 0x04
    174c:	48 16       	cp	r4, r24
    174e:	59 06       	cpc	r5, r25
    1750:	6a 06       	cpc	r6, r26
    1752:	7b 06       	cpc	r7, r27
    1754:	01 f0       	breq	.+0      	; 0x1756 <_fatGetFreeCluster+0x98>
			// Release any existing sector
			if(fatBuf){
    1756:	01 15       	cp	r16, r1
    1758:	11 05       	cpc	r17, r1
    175a:	01 f0       	breq	.+0      	; 0x175c <_fatGetFreeCluster+0x9e>
    175c:	b8 01       	movw	r22, r16
    175e:	c1 01       	movw	r24, r2
    1760:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				partition_releaseSector(disk,fatBuf);
				fatBuf = null;
			}
			// Read the new sector
			fatSector = sector;
			fatBuf = _partitionGetSector(disk,fatSector,BUFFER_MODE_READONLY);
    1764:	21 e0       	ldi	r18, 0x01	; 1
    1766:	b3 01       	movw	r22, r6
    1768:	a2 01       	movw	r20, r4
    176a:	c1 01       	movw	r24, r2
    176c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1770:	8c 01       	movw	r16, r24
    1772:	49 82       	std	Y+1, r4	; 0x01
    1774:	5a 82       	std	Y+2, r5	; 0x02
    1776:	6b 82       	std	Y+3, r6	; 0x03
    1778:	7c 82       	std	Y+4, r7	; 0x04
		}

		CLUSTER next = _fatGetNextClusterAddressInRAM(disk,current,fatBuf);
    177a:	98 01       	movw	r18, r16
    177c:	b7 01       	movw	r22, r14
    177e:	a6 01       	movw	r20, r12
    1780:	c1 01       	movw	r24, r2
    1782:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Cluster %lu, next=%lu\n",current,next);
		rprintfInit(old);}
#endif

		if( next == 0){
    1786:	67 2b       	or	r22, r23
    1788:	68 2b       	or	r22, r24
    178a:	69 2b       	or	r22, r25
    178c:	01 f0       	breq	.+0      	; 0x178e <_fatGetFreeCluster+0xd0>
			rtn = current;
		}else{
			// try the next one and wrap around if reqd
			if(++current > disk->dataClusterCount){
    178e:	9f ef       	ldi	r25, 0xFF	; 255
    1790:	c9 1a       	sub	r12, r25
    1792:	d9 0a       	sbc	r13, r25
    1794:	e9 0a       	sbc	r14, r25
    1796:	f9 0a       	sbc	r15, r25
    1798:	f1 01       	movw	r30, r2
    179a:	82 a1       	ldd	r24, Z+34	; 0x22
    179c:	93 a1       	ldd	r25, Z+35	; 0x23
    179e:	a4 a1       	ldd	r26, Z+36	; 0x24
    17a0:	b5 a1       	ldd	r27, Z+37	; 0x25
    17a2:	8c 15       	cp	r24, r12
    17a4:	9d 05       	cpc	r25, r13
    17a6:	ae 05       	cpc	r26, r14
    17a8:	bf 05       	cpc	r27, r15
    17aa:	00 f4       	brcc	.+0      	; 0x17ac <_fatGetFreeCluster+0xee>
				current = 2;
    17ac:	42 e0       	ldi	r20, 0x02	; 2
    17ae:	c4 2e       	mov	r12, r20
    17b0:	d1 2c       	mov	r13, r1
    17b2:	e1 2c       	mov	r14, r1
    17b4:	f1 2c       	mov	r15, r1
			}

			// If we are back at the start then exit - everthing is full
			if(current==start){
    17b6:	c8 14       	cp	r12, r8
    17b8:	d9 04       	cpc	r13, r9
    17ba:	ea 04       	cpc	r14, r10
    17bc:	fb 04       	cpc	r15, r11
    17be:	01 f0       	breq	.+0      	; 0x17c0 <_fatGetFreeCluster+0x102>
    17c0:	00 c0       	rjmp	.+0      	; 0x17c2 <_fatGetFreeCluster+0x104>
    17c2:	00 c0       	rjmp	.+0      	; 0x17c4 <_fatGetFreeCluster+0x106>

	SECTOR fatSector=0;
	void*  fatBuf=null;
	CLUSTER current = start;
	CLUSTER rtn = 0;
	while(rtn==0){
    17c4:	c1 14       	cp	r12, r1
    17c6:	d1 04       	cpc	r13, r1
    17c8:	e1 04       	cpc	r14, r1
    17ca:	f1 04       	cpc	r15, r1
    17cc:	01 f4       	brne	.+0      	; 0x17ce <_fatGetFreeCluster+0x110>
    17ce:	00 c0       	rjmp	.+0      	; 0x17d0 <_fatGetFreeCluster+0x112>
    17d0:	00 c0       	rjmp	.+0      	; 0x17d2 <_fatGetFreeCluster+0x114>
			if(++current > disk->dataClusterCount){
				current = 2;
			}

			// If we are back at the start then exit - everthing is full
			if(current==start){
    17d2:	c1 2c       	mov	r12, r1
    17d4:	d1 2c       	mov	r13, r1
    17d6:	76 01       	movw	r14, r12
			}
		}
	}

	// Release the current buffer
	if(fatBuf){
    17d8:	01 15       	cp	r16, r1
    17da:	11 05       	cpc	r17, r1
    17dc:	01 f0       	breq	.+0      	; 0x17de <_fatGetFreeCluster+0x120>
    17de:	b8 01       	movw	r22, r16
    17e0:	c1 01       	movw	r24, r2
    17e2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		partition_releaseSector(disk,fatBuf);
	}
	disk->freeClusterHint = rtn;
    17e6:	d1 01       	movw	r26, r2
    17e8:	9f 96       	adiw	r26, 0x2f	; 47
    17ea:	cd 92       	st	X+, r12
    17ec:	dd 92       	st	X+, r13
    17ee:	ed 92       	st	X+, r14
    17f0:	fc 92       	st	X, r15
    17f2:	d2 97       	sbiw	r26, 0x32	; 50
		rprintf("End Get Free Cluster=%lu\n",rtn);
		rprintfInit(old);}
#endif

	return rtn;
}
    17f4:	b6 01       	movw	r22, r12
    17f6:	c7 01       	movw	r24, r14
    17f8:	0f 90       	pop	r0
    17fa:	0f 90       	pop	r0
    17fc:	0f 90       	pop	r0
    17fe:	0f 90       	pop	r0
    1800:	df 91       	pop	r29
    1802:	cf 91       	pop	r28
    1804:	1f 91       	pop	r17
    1806:	0f 91       	pop	r16
    1808:	ff 90       	pop	r15
    180a:	ef 90       	pop	r14
    180c:	df 90       	pop	r13
    180e:	cf 90       	pop	r12
    1810:	bf 90       	pop	r11
    1812:	af 90       	pop	r10
    1814:	9f 90       	pop	r9
    1816:	8f 90       	pop	r8
    1818:	7f 90       	pop	r7
    181a:	6f 90       	pop	r6
    181c:	5f 90       	pop	r5
    181e:	4f 90       	pop	r4
    1820:	3f 90       	pop	r3
    1822:	2f 90       	pop	r2
    1824:	08 95       	ret

00001826 <_fatExtend>:

// Append 'num_clusters' to the end of the cluster chain
// Return TRUE on success, FALSE if the FAT is full
boolean _fatExtend(DISK* disk,CLUSTER_NAV *nav,CLUSTER_COUNT num_clusters){
    1826:	2f 92       	push	r2
    1828:	3f 92       	push	r3
    182a:	4f 92       	push	r4
    182c:	5f 92       	push	r5
    182e:	6f 92       	push	r6
    1830:	7f 92       	push	r7
    1832:	8f 92       	push	r8
    1834:	9f 92       	push	r9
    1836:	af 92       	push	r10
    1838:	bf 92       	push	r11
    183a:	cf 92       	push	r12
    183c:	df 92       	push	r13
    183e:	ef 92       	push	r14
    1840:	ff 92       	push	r15
    1842:	0f 93       	push	r16
    1844:	1f 93       	push	r17
    1846:	cf 93       	push	r28
    1848:	df 93       	push	r29
    184a:	00 d0       	rcall	.+0      	; 0x184c <_fatExtend+0x26>
    184c:	00 d0       	rcall	.+0      	; 0x184e <_fatExtend+0x28>
    184e:	00 d0       	rcall	.+0      	; 0x1850 <_fatExtend+0x2a>
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
    1854:	1c 01       	movw	r2, r24
    1856:	7e 83       	std	Y+6, r23	; 0x06
    1858:	6d 83       	std	Y+5, r22	; 0x05
    185a:	29 01       	movw	r4, r18
    185c:	3a 01       	movw	r6, r20
	CLUSTER numRemaining=num_clusters;

	// Check we have a valid start cluster
	if(nav->startCluster<2){
    185e:	fb 01       	movw	r30, r22
    1860:	84 85       	ldd	r24, Z+12	; 0x0c
    1862:	95 85       	ldd	r25, Z+13	; 0x0d
    1864:	a6 85       	ldd	r26, Z+14	; 0x0e
    1866:	b7 85       	ldd	r27, Z+15	; 0x0f
    1868:	02 97       	sbiw	r24, 0x02	; 2
    186a:	a1 05       	cpc	r26, r1
    186c:	b1 05       	cpc	r27, r1
    186e:	00 f4       	brcc	.+0      	; 0x1870 <_fatExtend+0x4a>
		return(FALSE);
    1870:	80 e0       	ldi	r24, 0x00	; 0
    1872:	00 c0       	rjmp	.+0      	; 0x1874 <_fatExtend+0x4e>
	}

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
    1874:	6d 81       	ldd	r22, Y+5	; 0x05
    1876:	7e 81       	ldd	r23, Y+6	; 0x06
    1878:	c1 01       	movw	r24, r2
    187a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    187e:	69 83       	std	Y+1, r22	; 0x01
    1880:	7a 83       	std	Y+2, r23	; 0x02
    1882:	8b 83       	std	Y+3, r24	; 0x03
    1884:	9c 83       	std	Y+4, r25	; 0x04
	disk->freeClusterHint = lastCluster;
    1886:	f1 01       	movw	r30, r2
    1888:	67 a7       	std	Z+47, r22	; 0x2f
    188a:	70 ab       	std	Z+48, r23	; 0x30
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	81 ab       	std	Z+49, r24	; 0x31
    1890:	92 ab       	std	Z+50, r25	; 0x32
}

// Append 'num_clusters' to the end of the cluster chain
// Return TRUE on success, FALSE if the FAT is full
boolean _fatExtend(DISK* disk,CLUSTER_NAV *nav,CLUSTER_COUNT num_clusters){
	CLUSTER numRemaining=num_clusters;
    1892:	53 01       	movw	r10, r6
    1894:	42 01       	movw	r8, r4

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
	disk->freeClusterHint = lastCluster;


	while(numRemaining > 0){
    1896:	00 c0       	rjmp	.+0      	; 0x1898 <_fatExtend+0x72>
		rprintf("\nStart extend: First Cl=%lu, End Cl=%lu\n",nav->startCluster,lastCluster);
		rprintfInit(old);}
#endif

		// Find the next free cluster
		CLUSTER currentCluster = _fatGetFreeCluster(disk);
    1898:	c1 01       	movw	r24, r2
    189a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    189e:	6b 01       	movw	r12, r22
    18a0:	7c 01       	movw	r14, r24

		if(currentCluster==0){
    18a2:	61 15       	cp	r22, r1
    18a4:	71 05       	cpc	r23, r1
    18a6:	81 05       	cpc	r24, r1
    18a8:	91 05       	cpc	r25, r1
    18aa:	01 f4       	brne	.+0      	; 0x18ac <_fatExtend+0x86>
			// The disk is full
			_fatSetNextClusterAddress(disk,lastCluster,_fatGiveEndMarker(disk));
    18ac:	c1 01       	movw	r24, r2
    18ae:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    18b2:	8b 01       	movw	r16, r22
    18b4:	9c 01       	movw	r18, r24
    18b6:	49 81       	ldd	r20, Y+1	; 0x01
    18b8:	5a 81       	ldd	r21, Y+2	; 0x02
    18ba:	6b 81       	ldd	r22, Y+3	; 0x03
    18bc:	7c 81       	ldd	r23, Y+4	; 0x04
    18be:	c1 01       	movw	r24, r2
    18c0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			nav->endCluster=lastCluster;
    18c4:	89 81       	ldd	r24, Y+1	; 0x01
    18c6:	ed 81       	ldd	r30, Y+5	; 0x05
    18c8:	fe 81       	ldd	r31, Y+6	; 0x06
    18ca:	80 8b       	std	Z+16, r24	; 0x10
    18cc:	8a 81       	ldd	r24, Y+2	; 0x02
    18ce:	81 8b       	std	Z+17, r24	; 0x11
    18d0:	8b 81       	ldd	r24, Y+3	; 0x03
    18d2:	82 8b       	std	Z+18, r24	; 0x12
    18d4:	8c 81       	ldd	r24, Y+4	; 0x04
    18d6:	83 8b       	std	Z+19, r24	; 0x13
			// Return TRUE if we have added at least one cluster
			return(num_clusters == numRemaining) ? FALSE : TRUE;
    18d8:	48 14       	cp	r4, r8
    18da:	59 04       	cpc	r5, r9
    18dc:	6a 04       	cpc	r6, r10
    18de:	7b 04       	cpc	r7, r11
    18e0:	01 f0       	breq	.+0      	; 0x18e2 <_fatExtend+0xbc>
    18e2:	00 c0       	rjmp	.+0      	; 0x18e4 <_fatExtend+0xbe>
		}

		// This cluster is available - so link it in
		_fatSetNextClusterAddress(disk,lastCluster,currentCluster);
    18e4:	8b 01       	movw	r16, r22
    18e6:	9c 01       	movw	r18, r24
    18e8:	49 81       	ldd	r20, Y+1	; 0x01
    18ea:	5a 81       	ldd	r21, Y+2	; 0x02
    18ec:	6b 81       	ldd	r22, Y+3	; 0x03
    18ee:	7c 81       	ldd	r23, Y+4	; 0x04
    18f0:	c1 01       	movw	r24, r2
    18f2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

		// One less to do
		numRemaining--;
    18f6:	e1 e0       	ldi	r30, 0x01	; 1
    18f8:	8e 1a       	sub	r8, r30
    18fa:	91 08       	sbc	r9, r1
    18fc:	a1 08       	sbc	r10, r1
    18fe:	b1 08       	sbc	r11, r1
		lastCluster=currentCluster;

		// If all done then mark end of chain
		if(numRemaining==0){
    1900:	01 f4       	brne	.+0      	; 0x1902 <_fatExtend+0xdc>
			_fatSetNextClusterAddress(disk,lastCluster,_fatGiveEndMarker(disk));
    1902:	c1 01       	movw	r24, r2
    1904:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1908:	8b 01       	movw	r16, r22
    190a:	9c 01       	movw	r18, r24
    190c:	b7 01       	movw	r22, r14
    190e:	a6 01       	movw	r20, r12
    1910:	c1 01       	movw	r24, r2
    1912:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			nav->endCluster=lastCluster;
    1916:	ed 81       	ldd	r30, Y+5	; 0x05
    1918:	fe 81       	ldd	r31, Y+6	; 0x06
    191a:	c0 8a       	std	Z+16, r12	; 0x10
    191c:	d1 8a       	std	Z+17, r13	; 0x11
    191e:	e2 8a       	std	Z+18, r14	; 0x12
    1920:	f3 8a       	std	Z+19, r15	; 0x13
    1922:	c9 82       	std	Y+1, r12	; 0x01
    1924:	da 82       	std	Y+2, r13	; 0x02
    1926:	eb 82       	std	Y+3, r14	; 0x03
    1928:	fc 82       	std	Y+4, r15	; 0x04

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
	disk->freeClusterHint = lastCluster;


	while(numRemaining > 0){
    192a:	81 14       	cp	r8, r1
    192c:	91 04       	cpc	r9, r1
    192e:	a1 04       	cpc	r10, r1
    1930:	b1 04       	cpc	r11, r1
    1932:	01 f0       	breq	.+0      	; 0x1934 <_fatExtend+0x10e>
    1934:	00 c0       	rjmp	.+0      	; 0x1936 <_fatExtend+0x110>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("End extend: First Cl=%lu, End Cl=%lu, Current=%lu\n",nav->startCluster,lastCluster,nav->currentCluster);
		rprintfInit(old);}
#endif

	if(nav->totalClusters){
    1936:	ed 81       	ldd	r30, Y+5	; 0x05
    1938:	fe 81       	ldd	r31, Y+6	; 0x06
    193a:	84 89       	ldd	r24, Z+20	; 0x14
    193c:	95 89       	ldd	r25, Z+21	; 0x15
    193e:	a6 89       	ldd	r26, Z+22	; 0x16
    1940:	b7 89       	ldd	r27, Z+23	; 0x17
    1942:	00 97       	sbiw	r24, 0x00	; 0
    1944:	a1 05       	cpc	r26, r1
    1946:	b1 05       	cpc	r27, r1
    1948:	01 f0       	breq	.+0      	; 0x194a <_fatExtend+0x124>
		nav->totalClusters+=num_clusters;
    194a:	48 0e       	add	r4, r24
    194c:	59 1e       	adc	r5, r25
    194e:	6a 1e       	adc	r6, r26
    1950:	7b 1e       	adc	r7, r27
    1952:	44 8a       	std	Z+20, r4	; 0x14
    1954:	55 8a       	std	Z+21, r5	; 0x15
    1956:	66 8a       	std	Z+22, r6	; 0x16
    1958:	77 8a       	std	Z+23, r7	; 0x17
	}
	return(TRUE);
    195a:	8f ef       	ldi	r24, 0xFF	; 255
}
    195c:	26 96       	adiw	r28, 0x06	; 6
    195e:	0f b6       	in	r0, 0x3f	; 63
    1960:	f8 94       	cli
    1962:	de bf       	out	0x3e, r29	; 62
    1964:	0f be       	out	0x3f, r0	; 63
    1966:	cd bf       	out	0x3d, r28	; 61
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	ff 90       	pop	r15
    1972:	ef 90       	pop	r14
    1974:	df 90       	pop	r13
    1976:	cf 90       	pop	r12
    1978:	bf 90       	pop	r11
    197a:	af 90       	pop	r10
    197c:	9f 90       	pop	r9
    197e:	8f 90       	pop	r8
    1980:	7f 90       	pop	r7
    1982:	6f 90       	pop	r6
    1984:	5f 90       	pop	r5
    1986:	4f 90       	pop	r4
    1988:	3f 90       	pop	r3
    198a:	2f 90       	pop	r2
    198c:	08 95       	ret

0000198e <_dirGetFatFileName>:

// This function will take a full directory path, and strip off all leading
// dirs and characters, leaving you with the MS-DOS notation of the actual filename.
// Return value: TRUE on success, FALSE on not being able to produce a filename

boolean _dirGetFatFileName(const char* filename, char* fatfilename){
    198e:	ef 92       	push	r14
    1990:	ff 92       	push	r15
    1992:	0f 93       	push	r16
    1994:	1f 93       	push	r17
    1996:	cf 93       	push	r28
    1998:	df 93       	push	r29
    199a:	cd b7       	in	r28, 0x3d	; 61
    199c:	de b7       	in	r29, 0x3e	; 62
    199e:	2b 97       	sbiw	r28, 0x0b	; 11
    19a0:	0f b6       	in	r0, 0x3f	; 63
    19a2:	f8 94       	cli
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	0f be       	out	0x3f, r0	; 63
    19a8:	cd bf       	out	0x3d, r28	; 61
    19aa:	06 2f       	mov	r16, r22
    19ac:	f7 2e       	mov	r15, r23
	char ffnamec[11];
	const char *next;
	char nn=0;

	memclr(ffnamec,11);
    19ae:	2b e0       	ldi	r18, 0x0B	; 11
    19b0:	fe 01       	movw	r30, r28
    19b2:	31 96       	adiw	r30, 0x01	; 1
    19b4:	df 01       	movw	r26, r30
    19b6:	32 2f       	mov	r19, r18
    19b8:	1d 92       	st	X+, r1
    19ba:	3a 95       	dec	r19
    19bc:	01 f4       	brne	.+0      	; 0x19be <_dirGetFatFileName+0x30>
	memclr(fatfilename,11);
    19be:	e6 2f       	mov	r30, r22
    19c0:	f7 2f       	mov	r31, r23
    19c2:	df 01       	movw	r26, r30
    19c4:	1d 92       	st	X+, r1
    19c6:	2a 95       	dec	r18
    19c8:	01 f4       	brne	.+0      	; 0x19ca <_dirGetFatFileName+0x3c>
	next = filename;

	if(*filename=='/'){
    19ca:	fc 01       	movw	r30, r24
    19cc:	20 81       	ld	r18, Z
    19ce:	2f 32       	cpi	r18, 0x2F	; 47
    19d0:	01 f4       	brne	.+0      	; 0x19d2 <_dirGetFatFileName+0x44>
		next++;
    19d2:	01 96       	adiw	r24, 0x01	; 1
	const char *next;
	char nn=0;

	memclr(ffnamec,11);
	memclr(fatfilename,11);
	next = filename;
    19d4:	10 e0       	ldi	r17, 0x00	; 0
		next++;
	}

	while((next=_fileUserToFatName(next,ffnamec))){
//		memCpy(ffnamec,fatfilename,11);
		memcpy(fatfilename,ffnamec,11);
    19d6:	6b e0       	ldi	r22, 0x0B	; 11
    19d8:	e6 2e       	mov	r14, r22
    19da:	00 c0       	rjmp	.+0      	; 0x19dc <_dirGetFatFileName+0x4e>
    19dc:	fe 01       	movw	r30, r28
    19de:	31 96       	adiw	r30, 0x01	; 1
    19e0:	a0 2f       	mov	r26, r16
    19e2:	bf 2d       	mov	r27, r15
    19e4:	2e 2d       	mov	r18, r14
    19e6:	01 90       	ld	r0, Z+
    19e8:	0d 92       	st	X+, r0
    19ea:	2a 95       	dec	r18
    19ec:	01 f4       	brne	.+0      	; 0x19ee <_dirGetFatFileName+0x60>
		nn++;
    19ee:	1f 5f       	subi	r17, 0xFF	; 255

	if(*filename=='/'){
		next++;
	}

	while((next=_fileUserToFatName(next,ffnamec))){
    19f0:	be 01       	movw	r22, r28
    19f2:	6f 5f       	subi	r22, 0xFF	; 255
    19f4:	7f 4f       	sbci	r23, 0xFF	; 255
    19f6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    19fa:	00 97       	sbiw	r24, 0x00	; 0
    19fc:	01 f4       	brne	.+0      	; 0x19fe <_dirGetFatFileName+0x70>
//		memCpy(ffnamec,fatfilename,11);
		memcpy(fatfilename,ffnamec,11);
		nn++;
	}
	return (nn) ? TRUE : FALSE;
    19fe:	11 23       	and	r17, r17
    1a00:	01 f0       	breq	.+0      	; 0x1a02 <_dirGetFatFileName+0x74>
    1a02:	8f ef       	ldi	r24, 0xFF	; 255
    1a04:	00 c0       	rjmp	.+0      	; 0x1a06 <_dirGetFatFileName+0x78>
    1a06:	80 e0       	ldi	r24, 0x00	; 0
}
    1a08:	2b 96       	adiw	r28, 0x0b	; 11
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	df 91       	pop	r29
    1a16:	cf 91       	pop	r28
    1a18:	1f 91       	pop	r17
    1a1a:	0f 91       	pop	r16
    1a1c:	ff 90       	pop	r15
    1a1e:	ef 90       	pop	r14
    1a20:	08 95       	ret

00001a22 <_dirCreateDirectoryEntry>:
	_partitionClearCluster(disk,lastc);
	return(TRUE);
}

// Write a directory entry
void _dirCreateDirectoryEntry(const DISK* disk,const DIR_ENTRY *filerec,const DIR_POSITION *loc){
    1a22:	ef 92       	push	r14
    1a24:	ff 92       	push	r15
    1a26:	0f 93       	push	r16
    1a28:	1f 93       	push	r17
    1a2a:	cf 93       	push	r28
    1a2c:	df 93       	push	r29
    1a2e:	ec 01       	movw	r28, r24
    1a30:	7b 01       	movw	r14, r22
    1a32:	8a 01       	movw	r16, r20
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
    1a34:	fa 01       	movw	r30, r20
    1a36:	40 81       	ld	r20, Z
    1a38:	51 81       	ldd	r21, Z+1	; 0x01
    1a3a:	62 81       	ldd	r22, Z+2	; 0x02
    1a3c:	73 81       	ldd	r23, Z+3	; 0x03
    1a3e:	22 e0       	ldi	r18, 0x02	; 2
    1a40:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	memcpy(&dir[loc->entryInSector],filerec,sizeof(*filerec));
    1a44:	f8 01       	movw	r30, r16
    1a46:	24 81       	ldd	r18, Z+4	; 0x04
    1a48:	dc 01       	movw	r26, r24
    1a4a:	f0 e2       	ldi	r31, 0x20	; 32
    1a4c:	2f 9f       	mul	r18, r31
    1a4e:	a0 0d       	add	r26, r0
    1a50:	b1 1d       	adc	r27, r1
    1a52:	11 24       	eor	r1, r1
    1a54:	20 e2       	ldi	r18, 0x20	; 32
    1a56:	f7 01       	movw	r30, r14
    1a58:	01 90       	ld	r0, Z+
    1a5a:	0d 92       	st	X+, r0
    1a5c:	2a 95       	dec	r18
    1a5e:	01 f4       	brne	.+0      	; 0x1a60 <_dirCreateDirectoryEntry+0x3e>
    1a60:	bc 01       	movw	r22, r24
    1a62:	ce 01       	movw	r24, r28
	partition_releaseSector(disk,dir);
}
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	1f 91       	pop	r17
    1a6a:	0f 91       	pop	r16
    1a6c:	ff 90       	pop	r15
    1a6e:	ef 90       	pop	r14
    1a70:	0c 94 00 00 	jmp	0	; 0x0 <_bufferIsWritable>

00001a74 <_dirSetFirstClusterInDirEntry>:
	return(FALSE);
}

// Update the disk directory with the start cluster
void _dirSetFirstClusterInDirEntry(DIR_ENTRY *rec,CLUSTER cluster_addr){
	rec->firstClusterHigh=cluster_addr>>16;
    1a74:	fc 01       	movw	r30, r24
    1a76:	75 8b       	std	Z+21, r23	; 0x15
    1a78:	64 8b       	std	Z+20, r22	; 0x14
	rec->firstClusterLow=cluster_addr&0xFFFF;
    1a7a:	53 8f       	std	Z+27, r21	; 0x1b
    1a7c:	42 8f       	std	Z+26, r20	; 0x1a
    1a7e:	08 95       	ret

00001a80 <_navInitClusterChain>:
		}
	}
	return(nav->endCluster);
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
    1a80:	fc 01       	movw	r30, r24
	memclr(nav,sizeof(CLUSTER_NAV));
    1a82:	88 e1       	ldi	r24, 0x18	; 24
    1a84:	df 01       	movw	r26, r30
    1a86:	1d 92       	st	X+, r1
    1a88:	8a 95       	dec	r24
    1a8a:	01 f4       	brne	.+0      	; 0x1a8c <_navInitClusterChain+0xc>
	nav->startCluster = nav->currentCluster=cluster_addr;
    1a8c:	40 87       	std	Z+8, r20	; 0x08
    1a8e:	51 87       	std	Z+9, r21	; 0x09
    1a90:	62 87       	std	Z+10, r22	; 0x0a
    1a92:	73 87       	std	Z+11, r23	; 0x0b
    1a94:	44 87       	std	Z+12, r20	; 0x0c
    1a96:	55 87       	std	Z+13, r21	; 0x0d
    1a98:	66 87       	std	Z+14, r22	; 0x0e
    1a9a:	77 87       	std	Z+15, r23	; 0x0f
    1a9c:	08 95       	ret

00001a9e <_dirFindinDir>:

// This function will search for an existing (fatname) or free directory entry
// in a directory, following the clusterchains.
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode){
    1a9e:	2f 92       	push	r2
    1aa0:	3f 92       	push	r3
    1aa2:	4f 92       	push	r4
    1aa4:	5f 92       	push	r5
    1aa6:	6f 92       	push	r6
    1aa8:	7f 92       	push	r7
    1aaa:	8f 92       	push	r8
    1aac:	9f 92       	push	r9
    1aae:	af 92       	push	r10
    1ab0:	bf 92       	push	r11
    1ab2:	cf 92       	push	r12
    1ab4:	df 92       	push	r13
    1ab6:	ef 92       	push	r14
    1ab8:	ff 92       	push	r15
    1aba:	0f 93       	push	r16
    1abc:	1f 93       	push	r17
    1abe:	cf 93       	push	r28
    1ac0:	df 93       	push	r29
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
    1ac6:	a7 97       	sbiw	r28, 0x27	; 39
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	de bf       	out	0x3e, r29	; 62
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	cd bf       	out	0x3d, r28	; 61
    1ad2:	1c 01       	movw	r2, r24
    1ad4:	79 a3       	std	Y+33, r23	; 0x21
    1ad6:	68 a3       	std	Y+32, r22	; 0x20
    1ad8:	49 01       	movw	r8, r18
    1ada:	5a 01       	movw	r10, r20
    1adc:	ef 8e       	std	Y+31, r14	; 0x1f
	CLUSTER_COUNT c=0;
	CLUSTER cluster;
	CLUSTER_NAV nav;

	_navInitClusterChain(&nav,firstcluster);
    1ade:	ba 01       	movw	r22, r20
    1ae0:	a9 01       	movw	r20, r18
    1ae2:	ee 24       	eor	r14, r14
    1ae4:	e3 94       	inc	r14
    1ae6:	f1 2c       	mov	r15, r1
    1ae8:	ec 0e       	add	r14, r28
    1aea:	fd 1e       	adc	r15, r29
    1aec:	c7 01       	movw	r24, r14
    1aee:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

	if(firstcluster <= 1){
    1af2:	22 e0       	ldi	r18, 0x02	; 2
    1af4:	82 16       	cp	r8, r18
    1af6:	91 04       	cpc	r9, r1
    1af8:	a1 04       	cpc	r10, r1
    1afa:	b1 04       	cpc	r11, r1
    1afc:	00 f0       	brcs	.+0      	; 0x1afe <_dirFindinDir+0x60>
    1afe:	00 c0       	rjmp	.+0      	; 0x1b00 <_dirFindinDir+0x62>
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
static CLUSTER _dirFindinRootArea(const DISK *disk,const char* fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	// FAT32 doesn't have a root area
	if((disk->fatType != 12) && (disk->fatType != 16))
    1b00:	d1 01       	movw	r26, r2
    1b02:	96 96       	adiw	r26, 0x26	; 38
    1b04:	8c 91       	ld	r24, X
    1b06:	8c 30       	cpi	r24, 0x0C	; 12
    1b08:	01 f0       	breq	.+0      	; 0x1b0a <_dirFindinDir+0x6c>
    1b0a:	80 31       	cpi	r24, 0x10	; 16
    1b0c:	01 f0       	breq	.+0      	; 0x1b0e <_dirFindinDir+0x70>
    1b0e:	00 c0       	rjmp	.+0      	; 0x1b10 <_dirFindinDir+0x72>
		return(0);

	// Find the end sector of the root area
	SECTOR last = disk->firstSectorRootDir + disk->volume.rootDirEntryCount/32;
    1b10:	f1 01       	movw	r30, r2
    1b12:	87 a0       	ldd	r8, Z+39	; 0x27
    1b14:	90 a4       	ldd	r9, Z+40	; 0x28
    1b16:	a1 a4       	ldd	r10, Z+41	; 0x29
    1b18:	b2 a4       	ldd	r11, Z+42	; 0x2a
    1b1a:	84 89       	ldd	r24, Z+20	; 0x14
    1b1c:	95 89       	ldd	r25, Z+21	; 0x15
    1b1e:	75 e0       	ldi	r23, 0x05	; 5
    1b20:	96 95       	lsr	r25
    1b22:	87 95       	ror	r24
    1b24:	7a 95       	dec	r23
    1b26:	01 f4       	brne	.+0      	; 0x1b28 <_dirFindinDir+0x8a>
    1b28:	a5 01       	movw	r20, r10
    1b2a:	94 01       	movw	r18, r8
    1b2c:	28 0f       	add	r18, r24
    1b2e:	39 1f       	adc	r19, r25
    1b30:	41 1d       	adc	r20, r1
    1b32:	51 1d       	adc	r21, r1
    1b34:	29 8f       	std	Y+25, r18	; 0x19
    1b36:	3a 8f       	std	Y+26, r19	; 0x1a
    1b38:	4b 8f       	std	Y+27, r20	; 0x1b
    1b3a:	5c 8f       	std	Y+28, r21	; 0x1c
    1b3c:	00 c0       	rjmp	.+0      	; 0x1b3e <_dirFindinDir+0xa0>

	for(SECTOR c=disk->firstSectorRootDir; c<last; c++){
		void* buf= _partitionGetSector(disk,c,BUFFER_MODE_READONLY);
    1b3e:	21 e0       	ldi	r18, 0x01	; 1
    1b40:	b5 01       	movw	r22, r10
    1b42:	a4 01       	movw	r20, r8
    1b44:	c1 01       	movw	r24, r2
    1b46:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1b4a:	3c 01       	movw	r6, r24
}

// This function searches for a given fatfilename in a buffer.
// Return value: Returns 0 on not found, and the firstcluster when the name is found.
static CLUSTER _dirFindInSector(const DIR_ENTRY *fileEntry,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	switch(mode){
    1b4c:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1b4e:	33 23       	and	r19, r19
    1b50:	01 f0       	breq	.+0      	; 0x1b52 <_dirFindinDir+0xb4>
    1b52:	31 30       	cpi	r19, 0x01	; 1
    1b54:	01 f4       	brne	.+0      	; 0x1b56 <_dirFindinDir+0xb8>
    1b56:	00 c0       	rjmp	.+0      	; 0x1b58 <_dirFindinDir+0xba>
		case DIRFIND_FILE:
			return(_dirFindFileInSector(fileEntry,fatname,loc));
    1b58:	a8 01       	movw	r20, r16
    1b5a:	68 a1       	ldd	r22, Y+32	; 0x20
    1b5c:	79 a1       	ldd	r23, Y+33	; 0x21
    1b5e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1b62:	00 c0       	rjmp	.+0      	; 0x1b64 <_dirFindinDir+0xc6>
		case DIRFIND_FREE:
			return(_dirFindFreeEntryinRAM(fileEntry,loc));
    1b64:	b8 01       	movw	r22, r16
    1b66:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1b6a:	6b 01       	movw	r12, r22
    1b6c:	7c 01       	movw	r14, r24
	// Find the end sector of the root area
	SECTOR last = disk->firstSectorRootDir + disk->volume.rootDirEntryCount/32;

	for(SECTOR c=disk->firstSectorRootDir; c<last; c++){
		void* buf= _partitionGetSector(disk,c,BUFFER_MODE_READONLY);
		if((fclus=_dirFindInSector(buf,fatname,loc,mode))){
    1b6e:	61 15       	cp	r22, r1
    1b70:	71 05       	cpc	r23, r1
    1b72:	81 05       	cpc	r24, r1
    1b74:	91 05       	cpc	r25, r1
    1b76:	01 f0       	breq	.+0      	; 0x1b78 <_dirFindinDir+0xda>
			if(loc){
    1b78:	01 15       	cp	r16, r1
    1b7a:	11 05       	cpc	r17, r1
    1b7c:	01 f0       	breq	.+0      	; 0x1b7e <_dirFindinDir+0xe0>
				loc->sector=c;
    1b7e:	d8 01       	movw	r26, r16
    1b80:	8d 92       	st	X+, r8
    1b82:	9d 92       	st	X+, r9
    1b84:	ad 92       	st	X+, r10
    1b86:	bc 92       	st	X, r11
    1b88:	13 97       	sbiw	r26, 0x03	; 3
    1b8a:	b3 01       	movw	r22, r6
    1b8c:	00 c0       	rjmp	.+0      	; 0x1b8e <_dirFindinDir+0xf0>
    1b8e:	b3 01       	movw	r22, r6
    1b90:	c1 01       	movw	r24, r2
    1b92:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		return(0);

	// Find the end sector of the root area
	SECTOR last = disk->firstSectorRootDir + disk->volume.rootDirEntryCount/32;

	for(SECTOR c=disk->firstSectorRootDir; c<last; c++){
    1b96:	bf ef       	ldi	r27, 0xFF	; 255
    1b98:	8b 1a       	sub	r8, r27
    1b9a:	9b 0a       	sbc	r9, r27
    1b9c:	ab 0a       	sbc	r10, r27
    1b9e:	bb 0a       	sbc	r11, r27
    1ba0:	29 8d       	ldd	r18, Y+25	; 0x19
    1ba2:	3a 8d       	ldd	r19, Y+26	; 0x1a
    1ba4:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1ba6:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1ba8:	82 16       	cp	r8, r18
    1baa:	93 06       	cpc	r9, r19
    1bac:	a4 06       	cpc	r10, r20
    1bae:	b5 06       	cpc	r11, r21
    1bb0:	00 f0       	brcs	.+0      	; 0x1bb2 <_dirFindinDir+0x114>
    1bb2:	00 c0       	rjmp	.+0      	; 0x1bb4 <_dirFindinDir+0x116>
	if(firstcluster <= 1){
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
		if((cluster=_dirFindinCluster(disk,nav.currentCluster,fatname,loc,mode))){
    1bb4:	89 84       	ldd	r8, Y+9	; 0x09
    1bb6:	9a 84       	ldd	r9, Y+10	; 0x0a
    1bb8:	ab 84       	ldd	r10, Y+11	; 0x0b
    1bba:	bc 84       	ldd	r11, Y+12	; 0x0c
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
    1bbc:	19 8e       	std	Y+25, r1	; 0x19
    1bbe:	00 c0       	rjmp	.+0      	; 0x1bc0 <_dirFindinDir+0x122>
		DIR_ENTRY* buf = _partitionGetSector(disk,_diskClusterToSector(disk,cluster)+c,BUFFER_MODE_READONLY);
    1bc0:	b5 01       	movw	r22, r10
    1bc2:	a4 01       	movw	r20, r8
    1bc4:	c1 01       	movw	r24, r2
    1bc6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1bca:	ab 01       	movw	r20, r22
    1bcc:	bc 01       	movw	r22, r24
    1bce:	39 8d       	ldd	r19, Y+25	; 0x19
    1bd0:	43 2e       	mov	r4, r19
    1bd2:	51 2c       	mov	r5, r1
    1bd4:	61 2c       	mov	r6, r1
    1bd6:	71 2c       	mov	r7, r1
    1bd8:	44 0d       	add	r20, r4
    1bda:	55 1d       	adc	r21, r5
    1bdc:	66 1d       	adc	r22, r6
    1bde:	77 1d       	adc	r23, r7
    1be0:	21 e0       	ldi	r18, 0x01	; 1
    1be2:	c1 01       	movw	r24, r2
    1be4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1be8:	9e 8f       	std	Y+30, r25	; 0x1e
    1bea:	8d 8f       	std	Y+29, r24	; 0x1d
}

// This function searches for a given fatfilename in a buffer.
// Return value: Returns 0 on not found, and the firstcluster when the name is found.
static CLUSTER _dirFindInSector(const DIR_ENTRY *fileEntry,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	switch(mode){
    1bec:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1bee:	44 23       	and	r20, r20
    1bf0:	01 f0       	breq	.+0      	; 0x1bf2 <_dirFindinDir+0x154>
    1bf2:	41 30       	cpi	r20, 0x01	; 1
    1bf4:	01 f4       	brne	.+0      	; 0x1bf6 <_dirFindinDir+0x158>
    1bf6:	00 c0       	rjmp	.+0      	; 0x1bf8 <_dirFindinDir+0x15a>
		case DIRFIND_FILE:
			return(_dirFindFileInSector(fileEntry,fatname,loc));
    1bf8:	a8 01       	movw	r20, r16
    1bfa:	68 a1       	ldd	r22, Y+32	; 0x20
    1bfc:	79 a1       	ldd	r23, Y+33	; 0x21
    1bfe:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c00:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c02:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c06:	00 c0       	rjmp	.+0      	; 0x1c08 <_dirFindinDir+0x16a>
		case DIRFIND_FREE:
			return(_dirFindFreeEntryinRAM(fileEntry,loc));
    1c08:	b8 01       	movw	r22, r16
    1c0a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c0c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c0e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c12:	6b 01       	movw	r12, r22
    1c14:	7c 01       	movw	r14, r24
static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
		DIR_ENTRY* buf = _partitionGetSector(disk,_diskClusterToSector(disk,cluster)+c,BUFFER_MODE_READONLY);
		if((fclus=_dirFindInSector(buf,fatname,loc,mode))){
    1c16:	61 15       	cp	r22, r1
    1c18:	71 05       	cpc	r23, r1
    1c1a:	81 05       	cpc	r24, r1
    1c1c:	91 05       	cpc	r25, r1
    1c1e:	01 f0       	breq	.+0      	; 0x1c20 <_dirFindinDir+0x182>
			if(loc){
    1c20:	01 15       	cp	r16, r1
    1c22:	11 05       	cpc	r17, r1
    1c24:	01 f0       	breq	.+0      	; 0x1c26 <_dirFindinDir+0x188>
				loc->sector = _diskClusterToSector(disk,cluster) + c;
    1c26:	b5 01       	movw	r22, r10
    1c28:	a4 01       	movw	r20, r8
    1c2a:	c1 01       	movw	r24, r2
    1c2c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c30:	64 0d       	add	r22, r4
    1c32:	75 1d       	adc	r23, r5
    1c34:	86 1d       	adc	r24, r6
    1c36:	97 1d       	adc	r25, r7
    1c38:	d8 01       	movw	r26, r16
    1c3a:	6d 93       	st	X+, r22
    1c3c:	7d 93       	st	X+, r23
    1c3e:	8d 93       	st	X+, r24
    1c40:	9c 93       	st	X, r25
    1c42:	13 97       	sbiw	r26, 0x03	; 3
    1c44:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1c46:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1c48:	c1 01       	movw	r24, r2
    1c4a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c4e:	00 c0       	rjmp	.+0      	; 0x1c50 <_dirFindinDir+0x1b2>
    1c50:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1c52:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1c54:	c1 01       	movw	r24, r2
    1c56:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
    1c5a:	39 8d       	ldd	r19, Y+25	; 0x19
    1c5c:	3f 5f       	subi	r19, 0xFF	; 255
    1c5e:	39 8f       	std	Y+25, r19	; 0x19

	if(firstcluster <= 1){
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
    1c60:	2a a1       	ldd	r18, Y+34	; 0x22
    1c62:	3b a1       	ldd	r19, Y+35	; 0x23
    1c64:	4c a1       	ldd	r20, Y+36	; 0x24
    1c66:	5d a1       	ldd	r21, Y+37	; 0x25
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
    1c68:	d1 01       	movw	r26, r2
    1c6a:	50 96       	adiw	r26, 0x10	; 16
    1c6c:	8c 91       	ld	r24, X
    1c6e:	b9 8d       	ldd	r27, Y+25	; 0x19
    1c70:	b8 17       	cp	r27, r24
    1c72:	00 f4       	brcc	.+0      	; 0x1c74 <_dirFindinDir+0x1d6>
    1c74:	00 c0       	rjmp	.+0      	; 0x1c76 <_dirFindinDir+0x1d8>
    1c76:	00 c0       	rjmp	.+0      	; 0x1c78 <_dirFindinDir+0x1da>
	CLUSTER cluster;
	CLUSTER_NAV nav;

	_navInitClusterChain(&nav,firstcluster);

	if(firstcluster <= 1){
    1c78:	20 e0       	ldi	r18, 0x00	; 0
    1c7a:	30 e0       	ldi	r19, 0x00	; 0
    1c7c:	a9 01       	movw	r20, r18
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
    1c7e:	ee a2       	std	Y+38, r14	; 0x26
    1c80:	ff a2       	std	Y+39, r15	; 0x27
    1c82:	da 01       	movw	r26, r20
    1c84:	c9 01       	movw	r24, r18
    1c86:	01 96       	adiw	r24, 0x01	; 1
    1c88:	a1 1d       	adc	r26, r1
    1c8a:	b1 1d       	adc	r27, r1
    1c8c:	8a a3       	std	Y+34, r24	; 0x22
    1c8e:	9b a3       	std	Y+35, r25	; 0x23
    1c90:	ac a3       	std	Y+36, r26	; 0x24
    1c92:	bd a3       	std	Y+37, r27	; 0x25
    1c94:	6e a1       	ldd	r22, Y+38	; 0x26
    1c96:	7f a1       	ldd	r23, Y+39	; 0x27
    1c98:	c1 01       	movw	r24, r2
    1c9a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	00 c0       	rjmp	.+0      	; 0x1ca2 <_dirFindinDir+0x204>
		if((cluster=_dirFindinCluster(disk,nav.currentCluster,fatname,loc,mode))){
			return(cluster);
		}
	}
	return(0);
    1ca2:	c1 2c       	mov	r12, r1
    1ca4:	d1 2c       	mov	r13, r1
    1ca6:	76 01       	movw	r14, r12
}
    1ca8:	b6 01       	movw	r22, r12
    1caa:	c7 01       	movw	r24, r14
    1cac:	a7 96       	adiw	r28, 0x27	; 39
    1cae:	0f b6       	in	r0, 0x3f	; 63
    1cb0:	f8 94       	cli
    1cb2:	de bf       	out	0x3e, r29	; 62
    1cb4:	0f be       	out	0x3f, r0	; 63
    1cb6:	cd bf       	out	0x3d, r28	; 61
    1cb8:	df 91       	pop	r29
    1cba:	cf 91       	pop	r28
    1cbc:	1f 91       	pop	r17
    1cbe:	0f 91       	pop	r16
    1cc0:	ff 90       	pop	r15
    1cc2:	ef 90       	pop	r14
    1cc4:	df 90       	pop	r13
    1cc6:	cf 90       	pop	r12
    1cc8:	bf 90       	pop	r11
    1cca:	af 90       	pop	r10
    1ccc:	9f 90       	pop	r9
    1cce:	8f 90       	pop	r8
    1cd0:	7f 90       	pop	r7
    1cd2:	6f 90       	pop	r6
    1cd4:	5f 90       	pop	r5
    1cd6:	4f 90       	pop	r4
    1cd8:	3f 90       	pop	r3
    1cda:	2f 90       	pop	r2
    1cdc:	08 95       	ret

00001cde <_fileFindFile>:
// Try to locate a file with the given name
// Return value: Returns 0 when nothing was found, 1 when the thing found (and loc is filled in)
// was a file and 2 if the thing found was a directory. Also returns lstDir set to the cluster
// of the directory

int8_t _fileFindFile(const DISK* disk,const char* filename,DIR_POSITION *loc,CLUSTER *lastDir){
    1cde:	2f 92       	push	r2
    1ce0:	3f 92       	push	r3
    1ce2:	4f 92       	push	r4
    1ce4:	5f 92       	push	r5
    1ce6:	6f 92       	push	r6
    1ce8:	7f 92       	push	r7
    1cea:	8f 92       	push	r8
    1cec:	9f 92       	push	r9
    1cee:	af 92       	push	r10
    1cf0:	bf 92       	push	r11
    1cf2:	cf 92       	push	r12
    1cf4:	df 92       	push	r13
    1cf6:	ef 92       	push	r14
    1cf8:	ff 92       	push	r15
    1cfa:	0f 93       	push	r16
    1cfc:	1f 93       	push	r17
    1cfe:	cf 93       	push	r28
    1d00:	df 93       	push	r29
    1d02:	cd b7       	in	r28, 0x3d	; 61
    1d04:	de b7       	in	r29, 0x3e	; 62
    1d06:	2c 97       	sbiw	r28, 0x0c	; 12
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	de bf       	out	0x3e, r29	; 62
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	cd bf       	out	0x3d, r28	; 61
    1d12:	2c 01       	movw	r4, r24
    1d14:	fb 01       	movw	r30, r22
    1d16:	1a 01       	movw	r2, r20
    1d18:	69 01       	movw	r12, r18
	CLUSTER tmpclus;
	char ffname[11];
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
    1d1a:	80 81       	ld	r24, Z

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    1d1c:	d2 01       	movw	r26, r4
	CLUSTER tmpclus;
	char ffname[11];
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
    1d1e:	8f 32       	cpi	r24, 0x2F	; 47
    1d20:	01 f4       	brne	.+0      	; 0x1d22 <_fileFindFile+0x44>

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    1d22:	96 96       	adiw	r26, 0x26	; 38
    1d24:	8c 91       	ld	r24, X
    1d26:	96 97       	sbiw	r26, 0x26	; 38
    1d28:	80 32       	cpi	r24, 0x20	; 32
    1d2a:	01 f4       	brne	.+0      	; 0x1d2c <_fileFindFile+0x4e>
    1d2c:	56 96       	adiw	r26, 0x16	; 22
    1d2e:	8d 90       	ld	r8, X+
    1d30:	9d 90       	ld	r9, X+
    1d32:	ad 90       	ld	r10, X+
    1d34:	bc 90       	ld	r11, X
    1d36:	59 97       	sbiw	r26, 0x19	; 25
    1d38:	00 c0       	rjmp	.+0      	; 0x1d3a <_fileFindFile+0x5c>
    1d3a:	81 2c       	mov	r8, r1
    1d3c:	91 2c       	mov	r9, r1
    1d3e:	54 01       	movw	r10, r8
    1d40:	83 94       	inc	r8
	boolean filefound=FALSE;

	if(*filename=='/'){
		fccd = _diskGetFirstClusterRootDir(disk);		// current directory = root
		filename++;
		if(lastDir){
    1d42:	c1 14       	cp	r12, r1
    1d44:	d1 04       	cpc	r13, r1
    1d46:	01 f0       	breq	.+0      	; 0x1d48 <_fileFindFile+0x6a>
			*lastDir=fccd;
    1d48:	d6 01       	movw	r26, r12
    1d4a:	8d 92       	st	X+, r8
    1d4c:	9d 92       	st	X+, r9
    1d4e:	ad 92       	st	X+, r10
    1d50:	bc 92       	st	X, r11
    1d52:	13 97       	sbiw	r26, 0x03	; 3
		}
		if(*filename=='\0'){
    1d54:	81 81       	ldd	r24, Z+1	; 0x01
    1d56:	88 23       	and	r24, r24
    1d58:	01 f0       	breq	.+0      	; 0x1d5a <_fileFindFile+0x7c>
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
		fccd = _diskGetFirstClusterRootDir(disk);		// current directory = root
		filename++;
    1d5a:	31 96       	adiw	r30, 0x01	; 1
    1d5c:	00 c0       	rjmp	.+0      	; 0x1d5e <_fileFindFile+0x80>
		if(lastDir){
			*lastDir=fccd;
		}
		if(*filename=='\0'){
			return(2);								// The filename is a directory
    1d5e:	82 e0       	ldi	r24, 0x02	; 2
    1d60:	00 c0       	rjmp	.+0      	; 0x1d62 <_fileFindFile+0x84>
		}
	}else{
		fccd = disk->firstClusterCurrentDir;		// current directory = current directory
    1d62:	9b 96       	adiw	r26, 0x2b	; 43
    1d64:	8d 90       	ld	r8, X+
    1d66:	9d 90       	ld	r9, X+
    1d68:	ad 90       	ld	r10, X+
    1d6a:	bc 90       	ld	r11, X
    1d6c:	9e 97       	sbiw	r26, 0x2e	; 46
		if(lastDir){
    1d6e:	21 15       	cp	r18, r1
    1d70:	31 05       	cpc	r19, r1
    1d72:	01 f0       	breq	.+0      	; 0x1d74 <_fileFindFile+0x96>
			*lastDir=fccd;
    1d74:	d9 01       	movw	r26, r18
    1d76:	8d 92       	st	X+, r8
    1d78:	9d 92       	st	X+, r9
    1d7a:	ad 92       	st	X+, r10
    1d7c:	bc 92       	st	X, r11
    1d7e:	13 97       	sbiw	r26, 0x03	; 3
			fccd = tmpclus;
			filename = next;
			if(lastDir){
				*lastDir=fccd;
			}
			if(filefound){
    1d80:	f1 2c       	mov	r15, r1
    1d82:	1c 86       	std	Y+12, r1	; 0x0c
    1d84:	00 c0       	rjmp	.+0      	; 0x1d86 <_fileFindFile+0xa8>
	// Iterator
	uint8_t it=0;

	while((next=_fileUserToFatName(filename,ffname))!=0){

		if((tmpclus=_dirFindinDir(disk,ffname,fccd,loc,DIRFIND_FILE))==0){
    1d86:	e1 2c       	mov	r14, r1
    1d88:	81 01       	movw	r16, r2
    1d8a:	a5 01       	movw	r20, r10
    1d8c:	94 01       	movw	r18, r8
    1d8e:	be 01       	movw	r22, r28
    1d90:	6f 5f       	subi	r22, 0xFF	; 255
    1d92:	7f 4f       	sbci	r23, 0xFF	; 255
    1d94:	c2 01       	movw	r24, r4
    1d96:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1d9a:	61 15       	cp	r22, r1
    1d9c:	71 05       	cpc	r23, r1
    1d9e:	81 05       	cpc	r24, r1
    1da0:	91 05       	cpc	r25, r1
    1da2:	01 f4       	brne	.+0      	; 0x1da4 <_fileFindFile+0xc6>
			/* We didn't find what we wanted */
			/* We should check, to see if there is more after it, so that
			 * we can invalidate lastDir
			 */
			if((_fileUserToFatName(next,ffname))!=0){
    1da4:	be 01       	movw	r22, r28
    1da6:	6f 5f       	subi	r22, 0xFF	; 255
    1da8:	7f 4f       	sbci	r23, 0xFF	; 255
    1daa:	c3 01       	movw	r24, r6
    1dac:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1db0:	89 2b       	or	r24, r25
    1db2:	01 f4       	brne	.+0      	; 0x1db4 <_fileFindFile+0xd6>
    1db4:	00 c0       	rjmp	.+0      	; 0x1db6 <_fileFindFile+0xd8>
				if(lastDir){
    1db6:	c1 14       	cp	r12, r1
    1db8:	d1 04       	cpc	r13, r1
    1dba:	01 f0       	breq	.+0      	; 0x1dbc <_fileFindFile+0xde>
					*lastDir=0;
    1dbc:	f6 01       	movw	r30, r12
    1dbe:	10 82       	st	Z, r1
    1dc0:	11 82       	std	Z+1, r1	; 0x01
    1dc2:	12 82       	std	Z+2, r1	; 0x02
    1dc4:	13 82       	std	Z+3, r1	; 0x03
				}
			}
			return(0);
    1dc6:	80 e0       	ldi	r24, 0x00	; 0
    1dc8:	00 c0       	rjmp	.+0      	; 0x1dca <_fileFindFile+0xec>
		}

		it++;
    1dca:	f3 94       	inc	r15

		if(loc->attrib.flags.isDirectory){
    1dcc:	d1 01       	movw	r26, r2
    1dce:	15 96       	adiw	r26, 0x05	; 5
    1dd0:	2c 91       	ld	r18, X
    1dd2:	24 ff       	sbrs	r18, 4
    1dd4:	00 c0       	rjmp	.+0      	; 0x1dd6 <_fileFindFile+0xf8>
			fccd = tmpclus;
			filename = next;
			if(lastDir){
    1dd6:	c1 14       	cp	r12, r1
    1dd8:	d1 04       	cpc	r13, r1
    1dda:	01 f0       	breq	.+0      	; 0x1ddc <_fileFindFile+0xfe>
				*lastDir=fccd;
    1ddc:	f6 01       	movw	r30, r12
    1dde:	60 83       	st	Z, r22
    1de0:	71 83       	std	Z+1, r23	; 0x01
    1de2:	82 83       	std	Z+2, r24	; 0x02
    1de4:	93 83       	std	Z+3, r25	; 0x03
			}
			if(filefound){
    1de6:	fc 85       	ldd	r31, Y+12	; 0x0c
    1de8:	ff 23       	and	r31, r31
    1dea:	01 f0       	breq	.+0      	; 0x1dec <_fileFindFile+0x10e>
				*lastDir=0;
    1dec:	d6 01       	movw	r26, r12
    1dee:	1d 92       	st	X+, r1
    1df0:	1d 92       	st	X+, r1
    1df2:	1d 92       	st	X+, r1
    1df4:	1c 92       	st	X, r1
    1df6:	13 97       	sbiw	r26, 0x03	; 3
    1df8:	00 c0       	rjmp	.+0      	; 0x1dfa <_fileFindFile+0x11c>
			}
		}else{
			filefound=TRUE;
			if((_fileUserToFatName(next,ffname))!=0){
    1dfa:	be 01       	movw	r22, r28
    1dfc:	6f 5f       	subi	r22, 0xFF	; 255
    1dfe:	7f 4f       	sbci	r23, 0xFF	; 255
    1e00:	c3 01       	movw	r24, r6
    1e02:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1e06:	89 2b       	or	r24, r25
    1e08:	01 f0       	breq	.+0      	; 0x1e0a <_fileFindFile+0x12c>
    1e0a:	00 c0       	rjmp	.+0      	; 0x1e0c <_fileFindFile+0x12e>
			fccd = tmpclus;
			filename = next;
			if(lastDir){
				*lastDir=fccd;
			}
			if(filefound){
    1e0c:	4b 01       	movw	r8, r22
    1e0e:	5c 01       	movw	r10, r24
    1e10:	00 c0       	rjmp	.+0      	; 0x1e12 <_fileFindFile+0x134>
				*lastDir=0;
			}
		}else{
			filefound=TRUE;
    1e12:	ff ef       	ldi	r31, 0xFF	; 255
    1e14:	fc 87       	std	Y+12, r31	; 0x0c
    1e16:	f3 01       	movw	r30, r6


	// Iterator
	uint8_t it=0;

	while((next=_fileUserToFatName(filename,ffname))!=0){
    1e18:	be 01       	movw	r22, r28
    1e1a:	6f 5f       	subi	r22, 0xFF	; 255
    1e1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1e1e:	cf 01       	movw	r24, r30
    1e20:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1e24:	3c 01       	movw	r6, r24
    1e26:	00 97       	sbiw	r24, 0x00	; 0
    1e28:	01 f0       	breq	.+0      	; 0x1e2a <_fileFindFile+0x14c>
    1e2a:	00 c0       	rjmp	.+0      	; 0x1e2c <_fileFindFile+0x14e>
				filename=next;
			}
		}
	}

	if(it==0){
    1e2c:	ff 20       	and	r15, r15
    1e2e:	01 f0       	breq	.+0      	; 0x1e30 <_fileFindFile+0x152>
		return(0);
	}

	if(loc->attrib.flags.isDirectory || !filefound){
    1e30:	d1 01       	movw	r26, r2
    1e32:	15 96       	adiw	r26, 0x05	; 5
    1e34:	8c 91       	ld	r24, X
    1e36:	84 fd       	sbrc	r24, 4
    1e38:	00 c0       	rjmp	.+0      	; 0x1e3a <_fileFindFile+0x15c>
    1e3a:	bc 85       	ldd	r27, Y+12	; 0x0c
    1e3c:	bb 23       	and	r27, r27
    1e3e:	01 f4       	brne	.+0      	; 0x1e40 <_fileFindFile+0x162>
    1e40:	00 c0       	rjmp	.+0      	; 0x1e42 <_fileFindFile+0x164>
		return(2);
	}
	return(1);
    1e42:	81 e0       	ldi	r24, 0x01	; 1
}
    1e44:	2c 96       	adiw	r28, 0x0c	; 12
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	de bf       	out	0x3e, r29	; 62
    1e4c:	0f be       	out	0x3f, r0	; 63
    1e4e:	cd bf       	out	0x3d, r28	; 61
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	1f 91       	pop	r17
    1e56:	0f 91       	pop	r16
    1e58:	ff 90       	pop	r15
    1e5a:	ef 90       	pop	r14
    1e5c:	df 90       	pop	r13
    1e5e:	cf 90       	pop	r12
    1e60:	bf 90       	pop	r11
    1e62:	af 90       	pop	r10
    1e64:	9f 90       	pop	r9
    1e66:	8f 90       	pop	r8
    1e68:	7f 90       	pop	r7
    1e6a:	6f 90       	pop	r6
    1e6c:	5f 90       	pop	r5
    1e6e:	4f 90       	pop	r4
    1e70:	3f 90       	pop	r3
    1e72:	2f 90       	pop	r2
    1e74:	08 95       	ret

00001e76 <_dirFindFreeFile>:
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
	memcpy(&dir[loc->entryInSector],filerec,sizeof(*filerec));
	partition_releaseSector(disk,dir);
}

boolean _dirFindFreeFile(DISK* disk,const char* filename,DIR_POSITION *loc){
    1e76:	af 92       	push	r10
    1e78:	bf 92       	push	r11
    1e7a:	cf 92       	push	r12
    1e7c:	df 92       	push	r13
    1e7e:	ef 92       	push	r14
    1e80:	0f 93       	push	r16
    1e82:	1f 93       	push	r17
    1e84:	cf 93       	push	r28
    1e86:	df 93       	push	r29
    1e88:	cd b7       	in	r28, 0x3d	; 61
    1e8a:	de b7       	in	r29, 0x3e	; 62
    1e8c:	a7 97       	sbiw	r28, 0x27	; 39
    1e8e:	0f b6       	in	r0, 0x3f	; 63
    1e90:	f8 94       	cli
    1e92:	de bf       	out	0x3e, r29	; 62
    1e94:	0f be       	out	0x3f, r0	; 63
    1e96:	cd bf       	out	0x3d, r28	; 61
    1e98:	6c 01       	movw	r12, r24
    1e9a:	8b 01       	movw	r16, r22
    1e9c:	5a 01       	movw	r10, r20
	CLUSTER targetdir=0;
    1e9e:	1c a2       	std	Y+36, r1	; 0x24
    1ea0:	1d a2       	std	Y+37, r1	; 0x25
    1ea2:	1e a2       	std	Y+38, r1	; 0x26
    1ea4:	1f a2       	std	Y+39, r1	; 0x27
	char ffname[11];

	if(_fileFindFile(disk,filename,loc,&targetdir)){
    1ea6:	9e 01       	movw	r18, r28
    1ea8:	2c 5d       	subi	r18, 0xDC	; 220
    1eaa:	3f 4f       	sbci	r19, 0xFF	; 255
    1eac:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1eb0:	81 11       	cpse	r24, r1
    1eb2:	00 c0       	rjmp	.+0      	; 0x1eb4 <_dirFindFreeFile+0x3e>
		// The file already exists
		return(FALSE);
	}

	// Parse for a valid filename
	if(!_dirGetFatFileName(filename,ffname)){
    1eb4:	be 01       	movw	r22, r28
    1eb6:	67 5e       	subi	r22, 0xE7	; 231
    1eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eba:	c8 01       	movw	r24, r16
    1ebc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1ec0:	88 23       	and	r24, r24
    1ec2:	01 f4       	brne	.+0      	; 0x1ec4 <_dirFindFreeFile+0x4e>
    1ec4:	00 c0       	rjmp	.+0      	; 0x1ec6 <_dirFindFreeFile+0x50>
		return(FALSE);
	}

	if(_dirFindinDir(disk,ffname,targetdir,loc,DIRFIND_FREE)){
    1ec6:	2c a1       	ldd	r18, Y+36	; 0x24
    1ec8:	3d a1       	ldd	r19, Y+37	; 0x25
    1eca:	4e a1       	ldd	r20, Y+38	; 0x26
    1ecc:	5f a1       	ldd	r21, Y+39	; 0x27
    1ece:	ee 24       	eor	r14, r14
    1ed0:	e3 94       	inc	r14
    1ed2:	85 01       	movw	r16, r10
    1ed4:	be 01       	movw	r22, r28
    1ed6:	67 5e       	subi	r22, 0xE7	; 231
    1ed8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eda:	c6 01       	movw	r24, r12
    1edc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1ee0:	67 2b       	or	r22, r23
    1ee2:	68 2b       	or	r22, r24
    1ee4:	69 2b       	or	r22, r25
    1ee6:	01 f0       	breq	.+0      	; 0x1ee8 <_dirFindFreeFile+0x72>
		return(TRUE);
    1ee8:	8f ef       	ldi	r24, 0xFF	; 255
    1eea:	00 c0       	rjmp	.+0      	; 0x1eec <_dirFindFreeFile+0x76>
// cluster. (or clusters)
// Return value: TRUE on success, FALSE on fail

static boolean _dirAddCluster(DISK* disk,CLUSTER firstCluster){
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav,firstCluster);
    1eec:	4c a1       	ldd	r20, Y+36	; 0x24
    1eee:	5d a1       	ldd	r21, Y+37	; 0x25
    1ef0:	6e a1       	ldd	r22, Y+38	; 0x26
    1ef2:	7f a1       	ldd	r23, Y+39	; 0x27
    1ef4:	ce 01       	movw	r24, r28
    1ef6:	01 96       	adiw	r24, 0x01	; 1
    1ef8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	if(!_fatExtend(disk,&nav,1)){
    1efc:	21 e0       	ldi	r18, 0x01	; 1
    1efe:	30 e0       	ldi	r19, 0x00	; 0
    1f00:	40 e0       	ldi	r20, 0x00	; 0
    1f02:	50 e0       	ldi	r21, 0x00	; 0
    1f04:	be 01       	movw	r22, r28
    1f06:	6f 5f       	subi	r22, 0xFF	; 255
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0a:	c6 01       	movw	r24, r12
    1f0c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f10:	88 23       	and	r24, r24
    1f12:	01 f0       	breq	.+0      	; 0x1f14 <_dirFindFreeFile+0x9e>
		return(FALSE);
	}
	CLUSTER lastc = _navGetLastCluster(disk,&nav);
    1f14:	be 01       	movw	r22, r28
    1f16:	6f 5f       	subi	r22, 0xFF	; 255
    1f18:	7f 4f       	sbci	r23, 0xFF	; 255
    1f1a:	c6 01       	movw	r24, r12
    1f1c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f20:	ab 01       	movw	r20, r22
    1f22:	bc 01       	movw	r22, r24
	_partitionClearCluster(disk,lastc);
    1f24:	c6 01       	movw	r24, r12
    1f26:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	}else{
		// Try to increase the directory size
		if(!_dirAddCluster(disk,targetdir)){
			return(FALSE);
		}else{
			if(_dirFindinDir(disk,ffname,targetdir,loc,DIRFIND_FREE)){
    1f2a:	2c a1       	ldd	r18, Y+36	; 0x24
    1f2c:	3d a1       	ldd	r19, Y+37	; 0x25
    1f2e:	4e a1       	ldd	r20, Y+38	; 0x26
    1f30:	5f a1       	ldd	r21, Y+39	; 0x27
    1f32:	ee 24       	eor	r14, r14
    1f34:	e3 94       	inc	r14
    1f36:	85 01       	movw	r16, r10
    1f38:	be 01       	movw	r22, r28
    1f3a:	67 5e       	subi	r22, 0xE7	; 231
    1f3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f3e:	c6 01       	movw	r24, r12
    1f40:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f44:	67 2b       	or	r22, r23
    1f46:	68 2b       	or	r22, r24
    1f48:	69 2b       	or	r22, r25
    1f4a:	01 f4       	brne	.+0      	; 0x1f4c <_dirFindFreeFile+0xd6>
				return(TRUE);
			}
		}
	}

	return(FALSE);
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
}
    1f4e:	a7 96       	adiw	r28, 0x27	; 39
    1f50:	0f b6       	in	r0, 0x3f	; 63
    1f52:	f8 94       	cli
    1f54:	de bf       	out	0x3e, r29	; 62
    1f56:	0f be       	out	0x3f, r0	; 63
    1f58:	cd bf       	out	0x3d, r28	; 61
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	1f 91       	pop	r17
    1f60:	0f 91       	pop	r16
    1f62:	ef 90       	pop	r14
    1f64:	df 90       	pop	r13
    1f66:	cf 90       	pop	r12
    1f68:	bf 90       	pop	r11
    1f6a:	af 90       	pop	r10
    1f6c:	08 95       	ret

FATdelfile.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000013e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000172  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000172  2**0
                  ALLOC
  3 .debug_info   00000956  00000000  00000000  00000172  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000022c  00000000  00000000  00000ac8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002ad  00000000  00000000  00000cf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000fa1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f9  00000000  00000000  00000fc1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000058f  00000000  00000000  000010ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00001649  2**0
                  CONTENTS, READONLY
 10 .debug_frame  0000007c  00000000  00000000  00001674  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <fileDelete>:



// Return value: TRUE if deleted

boolean fileDelete(DISK * disk,const char* filename){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	cd b7       	in	r28, 0x3d	; 61
  22:	de b7       	in	r29, 0x3e	; 62
  24:	6e 97       	sbiw	r28, 0x1e	; 30
  26:	0f b6       	in	r0, 0x3f	; 63
  28:	f8 94       	cli
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	0f be       	out	0x3f, r0	; 63
  2e:	cd bf       	out	0x3d, r28	; 61
  30:	2c 01       	movw	r4, r24
	boolean rtn = FALSE;
	DIR_POSITION loc;

	if((_fileFindFile(disk,filename,&loc,0))==1){
  32:	20 e0       	ldi	r18, 0x00	; 0
  34:	30 e0       	ldi	r19, 0x00	; 0
  36:	ae 01       	movw	r20, r28
  38:	47 5e       	subi	r20, 0xE7	; 231
  3a:	5f 4f       	sbci	r21, 0xFF	; 255
  3c:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
  40:	81 30       	cpi	r24, 0x01	; 1
  42:	01 f0       	breq	.+0      	; 0x44 <fileDelete+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <fileDelete+0x46>
		if(loc.attrib.flags.isReadOnly){
  46:	8e 8d       	ldd	r24, Y+30	; 0x1e
  48:	80 fd       	sbrc	r24, 0
  4a:	00 c0       	rjmp	.+0      	; 0x4c <fileDelete+0x4c>
			return FALSE;
		}
		CLUSTER firstCluster;

		// Read the directory sector
		DIR_ENTRY* buf=_partitionGetSector(disk,loc.sector,BUFFER_MODE_READWRITE);
  4c:	49 8d       	ldd	r20, Y+25	; 0x19
  4e:	5a 8d       	ldd	r21, Y+26	; 0x1a
  50:	6b 8d       	ldd	r22, Y+27	; 0x1b
  52:	7c 8d       	ldd	r23, Y+28	; 0x1c
  54:	22 e0       	ldi	r18, 0x02	; 2
  56:	c2 01       	movw	r24, r4
  58:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
		DIR_ENTRY* dir = &buf[loc.entryInSector];
  5c:	2d 8d       	ldd	r18, Y+29	; 0x1d
  5e:	fc 01       	movw	r30, r24
  60:	30 e2       	ldi	r19, 0x20	; 32
  62:	23 9f       	mul	r18, r19
  64:	e0 0d       	add	r30, r0
  66:	f1 1d       	adc	r31, r1
  68:	11 24       	eor	r1, r1
		firstCluster = dir->firstClusterHigh;
  6a:	c4 88       	ldd	r12, Z+20	; 0x14
  6c:	d5 88       	ldd	r13, Z+21	; 0x15
  6e:	e1 2c       	mov	r14, r1
  70:	f1 2c       	mov	r15, r1
		firstCluster <<= 16;
  72:	76 01       	movw	r14, r12
  74:	dd 24       	eor	r13, r13
  76:	cc 24       	eor	r12, r12
		firstCluster |= dir->firstClusterLow;
  78:	42 8d       	ldd	r20, Z+26	; 0x1a
  7a:	53 8d       	ldd	r21, Z+27	; 0x1b
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	70 e0       	ldi	r23, 0x00	; 0
  80:	c4 2a       	or	r12, r20
  82:	d5 2a       	or	r13, r21
  84:	e6 2a       	or	r14, r22
  86:	f7 2a       	or	r15, r23
		dir->filename[0] = 0xE5;		// Mark file as deleted
  88:	25 ee       	ldi	r18, 0xE5	; 229
  8a:	20 83       	st	Z, r18

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
  8c:	bc 01       	movw	r22, r24
  8e:	c2 01       	movw	r24, r4
  90:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
static void _fatUnlinkClusterChain(const DISK* disk,CLUSTER firstCluster){
	CLUSTER tbd=0;

	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);
  94:	b7 01       	movw	r22, r14
  96:	a6 01       	movw	r20, r12
  98:	8e 01       	movw	r16, r28
  9a:	0f 5f       	subi	r16, 0xFF	; 255
  9c:	1f 4f       	sbci	r17, 0xFF	; 255
  9e:	c8 01       	movw	r24, r16
  a0:	0e 94 00 00 	call	0	; 0x0 <fileDelete>

	CLUSTER_COUNT c=0;
  a4:	20 e0       	ldi	r18, 0x00	; 0
  a6:	30 e0       	ldi	r19, 0x00	; 0
  a8:	a9 01       	movw	r20, r18

#include "FATImpl.h"

// Delete all cluster chains starting at the given entry
static void _fatUnlinkClusterChain(const DISK* disk,CLUSTER firstCluster){
	CLUSTER tbd=0;
  aa:	c1 2c       	mov	r12, r1
  ac:	d1 2c       	mov	r13, r1
  ae:	76 01       	movw	r14, r12
	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);

	CLUSTER_COUNT c=0;
	while(_fatNavigateTo(disk,&nav,c++)){
  b0:	38 01       	movw	r6, r16
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <fileDelete+0xb4>
		if(tbd!=0){					// Delete any current cluster
  b4:	c1 14       	cp	r12, r1
  b6:	d1 04       	cpc	r13, r1
  b8:	e1 04       	cpc	r14, r1
  ba:	f1 04       	cpc	r15, r1
  bc:	01 f0       	breq	.+0      	; 0xbe <fileDelete+0xbe>
			_fatSetNextClusterAddress(disk,tbd,0);
  be:	00 e0       	ldi	r16, 0x00	; 0
  c0:	10 e0       	ldi	r17, 0x00	; 0
  c2:	98 01       	movw	r18, r16
  c4:	b7 01       	movw	r22, r14
  c6:	a6 01       	movw	r20, r12
  c8:	c2 01       	movw	r24, r4
  ca:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
		}
		tbd=nav.currentCluster;		// The current cluser
  ce:	c9 84       	ldd	r12, Y+9	; 0x09
  d0:	da 84       	ldd	r13, Y+10	; 0x0a
  d2:	eb 84       	ldd	r14, Y+11	; 0x0b
  d4:	fc 84       	ldd	r15, Y+12	; 0x0c
	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);

	CLUSTER_COUNT c=0;
	while(_fatNavigateTo(disk,&nav,c++)){
  d6:	a5 01       	movw	r20, r10
  d8:	94 01       	movw	r18, r8
  da:	81 2c       	mov	r8, r1
  dc:	91 2c       	mov	r9, r1
  de:	54 01       	movw	r10, r8
  e0:	83 94       	inc	r8
  e2:	82 0e       	add	r8, r18
  e4:	93 1e       	adc	r9, r19
  e6:	a4 1e       	adc	r10, r20
  e8:	b5 1e       	adc	r11, r21
  ea:	b3 01       	movw	r22, r6
  ec:	c2 01       	movw	r24, r4
  ee:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
  f2:	81 11       	cpse	r24, r1
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <fileDelete+0xf6>
		if(tbd!=0){					// Delete any current cluster
			_fatSetNextClusterAddress(disk,tbd,0);
		}
		tbd=nav.currentCluster;		// The current cluser
	}
	_fatSetNextClusterAddress(disk,nav.currentCluster,0);
  f6:	49 85       	ldd	r20, Y+9	; 0x09
  f8:	5a 85       	ldd	r21, Y+10	; 0x0a
  fa:	6b 85       	ldd	r22, Y+11	; 0x0b
  fc:	7c 85       	ldd	r23, Y+12	; 0x0c
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	10 e0       	ldi	r17, 0x00	; 0
 102:	98 01       	movw	r18, r16
 104:	c2 01       	movw	r24, r4
 106:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
		firstCluster |= dir->firstClusterLow;
		dir->filename[0] = 0xE5;		// Mark file as deleted
		partition_releaseSector(disk,buf);

 		_fatUnlinkClusterChain(disk,firstCluster);
		rtn = TRUE;
 10a:	8f ef       	ldi	r24, 0xFF	; 255
 10c:	00 c0       	rjmp	.+0      	; 0x10e <fileDelete+0x10e>


// Return value: TRUE if deleted

boolean fileDelete(DISK * disk,const char* filename){
	boolean rtn = FALSE;
 10e:	80 e0       	ldi	r24, 0x00	; 0

 		_fatUnlinkClusterChain(disk,firstCluster);
		rtn = TRUE;
	}
	return rtn;
}
 110:	6e 96       	adiw	r28, 0x1e	; 30
 112:	0f b6       	in	r0, 0x3f	; 63
 114:	f8 94       	cli
 116:	de bf       	out	0x3e, r29	; 62
 118:	0f be       	out	0x3f, r0	; 63
 11a:	cd bf       	out	0x3d, r28	; 61
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	bf 90       	pop	r11
 12e:	af 90       	pop	r10
 130:	9f 90       	pop	r9
 132:	8f 90       	pop	r8
 134:	7f 90       	pop	r7
 136:	6f 90       	pop	r6
 138:	5f 90       	pop	r5
 13a:	4f 90       	pop	r4
 13c:	08 95       	ret

FATfile.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000bfc  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000c30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000c30  2**0
                  ALLOC
  3 .debug_info   00001be0  00000000  00000000  00000c30  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000044e  00000000  00000000  00002810  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00001a26  00000000  00000000  00002c5e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00004684  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000048  00000000  00000000  000046a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000002a6  00000000  00000000  000046ec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000925  00000000  00000000  00004992  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000052b7  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000374  00000000  00000000  000052e4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_dirGetFileStructure>:


// This function stores the filerecord located at loc in filerec.
// It fetches the required sector for this.
// Return value: void
static void _dirGetFileStructure(const DISK* disk,DIR_ENTRY *filerec,const DIR_POSITION *loc){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	7b 01       	movw	r14, r22
  10:	8a 01       	movw	r16, r20
	void* buf=_partitionGetSector(disk,loc->sector,BUFFER_MODE_READONLY);
  12:	fa 01       	movw	r30, r20
  14:	40 81       	ld	r20, Z
  16:	51 81       	ldd	r21, Z+1	; 0x01
  18:	62 81       	ldd	r22, Z+2	; 0x02
  1a:	73 81       	ldd	r23, Z+3	; 0x03
  1c:	21 e0       	ldi	r18, 0x01	; 1
  1e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	DIR_ENTRY* dir = (DIR_ENTRY*)buf;
	memcpy(filerec,&dir[loc->entryInSector],sizeof(DIR_ENTRY));
  22:	f8 01       	movw	r30, r16
  24:	24 81       	ldd	r18, Z+4	; 0x04
  26:	fc 01       	movw	r30, r24
  28:	30 e2       	ldi	r19, 0x20	; 32
  2a:	23 9f       	mul	r18, r19
  2c:	e0 0d       	add	r30, r0
  2e:	f1 1d       	adc	r31, r1
  30:	11 24       	eor	r1, r1
  32:	20 e2       	ldi	r18, 0x20	; 32
  34:	d7 01       	movw	r26, r14
  36:	01 90       	ld	r0, Z+
  38:	0d 92       	st	X+, r0
  3a:	2a 95       	dec	r18
  3c:	01 f4       	brne	.+0      	; 0x3e <_dirGetFileStructure+0x3e>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
  3e:	bc 01       	movw	r22, r24
  40:	ce 01       	movw	r24, r28
	partition_releaseSector(disk,buf);
}
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	1f 91       	pop	r17
  48:	0f 91       	pop	r16
  4a:	ff 90       	pop	r15
  4c:	ef 90       	pop	r14
  4e:	0c 94 00 00 	jmp	0	; 0x0 <_dirGetFileStructure>

00000052 <_fileInitFile>:
	memcpy(filerec->filename,fatfilename,11);
}


// Initialises a new file object
static void _fileInitFile(DISK* disk, FATFILE *file, const DIR_ENTRY* dir, const DIR_POSITION *loc){
  52:	0f 93       	push	r16
  54:	1f 93       	push	r17
  56:	cf 93       	push	r28
  58:	df 93       	push	r29
  5a:	fb 01       	movw	r30, r22
  5c:	da 01       	movw	r26, r20
  5e:	e9 01       	movw	r28, r18
	file->disk=disk;
  60:	91 83       	std	Z+1, r25	; 0x01
  62:	80 83       	st	Z, r24
	file->fileSize=dir->fileSize;
  64:	5c 96       	adiw	r26, 0x1c	; 28
  66:	0d 91       	ld	r16, X+
  68:	1d 91       	ld	r17, X+
  6a:	2d 91       	ld	r18, X+
  6c:	3c 91       	ld	r19, X
  6e:	5f 97       	sbiw	r26, 0x1f	; 31
  70:	01 a7       	std	Z+41, r16	; 0x29
  72:	12 a7       	std	Z+42, r17	; 0x2a
  74:	23 a7       	std	Z+43, r18	; 0x2b
  76:	34 a7       	std	Z+44, r19	; 0x2c
	file->filePos=0;
  78:	15 a2       	std	Z+37, r1	; 0x25
  7a:	16 a2       	std	Z+38, r1	; 0x26
  7c:	17 a2       	std	Z+39, r1	; 0x27
  7e:	10 a6       	std	Z+40, r1	; 0x28
	file->directory.sector=loc->sector;
  80:	08 81       	ld	r16, Y
  82:	19 81       	ldd	r17, Y+1	; 0x01
  84:	2a 81       	ldd	r18, Y+2	; 0x02
  86:	3b 81       	ldd	r19, Y+3	; 0x03
  88:	06 83       	std	Z+6, r16	; 0x06
  8a:	17 83       	std	Z+7, r17	; 0x07
  8c:	20 87       	std	Z+8, r18	; 0x08
  8e:	31 87       	std	Z+9, r19	; 0x09
	file->directory.entryInSector=loc->entryInSector;
  90:	8c 81       	ldd	r24, Y+4	; 0x04
  92:	82 87       	std	Z+10, r24	; 0x0a

	CLUSTER firstCluster = (((CLUSTER)dir->firstClusterHigh)<<16)+dir->firstClusterLow;;
  94:	54 96       	adiw	r26, 0x14	; 20
  96:	4d 91       	ld	r20, X+
  98:	5c 91       	ld	r21, X
  9a:	55 97       	sbiw	r26, 0x15	; 21
  9c:	60 e0       	ldi	r22, 0x00	; 0
  9e:	70 e0       	ldi	r23, 0x00	; 0
  a0:	ba 01       	movw	r22, r20
  a2:	55 27       	eor	r21, r21
  a4:	44 27       	eor	r20, r20
  a6:	5a 96       	adiw	r26, 0x1a	; 26
  a8:	8d 91       	ld	r24, X+
  aa:	9c 91       	ld	r25, X
  ac:	5b 97       	sbiw	r26, 0x1b	; 27
  ae:	48 0f       	add	r20, r24
  b0:	59 1f       	adc	r21, r25
  b2:	61 1d       	adc	r22, r1
  b4:	71 1d       	adc	r23, r1
	file->startCluster = firstCluster;
  b6:	42 83       	std	Z+2, r20	; 0x02
  b8:	53 83       	std	Z+3, r21	; 0x03
  ba:	64 83       	std	Z+4, r22	; 0x04
  bc:	75 83       	std	Z+5, r23	; 0x05

	_navInitClusterChain(&file->nav, firstCluster);
  be:	cf 01       	movw	r24, r30
  c0:	0c 96       	adiw	r24, 0x0c	; 12
}
  c2:	df 91       	pop	r29
  c4:	cf 91       	pop	r28
  c6:	1f 91       	pop	r17
  c8:	0f 91       	pop	r16
	file->directory.entryInSector=loc->entryInSector;

	CLUSTER firstCluster = (((CLUSTER)dir->firstClusterHigh)<<16)+dir->firstClusterLow;;
	file->startCluster = firstCluster;

	_navInitClusterChain(&file->nav, firstCluster);
  ca:	0c 94 00 00 	jmp	0	; 0x0 <_dirGetFileStructure>

000000ce <_allocateFirstCluster>:
	dir[loc->entryInSector].firstClusterLow=cluster_addr&0xFFFF;
	partition_releaseSector(disk,dir);
}


static void _allocateFirstCluster(DISK* disk, FATFILE* file, DIR_ENTRY* dir, const DIR_POSITION *loc){
  ce:	6f 92       	push	r6
  d0:	7f 92       	push	r7
  d2:	8f 92       	push	r8
  d4:	9f 92       	push	r9
  d6:	af 92       	push	r10
  d8:	bf 92       	push	r11
  da:	cf 92       	push	r12
  dc:	df 92       	push	r13
  de:	ef 92       	push	r14
  e0:	ff 92       	push	r15
  e2:	0f 93       	push	r16
  e4:	1f 93       	push	r17
  e6:	cf 93       	push	r28
  e8:	df 93       	push	r29
  ea:	ec 01       	movw	r28, r24
  ec:	5b 01       	movw	r10, r22
  ee:	4a 01       	movw	r8, r20
  f0:	39 01       	movw	r6, r18
	CLUSTER cluster=_fatGetFreeCluster(disk);
  f2:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
  f6:	6b 01       	movw	r12, r22
  f8:	7c 01       	movw	r14, r24
	if(cluster != 0){
  fa:	61 15       	cp	r22, r1
  fc:	71 05       	cpc	r23, r1
  fe:	81 05       	cpc	r24, r1
 100:	91 05       	cpc	r25, r1
 102:	01 f4       	brne	.+0      	; 0x104 <_allocateFirstCluster+0x36>
 104:	00 c0       	rjmp	.+0      	; 0x106 <_allocateFirstCluster+0x38>
	}
}

// Update a disk directory entry with the given start cluster
static void _dirSetFirstCluster(const DISK* disk,const DIR_POSITION *loc,CLUSTER cluster_addr){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 106:	f5 01       	movw	r30, r10
 108:	46 81       	ldd	r20, Z+6	; 0x06
 10a:	57 81       	ldd	r21, Z+7	; 0x07
 10c:	60 85       	ldd	r22, Z+8	; 0x08
 10e:	71 85       	ldd	r23, Z+9	; 0x09
 110:	22 e0       	ldi	r18, 0x02	; 2
 112:	ce 01       	movw	r24, r28
 114:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 118:	bc 01       	movw	r22, r24
	dir[loc->entryInSector].firstClusterHigh=cluster_addr>>16;
 11a:	f5 01       	movw	r30, r10
 11c:	82 85       	ldd	r24, Z+10	; 0x0a
 11e:	fb 01       	movw	r30, r22
 120:	90 e2       	ldi	r25, 0x20	; 32
 122:	89 9f       	mul	r24, r25
 124:	e0 0d       	add	r30, r0
 126:	f1 1d       	adc	r31, r1
 128:	11 24       	eor	r1, r1
 12a:	f5 8a       	std	Z+21, r15	; 0x15
 12c:	e4 8a       	std	Z+20, r14	; 0x14
	dir[loc->entryInSector].firstClusterLow=cluster_addr&0xFFFF;
 12e:	f5 01       	movw	r30, r10
 130:	82 85       	ldd	r24, Z+10	; 0x0a
 132:	fb 01       	movw	r30, r22
 134:	90 e2       	ldi	r25, 0x20	; 32
 136:	89 9f       	mul	r24, r25
 138:	e0 0d       	add	r30, r0
 13a:	f1 1d       	adc	r31, r1
 13c:	11 24       	eor	r1, r1
 13e:	d3 8e       	std	Z+27, r13	; 0x1b
 140:	c2 8e       	std	Z+26, r12	; 0x1a
 142:	ce 01       	movw	r24, r28
 144:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	if(cluster != 0){
		// Update disk dir with first cluster
		_dirSetFirstCluster(disk,&(file->directory),cluster);

		// Update directory with first cluster
		_dirSetFirstClusterInDirEntry(dir,cluster);
 148:	b7 01       	movw	r22, r14
 14a:	a6 01       	movw	r20, r12
 14c:	c4 01       	movw	r24, r8
 14e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

		// First cluster is end of chain
		_fatSetNextClusterAddress(disk,cluster,_fatGiveEndMarker(disk));
 152:	ce 01       	movw	r24, r28
 154:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 158:	8b 01       	movw	r16, r22
 15a:	9c 01       	movw	r18, r24
 15c:	b7 01       	movw	r22, r14
 15e:	a6 01       	movw	r20, r12
 160:	ce 01       	movw	r24, r28
 162:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

		// Re-initialise the file with the changes
		_fileInitFile(disk,file,dir,loc);
 166:	93 01       	movw	r18, r6
 168:	a4 01       	movw	r20, r8
 16a:	b5 01       	movw	r22, r10
 16c:	ce 01       	movw	r24, r28
	}
}
 16e:	df 91       	pop	r29
 170:	cf 91       	pop	r28
 172:	1f 91       	pop	r17
 174:	0f 91       	pop	r16
 176:	ff 90       	pop	r15
 178:	ef 90       	pop	r14
 17a:	df 90       	pop	r13
 17c:	cf 90       	pop	r12
 17e:	bf 90       	pop	r11
 180:	af 90       	pop	r10
 182:	9f 90       	pop	r9
 184:	8f 90       	pop	r8
 186:	7f 90       	pop	r7
 188:	6f 90       	pop	r6

		// First cluster is end of chain
		_fatSetNextClusterAddress(disk,cluster,_fatGiveEndMarker(disk));

		// Re-initialise the file with the changes
		_fileInitFile(disk,file,dir,loc);
 18a:	0c 94 00 00 	jmp	0	; 0x0 <_dirGetFileStructure>
	}
}
 18e:	df 91       	pop	r29
 190:	cf 91       	pop	r28
 192:	1f 91       	pop	r17
 194:	0f 91       	pop	r16
 196:	ff 90       	pop	r15
 198:	ef 90       	pop	r14
 19a:	df 90       	pop	r13
 19c:	cf 90       	pop	r12
 19e:	bf 90       	pop	r11
 1a0:	af 90       	pop	r10
 1a2:	9f 90       	pop	r9
 1a4:	8f 90       	pop	r8
 1a6:	7f 90       	pop	r7
 1a8:	6f 90       	pop	r6
 1aa:	08 95       	ret

000001ac <fileSetPos>:
	file->startCluster = firstCluster;

	_navInitClusterChain(&file->nav, firstCluster);
}

boolean fileSetPos(FATFILE *file,uint32_t pos){
 1ac:	0f 93       	push	r16
 1ae:	1f 93       	push	r17
	if(pos<=file->fileSize){
 1b0:	fc 01       	movw	r30, r24
 1b2:	01 a5       	ldd	r16, Z+41	; 0x29
 1b4:	12 a5       	ldd	r17, Z+42	; 0x2a
 1b6:	23 a5       	ldd	r18, Z+43	; 0x2b
 1b8:	34 a5       	ldd	r19, Z+44	; 0x2c
 1ba:	04 17       	cp	r16, r20
 1bc:	15 07       	cpc	r17, r21
 1be:	26 07       	cpc	r18, r22
 1c0:	37 07       	cpc	r19, r23
 1c2:	00 f0       	brcs	.+0      	; 0x1c4 <fileSetPos+0x18>
		file->filePos=pos;
 1c4:	45 a3       	std	Z+37, r20	; 0x25
 1c6:	56 a3       	std	Z+38, r21	; 0x26
 1c8:	67 a3       	std	Z+39, r22	; 0x27
 1ca:	70 a7       	std	Z+40, r23	; 0x28
		return(TRUE);
 1cc:	8f ef       	ldi	r24, 0xFF	; 255
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <fileSetPos+0x24>
	}
	return(FALSE);
 1d0:	80 e0       	ldi	r24, 0x00	; 0
}
 1d2:	1f 91       	pop	r17
 1d4:	0f 91       	pop	r16
 1d6:	08 95       	ret

000001d8 <fileExists>:
		// Re-initialise the file with the changes
		_fileInitFile(disk,file,dir,loc);
	}
}

boolean fileExists(DISK * disk,const char* filename){
 1d8:	ef 92       	push	r14
 1da:	ff 92       	push	r15
 1dc:	0f 93       	push	r16
 1de:	1f 93       	push	r17
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
 1e4:	cd b7       	in	r28, 0x3d	; 61
 1e6:	de b7       	in	r29, 0x3e	; 62
 1e8:	61 97       	sbiw	r28, 0x11	; 17
 1ea:	0f b6       	in	r0, 0x3f	; 63
 1ec:	f8 94       	cli
 1ee:	de bf       	out	0x3e, r29	; 62
 1f0:	0f be       	out	0x3f, r0	; 63
 1f2:	cd bf       	out	0x3d, r28	; 61
 1f4:	7c 01       	movw	r14, r24
 1f6:	8b 01       	movw	r16, r22
    DIR_POSITION loc;
    char fatfilename[11];
    _dirGetFatFileName(filename,fatfilename);
 1f8:	be 01       	movw	r22, r28
 1fa:	6f 5f       	subi	r22, 0xFF	; 255
 1fc:	7f 4f       	sbci	r23, 0xFF	; 255
 1fe:	c8 01       	movw	r24, r16
 200:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
    return (_fileFindFile(disk,filename,&loc,null)==0) ? FALSE : TRUE;
 204:	20 e0       	ldi	r18, 0x00	; 0
 206:	30 e0       	ldi	r19, 0x00	; 0
 208:	ae 01       	movw	r20, r28
 20a:	44 5f       	subi	r20, 0xF4	; 244
 20c:	5f 4f       	sbci	r21, 0xFF	; 255
 20e:	b8 01       	movw	r22, r16
 210:	c7 01       	movw	r24, r14
 212:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 216:	81 11       	cpse	r24, r1
 218:	8f ef       	ldi	r24, 0xFF	; 255
}
 21a:	61 96       	adiw	r28, 0x11	; 17
 21c:	0f b6       	in	r0, 0x3f	; 63
 21e:	f8 94       	cli
 220:	de bf       	out	0x3e, r29	; 62
 222:	0f be       	out	0x3f, r0	; 63
 224:	cd bf       	out	0x3d, r28	; 61
 226:	df 91       	pop	r29
 228:	cf 91       	pop	r28
 22a:	1f 91       	pop	r17
 22c:	0f 91       	pop	r16
 22e:	ff 90       	pop	r15
 230:	ef 90       	pop	r14
 232:	08 95       	ret

00000234 <fileOpen>:

// Open a file and return a file handle 'File'
int8_t fileOpen(DISK* disk, FATFILE* file,const char* filename,char mode){
 234:	af 92       	push	r10
 236:	bf 92       	push	r11
 238:	cf 92       	push	r12
 23a:	df 92       	push	r13
 23c:	ef 92       	push	r14
 23e:	ff 92       	push	r15
 240:	0f 93       	push	r16
 242:	1f 93       	push	r17
 244:	cf 93       	push	r28
 246:	df 93       	push	r29
 248:	cd b7       	in	r28, 0x3d	; 61
 24a:	de b7       	in	r29, 0x3e	; 62
 24c:	e6 97       	sbiw	r28, 0x36	; 54
 24e:	0f b6       	in	r0, 0x3f	; 63
 250:	f8 94       	cli
 252:	de bf       	out	0x3e, r29	; 62
 254:	0f be       	out	0x3f, r0	; 63
 256:	cd bf       	out	0x3d, r28	; 61
 258:	6c 01       	movw	r12, r24
 25a:	7b 01       	movw	r14, r22
 25c:	5a 01       	movw	r10, r20
    DIR_POSITION loc;
    char fatfilename[11];
    CLUSTER dirCluster;
	DIR_ENTRY wtmp;

    _dirGetFatFileName(filename,fatfilename);
 25e:	be 01       	movw	r22, r28
 260:	6f 5d       	subi	r22, 0xDF	; 223
 262:	7f 4f       	sbci	r23, 0xFF	; 255
 264:	ca 01       	movw	r24, r20
 266:	2e ab       	std	Y+54, r18	; 0x36
 268:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

    switch(mode){
 26c:	2e a9       	ldd	r18, Y+54	; 0x36
 26e:	22 37       	cpi	r18, 0x72	; 114
 270:	01 f0       	breq	.+0      	; 0x272 <fileOpen+0x3e>
 272:	27 37       	cpi	r18, 0x77	; 119
 274:	01 f0       	breq	.+0      	; 0x276 <fileOpen+0x42>
 276:	21 36       	cpi	r18, 0x61	; 97
 278:	01 f0       	breq	.+0      	; 0x27a <fileOpen+0x46>
 27a:	00 c0       	rjmp	.+0      	; 0x27c <fileOpen+0x48>
 27c:	00 c0       	rjmp	.+0      	; 0x27e <fileOpen+0x4a>
        case MODE_READ:
            if(_fileFindFile(disk,filename,&loc,null)==1){
 27e:	20 e0       	ldi	r18, 0x00	; 0
 280:	30 e0       	ldi	r19, 0x00	; 0
 282:	ae 01       	movw	r20, r28
 284:	44 5d       	subi	r20, 0xD4	; 212
 286:	5f 4f       	sbci	r21, 0xFF	; 255
 288:	b5 01       	movw	r22, r10
 28a:	c6 01       	movw	r24, r12
 28c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 290:	81 30       	cpi	r24, 0x01	; 1
 292:	01 f0       	breq	.+0      	; 0x294 <fileOpen+0x60>
 294:	00 c0       	rjmp	.+0      	; 0x296 <fileOpen+0x62>
                _dirGetFileStructure(disk,&wtmp, &loc);
 296:	ae 01       	movw	r20, r28
 298:	44 5d       	subi	r20, 0xD4	; 212
 29a:	5f 4f       	sbci	r21, 0xFF	; 255
 29c:	be 01       	movw	r22, r28
 29e:	6f 5f       	subi	r22, 0xFF	; 255
 2a0:	7f 4f       	sbci	r23, 0xFF	; 255
 2a2:	c6 01       	movw	r24, r12
 2a4:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
                _fileInitFile(disk,file,&wtmp,&loc);
 2a8:	9e 01       	movw	r18, r28
 2aa:	24 5d       	subi	r18, 0xD4	; 212
 2ac:	3f 4f       	sbci	r19, 0xFF	; 255
 2ae:	ae 01       	movw	r20, r28
 2b0:	4f 5f       	subi	r20, 0xFF	; 255
 2b2:	5f 4f       	sbci	r21, 0xFF	; 255
 2b4:	b7 01       	movw	r22, r14
 2b6:	c6 01       	movw	r24, r12
 2b8:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	return(file->mode&(1<<attribute));
}

static void _fileSetAttr(FATFILE* file,uint8_t attribute,uint8_t val){
	if(val){
		file->mode|=1<<attribute;
 2bc:	f7 01       	movw	r30, r14
 2be:	84 a1       	ldd	r24, Z+36	; 0x24
 2c0:	81 60       	ori	r24, 0x01	; 1
	}else{
		file->mode&=~(1<<attribute);
 2c2:	8d 7f       	andi	r24, 0xFD	; 253
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <fileOpen+0x92>
				_fileSetAttr(file,FILE_STATUS_WRITE,0);
                return(0);
            }
            return(-1);
        case MODE_WRITE:
            if(_fileFindFile(disk,filename,&loc,&dirCluster)){
 2c6:	9e 01       	movw	r18, r28
 2c8:	2e 5c       	subi	r18, 0xCE	; 206
 2ca:	3f 4f       	sbci	r19, 0xFF	; 255
 2cc:	ae 01       	movw	r20, r28
 2ce:	44 5d       	subi	r20, 0xD4	; 212
 2d0:	5f 4f       	sbci	r21, 0xFF	; 255
 2d2:	b5 01       	movw	r22, r10
 2d4:	c6 01       	movw	r24, r12
 2d6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 2da:	81 11       	cpse	r24, r1
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <fileOpen+0xaa>
                return(-2);	// File already exists
			}
			if(dirCluster==0){ 	// Parent dir does not exist
 2de:	0a a9       	ldd	r16, Y+50	; 0x32
 2e0:	1b a9       	ldd	r17, Y+51	; 0x33
 2e2:	2c a9       	ldd	r18, Y+52	; 0x34
 2e4:	3d a9       	ldd	r19, Y+53	; 0x35
 2e6:	01 2b       	or	r16, r17
 2e8:	02 2b       	or	r16, r18
 2ea:	03 2b       	or	r16, r19
 2ec:	01 f0       	breq	.+0      	; 0x2ee <fileOpen+0xba>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <fileOpen+0xbc>
 2f0:	00 c0       	rjmp	.+0      	; 0x2f2 <fileOpen+0xbe>
 				return(-3);
			}
			goto create;
        case MODE_APPEND:
			if(_fileFindFile(disk,filename,&loc,0)==1){ /* File exists */
 2f2:	20 e0       	ldi	r18, 0x00	; 0
 2f4:	30 e0       	ldi	r19, 0x00	; 0
 2f6:	ae 01       	movw	r20, r28
 2f8:	44 5d       	subi	r20, 0xD4	; 212
 2fa:	5f 4f       	sbci	r21, 0xFF	; 255
 2fc:	b5 01       	movw	r22, r10
 2fe:	c6 01       	movw	r24, r12
 300:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 304:	81 30       	cpi	r24, 0x01	; 1
 306:	01 f4       	brne	.+0      	; 0x308 <fileOpen+0xd4>
				if(loc.attrib.flags.isReadOnly){
 308:	89 a9       	ldd	r24, Y+49	; 0x31
 30a:	80 fd       	sbrc	r24, 0
 30c:	00 c0       	rjmp	.+0      	; 0x30e <fileOpen+0xda>
					return -4;						  /* but is read only */
				}
				_dirGetFileStructure(disk,&wtmp, &loc);
 30e:	ae 01       	movw	r20, r28
 310:	44 5d       	subi	r20, 0xD4	; 212
 312:	5f 4f       	sbci	r21, 0xFF	; 255
 314:	be 01       	movw	r22, r28
 316:	6f 5f       	subi	r22, 0xFF	; 255
 318:	7f 4f       	sbci	r23, 0xFF	; 255
 31a:	c6 01       	movw	r24, r12
 31c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				_fileInitFile(disk,file,&wtmp,&loc);
 320:	9e 01       	movw	r18, r28
 322:	24 5d       	subi	r18, 0xD4	; 212
 324:	3f 4f       	sbci	r19, 0xFF	; 255
 326:	ae 01       	movw	r20, r28
 328:	4f 5f       	subi	r20, 0xFF	; 255
 32a:	5f 4f       	sbci	r21, 0xFF	; 255
 32c:	b7 01       	movw	r22, r14
 32e:	c6 01       	movw	r24, r12
 330:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				if(file->nav.startCluster==0){
 334:	f7 01       	movw	r30, r14
 336:	40 8d       	ldd	r20, Z+24	; 0x18
 338:	51 8d       	ldd	r21, Z+25	; 0x19
 33a:	62 8d       	ldd	r22, Z+26	; 0x1a
 33c:	73 8d       	ldd	r23, Z+27	; 0x1b
 33e:	45 2b       	or	r20, r21
 340:	46 2b       	or	r20, r22
 342:	47 2b       	or	r20, r23
 344:	01 f4       	brne	.+0      	; 0x346 <fileOpen+0x112>
					// The file is empty
					_allocateFirstCluster(disk,file,&wtmp,&loc);
 346:	9e 01       	movw	r18, r28
 348:	24 5d       	subi	r18, 0xD4	; 212
 34a:	3f 4f       	sbci	r19, 0xFF	; 255
 34c:	ae 01       	movw	r20, r28
 34e:	4f 5f       	subi	r20, 0xFF	; 255
 350:	5f 4f       	sbci	r21, 0xFF	; 255
 352:	b7 01       	movw	r22, r14
 354:	c6 01       	movw	r24, r12
 356:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	_navInitClusterChain(&file->nav, firstCluster);
}

boolean fileSetPos(FATFILE *file,uint32_t pos){
	if(pos<=file->fileSize){
		file->filePos=pos;
 35a:	f7 01       	movw	r30, r14
 35c:	81 a5       	ldd	r24, Z+41	; 0x29
 35e:	92 a5       	ldd	r25, Z+42	; 0x2a
 360:	a3 a5       	ldd	r26, Z+43	; 0x2b
 362:	b4 a5       	ldd	r27, Z+44	; 0x2c
 364:	85 a3       	std	Z+37, r24	; 0x25
 366:	96 a3       	std	Z+38, r25	; 0x26
 368:	a7 a3       	std	Z+39, r26	; 0x27
 36a:	b0 a7       	std	Z+40, r27	; 0x28
 36c:	00 c0       	rjmp	.+0      	; 0x36e <fileOpen+0x13a>
				_fileSetAttr(file,FILE_STATUS_OPEN,1);
				_fileSetAttr(file,FILE_STATUS_WRITE,1);
			}else{ /* File does not excist */
create:
				// Create a new file
				if(_dirFindFreeFile(disk,filename,&loc))	{
 36e:	ae 01       	movw	r20, r28
 370:	44 5d       	subi	r20, 0xD4	; 212
 372:	5f 4f       	sbci	r21, 0xFF	; 255
 374:	b5 01       	movw	r22, r10
 376:	c6 01       	movw	r24, r12
 378:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 37c:	88 23       	and	r24, r24
 37e:	01 f0       	breq	.+0      	; 0x380 <fileOpen+0x14c>
// This function fills in a filerecord with safe default values, and
// a given fatfilename. If your system has a means of knowing time, here is an
// excellent place to apply it to the filerecord.
// Return value: void
static void _dirCreateDefaultEntry(DIR_ENTRY *filerec,const char* fatfilename){
	memclr(filerec,sizeof(DIR_ENTRY));
 380:	8e 01       	movw	r16, r28
 382:	0f 5f       	subi	r16, 0xFF	; 255
 384:	1f 4f       	sbci	r17, 0xFF	; 255
 386:	80 e2       	ldi	r24, 0x20	; 32
 388:	f8 01       	movw	r30, r16
 38a:	11 92       	st	Z+, r1
 38c:	8a 95       	dec	r24
 38e:	01 f4       	brne	.+0      	; 0x390 <fileOpen+0x15c>
	memcpy(filerec->filename,fatfilename,11);
 390:	8b e0       	ldi	r24, 0x0B	; 11
 392:	fe 01       	movw	r30, r28
 394:	b1 96       	adiw	r30, 0x21	; 33
 396:	d8 01       	movw	r26, r16
 398:	01 90       	ld	r0, Z+
 39a:	0d 92       	st	X+, r0
 39c:	8a 95       	dec	r24
 39e:	01 f4       	brne	.+0      	; 0x3a0 <fileOpen+0x16c>
create:
				// Create a new file
				if(_dirFindFreeFile(disk,filename,&loc))	{
					_dirCreateDefaultEntry(&wtmp,fatfilename);
					// Copy directory to disk
					_dirCreateDirectoryEntry(disk,&wtmp,&loc);
 3a0:	ae 01       	movw	r20, r28
 3a2:	44 5d       	subi	r20, 0xD4	; 212
 3a4:	5f 4f       	sbci	r21, 0xFF	; 255
 3a6:	b8 01       	movw	r22, r16
 3a8:	c6 01       	movw	r24, r12
 3aa:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		rprintfInit(old);}
#endif


					// Initialise file with directory info
					_fileInitFile(disk,file,&wtmp, &loc);
 3ae:	9e 01       	movw	r18, r28
 3b0:	24 5d       	subi	r18, 0xD4	; 212
 3b2:	3f 4f       	sbci	r19, 0xFF	; 255
 3b4:	a8 01       	movw	r20, r16
 3b6:	b7 01       	movw	r22, r14
 3b8:	c6 01       	movw	r24, r12
 3ba:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

					// Allocate the first cluster to the file data
					_allocateFirstCluster(disk,file,&wtmp,&loc);
 3be:	9e 01       	movw	r18, r28
 3c0:	24 5d       	subi	r18, 0xD4	; 212
 3c2:	3f 4f       	sbci	r19, 0xFF	; 255
 3c4:	a8 01       	movw	r20, r16
 3c6:	b7 01       	movw	r22, r14
 3c8:	c6 01       	movw	r24, r12
 3ca:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	return(file->mode&(1<<attribute));
}

static void _fileSetAttr(FATFILE* file,uint8_t attribute,uint8_t val){
	if(val){
		file->mode|=1<<attribute;
 3ce:	f7 01       	movw	r30, r14
 3d0:	84 a1       	ldd	r24, Z+36	; 0x24
 3d2:	83 60       	ori	r24, 0x03	; 3
 3d4:	84 a3       	std	Z+36, r24	; 0x24
					_fileSetAttr(file,FILE_STATUS_WRITE,1);
				}else{
					return(-5);
				}
			}
			return(0);
 3d6:	80 e0       	ldi	r24, 0x00	; 0
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <fileOpen+0x1a6>
    }
    return(-6);
 3da:	8a ef       	ldi	r24, 0xFA	; 250
 3dc:	00 c0       	rjmp	.+0      	; 0x3de <fileOpen+0x1aa>
                _fileInitFile(disk,file,&wtmp,&loc);
				_fileSetAttr(file,FILE_STATUS_OPEN,1);
				_fileSetAttr(file,FILE_STATUS_WRITE,0);
                return(0);
            }
            return(-1);
 3de:	8f ef       	ldi	r24, 0xFF	; 255
 3e0:	00 c0       	rjmp	.+0      	; 0x3e2 <fileOpen+0x1ae>
        case MODE_WRITE:
            if(_fileFindFile(disk,filename,&loc,&dirCluster)){
                return(-2);	// File already exists
 3e2:	8e ef       	ldi	r24, 0xFE	; 254
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <fileOpen+0x1b2>
			}
			if(dirCluster==0){ 	// Parent dir does not exist
 				return(-3);
 3e6:	8d ef       	ldi	r24, 0xFD	; 253
 3e8:	00 c0       	rjmp	.+0      	; 0x3ea <fileOpen+0x1b6>
			}
			goto create;
        case MODE_APPEND:
			if(_fileFindFile(disk,filename,&loc,0)==1){ /* File exists */
				if(loc.attrib.flags.isReadOnly){
					return -4;						  /* but is read only */
 3ea:	8c ef       	ldi	r24, 0xFC	; 252
 3ec:	00 c0       	rjmp	.+0      	; 0x3ee <fileOpen+0x1ba>
					_allocateFirstCluster(disk,file,&wtmp,&loc);

					_fileSetAttr(file,FILE_STATUS_OPEN,1);
					_fileSetAttr(file,FILE_STATUS_WRITE,1);
				}else{
					return(-5);
 3ee:	8b ef       	ldi	r24, 0xFB	; 251
				}
			}
			return(0);
    }
    return(-6);
}
 3f0:	e6 96       	adiw	r28, 0x36	; 54
 3f2:	0f b6       	in	r0, 0x3f	; 63
 3f4:	f8 94       	cli
 3f6:	de bf       	out	0x3e, r29	; 62
 3f8:	0f be       	out	0x3f, r0	; 63
 3fa:	cd bf       	out	0x3d, r28	; 61
 3fc:	df 91       	pop	r29
 3fe:	cf 91       	pop	r28
 400:	1f 91       	pop	r17
 402:	0f 91       	pop	r16
 404:	ff 90       	pop	r15
 406:	ef 90       	pop	r14
 408:	df 90       	pop	r13
 40a:	cf 90       	pop	r12
 40c:	bf 90       	pop	r11
 40e:	af 90       	pop	r10
 410:	08 95       	ret

00000412 <fileFlush>:

	// Return the count
	return(c-1);
}

void fileFlush(FATFILE* file){
 412:	cf 92       	push	r12
 414:	df 92       	push	r13
 416:	ef 92       	push	r14
 418:	ff 92       	push	r15
 41a:	0f 93       	push	r16
 41c:	1f 93       	push	r17
 41e:	cf 93       	push	r28
 420:	df 93       	push	r29
 422:	ec 01       	movw	r28, r24
	}
	return(FALSE);
}

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
 424:	8c a1       	ldd	r24, Y+36	; 0x24
	// Return the count
	return(c-1);
}

void fileFlush(FATFILE* file){
	if(_fileGetAttr(file,FILE_STATUS_WRITE)){
 426:	81 ff       	sbrs	r24, 1
 428:	00 c0       	rjmp	.+0      	; 0x42a <fileFlush+0x18>
		CLUSTER_COUNT cnt = _fatCountClustersInChain(file->disk,file->startCluster);
		rprintf("Flush File: First Cl=%lu, NumCl=%lu\n",file->startCluster,cnt);
		rprintfInit(old);}
#endif

		_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
 42a:	c9 a4       	ldd	r12, Y+41	; 0x29
 42c:	da a4       	ldd	r13, Y+42	; 0x2a
 42e:	eb a4       	ldd	r14, Y+43	; 0x2b
 430:	fc a4       	ldd	r15, Y+44	; 0x2c
 432:	08 81       	ld	r16, Y
 434:	19 81       	ldd	r17, Y+1	; 0x01

FATFILE* activeFile;

// Update a disk directory entry with the file size
static void _dirSetFileSize(const DISK *disk, DIR_POSITION *loc,uint32_t numbytes){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 436:	4e 81       	ldd	r20, Y+6	; 0x06
 438:	5f 81       	ldd	r21, Y+7	; 0x07
 43a:	68 85       	ldd	r22, Y+8	; 0x08
 43c:	79 85       	ldd	r23, Y+9	; 0x09
 43e:	22 e0       	ldi	r18, 0x02	; 2
 440:	c8 01       	movw	r24, r16
 442:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	dir[loc->entryInSector].fileSize=numbytes;
 446:	2a 85       	ldd	r18, Y+10	; 0x0a
 448:	fc 01       	movw	r30, r24
 44a:	30 e2       	ldi	r19, 0x20	; 32
 44c:	23 9f       	mul	r18, r19
 44e:	e0 0d       	add	r30, r0
 450:	f1 1d       	adc	r31, r1
 452:	11 24       	eor	r1, r1
 454:	c4 8e       	std	Z+28, r12	; 0x1c
 456:	d5 8e       	std	Z+29, r13	; 0x1d
 458:	e6 8e       	std	Z+30, r14	; 0x1e
 45a:	f7 8e       	std	Z+31, r15	; 0x1f
 45c:	bc 01       	movw	r22, r24
 45e:	c8 01       	movw	r24, r16
 460:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		rprintfInit(old);}
#endif

		_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
		// Flush everything for now
		diskFlush(file->disk);
 464:	88 81       	ld	r24, Y
 466:	99 81       	ldd	r25, Y+1	; 0x01
	}
}
 468:	df 91       	pop	r29
 46a:	cf 91       	pop	r28
 46c:	1f 91       	pop	r17
 46e:	0f 91       	pop	r16
 470:	ff 90       	pop	r15
 472:	ef 90       	pop	r14
 474:	df 90       	pop	r13
 476:	cf 90       	pop	r12
		rprintfInit(old);}
#endif

		_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
		// Flush everything for now
		diskFlush(file->disk);
 478:	0c 94 00 00 	jmp	0	; 0x0 <_dirGetFileStructure>
	}
}
 47c:	df 91       	pop	r29
 47e:	cf 91       	pop	r28
 480:	1f 91       	pop	r17
 482:	0f 91       	pop	r16
 484:	ff 90       	pop	r15
 486:	ef 90       	pop	r14
 488:	df 90       	pop	r13
 48a:	cf 90       	pop	r12
 48c:	08 95       	ret

0000048e <fileClose>:

void fileClose(FATFILE *file){
 48e:	cf 93       	push	r28
 490:	df 93       	push	r29
 492:	ec 01       	movw	r28, r24
	fileFlush(file);
 494:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

	if(activeFile==file){
 498:	80 91 00 00 	lds	r24, 0x0000
 49c:	90 91 00 00 	lds	r25, 0x0000
 4a0:	8c 17       	cp	r24, r28
 4a2:	9d 07       	cpc	r25, r29
 4a4:	01 f4       	brne	.+0      	; 0x4a6 <fileClose+0x18>
		activeFile = null;
 4a6:	10 92 00 00 	sts	0x0000, r1
 4aa:	10 92 00 00 	sts	0x0000, r1
	}

	memclr(file,sizeof(*file));
 4ae:	8d e2       	ldi	r24, 0x2D	; 45
 4b0:	fe 01       	movw	r30, r28
 4b2:	11 92       	st	Z+, r1
 4b4:	8a 95       	dec	r24
 4b6:	01 f4       	brne	.+0      	; 0x4b8 <fileClose+0x2a>
//	file_setAttr(file,FILE_STATUS_OPEN,0);
//	file_setAttr(file,FILE_STATUS_WRITE,0);
}
 4b8:	df 91       	pop	r29
 4ba:	cf 91       	pop	r28
 4bc:	08 95       	ret

000004be <_fileRequiredCluster>:


// Determine the number of clusters that neeed to be added to the end of the file
CLUSTER_COUNT _fileRequiredCluster(FATFILE *file,uint32_t offset, size_t size){
 4be:	2f 92       	push	r2
 4c0:	3f 92       	push	r3
 4c2:	4f 92       	push	r4
 4c4:	5f 92       	push	r5
 4c6:	6f 92       	push	r6
 4c8:	7f 92       	push	r7
 4ca:	8f 92       	push	r8
 4cc:	9f 92       	push	r9
 4ce:	af 92       	push	r10
 4d0:	bf 92       	push	r11
 4d2:	cf 92       	push	r12
 4d4:	df 92       	push	r13
 4d6:	ef 92       	push	r14
 4d8:	ff 92       	push	r15
 4da:	0f 93       	push	r16
 4dc:	1f 93       	push	r17
 4de:	cf 93       	push	r28
 4e0:	df 93       	push	r29
 4e2:	cd b7       	in	r28, 0x3d	; 61
 4e4:	de b7       	in	r29, 0x3e	; 62
 4e6:	6d 97       	sbiw	r28, 0x1d	; 29
 4e8:	0f b6       	in	r0, 0x3f	; 63
 4ea:	f8 94       	cli
 4ec:	de bf       	out	0x3e, r29	; 62
 4ee:	0f be       	out	0x3f, r0	; 63
 4f0:	cd bf       	out	0x3d, r28	; 61
 4f2:	8c 01       	movw	r16, r24
 4f4:	2a 01       	movw	r4, r20
 4f6:	3b 01       	movw	r6, r22
	CLUSTER_COUNT clusters_required=0;

	uint32_t endPos = offset + (uint32_t)size;
 4f8:	42 0e       	add	r4, r18
 4fa:	53 1e       	adc	r5, r19
 4fc:	61 1c       	adc	r6, r1
 4fe:	71 1c       	adc	r7, r1

	if(endPos > file->fileSize){
 500:	dc 01       	movw	r26, r24
 502:	99 96       	adiw	r26, 0x29	; 41
 504:	4d 91       	ld	r20, X+
 506:	5d 91       	ld	r21, X+
 508:	6d 91       	ld	r22, X+
 50a:	7c 91       	ld	r23, X
 50c:	9c 97       	sbiw	r26, 0x2c	; 44
 50e:	44 15       	cp	r20, r4
 510:	55 05       	cpc	r21, r5
 512:	66 05       	cpc	r22, r6
 514:	77 05       	cpc	r23, r7
 516:	00 f0       	brcs	.+0      	; 0x518 <_fileRequiredCluster+0x5a>
}


// Determine the number of clusters that neeed to be added to the end of the file
CLUSTER_COUNT _fileRequiredCluster(FATFILE *file,uint32_t offset, size_t size){
	CLUSTER_COUNT clusters_required=0;
 518:	20 e0       	ldi	r18, 0x00	; 0
 51a:	30 e0       	ldi	r19, 0x00	; 0
 51c:	a9 01       	movw	r20, r18
 51e:	00 c0       	rjmp	.+0      	; 0x520 <_fileRequiredCluster+0x62>
	uint32_t endPos = offset + (uint32_t)size;

	if(endPos > file->fileSize){
		// Find the number of clusters allocated to the file
		CLUSTER_COUNT hc;
		if(file->nav.totalClusters==0){ /* Number of cluster unknown */
 520:	fc 01       	movw	r30, r24
 522:	c0 a0       	ldd	r12, Z+32	; 0x20
 524:	d1 a0       	ldd	r13, Z+33	; 0x21
 526:	e2 a0       	ldd	r14, Z+34	; 0x22
 528:	f3 a0       	ldd	r15, Z+35	; 0x23
 52a:	c1 14       	cp	r12, r1
 52c:	d1 04       	cpc	r13, r1
 52e:	e1 04       	cpc	r14, r1
 530:	f1 04       	cpc	r15, r1
 532:	01 f4       	brne	.+0      	; 0x534 <_fileRequiredCluster+0x76>
			hc = _fatCountClustersInChain(file->disk,file->nav.startCluster);
 534:	40 8d       	ldd	r20, Z+24	; 0x18
 536:	51 8d       	ldd	r21, Z+25	; 0x19
 538:	62 8d       	ldd	r22, Z+26	; 0x1a
 53a:	73 8d       	ldd	r23, Z+27	; 0x1b
 53c:	20 80       	ld	r2, Z
 53e:	31 80       	ldd	r3, Z+1	; 0x01


// Calculate the number of clusters starting with a given one
static CLUSTER_COUNT _fatCountClustersInChain(const DISK *disk,CLUSTER firstcluster){

	if(firstcluster<=1){
 540:	42 30       	cpi	r20, 0x02	; 2
 542:	51 05       	cpc	r21, r1
 544:	61 05       	cpc	r22, r1
 546:	71 05       	cpc	r23, r1
 548:	00 f0       	brcs	.+0      	; 0x54a <_fileRequiredCluster+0x8c>
		return(0);
	}

	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav,firstcluster);
 54a:	aa 24       	eor	r10, r10
 54c:	a3 94       	inc	r10
 54e:	b1 2c       	mov	r11, r1
 550:	ac 0e       	add	r10, r28
 552:	bd 1e       	adc	r11, r29
 554:	c5 01       	movw	r24, r10
 556:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

	// Step through each successive cluster
	CLUSTER_COUNT c=0;
	while( _fatNavigateTo(disk,&nav,c++) );
 55a:	a9 8e       	std	Y+25, r10	; 0x19
 55c:	bd 8e       	std	Y+29, r11	; 0x1d
 55e:	00 c0       	rjmp	.+0      	; 0x560 <_fileRequiredCluster+0xa2>
 560:	75 01       	movw	r14, r10
 562:	64 01       	movw	r12, r8
 564:	81 2c       	mov	r8, r1
 566:	91 2c       	mov	r9, r1
 568:	54 01       	movw	r10, r8
 56a:	83 94       	inc	r8
 56c:	8c 0c       	add	r8, r12
 56e:	9d 1c       	adc	r9, r13
 570:	ae 1c       	adc	r10, r14
 572:	bf 1c       	adc	r11, r15
 574:	a7 01       	movw	r20, r14
 576:	96 01       	movw	r18, r12
 578:	69 8d       	ldd	r22, Y+25	; 0x19
 57a:	7d 8d       	ldd	r23, Y+29	; 0x1d
 57c:	c1 01       	movw	r24, r2
 57e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 582:	81 11       	cpse	r24, r1
 584:	00 c0       	rjmp	.+0      	; 0x586 <_fileRequiredCluster+0xc8>
	if(endPos > file->fileSize){
		// Find the number of clusters allocated to the file
		CLUSTER_COUNT hc;
		if(file->nav.totalClusters==0){ /* Number of cluster unknown */
			hc = _fatCountClustersInChain(file->disk,file->nav.startCluster);
			file->nav.totalClusters = hc;
 586:	d8 01       	movw	r26, r16
 588:	90 96       	adiw	r26, 0x20	; 32
 58a:	cd 92       	st	X+, r12
 58c:	dd 92       	st	X+, r13
 58e:	ed 92       	st	X+, r14
 590:	fc 92       	st	X, r15
 592:	93 97       	sbiw	r26, 0x23	; 35
		}

		// Find the clusters required for the file length.
		// NB 'hc' may be bigger than this if files are extended by more
		// than one cluster at a time
		uint32_t clustersize = file->disk->volume.bytesPerSector *
 594:	d8 01       	movw	r26, r16
 596:	ed 91       	ld	r30, X+
 598:	fc 91       	ld	r31, X
 59a:	11 97       	sbiw	r26, 0x01	; 1
 59c:	20 89       	ldd	r18, Z+16	; 0x10
 59e:	86 85       	ldd	r24, Z+14	; 0x0e
 5a0:	97 85       	ldd	r25, Z+15	; 0x0f
 5a2:	28 9f       	mul	r18, r24
 5a4:	40 01       	movw	r8, r0
 5a6:	29 9f       	mul	r18, r25
 5a8:	90 0c       	add	r9, r0
 5aa:	11 24       	eor	r1, r1
 5ac:	a1 2c       	mov	r10, r1
 5ae:	b1 2c       	mov	r11, r1
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
 5b0:	99 96       	adiw	r26, 0x29	; 41
 5b2:	8d 91       	ld	r24, X+
 5b4:	9d 91       	ld	r25, X+
 5b6:	0d 90       	ld	r0, X+
 5b8:	bc 91       	ld	r27, X
 5ba:	a0 2d       	mov	r26, r0
		if( (endPos-file->fileSize) >
 5bc:	a3 01       	movw	r20, r6
 5be:	92 01       	movw	r18, r4
 5c0:	28 1b       	sub	r18, r24
 5c2:	39 0b       	sbc	r19, r25
 5c4:	4a 0b       	sbc	r20, r26
 5c6:	5b 0b       	sbc	r21, r27
 5c8:	29 8f       	std	Y+25, r18	; 0x19
 5ca:	3a 8f       	std	Y+26, r19	; 0x1a
 5cc:	4b 8f       	std	Y+27, r20	; 0x1b
 5ce:	5c 8f       	std	Y+28, r21	; 0x1c
		// than one cluster at a time
		uint32_t clustersize = file->disk->volume.bytesPerSector *
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
 5d0:	bc 01       	movw	r22, r24
 5d2:	cd 01       	movw	r24, r26
 5d4:	61 50       	subi	r22, 0x01	; 1
 5d6:	71 09       	sbc	r23, r1
 5d8:	81 09       	sbc	r24, r1
 5da:	91 09       	sbc	r25, r1
 5dc:	68 0d       	add	r22, r8
 5de:	79 1d       	adc	r23, r9
 5e0:	8a 1d       	adc	r24, r10
 5e2:	9b 1d       	adc	r25, r11
 5e4:	a5 01       	movw	r20, r10
 5e6:	94 01       	movw	r18, r8
 5e8:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		if( (endPos-file->fileSize) >
		   ((hc-currentClusterSize)*clustersize)){
 5ec:	d7 01       	movw	r26, r14
 5ee:	c6 01       	movw	r24, r12
 5f0:	82 1b       	sub	r24, r18
 5f2:	93 0b       	sbc	r25, r19
 5f4:	a4 0b       	sbc	r26, r20
 5f6:	b5 0b       	sbc	r27, r21
 5f8:	9c 01       	movw	r18, r24
 5fa:	ad 01       	movw	r20, r26
 5fc:	c5 01       	movw	r24, r10
 5fe:	b4 01       	movw	r22, r8
 600:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		uint32_t clustersize = file->disk->volume.bytesPerSector *
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
		if( (endPos-file->fileSize) >
 604:	29 8d       	ldd	r18, Y+25	; 0x19
 606:	3a 8d       	ldd	r19, Y+26	; 0x1a
 608:	4b 8d       	ldd	r20, Y+27	; 0x1b
 60a:	5c 8d       	ldd	r21, Y+28	; 0x1c
 60c:	62 17       	cp	r22, r18
 60e:	73 07       	cpc	r23, r19
 610:	84 07       	cpc	r24, r20
 612:	95 07       	cpc	r25, r21
 614:	00 f0       	brcs	.+0      	; 0x616 <_fileRequiredCluster+0x158>
 616:	00 c0       	rjmp	.+0      	; 0x618 <_fileRequiredCluster+0x15a>
		   ((hc-currentClusterSize)*clustersize)){
			clusters_required = ((endPos-(hc*clustersize))+clustersize-1)/clustersize;
 618:	d5 01       	movw	r26, r10
 61a:	c4 01       	movw	r24, r8
 61c:	01 97       	sbiw	r24, 0x01	; 1
 61e:	a1 09       	sbc	r26, r1
 620:	b1 09       	sbc	r27, r1
 622:	84 0d       	add	r24, r4
 624:	95 1d       	adc	r25, r5
 626:	a6 1d       	adc	r26, r6
 628:	b7 1d       	adc	r27, r7
 62a:	89 8f       	std	Y+25, r24	; 0x19
 62c:	9a 8f       	std	Y+26, r25	; 0x1a
 62e:	ab 8f       	std	Y+27, r26	; 0x1b
 630:	bc 8f       	std	Y+28, r27	; 0x1c
 632:	a7 01       	movw	r20, r14
 634:	96 01       	movw	r18, r12
 636:	c5 01       	movw	r24, r10
 638:	b4 01       	movw	r22, r8
 63a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 63e:	29 8d       	ldd	r18, Y+25	; 0x19
 640:	3a 8d       	ldd	r19, Y+26	; 0x1a
 642:	4b 8d       	ldd	r20, Y+27	; 0x1b
 644:	5c 8d       	ldd	r21, Y+28	; 0x1c
 646:	26 1b       	sub	r18, r22
 648:	37 0b       	sbc	r19, r23
 64a:	48 0b       	sbc	r20, r24
 64c:	59 0b       	sbc	r21, r25
 64e:	ca 01       	movw	r24, r20
 650:	b9 01       	movw	r22, r18
 652:	a5 01       	movw	r20, r10
 654:	94 01       	movw	r18, r8
 656:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		}
	}
	return(clusters_required);
}
 65a:	b9 01       	movw	r22, r18
 65c:	ca 01       	movw	r24, r20
 65e:	6d 96       	adiw	r28, 0x1d	; 29
 660:	0f b6       	in	r0, 0x3f	; 63
 662:	f8 94       	cli
 664:	de bf       	out	0x3e, r29	; 62
 666:	0f be       	out	0x3f, r0	; 63
 668:	cd bf       	out	0x3d, r28	; 61
 66a:	df 91       	pop	r29
 66c:	cf 91       	pop	r28
 66e:	1f 91       	pop	r17
 670:	0f 91       	pop	r16
 672:	ff 90       	pop	r15
 674:	ef 90       	pop	r14
 676:	df 90       	pop	r13
 678:	cf 90       	pop	r12
 67a:	bf 90       	pop	r11
 67c:	af 90       	pop	r10
 67e:	9f 90       	pop	r9
 680:	8f 90       	pop	r8
 682:	7f 90       	pop	r7
 684:	6f 90       	pop	r6
 686:	5f 90       	pop	r5
 688:	4f 90       	pop	r4
 68a:	3f 90       	pop	r3
 68c:	2f 90       	pop	r2
 68e:	08 95       	ret

00000690 <fileRead>:
// This function reads 'size' bytes from 'file' starting at
// 'offset' and puts the result in '*buf'.
// This will not modify the current file position but can be used for random reads
// Return value: amount of bytes actually read (can differ from the given
// size when the file was smaller)
size_t fileRead(FATFILE *file,uint32_t offset, size_t size,void *buf){
 690:	2f 92       	push	r2
 692:	3f 92       	push	r3
 694:	4f 92       	push	r4
 696:	5f 92       	push	r5
 698:	6f 92       	push	r6
 69a:	7f 92       	push	r7
 69c:	8f 92       	push	r8
 69e:	9f 92       	push	r9
 6a0:	af 92       	push	r10
 6a2:	bf 92       	push	r11
 6a4:	cf 92       	push	r12
 6a6:	df 92       	push	r13
 6a8:	ef 92       	push	r14
 6aa:	ff 92       	push	r15
 6ac:	0f 93       	push	r16
 6ae:	1f 93       	push	r17
 6b0:	cf 93       	push	r28
 6b2:	df 93       	push	r29
 6b4:	cd b7       	in	r28, 0x3d	; 61
 6b6:	de b7       	in	r29, 0x3e	; 62
 6b8:	68 97       	sbiw	r28, 0x18	; 24
 6ba:	0f b6       	in	r0, 0x3f	; 63
 6bc:	f8 94       	cli
 6be:	de bf       	out	0x3e, r29	; 62
 6c0:	0f be       	out	0x3f, r0	; 63
 6c2:	cd bf       	out	0x3d, r28	; 61
 6c4:	1c 01       	movw	r2, r24
 6c6:	1e 8b       	std	Y+22, r17	; 0x16
 6c8:	0d 8b       	std	Y+21, r16	; 0x15
	}
	return(FALSE);
}

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
 6ca:	fc 01       	movw	r30, r24
 6cc:	84 a1       	ldd	r24, Z+36	; 0x24
	size_t size_left=size;			// The number of bytes left to read

	uint32_t currentOffset=offset;		// The current file position

	// Check that the file has been opened
	if(!_fileGetAttr(file,FILE_STATUS_OPEN)){
 6ce:	80 ff       	sbrs	r24, 0
 6d0:	00 c0       	rjmp	.+0      	; 0x6d2 <fileRead+0x42>
		return(0);
	}

	// Dont read beyond end of file
	if(offset>=file->fileSize){
 6d2:	c1 a4       	ldd	r12, Z+41	; 0x29
 6d4:	d2 a4       	ldd	r13, Z+42	; 0x2a
 6d6:	e3 a4       	ldd	r14, Z+43	; 0x2b
 6d8:	f4 a4       	ldd	r15, Z+44	; 0x2c
 6da:	4c 15       	cp	r20, r12
 6dc:	5d 05       	cpc	r21, r13
 6de:	6e 05       	cpc	r22, r14
 6e0:	7f 05       	cpc	r23, r15
 6e2:	00 f4       	brcc	.+0      	; 0x6e4 <fileRead+0x54>
// This will not modify the current file position but can be used for random reads
// Return value: amount of bytes actually read (can differ from the given
// size when the file was smaller)
size_t fileRead(FATFILE *file,uint32_t offset, size_t size,void *buf){
	size_t bytes_read=0;			// The number of bytes read
	size_t size_left=size;			// The number of bytes left to read
 6e4:	39 01       	movw	r6, r18
 6e6:	00 c0       	rjmp	.+0      	; 0x6e8 <fileRead+0x58>
		return(0);
	}

	// Dont read beyond end of file
	if(offset>=file->fileSize){
		size_left=0; /* Offset check */
 6e8:	61 2c       	mov	r6, r1
 6ea:	71 2c       	mov	r7, r1
	}

	// Limit reads from going beyond end of file
	if( (offset+size > file->fileSize) && size_left!=0){
 6ec:	db 01       	movw	r26, r22
 6ee:	ca 01       	movw	r24, r20
 6f0:	82 0f       	add	r24, r18
 6f2:	93 1f       	adc	r25, r19
 6f4:	a1 1d       	adc	r26, r1
 6f6:	b1 1d       	adc	r27, r1
 6f8:	c8 16       	cp	r12, r24
 6fa:	d9 06       	cpc	r13, r25
 6fc:	ea 06       	cpc	r14, r26
 6fe:	fb 06       	cpc	r15, r27
 700:	00 f4       	brcc	.+0      	; 0x702 <fileRead+0x72>
 702:	61 14       	cp	r6, r1
 704:	71 04       	cpc	r7, r1
 706:	01 f0       	breq	.+0      	; 0x708 <fileRead+0x78>
		size_left=file->fileSize-offset;
 708:	36 01       	movw	r6, r12
 70a:	64 1a       	sub	r6, r20
 70c:	75 0a       	sbc	r7, r21
		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
		}else{
			bytesToRead = 512;
 70e:	6a 01       	movw	r12, r20
 710:	7b 01       	movw	r14, r22
 712:	00 e0       	ldi	r16, 0x00	; 0
 714:	10 e0       	ldi	r17, 0x00	; 0
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 716:	c1 01       	movw	r24, r2
 718:	0c 96       	adiw	r24, 0x0c	; 12
 71a:	98 8f       	std	Y+24, r25	; 0x18
 71c:	8f 8b       	std	Y+23, r24	; 0x17
 71e:	00 c0       	rjmp	.+0      	; 0x720 <fileRead+0x90>
		size_left=file->fileSize-offset;
	}

	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
 720:	d7 01       	movw	r26, r14
 722:	c6 01       	movw	r24, r12
 724:	91 70       	andi	r25, 0x01	; 1
 726:	aa 27       	eor	r26, r26
 728:	bb 27       	eor	r27, r27
 72a:	9a 8b       	std	Y+18, r25	; 0x12
 72c:	89 8b       	std	Y+17, r24	; 0x11
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 72e:	f1 01       	movw	r30, r2
 730:	01 90       	ld	r0, Z+
 732:	f0 81       	ld	r31, Z
 734:	e0 2d       	mov	r30, r0
 736:	fc 8b       	std	Y+20, r31	; 0x14
 738:	eb 8b       	std	Y+19, r30	; 0x13
 73a:	20 89       	ldd	r18, Z+16	; 0x10
 73c:	30 e0       	ldi	r19, 0x00	; 0
 73e:	40 e0       	ldi	r20, 0x00	; 0
 740:	50 e0       	ldi	r21, 0x00	; 0
	}

	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
 742:	c7 01       	movw	r24, r14
 744:	b6 01       	movw	r22, r12
 746:	e9 e0       	ldi	r30, 0x09	; 9
 748:	96 95       	lsr	r25
 74a:	87 95       	ror	r24
 74c:	77 95       	ror	r23
 74e:	67 95       	ror	r22
 750:	ea 95       	dec	r30
 752:	01 f4       	brne	.+0      	; 0x754 <fileRead+0xc4>
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 754:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 758:	29 87       	std	Y+9, r18	; 0x09
 75a:	3a 87       	std	Y+10, r19	; 0x0a
 75c:	4b 87       	std	Y+11, r20	; 0x0b
 75e:	5c 87       	std	Y+12, r21	; 0x0c
 760:	6d 87       	std	Y+13, r22	; 0x0d
 762:	7e 87       	std	Y+14, r23	; 0x0e
 764:	8f 87       	std	Y+15, r24	; 0x0f
 766:	98 8b       	std	Y+16, r25	; 0x10
 768:	fe 01       	movw	r30, r28
 76a:	39 96       	adiw	r30, 0x09	; 9
 76c:	de 01       	movw	r26, r28
 76e:	11 96       	adiw	r26, 0x01	; 1
 770:	88 e0       	ldi	r24, 0x08	; 8
 772:	01 90       	ld	r0, Z+
 774:	0d 92       	st	X+, r0
 776:	8a 95       	dec	r24
 778:	01 f4       	brne	.+0      	; 0x77a <fileRead+0xea>
		CLUSTER_COUNT currentCluster = div.quot;
 77a:	29 81       	ldd	r18, Y+1	; 0x01
 77c:	3a 81       	ldd	r19, Y+2	; 0x02
 77e:	4b 81       	ldd	r20, Y+3	; 0x03
 780:	5c 81       	ldd	r21, Y+4	; 0x04
		SECTOR        sectorInCluster  = div.rem;
 782:	8d 80       	ldd	r8, Y+5	; 0x05
 784:	9e 80       	ldd	r9, Y+6	; 0x06
 786:	af 80       	ldd	r10, Y+7	; 0x07
 788:	b8 84       	ldd	r11, Y+8	; 0x08


		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
 78a:	89 89       	ldd	r24, Y+17	; 0x11
 78c:	9a 89       	ldd	r25, Y+18	; 0x12
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
 78e:	41 2c       	mov	r4, r1
 790:	f2 e0       	ldi	r31, 0x02	; 2
 792:	5f 2e       	mov	r5, r31
		SECTOR        sectorInCluster  = div.rem;


		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
 794:	89 2b       	or	r24, r25
 796:	01 f4       	brne	.+0      	; 0x798 <fileRead+0x108>
 798:	61 14       	cp	r6, r1
 79a:	92 e0       	ldi	r25, 0x02	; 2
 79c:	79 06       	cpc	r7, r25
 79e:	00 f4       	brcc	.+0      	; 0x7a0 <fileRead+0x110>
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
 7a0:	e9 89       	ldd	r30, Y+17	; 0x11
 7a2:	fa 89       	ldd	r31, Y+18	; 0x12
 7a4:	4e 1a       	sub	r4, r30
 7a6:	5f 0a       	sbc	r5, r31
 7a8:	64 14       	cp	r6, r4
 7aa:	75 04       	cpc	r7, r5
 7ac:	00 f4       	brcc	.+0      	; 0x7ae <fileRead+0x11e>
 7ae:	23 01       	movw	r4, r6
		}else{
			bytesToRead = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 7b0:	6f 89       	ldd	r22, Y+23	; 0x17
 7b2:	78 8d       	ldd	r23, Y+24	; 0x18
 7b4:	8b 89       	ldd	r24, Y+19	; 0x13
 7b6:	9c 89       	ldd	r25, Y+20	; 0x14
 7b8:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 7bc:	81 11       	cpse	r24, r1
 7be:	00 c0       	rjmp	.+0      	; 0x7c0 <fileRead+0x130>
 7c0:	00 c0       	rjmp	.+0      	; 0x7c2 <fileRead+0x132>
			return(0);													// Cluster out of bounds
		}

		// Calc the sector# in the partition
		SECTOR readSector=_diskClusterToSector(file->disk,file->nav.currentCluster) + sectorInCluster;
 7c2:	f1 01       	movw	r30, r2
 7c4:	44 89       	ldd	r20, Z+20	; 0x14
 7c6:	55 89       	ldd	r21, Z+21	; 0x15
 7c8:	66 89       	ldd	r22, Z+22	; 0x16
 7ca:	77 89       	ldd	r23, Z+23	; 0x17
 7cc:	80 81       	ld	r24, Z
 7ce:	91 81       	ldd	r25, Z+1	; 0x01
 7d0:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 7d4:	ab 01       	movw	r20, r22
 7d6:	bc 01       	movw	r22, r24
 7d8:	48 0d       	add	r20, r8
 7da:	59 1d       	adc	r21, r9
 7dc:	6a 1d       	adc	r22, r10
 7de:	7b 1d       	adc	r23, r11
 7e0:	f1 01       	movw	r30, r2
 7e2:	80 81       	ld	r24, Z
 7e4:	91 81       	ldd	r25, Z+1	; 0x01
 7e6:	ad 88       	ldd	r10, Y+21	; 0x15
 7e8:	be 88       	ldd	r11, Y+22	; 0x16
 7ea:	a0 0e       	add	r10, r16
 7ec:	b1 1e       	adc	r11, r17

		if(bytesToRead==512){
 7ee:	41 14       	cp	r4, r1
 7f0:	f2 e0       	ldi	r31, 0x02	; 2
 7f2:	5f 06       	cpc	r5, r31
 7f4:	01 f4       	brne	.+0      	; 0x7f6 <fileRead+0x166>
			// Read it via the buffers or directly to user RAM
			_partitionDirectSectorRead(file->disk,readSector,((uint8_t*)buf)+bytes_read);
 7f6:	95 01       	movw	r18, r10
 7f8:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 7fc:	00 c0       	rjmp	.+0      	; 0x7fe <fileRead+0x16e>
		}else{
			// Read it into the buffers
			uint8_t* tbuf = _partitionGetSector(file->disk,readSector,BUFFER_MODE_READONLY);
 7fe:	21 e0       	ldi	r18, 0x01	; 1
 800:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 804:	4c 01       	movw	r8, r24
			// Copy data from buffer into user memory
			memcpy(((uint8_t*)buf)+bytes_read, tbuf+offsetInSector,  bytesToRead);
 806:	89 89       	ldd	r24, Y+17	; 0x11
 808:	9a 89       	ldd	r25, Y+18	; 0x12
 80a:	88 0d       	add	r24, r8
 80c:	99 1d       	adc	r25, r9
 80e:	a2 01       	movw	r20, r4
 810:	bc 01       	movw	r22, r24
 812:	c5 01       	movw	r24, r10
 814:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 818:	b4 01       	movw	r22, r8
 81a:	f1 01       	movw	r30, r2
 81c:	80 81       	ld	r24, Z
 81e:	91 81       	ldd	r25, Z+1	; 0x01
 820:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
			// Release the sector
			partition_releaseSector(file->disk,tbuf);
		}

		currentOffset += bytesToRead;
 824:	c4 0c       	add	r12, r4
 826:	d5 1c       	adc	r13, r5
 828:	e1 1c       	adc	r14, r1
 82a:	f1 1c       	adc	r15, r1
		bytes_read += bytesToRead;
 82c:	04 0d       	add	r16, r4
 82e:	15 1d       	adc	r17, r5
		size_left -= bytesToRead;
 830:	64 18       	sub	r6, r4
 832:	75 08       	sbc	r7, r5
	// Limit reads from going beyond end of file
	if( (offset+size > file->fileSize) && size_left!=0){
		size_left=file->fileSize-offset;
	}

	while(size_left>0){
 834:	61 14       	cp	r6, r1
 836:	71 04       	cpc	r7, r1
 838:	01 f0       	breq	.+0      	; 0x83a <fileRead+0x1aa>
 83a:	00 c0       	rjmp	.+0      	; 0x83c <fileRead+0x1ac>
 83c:	00 c0       	rjmp	.+0      	; 0x83e <fileRead+0x1ae>

	uint32_t currentOffset=offset;		// The current file position

	// Check that the file has been opened
	if(!_fileGetAttr(file,FILE_STATUS_OPEN)){
		return(0);
 83e:	00 e0       	ldi	r16, 0x00	; 0
 840:	10 e0       	ldi	r17, 0x00	; 0
		bytes_read += bytesToRead;
		size_left -= bytesToRead;
	}

	return(bytes_read);
}
 842:	c8 01       	movw	r24, r16
 844:	68 96       	adiw	r28, 0x18	; 24
 846:	0f b6       	in	r0, 0x3f	; 63
 848:	f8 94       	cli
 84a:	de bf       	out	0x3e, r29	; 62
 84c:	0f be       	out	0x3f, r0	; 63
 84e:	cd bf       	out	0x3d, r28	; 61
 850:	df 91       	pop	r29
 852:	cf 91       	pop	r28
 854:	1f 91       	pop	r17
 856:	0f 91       	pop	r16
 858:	ff 90       	pop	r15
 85a:	ef 90       	pop	r14
 85c:	df 90       	pop	r13
 85e:	cf 90       	pop	r12
 860:	bf 90       	pop	r11
 862:	af 90       	pop	r10
 864:	9f 90       	pop	r9
 866:	8f 90       	pop	r8
 868:	7f 90       	pop	r7
 86a:	6f 90       	pop	r6
 86c:	5f 90       	pop	r5
 86e:	4f 90       	pop	r4
 870:	3f 90       	pop	r3
 872:	2f 90       	pop	r2
 874:	08 95       	ret

00000876 <fileReadNext>:

size_t fileReadNext(FATFILE *file,size_t size,void *buf){
 876:	0f 93       	push	r16
 878:	1f 93       	push	r17
 87a:	cf 93       	push	r28
 87c:	df 93       	push	r29
 87e:	ec 01       	movw	r28, r24
 880:	9b 01       	movw	r18, r22
 882:	8a 01       	movw	r16, r20
	size_t r=fileRead(file,file->filePos,size,buf);
 884:	4d a1       	ldd	r20, Y+37	; 0x25
 886:	5e a1       	ldd	r21, Y+38	; 0x26
 888:	6f a1       	ldd	r22, Y+39	; 0x27
 88a:	78 a5       	ldd	r23, Y+40	; 0x28
 88c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	file->filePos+=r;
 890:	4d a1       	ldd	r20, Y+37	; 0x25
 892:	5e a1       	ldd	r21, Y+38	; 0x26
 894:	6f a1       	ldd	r22, Y+39	; 0x27
 896:	78 a5       	ldd	r23, Y+40	; 0x28
 898:	48 0f       	add	r20, r24
 89a:	59 1f       	adc	r21, r25
 89c:	61 1d       	adc	r22, r1
 89e:	71 1d       	adc	r23, r1
 8a0:	4d a3       	std	Y+37, r20	; 0x25
 8a2:	5e a3       	std	Y+38, r21	; 0x26
 8a4:	6f a3       	std	Y+39, r22	; 0x27
 8a6:	78 a7       	std	Y+40, r23	; 0x28
	return(r);
}
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	1f 91       	pop	r17
 8ae:	0f 91       	pop	r16
 8b0:	08 95       	ret

000008b2 <fileWrite>:


// This function writes to a file, at offset 'offset' and size 'size'.
// It also updates the FileSize in the object, and disk directory
// Returns Bytes actually written.
size_t fileWrite(FATFILE* file,uint32_t offset,size_t size,const void* buf){
 8b2:	2f 92       	push	r2
 8b4:	3f 92       	push	r3
 8b6:	4f 92       	push	r4
 8b8:	5f 92       	push	r5
 8ba:	6f 92       	push	r6
 8bc:	7f 92       	push	r7
 8be:	8f 92       	push	r8
 8c0:	9f 92       	push	r9
 8c2:	af 92       	push	r10
 8c4:	bf 92       	push	r11
 8c6:	cf 92       	push	r12
 8c8:	df 92       	push	r13
 8ca:	ef 92       	push	r14
 8cc:	ff 92       	push	r15
 8ce:	0f 93       	push	r16
 8d0:	1f 93       	push	r17
 8d2:	cf 93       	push	r28
 8d4:	df 93       	push	r29
 8d6:	cd b7       	in	r28, 0x3d	; 61
 8d8:	de b7       	in	r29, 0x3e	; 62
 8da:	6c 97       	sbiw	r28, 0x1c	; 28
 8dc:	0f b6       	in	r0, 0x3f	; 63
 8de:	f8 94       	cli
 8e0:	de bf       	out	0x3e, r29	; 62
 8e2:	0f be       	out	0x3f, r0	; 63
 8e4:	cd bf       	out	0x3d, r28	; 61
 8e6:	1c 01       	movw	r2, r24
 8e8:	74 2e       	mov	r7, r20
 8ea:	65 2e       	mov	r6, r21
 8ec:	56 2e       	mov	r5, r22
 8ee:	47 2e       	mov	r4, r23
 8f0:	b2 2e       	mov	r11, r18
 8f2:	a3 2e       	mov	r10, r19
 8f4:	1a 8f       	std	Y+26, r17	; 0x1a
 8f6:	09 8f       	std	Y+25, r16	; 0x19
}

Writer fileGetWriter(const FATFILE* file){
	activeFile = (FATFILE*)file;
	return &writer;
}
 8f8:	dc 01       	movw	r26, r24
 8fa:	94 96       	adiw	r26, 0x24	; 36
 8fc:	8c 91       	ld	r24, X
// Returns Bytes actually written.
size_t fileWrite(FATFILE* file,uint32_t offset,size_t size,const void* buf){
	uint32_t currentOffset=offset;

	// Make sure file is open for write
	if(!_fileGetAttr(file,FILE_STATUS_OPEN) || !_fileGetAttr(file,FILE_STATUS_WRITE)){
 8fe:	80 fd       	sbrc	r24, 0
 900:	00 c0       	rjmp	.+0      	; 0x902 <fileWrite+0x50>
		return(0);
 902:	00 e0       	ldi	r16, 0x00	; 0
 904:	10 e0       	ldi	r17, 0x00	; 0
 906:	00 c0       	rjmp	.+0      	; 0x908 <fileWrite+0x56>
// Returns Bytes actually written.
size_t fileWrite(FATFILE* file,uint32_t offset,size_t size,const void* buf){
	uint32_t currentOffset=offset;

	// Make sure file is open for write
	if(!_fileGetAttr(file,FILE_STATUS_OPEN) || !_fileGetAttr(file,FILE_STATUS_WRITE)){
 908:	81 ff       	sbrs	r24, 1
 90a:	00 c0       	rjmp	.+0      	; 0x90c <fileWrite+0x5a>
		return(0);
	}

	// Put offset into range
	if(offset>file->fileSize){
 90c:	f1 01       	movw	r30, r2
 90e:	41 a5       	ldd	r20, Z+41	; 0x29
 910:	52 a5       	ldd	r21, Z+42	; 0x2a
 912:	63 a5       	ldd	r22, Z+43	; 0x2b
 914:	74 a5       	ldd	r23, Z+44	; 0x2c
 916:	c7 2c       	mov	r12, r7
 918:	d6 2c       	mov	r13, r6
 91a:	e5 2c       	mov	r14, r5
 91c:	f4 2c       	mov	r15, r4
 91e:	4c 15       	cp	r20, r12
 920:	5d 05       	cpc	r21, r13
 922:	6e 05       	cpc	r22, r14
 924:	7f 05       	cpc	r23, r15
 926:	00 f4       	brcc	.+0      	; 0x928 <fileWrite+0x76>
 928:	6a 01       	movw	r12, r20
 92a:	7b 01       	movw	r14, r22
		offset=file->fileSize;
	}

	// Find if need to allocate more clusters to the end of the file
	CLUSTER_COUNT need_cluster = _fileRequiredCluster(file,offset,size);
 92c:	2b 2d       	mov	r18, r11
 92e:	3a 2d       	mov	r19, r10
 930:	b7 01       	movw	r22, r14
 932:	a6 01       	movw	r20, r12
 934:	c1 01       	movw	r24, r2
 936:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 93a:	9b 01       	movw	r18, r22
 93c:	ac 01       	movw	r20, r24
	if(need_cluster){
 93e:	61 15       	cp	r22, r1
 940:	71 05       	cpc	r23, r1
 942:	81 05       	cpc	r24, r1
 944:	91 05       	cpc	r25, r1
 946:	01 f4       	brne	.+0      	; 0x948 <fileWrite+0x96>
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
		}else{
			bytesToWrite = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 948:	bb 8a       	std	Y+19, r11	; 0x13
 94a:	ac 8a       	std	Y+20, r10	; 0x14
 94c:	87 2c       	mov	r8, r7
 94e:	96 2c       	mov	r9, r6
 950:	a5 2c       	mov	r10, r5
 952:	b4 2c       	mov	r11, r4
 954:	00 e0       	ldi	r16, 0x00	; 0
 956:	10 e0       	ldi	r17, 0x00	; 0
 958:	91 01       	movw	r18, r2
 95a:	24 5f       	subi	r18, 0xF4	; 244
 95c:	3f 4f       	sbci	r19, 0xFF	; 255
 95e:	3c 8f       	std	Y+28, r19	; 0x1c
 960:	2b 8f       	std	Y+27, r18	; 0x1b
 962:	00 c0       	rjmp	.+0      	; 0x964 <fileWrite+0xb2>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("\nWrite to file@%lu, extend by %lu clusters\n",currentOffset,need_cluster);
		rprintfInit(old);}
#endif

		if(!_fatExtend(file->disk,&(file->nav),need_cluster)){
 964:	b1 01       	movw	r22, r2
 966:	64 5f       	subi	r22, 0xF4	; 244
 968:	7f 4f       	sbci	r23, 0xFF	; 255
 96a:	d1 01       	movw	r26, r2
 96c:	8d 91       	ld	r24, X+
 96e:	9c 91       	ld	r25, X
 970:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 974:	81 11       	cpse	r24, r1
 976:	00 c0       	rjmp	.+0      	; 0x978 <fileWrite+0xc6>
 978:	00 c0       	rjmp	.+0      	; 0x97a <fileWrite+0xc8>

	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
 97a:	d5 01       	movw	r26, r10
 97c:	c4 01       	movw	r24, r8
 97e:	91 70       	andi	r25, 0x01	; 1
 980:	aa 27       	eor	r26, r26
 982:	bb 27       	eor	r27, r27
 984:	2c 01       	movw	r4, r24
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 986:	f1 01       	movw	r30, r2
 988:	01 90       	ld	r0, Z+
 98a:	f0 81       	ld	r31, Z
 98c:	e0 2d       	mov	r30, r0
 98e:	fa 8b       	std	Y+18, r31	; 0x12
 990:	e9 8b       	std	Y+17, r30	; 0x11
 992:	20 89       	ldd	r18, Z+16	; 0x10
 994:	30 e0       	ldi	r19, 0x00	; 0
 996:	40 e0       	ldi	r20, 0x00	; 0
 998:	50 e0       	ldi	r21, 0x00	; 0
	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
 99a:	c5 01       	movw	r24, r10
 99c:	b4 01       	movw	r22, r8
 99e:	a9 e0       	ldi	r26, 0x09	; 9
 9a0:	96 95       	lsr	r25
 9a2:	87 95       	ror	r24
 9a4:	77 95       	ror	r23
 9a6:	67 95       	ror	r22
 9a8:	aa 95       	dec	r26
 9aa:	01 f4       	brne	.+0      	; 0x9ac <fileWrite+0xfa>
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 9ac:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 9b0:	29 87       	std	Y+9, r18	; 0x09
 9b2:	3a 87       	std	Y+10, r19	; 0x0a
 9b4:	4b 87       	std	Y+11, r20	; 0x0b
 9b6:	5c 87       	std	Y+12, r21	; 0x0c
 9b8:	6d 87       	std	Y+13, r22	; 0x0d
 9ba:	7e 87       	std	Y+14, r23	; 0x0e
 9bc:	8f 87       	std	Y+15, r24	; 0x0f
 9be:	98 8b       	std	Y+16, r25	; 0x10
 9c0:	fe 01       	movw	r30, r28
 9c2:	39 96       	adiw	r30, 0x09	; 9
 9c4:	de 01       	movw	r26, r28
 9c6:	11 96       	adiw	r26, 0x01	; 1
 9c8:	88 e0       	ldi	r24, 0x08	; 8
 9ca:	01 90       	ld	r0, Z+
 9cc:	0d 92       	st	X+, r0
 9ce:	8a 95       	dec	r24
 9d0:	01 f4       	brne	.+0      	; 0x9d2 <fileWrite+0x120>
		CLUSTER_COUNT currentCluster = div.quot;
 9d2:	29 81       	ldd	r18, Y+1	; 0x01
 9d4:	3a 81       	ldd	r19, Y+2	; 0x02
 9d6:	4b 81       	ldd	r20, Y+3	; 0x03
 9d8:	5c 81       	ldd	r21, Y+4	; 0x04
		SECTOR        sectorInCluster  = div.rem;
 9da:	8d 81       	ldd	r24, Y+5	; 0x05
 9dc:	9e 81       	ldd	r25, Y+6	; 0x06
 9de:	af 81       	ldd	r26, Y+7	; 0x07
 9e0:	b8 85       	ldd	r27, Y+8	; 0x08
 9e2:	8d 8b       	std	Y+21, r24	; 0x15
 9e4:	9e 8b       	std	Y+22, r25	; 0x16
 9e6:	af 8b       	std	Y+23, r26	; 0x17
 9e8:	b8 8f       	std	Y+24, r27	; 0x18

		// calc the number of bytes required from the current sector
		size_t bytesToWrite;
		if(offsetInSector!=0 || size_left<512){
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
 9ea:	61 2c       	mov	r6, r1
 9ec:	b2 e0       	ldi	r27, 0x02	; 2
 9ee:	7b 2e       	mov	r7, r27
		CLUSTER_COUNT currentCluster = div.quot;
		SECTOR        sectorInCluster  = div.rem;

		// calc the number of bytes required from the current sector
		size_t bytesToWrite;
		if(offsetInSector!=0 || size_left<512){
 9f0:	41 14       	cp	r4, r1
 9f2:	51 04       	cpc	r5, r1
 9f4:	01 f4       	brne	.+0      	; 0x9f6 <fileWrite+0x144>
 9f6:	ab 89       	ldd	r26, Y+19	; 0x13
 9f8:	bc 89       	ldd	r27, Y+20	; 0x14
 9fa:	a1 15       	cp	r26, r1
 9fc:	b2 40       	sbci	r27, 0x02	; 2
 9fe:	00 f4       	brcc	.+0      	; 0xa00 <fileWrite+0x14e>
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
 a00:	64 18       	sub	r6, r4
 a02:	75 08       	sbc	r7, r5
 a04:	8b 89       	ldd	r24, Y+19	; 0x13
 a06:	9c 89       	ldd	r25, Y+20	; 0x14
 a08:	86 15       	cp	r24, r6
 a0a:	97 05       	cpc	r25, r7
 a0c:	00 f4       	brcc	.+0      	; 0xa0e <fileWrite+0x15c>
 a0e:	3c 01       	movw	r6, r24
		}else{
			bytesToWrite = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 a10:	6b 8d       	ldd	r22, Y+27	; 0x1b
 a12:	7c 8d       	ldd	r23, Y+28	; 0x1c
 a14:	89 89       	ldd	r24, Y+17	; 0x11
 a16:	9a 89       	ldd	r25, Y+18	; 0x12
 a18:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 a1c:	d1 01       	movw	r26, r2
 a1e:	0d 90       	ld	r0, X+
 a20:	bc 91       	ld	r27, X
 a22:	a0 2d       	mov	r26, r0
 a24:	ba 8b       	std	Y+18, r27	; 0x12
 a26:	a9 8b       	std	Y+17, r26	; 0x11
 a28:	81 11       	cpse	r24, r1
 a2a:	00 c0       	rjmp	.+0      	; 0xa2c <fileWrite+0x17a>
			// cluster is out of bounds
			file->fileSize+=bytes_written;
 a2c:	f1 01       	movw	r30, r2
 a2e:	c1 a4       	ldd	r12, Z+41	; 0x29
 a30:	d2 a4       	ldd	r13, Z+42	; 0x2a
 a32:	e3 a4       	ldd	r14, Z+43	; 0x2b
 a34:	f4 a4       	ldd	r15, Z+44	; 0x2c
 a36:	c0 0e       	add	r12, r16
 a38:	d1 1e       	adc	r13, r17
 a3a:	e1 1c       	adc	r14, r1
 a3c:	f1 1c       	adc	r15, r1
 a3e:	c1 a6       	std	Z+41, r12	; 0x29
 a40:	d2 a6       	std	Z+42, r13	; 0x2a
 a42:	e3 a6       	std	Z+43, r14	; 0x2b
 a44:	f4 a6       	std	Z+44, r15	; 0x2c

FATFILE* activeFile;

// Update a disk directory entry with the file size
static void _dirSetFileSize(const DISK *disk, DIR_POSITION *loc,uint32_t numbytes){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 a46:	46 81       	ldd	r20, Z+6	; 0x06
 a48:	57 81       	ldd	r21, Z+7	; 0x07
 a4a:	60 85       	ldd	r22, Z+8	; 0x08
 a4c:	71 85       	ldd	r23, Z+9	; 0x09
 a4e:	22 e0       	ldi	r18, 0x02	; 2
 a50:	89 89       	ldd	r24, Y+17	; 0x11
 a52:	9a 89       	ldd	r25, Y+18	; 0x12
 a54:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	dir[loc->entryInSector].fileSize=numbytes;
 a58:	f1 01       	movw	r30, r2
 a5a:	22 85       	ldd	r18, Z+10	; 0x0a
 a5c:	fc 01       	movw	r30, r24
 a5e:	30 e2       	ldi	r19, 0x20	; 32
 a60:	23 9f       	mul	r18, r19
 a62:	e0 0d       	add	r30, r0
 a64:	f1 1d       	adc	r31, r1
 a66:	11 24       	eor	r1, r1
 a68:	c4 8e       	std	Z+28, r12	; 0x1c
 a6a:	d5 8e       	std	Z+29, r13	; 0x1d
 a6c:	e6 8e       	std	Z+30, r14	; 0x1e
 a6e:	f7 8e       	std	Z+31, r15	; 0x1f
 a70:	bc 01       	movw	r22, r24
 a72:	89 89       	ldd	r24, Y+17	; 0x11
 a74:	9a 89       	ldd	r25, Y+18	; 0x12
 a76:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 a7a:	00 c0       	rjmp	.+0      	; 0xa7c <fileWrite+0x1ca>
			file->fileSize+=bytes_written;
			_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
			return(bytes_written);
		}

		SECTOR writeSector=_diskClusterToSector(file->disk,file->nav.currentCluster) + sectorInCluster;
 a7c:	d1 01       	movw	r26, r2
 a7e:	54 96       	adiw	r26, 0x14	; 20
 a80:	4d 91       	ld	r20, X+
 a82:	5d 91       	ld	r21, X+
 a84:	6d 91       	ld	r22, X+
 a86:	7c 91       	ld	r23, X
 a88:	57 97       	sbiw	r26, 0x17	; 23
 a8a:	89 89       	ldd	r24, Y+17	; 0x11
 a8c:	9a 89       	ldd	r25, Y+18	; 0x12
 a8e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 a92:	ab 01       	movw	r20, r22
 a94:	bc 01       	movw	r22, r24
 a96:	8d 89       	ldd	r24, Y+21	; 0x15
 a98:	9e 89       	ldd	r25, Y+22	; 0x16
 a9a:	af 89       	ldd	r26, Y+23	; 0x17
 a9c:	b8 8d       	ldd	r27, Y+24	; 0x18
 a9e:	48 0f       	add	r20, r24
 aa0:	59 1f       	adc	r21, r25
 aa2:	6a 1f       	adc	r22, r26
 aa4:	7b 1f       	adc	r23, r27
 aa6:	d1 01       	movw	r26, r2
 aa8:	8d 91       	ld	r24, X+
 aaa:	9c 91       	ld	r25, X
 aac:	e9 8d       	ldd	r30, Y+25	; 0x19
 aae:	fa 8d       	ldd	r31, Y+26	; 0x1a
 ab0:	e0 0f       	add	r30, r16
 ab2:	f1 1f       	adc	r31, r17
 ab4:	fa 8b       	std	Y+18, r31	; 0x12
 ab6:	e9 8b       	std	Y+17, r30	; 0x11

		if(bytesToWrite==512){
 ab8:	61 14       	cp	r6, r1
 aba:	f2 e0       	ldi	r31, 0x02	; 2
 abc:	7f 06       	cpc	r7, r31
 abe:	01 f4       	brne	.+0      	; 0xac0 <fileWrite+0x20e>
			// Write directly from user memory to the device
			_partitionDirectSectorWrite(file->disk,writeSector,((const uint8_t*)buf)+bytes_written);
 ac0:	29 89       	ldd	r18, Y+17	; 0x11
 ac2:	3a 89       	ldd	r19, Y+18	; 0x12
 ac4:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 ac8:	00 c0       	rjmp	.+0      	; 0xaca <fileWrite+0x218>
		}else{
			// read the sector into the buffer for read/write
			uint8_t* tbuf = _partitionGetSector(file->disk,writeSector,BUFFER_MODE_READWRITE);
 aca:	22 e0       	ldi	r18, 0x02	; 2
 acc:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 ad0:	9e 8b       	std	Y+22, r25	; 0x16
 ad2:	8d 8b       	std	Y+21, r24	; 0x15
			// copy the user memory into the buffer
			memcpy(tbuf+offsetInSector,((const uint8_t*)buf)+bytes_written,bytesToWrite);
 ad4:	9c 01       	movw	r18, r24
 ad6:	24 0d       	add	r18, r4
 ad8:	35 1d       	adc	r19, r5
 ada:	a3 01       	movw	r20, r6
 adc:	69 89       	ldd	r22, Y+17	; 0x11
 ade:	7a 89       	ldd	r23, Y+18	; 0x12
 ae0:	c9 01       	movw	r24, r18
 ae2:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 ae6:	6d 89       	ldd	r22, Y+21	; 0x15
 ae8:	7e 89       	ldd	r23, Y+22	; 0x16
 aea:	d1 01       	movw	r26, r2
 aec:	8d 91       	ld	r24, X+
 aee:	9c 91       	ld	r25, X
 af0:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
			// release the sector
			partition_releaseSector(file->disk,tbuf);
		}

		currentOffset += bytesToWrite;
 af4:	86 0c       	add	r8, r6
 af6:	97 1c       	adc	r9, r7
 af8:	a1 1c       	adc	r10, r1
 afa:	b1 1c       	adc	r11, r1
		bytes_written += bytesToWrite;
 afc:	06 0d       	add	r16, r6
 afe:	17 1d       	adc	r17, r7
		size_left -= bytesToWrite;
 b00:	eb 89       	ldd	r30, Y+19	; 0x13
 b02:	fc 89       	ldd	r31, Y+20	; 0x14
 b04:	e6 19       	sub	r30, r6
 b06:	f7 09       	sbc	r31, r7
 b08:	fc 8b       	std	Y+20, r31	; 0x14
 b0a:	eb 8b       	std	Y+19, r30	; 0x13
		}
	}

	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){
 b0c:	2b 89       	ldd	r18, Y+19	; 0x13
 b0e:	3c 89       	ldd	r19, Y+20	; 0x14
 b10:	23 2b       	or	r18, r19
 b12:	01 f0       	breq	.+0      	; 0xb14 <fileWrite+0x262>
 b14:	00 c0       	rjmp	.+0      	; 0xb16 <fileWrite+0x264>
		bytes_written += bytesToWrite;
		size_left -= bytesToWrite;
	}

	// Update the file size
	if(bytes_written > file->fileSize - offset){
 b16:	48 01       	movw	r8, r16
 b18:	a1 2c       	mov	r10, r1
 b1a:	b1 2c       	mov	r11, r1
 b1c:	d1 01       	movw	r26, r2
 b1e:	99 96       	adiw	r26, 0x29	; 41
 b20:	4d 91       	ld	r20, X+
 b22:	5d 91       	ld	r21, X+
 b24:	6d 91       	ld	r22, X+
 b26:	7c 91       	ld	r23, X
 b28:	9c 97       	sbiw	r26, 0x2c	; 44
 b2a:	4c 19       	sub	r20, r12
 b2c:	5d 09       	sbc	r21, r13
 b2e:	6e 09       	sbc	r22, r14
 b30:	7f 09       	sbc	r23, r15
 b32:	48 15       	cp	r20, r8
 b34:	59 05       	cpc	r21, r9
 b36:	6a 05       	cpc	r22, r10
 b38:	7b 05       	cpc	r23, r11
 b3a:	00 f4       	brcc	.+0      	; 0xb3c <fileWrite+0x28a>
		file->fileSize += bytes_written - (file->fileSize-offset);
 b3c:	c8 0c       	add	r12, r8
 b3e:	d9 1c       	adc	r13, r9
 b40:	ea 1c       	adc	r14, r10
 b42:	fb 1c       	adc	r15, r11
 b44:	f1 01       	movw	r30, r2
 b46:	c1 a6       	std	Z+41, r12	; 0x29
 b48:	d2 a6       	std	Z+42, r13	; 0x2a
 b4a:	e3 a6       	std	Z+43, r14	; 0x2b
 b4c:	f4 a6       	std	Z+44, r15	; 0x2c
   }

	return(bytes_written);
}
 b4e:	c8 01       	movw	r24, r16
 b50:	6c 96       	adiw	r28, 0x1c	; 28
 b52:	0f b6       	in	r0, 0x3f	; 63
 b54:	f8 94       	cli
 b56:	de bf       	out	0x3e, r29	; 62
 b58:	0f be       	out	0x3f, r0	; 63
 b5a:	cd bf       	out	0x3d, r28	; 61
 b5c:	df 91       	pop	r29
 b5e:	cf 91       	pop	r28
 b60:	1f 91       	pop	r17
 b62:	0f 91       	pop	r16
 b64:	ff 90       	pop	r15
 b66:	ef 90       	pop	r14
 b68:	df 90       	pop	r13
 b6a:	cf 90       	pop	r12
 b6c:	bf 90       	pop	r11
 b6e:	af 90       	pop	r10
 b70:	9f 90       	pop	r9
 b72:	8f 90       	pop	r8
 b74:	7f 90       	pop	r7
 b76:	6f 90       	pop	r6
 b78:	5f 90       	pop	r5
 b7a:	4f 90       	pop	r4
 b7c:	3f 90       	pop	r3
 b7e:	2f 90       	pop	r2
 b80:	08 95       	ret

00000b82 <fileWriteNext>:
size_t fileWriteNext(FATFILE *file, size_t size,const void *buf){
 b82:	0f 93       	push	r16
 b84:	1f 93       	push	r17
 b86:	cf 93       	push	r28
 b88:	df 93       	push	r29
 b8a:	ec 01       	movw	r28, r24
 b8c:	9b 01       	movw	r18, r22
 b8e:	8a 01       	movw	r16, r20
	size_t r=fileWrite(file,file->filePos,size,buf);
 b90:	4d a1       	ldd	r20, Y+37	; 0x25
 b92:	5e a1       	ldd	r21, Y+38	; 0x26
 b94:	6f a1       	ldd	r22, Y+39	; 0x27
 b96:	78 a5       	ldd	r23, Y+40	; 0x28
 b98:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	file->filePos+=r;
 b9c:	4d a1       	ldd	r20, Y+37	; 0x25
 b9e:	5e a1       	ldd	r21, Y+38	; 0x26
 ba0:	6f a1       	ldd	r22, Y+39	; 0x27
 ba2:	78 a5       	ldd	r23, Y+40	; 0x28
 ba4:	48 0f       	add	r20, r24
 ba6:	59 1f       	adc	r21, r25
 ba8:	61 1d       	adc	r22, r1
 baa:	71 1d       	adc	r23, r1
 bac:	4d a3       	std	Y+37, r20	; 0x25
 bae:	5e a3       	std	Y+38, r21	; 0x26
 bb0:	6f a3       	std	Y+39, r22	; 0x27
 bb2:	78 a7       	std	Y+40, r23	; 0x28
	return(r);
}
 bb4:	df 91       	pop	r29
 bb6:	cf 91       	pop	r28
 bb8:	1f 91       	pop	r17
 bba:	0f 91       	pop	r16
 bbc:	08 95       	ret

00000bbe <writer>:

static MAKE_WRITER(writer){
 bbe:	cf 93       	push	r28
 bc0:	df 93       	push	r29
 bc2:	1f 92       	push	r1
 bc4:	cd b7       	in	r28, 0x3d	; 61
 bc6:	de b7       	in	r29, 0x3e	; 62
 bc8:	89 83       	std	Y+1, r24	; 0x01
	if(activeFile){
 bca:	80 91 00 00 	lds	r24, 0x0000
 bce:	90 91 00 00 	lds	r25, 0x0000
 bd2:	00 97       	sbiw	r24, 0x00	; 0
 bd4:	01 f0       	breq	.+0      	; 0xbd6 <writer+0x18>
		fileWriteNext(activeFile,1,&byte);
 bd6:	ae 01       	movw	r20, r28
 bd8:	4f 5f       	subi	r20, 0xFF	; 255
 bda:	5f 4f       	sbci	r21, 0xFF	; 255
 bdc:	61 e0       	ldi	r22, 0x01	; 1
 bde:	70 e0       	ldi	r23, 0x00	; 0
 be0:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	}
	return byte;
}
 be4:	89 81       	ldd	r24, Y+1	; 0x01
 be6:	0f 90       	pop	r0
 be8:	df 91       	pop	r29
 bea:	cf 91       	pop	r28
 bec:	08 95       	ret

00000bee <fileGetWriter>:

Writer fileGetWriter(const FATFILE* file){
	activeFile = (FATFILE*)file;
 bee:	90 93 00 00 	sts	0x0000, r25
 bf2:	80 93 00 00 	sts	0x0000, r24
	return &writer;
}
 bf6:	80 e0       	ldi	r24, 0x00	; 0
 bf8:	90 e0       	ldi	r25, 0x00	; 0
 bfa:	08 95       	ret

FATlist.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000246  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000027a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000027a  2**0
                  ALLOC
  3 .debug_info   00000ae1  00000000  00000000  0000027a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000002b6  00000000  00000000  00000d5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000003ed  00000000  00000000  00001011  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000013fe  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  0000141e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000134  00000000  00000000  0000144e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000063c  00000000  00000000  00001582  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001bbe  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000088  00000000  00000000  00001be8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_fileEntryToDirListEntry>:
 */
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
	buf+=offset;
   0:	25 e0       	ldi	r18, 0x05	; 5
   2:	44 0f       	add	r20, r20
   4:	55 1f       	adc	r21, r21
   6:	2a 95       	dec	r18
   8:	01 f4       	brne	.+0      	; 0xa <_fileEntryToDirListEntry+0xa>
   a:	64 0f       	add	r22, r20
   c:	75 1f       	adc	r23, r21
   e:	fb 01       	movw	r30, r22
	uint8_t srcpos = 0;
	uint8_t dstpos = 0;
  10:	20 e0       	ldi	r18, 0x00	; 0
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
	buf+=offset;
	uint8_t srcpos = 0;
  12:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t dstpos = 0;

	while(srcpos < 8){
		char c = buf->filename[srcpos];
  14:	41 91       	ld	r20, Z+
		if(c != ' ' && c != '\0'){
  16:	40 32       	cpi	r20, 0x20	; 32
  18:	01 f0       	breq	.+0      	; 0x1a <_fileEntryToDirListEntry+0x1a>
  1a:	44 23       	and	r20, r20
  1c:	01 f0       	breq	.+0      	; 0x1e <_fileEntryToDirListEntry+0x1e>
			dlist->filename[dstpos++] = c;
  1e:	dc 01       	movw	r26, r24
  20:	a2 0f       	add	r26, r18
  22:	b1 1d       	adc	r27, r1
  24:	4c 93       	st	X, r20
  26:	2f 5f       	subi	r18, 0xFF	; 255
		}
		srcpos++;
  28:	3f 5f       	subi	r19, 0xFF	; 255
static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
	buf+=offset;
	uint8_t srcpos = 0;
	uint8_t dstpos = 0;

	while(srcpos < 8){
  2a:	38 30       	cpi	r19, 0x08	; 8
  2c:	01 f4       	brne	.+0      	; 0x2e <_fileEntryToDirListEntry+0x2e>
		if(c != ' ' && c != '\0'){
			dlist->filename[dstpos++] = c;
		}
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';
  2e:	42 2f       	mov	r20, r18
  30:	4f 5f       	subi	r20, 0xFF	; 255
  32:	fc 01       	movw	r30, r24
  34:	e2 0f       	add	r30, r18
  36:	f1 1d       	adc	r31, r1
  38:	2e e2       	ldi	r18, 0x2E	; 46
  3a:	20 83       	st	Z, r18
  3c:	20 e0       	ldi	r18, 0x00	; 0
  3e:	30 e0       	ldi	r19, 0x00	; 0
 *      Author: Clive Webster
 */
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
  40:	fb 01       	movw	r30, r22
  42:	e2 0f       	add	r30, r18
  44:	f3 1f       	adc	r31, r19
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';

	while(srcpos < 8+3){
		char c = buf->filename[srcpos];
  46:	50 85       	ldd	r21, Z+8	; 0x08
		if(c != ' ' && c != '\0'){
  48:	50 32       	cpi	r21, 0x20	; 32
  4a:	01 f0       	breq	.+0      	; 0x4c <_fileEntryToDirListEntry+0x4c>
  4c:	55 23       	and	r21, r21
  4e:	01 f0       	breq	.+0      	; 0x50 <_fileEntryToDirListEntry+0x50>
			dlist->filename[dstpos++] = c;
  50:	fc 01       	movw	r30, r24
  52:	e4 0f       	add	r30, r20
  54:	f1 1d       	adc	r31, r1
  56:	50 83       	st	Z, r21
  58:	4f 5f       	subi	r20, 0xFF	; 255
  5a:	2f 5f       	subi	r18, 0xFF	; 255
  5c:	3f 4f       	sbci	r19, 0xFF	; 255
		}
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';

	while(srcpos < 8+3){
  5e:	23 30       	cpi	r18, 0x03	; 3
  60:	31 05       	cpc	r19, r1
  62:	01 f4       	brne	.+0      	; 0x64 <_fileEntryToDirListEntry+0x64>
			dlist->filename[dstpos++] = c;
		}
		srcpos++;
	}

	if(dlist->filename[dstpos-1] == '.'){
  64:	fc 01       	movw	r30, r24
  66:	e4 0f       	add	r30, r20
  68:	f1 1d       	adc	r31, r1
  6a:	31 97       	sbiw	r30, 0x01	; 1
  6c:	20 81       	ld	r18, Z
  6e:	2e 32       	cpi	r18, 0x2E	; 46
  70:	01 f4       	brne	.+0      	; 0x72 <_fileEntryToDirListEntry+0x72>
		dstpos--;
  72:	41 50       	subi	r20, 0x01	; 1
	}
	dlist->filename[dstpos] = '\0';
  74:	fc 01       	movw	r30, r24
  76:	e4 0f       	add	r30, r20
  78:	f1 1d       	adc	r31, r1
  7a:	10 82       	st	Z, r1

	dlist->attribute = buf->attribute;
  7c:	fb 01       	movw	r30, r22
  7e:	23 85       	ldd	r18, Z+11	; 0x0b
  80:	fc 01       	movw	r30, r24
  82:	21 8b       	std	Z+17, r18	; 0x11
	dlist->fileSize = buf->fileSize;
  84:	fb 01       	movw	r30, r22
  86:	44 8d       	ldd	r20, Z+28	; 0x1c
  88:	55 8d       	ldd	r21, Z+29	; 0x1d
  8a:	66 8d       	ldd	r22, Z+30	; 0x1e
  8c:	77 8d       	ldd	r23, Z+31	; 0x1f
  8e:	fc 01       	movw	r30, r24
  90:	45 87       	std	Z+13, r20	; 0x0d
  92:	56 87       	std	Z+14, r21	; 0x0e
  94:	67 87       	std	Z+15, r22	; 0x0f
  96:	70 8b       	std	Z+16, r23	; 0x10
  98:	08 95       	ret

0000009a <fileFindNext>:
 	return TRUE;
}


// Get the next directory entry
boolean fileFindNext(FILE_ITERATOR *dlist){
  9a:	cf 92       	push	r12
  9c:	df 92       	push	r13
  9e:	ef 92       	push	r14
  a0:	ff 92       	push	r15
  a2:	0f 93       	push	r16
  a4:	1f 93       	push	r17
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
	if(dlist->nav.startCluster<=1){
		return(FALSE);
	}

	CLUSTER_COUNT clusterInDir = (dlist->dirEntry)/(16 * dlist->disk->volume.sectorsPerCluster);
	if(_fatNavigateTo(dlist->disk,
  ac:	8c 01       	movw	r16, r24
  ae:	0a 5e       	subi	r16, 0xEA	; 234
  b0:	1f 4f       	sbci	r17, 0xFF	; 255

	return(TRUE);
}

static boolean _getDirEntry(FILE_ITERATOR *dlist){
	if(dlist->nav.startCluster == 1){
  b2:	4a a1       	ldd	r20, Y+34	; 0x22
  b4:	5b a1       	ldd	r21, Y+35	; 0x23
  b6:	6c a1       	ldd	r22, Y+36	; 0x24
  b8:	7d a1       	ldd	r23, Y+37	; 0x25
  ba:	41 30       	cpi	r20, 0x01	; 1
  bc:	51 05       	cpc	r21, r1
  be:	61 05       	cpc	r22, r1
  c0:	71 05       	cpc	r23, r1
  c2:	01 f4       	brne	.+0      	; 0xc4 <fileFindNext+0x2a>
	dlist->attribute = buf->attribute;
	dlist->fileSize = buf->fileSize;
}

static boolean _getRootAreaEntry(FILE_ITERATOR *dlist){
	if((dlist->disk->fatType != 12) && (dlist->disk->fatType != 16)){
  c4:	ea 89       	ldd	r30, Y+18	; 0x12
  c6:	fb 89       	ldd	r31, Y+19	; 0x13
  c8:	86 a1       	ldd	r24, Z+38	; 0x26
  ca:	8c 30       	cpi	r24, 0x0C	; 12
  cc:	01 f0       	breq	.+0      	; 0xce <fileFindNext+0x34>
  ce:	80 31       	cpi	r24, 0x10	; 16
  d0:	01 f4       	brne	.+0      	; 0xd2 <fileFindNext+0x38>
		return(FALSE);
	}
	if(dlist->dirEntry>=dlist->disk->volume.rootDirEntryCount){
  d2:	8c 89       	ldd	r24, Y+20	; 0x14
  d4:	9d 89       	ldd	r25, Y+21	; 0x15
  d6:	24 89       	ldd	r18, Z+20	; 0x14
  d8:	35 89       	ldd	r19, Z+21	; 0x15
  da:	82 17       	cp	r24, r18
  dc:	93 07       	cpc	r25, r19
  de:	00 f4       	brcc	.+0      	; 0xe0 <fileFindNext+0x46>
		return(FALSE);
	}

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,
					   dlist->disk->firstSectorRootDir+dlist->dirEntry/16,
  e0:	44 e0       	ldi	r20, 0x04	; 4
  e2:	96 95       	lsr	r25
  e4:	87 95       	ror	r24
  e6:	4a 95       	dec	r20
  e8:	01 f4       	brne	.+0      	; 0xea <fileFindNext+0x50>
	}
	if(dlist->dirEntry>=dlist->disk->volume.rootDirEntryCount){
		return(FALSE);
	}

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,
  ea:	47 a1       	ldd	r20, Z+39	; 0x27
  ec:	50 a5       	ldd	r21, Z+40	; 0x28
  ee:	61 a5       	ldd	r22, Z+41	; 0x29
  f0:	72 a5       	ldd	r23, Z+42	; 0x2a
  f2:	48 0f       	add	r20, r24
  f4:	59 1f       	adc	r21, r25
  f6:	61 1d       	adc	r22, r1
  f8:	71 1d       	adc	r23, r1
  fa:	21 e0       	ldi	r18, 0x01	; 1
  fc:	00 c0       	rjmp	.+0      	; 0xfe <fileFindNext+0x64>
}

static boolean _getDirEntry(FILE_ITERATOR *dlist){
	if(dlist->nav.startCluster == 1){
		return(_getRootAreaEntry(dlist));
	}else if(dlist->nav.startCluster){
  fe:	41 15       	cp	r20, r1
 100:	51 05       	cpc	r21, r1
 102:	61 05       	cpc	r22, r1
 104:	71 05       	cpc	r23, r1
 106:	01 f4       	brne	.+0      	; 0x108 <fileFindNext+0x6e>

// Get the next directory entry
boolean fileFindNext(FILE_ITERATOR *dlist){
	do{
		if(!_getDirEntry(dlist)){
			return FALSE;
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	00 c0       	rjmp	.+0      	; 0x10c <fileFindNext+0x72>
}


static boolean _getRealDirEntry(FILE_ITERATOR *dlist){

	if(dlist->nav.startCluster<=1){
 10c:	42 30       	cpi	r20, 0x02	; 2
 10e:	51 05       	cpc	r21, r1
 110:	61 05       	cpc	r22, r1
 112:	71 05       	cpc	r23, r1
 114:	00 f0       	brcs	.+0      	; 0x116 <fileFindNext+0x7c>
		return(FALSE);
	}

	CLUSTER_COUNT clusterInDir = (dlist->dirEntry)/(16 * dlist->disk->volume.sectorsPerCluster);
 116:	ea 89       	ldd	r30, Y+18	; 0x12
 118:	fb 89       	ldd	r31, Y+19	; 0x13
 11a:	60 89       	ldd	r22, Z+16	; 0x10
 11c:	80 e1       	ldi	r24, 0x10	; 16
 11e:	68 9f       	mul	r22, r24
 120:	b0 01       	movw	r22, r0
 122:	11 24       	eor	r1, r1
 124:	8c 89       	ldd	r24, Y+20	; 0x14
 126:	9d 89       	ldd	r25, Y+21	; 0x15
 128:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 12c:	9b 01       	movw	r18, r22
 12e:	40 e0       	ldi	r20, 0x00	; 0
 130:	50 e0       	ldi	r21, 0x00	; 0
	if(_fatNavigateTo(dlist->disk,
 132:	b8 01       	movw	r22, r16
 134:	cf 01       	movw	r24, r30
 136:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 13a:	88 23       	and	r24, r24
 13c:	01 f0       	breq	.+0      	; 0x13e <fileFindNext+0xa4>
						   &(dlist->nav),
						   clusterInDir)==FALSE){
		return(FALSE);
	}

	SECTOR sector = _diskClusterToSector(dlist->disk,dlist->nav.currentCluster) +
 13e:	4e 8d       	ldd	r20, Y+30	; 0x1e
 140:	5f 8d       	ldd	r21, Y+31	; 0x1f
 142:	68 a1       	ldd	r22, Y+32	; 0x20
 144:	79 a1       	ldd	r23, Y+33	; 0x21
 146:	8a 89       	ldd	r24, Y+18	; 0x12
 148:	9b 89       	ldd	r25, Y+19	; 0x13
 14a:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 14e:	6b 01       	movw	r12, r22
 150:	7c 01       	movw	r14, r24
					(dlist->dirEntry/16)%dlist->disk->volume.sectorsPerCluster;
 152:	ea 89       	ldd	r30, Y+18	; 0x12
 154:	fb 89       	ldd	r31, Y+19	; 0x13
 156:	8c 89       	ldd	r24, Y+20	; 0x14
 158:	9d 89       	ldd	r25, Y+21	; 0x15
 15a:	34 e0       	ldi	r19, 0x04	; 4
 15c:	96 95       	lsr	r25
 15e:	87 95       	ror	r24
 160:	3a 95       	dec	r19
 162:	01 f4       	brne	.+0      	; 0x164 <fileFindNext+0xca>
 164:	60 89       	ldd	r22, Z+16	; 0x10
 166:	70 e0       	ldi	r23, 0x00	; 0
 168:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
						   &(dlist->nav),
						   clusterInDir)==FALSE){
		return(FALSE);
	}

	SECTOR sector = _diskClusterToSector(dlist->disk,dlist->nav.currentCluster) +
 16c:	c8 0e       	add	r12, r24
 16e:	d9 1e       	adc	r13, r25
 170:	e1 1c       	adc	r14, r1
 172:	f1 1c       	adc	r15, r1
					(dlist->dirEntry/16)%dlist->disk->volume.sectorsPerCluster;

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,sector,BUFFER_MODE_READONLY);
 174:	21 e0       	ldi	r18, 0x01	; 1
 176:	b7 01       	movw	r22, r14
 178:	a6 01       	movw	r20, r12
 17a:	cf 01       	movw	r24, r30
 17c:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 180:	7c 01       	movw	r14, r24
	_fileEntryToDirListEntry(dlist,buf,(dlist->dirEntry%16));
 182:	4c 89       	ldd	r20, Y+20	; 0x14
 184:	5d 89       	ldd	r21, Y+21	; 0x15
 186:	4f 70       	andi	r20, 0x0F	; 15
 188:	55 27       	eor	r21, r21
 18a:	bc 01       	movw	r22, r24
 18c:	ce 01       	movw	r24, r28
 18e:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
 192:	b7 01       	movw	r22, r14
 194:	8a 89       	ldd	r24, Y+18	; 0x12
 196:	9b 89       	ldd	r25, Y+19	; 0x13
 198:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
boolean fileFindNext(FILE_ITERATOR *dlist){
	do{
		if(!_getDirEntry(dlist)){
			return FALSE;
		}
		dlist->dirEntry++;
 19c:	8c 89       	ldd	r24, Y+20	; 0x14
 19e:	9d 89       	ldd	r25, Y+21	; 0x15
 1a0:	01 96       	adiw	r24, 0x01	; 1
 1a2:	9d 8b       	std	Y+21, r25	; 0x15
 1a4:	8c 8b       	std	Y+20, r24	; 0x14
	}
	return(FALSE);
}

static boolean _isValidFileEntry(FILE_ITERATOR *entry){
	if(entry->filename[0] == 0 || entry->filename[0] == 0xE5 || entry->filename[0] == '.'){
 1a6:	88 81       	ld	r24, Y
 1a8:	88 23       	and	r24, r24
 1aa:	01 f4       	brne	.+0      	; 0x1ac <fileFindNext+0x112>
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <fileFindNext+0x114>
 1ae:	85 3e       	cpi	r24, 0xE5	; 229
 1b0:	01 f4       	brne	.+0      	; 0x1b2 <fileFindNext+0x118>
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <fileFindNext+0x11a>
 1b4:	8e 32       	cpi	r24, 0x2E	; 46
 1b6:	01 f4       	brne	.+0      	; 0x1b8 <fileFindNext+0x11e>
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <fileFindNext+0x120>
		return FALSE;
	}
	if((entry->attribute.bits & 0x0F)==0x0F){
 1ba:	89 89       	ldd	r24, Y+17	; 0x11
 1bc:	8f 70       	andi	r24, 0x0F	; 15
 1be:	8f 30       	cpi	r24, 0x0F	; 15
 1c0:	01 f4       	brne	.+0      	; 0x1c2 <fileFindNext+0x128>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <fileFindNext+0x12a>
		}
		dlist->dirEntry++;

	}while(!_isValidFileEntry(dlist));

	return TRUE;
 1c4:	8f ef       	ldi	r24, 0xFF	; 255
}
 1c6:	df 91       	pop	r29
 1c8:	cf 91       	pop	r28
 1ca:	1f 91       	pop	r17
 1cc:	0f 91       	pop	r16
 1ce:	ff 90       	pop	r15
 1d0:	ef 90       	pop	r14
 1d2:	df 90       	pop	r13
 1d4:	cf 90       	pop	r12
 1d6:	08 95       	ret

000001d8 <fileFindFirst>:

// Open a directory
// This will fill in the FILE_ITERATOR
// Returns: FALSE if it cannot find the directory
// else use ls_getNext to iterate through each file name in the directory
boolean fileFindFirst(const DISK* disk,FILE_ITERATOR *dlist,const char* dirname){
 1d8:	0f 93       	push	r16
 1da:	1f 93       	push	r17
 1dc:	cf 93       	push	r28
 1de:	df 93       	push	r29
 1e0:	cd b7       	in	r28, 0x3d	; 61
 1e2:	de b7       	in	r29, 0x3e	; 62
 1e4:	2a 97       	sbiw	r28, 0x0a	; 10
 1e6:	0f b6       	in	r0, 0x3f	; 63
 1e8:	f8 94       	cli
 1ea:	de bf       	out	0x3e, r29	; 62
 1ec:	0f be       	out	0x3f, r0	; 63
 1ee:	cd bf       	out	0x3d, r28	; 61
 1f0:	8b 01       	movw	r16, r22
 1f2:	ba 01       	movw	r22, r20
	DIR_POSITION loc;
	CLUSTER directoryCluster;

	dlist->disk=disk;
 1f4:	f8 01       	movw	r30, r16
 1f6:	93 8b       	std	Z+19, r25	; 0x13
 1f8:	82 8b       	std	Z+18, r24	; 0x12

	if(_fileFindFile(disk,dirname,&loc,&directoryCluster)!=2){
 1fa:	9e 01       	movw	r18, r28
 1fc:	29 5f       	subi	r18, 0xF9	; 249
 1fe:	3f 4f       	sbci	r19, 0xFF	; 255
 200:	ae 01       	movw	r20, r28
 202:	4f 5f       	subi	r20, 0xFF	; 255
 204:	5f 4f       	sbci	r21, 0xFF	; 255
 206:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 20a:	82 30       	cpi	r24, 0x02	; 2
 20c:	01 f4       	brne	.+0      	; 0x20e <fileFindFirst+0x36>
		// Cant find directory
		return FALSE;
	}


	_navInitClusterChain(&(dlist->nav),directoryCluster);
 20e:	4f 81       	ldd	r20, Y+7	; 0x07
 210:	58 85       	ldd	r21, Y+8	; 0x08
 212:	69 85       	ldd	r22, Y+9	; 0x09
 214:	7a 85       	ldd	r23, Y+10	; 0x0a
 216:	c8 01       	movw	r24, r16
 218:	46 96       	adiw	r24, 0x16	; 22
 21a:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>

	dlist->filename[0] = '\0';
 21e:	f8 01       	movw	r30, r16
 220:	10 82       	st	Z, r1
	dlist->dirEntry=0;
 222:	15 8a       	std	Z+21, r1	; 0x15
 224:	14 8a       	std	Z+20, r1	; 0x14

	return fileFindNext(dlist);
 226:	c8 01       	movw	r24, r16
 228:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <fileFindFirst+0x56>

	dlist->disk=disk;

	if(_fileFindFile(disk,dirname,&loc,&directoryCluster)!=2){
		// Cant find directory
		return FALSE;
 22e:	80 e0       	ldi	r24, 0x00	; 0

	dlist->filename[0] = '\0';
	dlist->dirEntry=0;

	return fileFindNext(dlist);
}
 230:	2a 96       	adiw	r28, 0x0a	; 10
 232:	0f b6       	in	r0, 0x3f	; 63
 234:	f8 94       	cli
 236:	de bf       	out	0x3e, r29	; 62
 238:	0f be       	out	0x3f, r0	; 63
 23a:	cd bf       	out	0x3d, r28	; 61
 23c:	df 91       	pop	r29
 23e:	cf 91       	pop	r28
 240:	1f 91       	pop	r17
 242:	0f 91       	pop	r16
 244:	08 95       	ret

FATmkdir.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001f6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000022a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000022a  2**0
                  ALLOC
  3 .rodata.str1.1 00000018  00000000  00000000  0000022a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000a21  00000000  00000000  00000242  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000020a  00000000  00000000  00000c63  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000025b  00000000  00000000  00000e6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000010c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000109  00000000  00000000  000010e8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000005a3  00000000  00000000  000011f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001794  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000006c  00000000  00000000  000017c0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <diskMkdir>:
 *  Created on: 4 Mar 2010
 *      Author: Clive Webster
 */
#include "FATImpl.h"

int8_t diskMkdir(DISK* disk,const char* dirname){
   0:	7f 92       	push	r7
   2:	8f 92       	push	r8
   4:	9f 92       	push	r9
   6:	af 92       	push	r10
   8:	bf 92       	push	r11
   a:	cf 92       	push	r12
   c:	df 92       	push	r13
   e:	ef 92       	push	r14
  10:	ff 92       	push	r15
  12:	0f 93       	push	r16
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	cd b7       	in	r28, 0x3d	; 61
  1c:	de b7       	in	r29, 0x3e	; 62
  1e:	e5 97       	sbiw	r28, 0x35	; 53
  20:	0f b6       	in	r0, 0x3f	; 63
  22:	f8 94       	cli
  24:	de bf       	out	0x3e, r29	; 62
  26:	0f be       	out	0x3f, r0	; 63
  28:	cd bf       	out	0x3d, r28	; 61
  2a:	5c 01       	movw	r10, r24
  2c:	8b 01       	movw	r16, r22
	DIR_POSITION loc;
	DIR_ENTRY direntry;
	CLUSTER parentdir;
	char ffname[11];

	if( _fileFindFile(disk,dirname,&loc,&parentdir) ){
  2e:	9e 01       	movw	r18, r28
  30:	2e 5c       	subi	r18, 0xCE	; 206
  32:	3f 4f       	sbci	r19, 0xFF	; 255
  34:	ae 01       	movw	r20, r28
  36:	44 5d       	subi	r20, 0xD4	; 212
  38:	5f 4f       	sbci	r21, 0xFF	; 255
  3a:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  3e:	81 11       	cpse	r24, r1
  40:	00 c0       	rjmp	.+0      	; 0x42 <diskMkdir+0x42>
		// File or Dir already exists
		return(-1);
	}

	if(parentdir==0){
  42:	4a a9       	ldd	r20, Y+50	; 0x32
  44:	5b a9       	ldd	r21, Y+51	; 0x33
  46:	6c a9       	ldd	r22, Y+52	; 0x34
  48:	7d a9       	ldd	r23, Y+53	; 0x35
  4a:	45 2b       	or	r20, r21
  4c:	46 2b       	or	r20, r22
  4e:	47 2b       	or	r20, r23
  50:	01 f4       	brne	.+0      	; 0x52 <diskMkdir+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <diskMkdir+0x54>
		// Cannot create a new root
		return(-1);
	}

	if(!_dirFindFreeFile(disk,dirname,&loc)){
  54:	ae 01       	movw	r20, r28
  56:	44 5d       	subi	r20, 0xD4	; 212
  58:	5f 4f       	sbci	r21, 0xFF	; 255
  5a:	b8 01       	movw	r22, r16
  5c:	c5 01       	movw	r24, r10
  5e:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  62:	88 23       	and	r24, r24
  64:	01 f4       	brne	.+0      	; 0x66 <diskMkdir+0x66>
  66:	00 c0       	rjmp	.+0      	; 0x68 <diskMkdir+0x68>
		// No directory space
		return(-2);
	}

	CLUSTER nc = _fatGetFreeCluster(disk);
  68:	c5 01       	movw	r24, r10
  6a:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  6e:	6b 01       	movw	r12, r22
  70:	7c 01       	movw	r14, r24
	if(nc==0){
  72:	61 15       	cp	r22, r1
  74:	71 05       	cpc	r23, r1
  76:	81 05       	cpc	r24, r1
  78:	91 05       	cpc	r25, r1
  7a:	01 f4       	brne	.+0      	; 0x7c <diskMkdir+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <diskMkdir+0x7e>
		// No space to create the new directory area
		return(-3);
	}

	_partitionClearCluster(disk,nc);
  7e:	ab 01       	movw	r20, r22
  80:	bc 01       	movw	r22, r24
  82:	c5 01       	movw	r24, r10
  84:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>


	// Create it in the parent directory
	_dirGetFatFileName(dirname,ffname);
  88:	be 01       	movw	r22, r28
  8a:	6f 5d       	subi	r22, 0xDF	; 223
  8c:	7f 4f       	sbci	r23, 0xFF	; 255
  8e:	c8 01       	movw	r24, r16
  90:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memclr(&direntry,sizeof(direntry));
  94:	90 e2       	ldi	r25, 0x20	; 32
  96:	79 2e       	mov	r7, r25
  98:	8e 01       	movw	r16, r28
  9a:	0f 5f       	subi	r16, 0xFF	; 255
  9c:	1f 4f       	sbci	r17, 0xFF	; 255
  9e:	f8 01       	movw	r30, r16
  a0:	87 2d       	mov	r24, r7
  a2:	11 92       	st	Z+, r1
  a4:	8a 95       	dec	r24
  a6:	01 f4       	brne	.+0      	; 0xa8 <diskMkdir+0xa8>
	memcpy(&direntry,ffname,11);
  a8:	8b e0       	ldi	r24, 0x0B	; 11
  aa:	fe 01       	movw	r30, r28
  ac:	b1 96       	adiw	r30, 0x21	; 33
  ae:	d8 01       	movw	r26, r16
  b0:	01 90       	ld	r0, Z+
  b2:	0d 92       	st	X+, r0
  b4:	8a 95       	dec	r24
  b6:	01 f4       	brne	.+0      	; 0xb8 <diskMkdir+0xb8>
	_dirSetFirstClusterInDirEntry(&direntry,nc);
  b8:	b7 01       	movw	r22, r14
  ba:	a6 01       	movw	r20, r12
  bc:	c8 01       	movw	r24, r16
  be:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	direntry.attribute.flags.isDirectory = 1;
  c2:	8c 85       	ldd	r24, Y+12	; 0x0c
  c4:	80 61       	ori	r24, 0x10	; 16
  c6:	8c 87       	std	Y+12, r24	; 0x0c
	_dirCreateDirectoryEntry(disk,&direntry,&loc);
  c8:	ae 01       	movw	r20, r28
  ca:	44 5d       	subi	r20, 0xD4	; 212
  cc:	5f 4f       	sbci	r21, 0xFF	; 255
  ce:	b8 01       	movw	r22, r16
  d0:	c5 01       	movw	r24, r10
  d2:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	// Now add the '.' and '..' entries into the new directory
	DIR_ENTRY* dir = _partitionGetSector(disk,_diskClusterToSector(disk,nc),BUFFER_MODE_READWRITE);
  d6:	b7 01       	movw	r22, r14
  d8:	a6 01       	movw	r20, r12
  da:	c5 01       	movw	r24, r10
  dc:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  e0:	ab 01       	movw	r20, r22
  e2:	bc 01       	movw	r22, r24
  e4:	22 e0       	ldi	r18, 0x02	; 2
  e6:	c5 01       	movw	r24, r10
  e8:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  ec:	4c 01       	movw	r8, r24
	memclr(&direntry,sizeof(direntry));
  ee:	f8 01       	movw	r30, r16
  f0:	87 2d       	mov	r24, r7
  f2:	11 92       	st	Z+, r1
  f4:	8a 95       	dec	r24
  f6:	01 f4       	brne	.+0      	; 0xf8 <diskMkdir+0xf8>
	memcpy(&direntry,".          ",11);
  f8:	8b e0       	ldi	r24, 0x0B	; 11
  fa:	e0 e0       	ldi	r30, 0x00	; 0
  fc:	f0 e0       	ldi	r31, 0x00	; 0
  fe:	d8 01       	movw	r26, r16
 100:	01 90       	ld	r0, Z+
 102:	0d 92       	st	X+, r0
 104:	8a 95       	dec	r24
 106:	01 f4       	brne	.+0      	; 0x108 <diskMkdir+0x108>
	direntry.attribute.flags.isDirectory = 1;
 108:	8c 85       	ldd	r24, Y+12	; 0x0c
 10a:	80 61       	ori	r24, 0x10	; 16
 10c:	8c 87       	std	Y+12, r24	; 0x0c
	_dirSetFirstClusterInDirEntry(&direntry,nc);
 10e:	b7 01       	movw	r22, r14
 110:	a6 01       	movw	r20, r12
 112:	c8 01       	movw	r24, r16
 114:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memcpy(&dir[0],&direntry,sizeof(DIR_ENTRY));
 118:	f8 01       	movw	r30, r16
 11a:	d4 01       	movw	r26, r8
 11c:	01 90       	ld	r0, Z+
 11e:	0d 92       	st	X+, r0
 120:	7a 94       	dec	r7
 122:	01 f4       	brne	.+0      	; 0x124 <diskMkdir+0x124>

	if(disk->fatType == 32 && parentdir == disk->volume.rootDirCluster){
 124:	f5 01       	movw	r30, r10
 126:	86 a1       	ldd	r24, Z+38	; 0x26
 128:	4a a9       	ldd	r20, Y+50	; 0x32
 12a:	5b a9       	ldd	r21, Y+51	; 0x33
 12c:	6c a9       	ldd	r22, Y+52	; 0x34
 12e:	7d a9       	ldd	r23, Y+53	; 0x35
 130:	80 32       	cpi	r24, 0x20	; 32
 132:	01 f0       	breq	.+0      	; 0x134 <diskMkdir+0x134>
 134:	00 c0       	rjmp	.+0      	; 0x136 <diskMkdir+0x136>
 136:	06 89       	ldd	r16, Z+22	; 0x16
 138:	17 89       	ldd	r17, Z+23	; 0x17
 13a:	20 8d       	ldd	r18, Z+24	; 0x18
 13c:	31 8d       	ldd	r19, Z+25	; 0x19
 13e:	40 17       	cp	r20, r16
 140:	51 07       	cpc	r21, r17
 142:	62 07       	cpc	r22, r18
 144:	73 07       	cpc	r23, r19
 146:	01 f4       	brne	.+0      	; 0x148 <diskMkdir+0x148>
		parentdir = 0;
	}
	if(disk->fatType != 32 && parentdir<=1){
		parentdir = 0;
 148:	1a aa       	std	Y+50, r1	; 0x32
 14a:	1b aa       	std	Y+51, r1	; 0x33
 14c:	1c aa       	std	Y+52, r1	; 0x34
 14e:	1d aa       	std	Y+53, r1	; 0x35
	}

	memclr(&direntry,sizeof(direntry));
 150:	80 e2       	ldi	r24, 0x20	; 32
 152:	78 2e       	mov	r7, r24
 154:	8e 01       	movw	r16, r28
 156:	0f 5f       	subi	r16, 0xFF	; 255
 158:	1f 4f       	sbci	r17, 0xFF	; 255
 15a:	f8 01       	movw	r30, r16
 15c:	87 2d       	mov	r24, r7
 15e:	11 92       	st	Z+, r1
 160:	8a 95       	dec	r24
 162:	01 f4       	brne	.+0      	; 0x164 <diskMkdir+0x164>
	memcpy(&direntry,"..         ",11);
 164:	8b e0       	ldi	r24, 0x0B	; 11
 166:	e0 e0       	ldi	r30, 0x00	; 0
 168:	f0 e0       	ldi	r31, 0x00	; 0
 16a:	d8 01       	movw	r26, r16
 16c:	01 90       	ld	r0, Z+
 16e:	0d 92       	st	X+, r0
 170:	8a 95       	dec	r24
 172:	01 f4       	brne	.+0      	; 0x174 <diskMkdir+0x174>
	direntry.attribute.flags.isDirectory = 1;
 174:	8c 85       	ldd	r24, Y+12	; 0x0c
 176:	80 61       	ori	r24, 0x10	; 16
 178:	8c 87       	std	Y+12, r24	; 0x0c
	_dirSetFirstClusterInDirEntry(&direntry,parentdir);
 17a:	4a a9       	ldd	r20, Y+50	; 0x32
 17c:	5b a9       	ldd	r21, Y+51	; 0x33
 17e:	6c a9       	ldd	r22, Y+52	; 0x34
 180:	7d a9       	ldd	r23, Y+53	; 0x35
 182:	c8 01       	movw	r24, r16
 184:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memcpy(&dir[1],&direntry,sizeof(DIR_ENTRY));
 188:	f8 01       	movw	r30, r16
 18a:	d4 01       	movw	r26, r8
 18c:	90 96       	adiw	r26, 0x20	; 32
 18e:	01 90       	ld	r0, Z+
 190:	0d 92       	st	X+, r0
 192:	7a 94       	dec	r7
 194:	01 f4       	brne	.+0      	; 0x196 <diskMkdir+0x196>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
 196:	b4 01       	movw	r22, r8
 198:	c5 01       	movw	r24, r10
 19a:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	partition_releaseSector(disk,dir);


	// Now tell the FAT that the new directory is only one cluster long
	_fatSetNextClusterAddress(disk,nc,_fatGiveEndMarker(disk));
 19e:	c5 01       	movw	r24, r10
 1a0:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
 1a4:	8b 01       	movw	r16, r22
 1a6:	9c 01       	movw	r18, r24
 1a8:	b7 01       	movw	r22, r14
 1aa:	a6 01       	movw	r20, r12
 1ac:	c5 01       	movw	r24, r10
 1ae:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	return(0);
 1b2:	80 e0       	ldi	r24, 0x00	; 0
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <diskMkdir+0x1b6>
	CLUSTER parentdir;
	char ffname[11];

	if( _fileFindFile(disk,dirname,&loc,&parentdir) ){
		// File or Dir already exists
		return(-1);
 1b6:	8f ef       	ldi	r24, 0xFF	; 255
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <diskMkdir+0x1ba>
		return(-1);
	}

	if(!_dirFindFreeFile(disk,dirname,&loc)){
		// No directory space
		return(-2);
 1ba:	8e ef       	ldi	r24, 0xFE	; 254
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <diskMkdir+0x1be>
	}

	CLUSTER nc = _fatGetFreeCluster(disk);
	if(nc==0){
		// No space to create the new directory area
		return(-3);
 1be:	8d ef       	ldi	r24, 0xFD	; 253
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <diskMkdir+0x1c2>
	memcpy(&dir[0],&direntry,sizeof(DIR_ENTRY));

	if(disk->fatType == 32 && parentdir == disk->volume.rootDirCluster){
		parentdir = 0;
	}
	if(disk->fatType != 32 && parentdir<=1){
 1c2:	42 30       	cpi	r20, 0x02	; 2
 1c4:	51 05       	cpc	r21, r1
 1c6:	61 05       	cpc	r22, r1
 1c8:	71 05       	cpc	r23, r1
 1ca:	00 f4       	brcc	.+0      	; 0x1cc <diskMkdir+0x1cc>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <diskMkdir+0x1ce>

	// Now tell the FAT that the new directory is only one cluster long
	_fatSetNextClusterAddress(disk,nc,_fatGiveEndMarker(disk));

	return(0);
}
 1ce:	e5 96       	adiw	r28, 0x35	; 53
 1d0:	0f b6       	in	r0, 0x3f	; 63
 1d2:	f8 94       	cli
 1d4:	de bf       	out	0x3e, r29	; 62
 1d6:	0f be       	out	0x3f, r0	; 63
 1d8:	cd bf       	out	0x3d, r28	; 61
 1da:	df 91       	pop	r29
 1dc:	cf 91       	pop	r28
 1de:	1f 91       	pop	r17
 1e0:	0f 91       	pop	r16
 1e2:	ff 90       	pop	r15
 1e4:	ef 90       	pop	r14
 1e6:	df 90       	pop	r13
 1e8:	cf 90       	pop	r12
 1ea:	bf 90       	pop	r11
 1ec:	af 90       	pop	r10
 1ee:	9f 90       	pop	r9
 1f0:	8f 90       	pop	r8
 1f2:	7f 90       	pop	r7
 1f4:	08 95       	ret

i2cEEPROM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002f4  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000328  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000328  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  00000328  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a1e  00000000  00000000  0000032e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000024b  00000000  00000000  00000d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000a65  00000000  00000000  00000f97  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000019fc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000190  00000000  00000000  00001a1c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000373  00000000  00000000  00001bac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001f1f  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000001a0  00000000  00000000  00001f4c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
	EEPROM_ADDR addr = absSector * 512;
	i2cEEPROM_writeBytes(eeprom,addr,dta,512);
	return TRUE;
}

static uint32_t disk_total_sectors(void* device){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

// Write a sequence of bytes
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes);

static __inline__ EEPROM_ADDR i2cEEPROM_totalBytes(const I2C_EEPROM* eeprom){
	return eeprom->totalBytes;
   4:	fc 01       	movw	r30, r24
   6:	06 81       	ldd	r16, Z+6	; 0x06
   8:	17 81       	ldd	r17, Z+7	; 0x07
   a:	20 85       	ldd	r18, Z+8	; 0x08
   c:	31 85       	ldd	r19, Z+9	; 0x09
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	uint32_t sectors = i2cEEPROM_totalBytes(eeprom);
	sectors /= 512;
   e:	89 e0       	ldi	r24, 0x09	; 9
  10:	36 95       	lsr	r19
  12:	27 95       	ror	r18
  14:	17 95       	ror	r17
  16:	07 95       	ror	r16
  18:	8a 95       	dec	r24
  1a:	01 f4       	brne	.+0      	; 0x1c <disk_total_sectors+0x1c>
	return sectors;
}
  1c:	b8 01       	movw	r22, r16
  1e:	c9 01       	movw	r24, r18
  20:	1f 91       	pop	r17
  22:	0f 91       	pop	r16
  24:	08 95       	ret

00000026 <i2cEEPROM_readBytes>:

	return rtn;
}

// Read a sequence of byte
void i2cEEPROM_readBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
  26:	4f 92       	push	r4
  28:	5f 92       	push	r5
  2a:	6f 92       	push	r6
  2c:	7f 92       	push	r7
  2e:	8f 92       	push	r8
  30:	9f 92       	push	r9
  32:	af 92       	push	r10
  34:	bf 92       	push	r11
  36:	cf 92       	push	r12
  38:	df 92       	push	r13
  3a:	ef 92       	push	r14
  3c:	ff 92       	push	r15
  3e:	0f 93       	push	r16
  40:	1f 93       	push	r17
  42:	cf 93       	push	r28
  44:	df 93       	push	r29
  46:	cd b7       	in	r28, 0x3d	; 61
  48:	de b7       	in	r29, 0x3e	; 62
  4a:	27 97       	sbiw	r28, 0x07	; 7
  4c:	0f b6       	in	r0, 0x3f	; 63
  4e:	f8 94       	cli
  50:	de bf       	out	0x3e, r29	; 62
  52:	0f be       	out	0x3f, r0	; 63
  54:	cd bf       	out	0x3d, r28	; 61
  56:	5c 01       	movw	r10, r24
  58:	cb 01       	movw	r24, r22
  5a:	ba 01       	movw	r22, r20
  5c:	49 01       	movw	r8, r18
  5e:	38 01       	movw	r6, r16
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
  60:	f5 01       	movw	r30, r10
  62:	26 81       	ldd	r18, Z+6	; 0x06
  64:	37 81       	ldd	r19, Z+7	; 0x07
  66:	40 85       	ldd	r20, Z+8	; 0x08
  68:	51 85       	ldd	r21, Z+9	; 0x09
  6a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  6e:	6b 01       	movw	r12, r22
  70:	7c 01       	movw	r14, r24
	uint8_t* pos = dest;
  72:	24 01       	movw	r4, r8
	uint8_t  buf[4];


	while(numBytes){
  74:	00 c0       	rjmp	.+0      	; 0x76 <i2cEEPROM_readBytes+0x50>
		size_t offset = src % eeprom->pageSize;			/* Offset into the page						*/
  76:	f5 01       	movw	r30, r10
  78:	84 80       	ldd	r8, Z+4	; 0x04
  7a:	95 80       	ldd	r9, Z+5	; 0x05
  7c:	94 01       	movw	r18, r8
  7e:	40 e0       	ldi	r20, 0x00	; 0
  80:	50 e0       	ldi	r21, 0x00	; 0
  82:	c7 01       	movw	r24, r14
  84:	b6 01       	movw	r22, r12
  86:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		size_t bytesToRead = eeprom->pageSize - offset;	/* The number of bytes left in page 	  	*/
  8a:	86 1a       	sub	r8, r22
  8c:	97 0a       	sbc	r9, r23
  8e:	68 14       	cp	r6, r8
  90:	79 04       	cpc	r7, r9
  92:	00 f4       	brcc	.+0      	; 0x94 <i2cEEPROM_readBytes+0x6e>
  94:	43 01       	movw	r8, r6
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
}


static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;
  96:	f5 01       	movw	r30, r10
  98:	a2 81       	ldd	r26, Z+2	; 0x02

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  9a:	33 81       	ldd	r19, Z+3	; 0x03
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
  9c:	83 2f       	mov	r24, r19
  9e:	90 e0       	ldi	r25, 0x00	; 0

static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
  a0:	b7 01       	movw	r22, r14
  a2:	a6 01       	movw	r20, r12
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  a4:	21 e0       	ldi	r18, 0x01	; 1
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <i2cEEPROM_readBytes+0x82>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
  a8:	fc 01       	movw	r30, r24
  aa:	e2 1b       	sub	r30, r18
  ac:	f1 09       	sbc	r31, r1
  ae:	01 e0       	ldi	r16, 0x01	; 1
  b0:	10 e0       	ldi	r17, 0x00	; 0
  b2:	0c 0f       	add	r16, r28
  b4:	1d 1f       	adc	r17, r29
  b6:	e0 0f       	add	r30, r16
  b8:	f1 1f       	adc	r31, r17
  ba:	40 83       	st	Z, r20
		hiBits >>= 8;
  bc:	45 2f       	mov	r20, r21
  be:	56 2f       	mov	r21, r22
  c0:	67 2f       	mov	r22, r23
  c2:	77 27       	eor	r23, r23
static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  c4:	2f 5f       	subi	r18, 0xFF	; 255
  c6:	32 17       	cp	r19, r18
  c8:	00 f4       	brcc	.+0      	; 0xca <i2cEEPROM_readBytes+0xa4>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
		hiBits >>= 8;
	}
	uint8_t mask = hiBits & 0xff;
	rtn |= (mask<<1);
  ca:	44 0f       	add	r20, r20
  cc:	4a 2b       	or	r20, r26
		size_t bytesToRead = eeprom->pageSize - offset;	/* The number of bytes left in page 	  	*/
		if(bytesToRead > numBytes){
			bytesToRead = numBytes;						/* The number of bytes to read from page  	*/
		}
		// Create dummy i2c device
		I2C_DEVICE i2c = MAKE_I2C_DEVICE(address(eeprom,src,buf));
  ce:	4e 7f       	andi	r20, 0xFE	; 254
  d0:	4f 83       	std	Y+7, r20	; 0x07
		i2c.bus = eeprom->i2cInfo.bus;
  d2:	f5 01       	movw	r30, r10
  d4:	80 81       	ld	r24, Z
  d6:	91 81       	ldd	r25, Z+1	; 0x01
  d8:	9e 83       	std	Y+6, r25	; 0x06
  da:	8d 83       	std	Y+5, r24	; 0x05

		// Keep sending the data as it may fail if eeprom is busy writing
		// Write the 'address' then reads the data
		while(!i2cMasterTransfer(&i2c, eeprom->addrBytes, buf, bytesToRead, pos));
  dc:	f5 01       	movw	r30, r10
  de:	63 81       	ldd	r22, Z+3	; 0x03
  e0:	82 01       	movw	r16, r4
  e2:	94 01       	movw	r18, r8
  e4:	ae 01       	movw	r20, r28
  e6:	4f 5f       	subi	r20, 0xFF	; 255
  e8:	5f 4f       	sbci	r21, 0xFF	; 255
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	ce 01       	movw	r24, r28
  ee:	05 96       	adiw	r24, 0x05	; 5
  f0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  f4:	88 23       	and	r24, r24
  f6:	01 f0       	breq	.+0      	; 0xf8 <i2cEEPROM_readBytes+0xd2>

		src += bytesToRead;
  f8:	c8 0c       	add	r12, r8
  fa:	d9 1c       	adc	r13, r9
  fc:	e1 1c       	adc	r14, r1
  fe:	f1 1c       	adc	r15, r1
		pos += bytesToRead;
 100:	48 0c       	add	r4, r8
 102:	59 1c       	adc	r5, r9
		numBytes -= bytesToRead;
 104:	68 18       	sub	r6, r8
 106:	79 08       	sbc	r7, r9
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;
	uint8_t  buf[4];


	while(numBytes){
 108:	61 14       	cp	r6, r1
 10a:	71 04       	cpc	r7, r1
 10c:	01 f0       	breq	.+0      	; 0x10e <i2cEEPROM_readBytes+0xe8>
 10e:	00 c0       	rjmp	.+0      	; 0x110 <i2cEEPROM_readBytes+0xea>

		src += bytesToRead;
		pos += bytesToRead;
		numBytes -= bytesToRead;
	}
}
 110:	27 96       	adiw	r28, 0x07	; 7
 112:	0f b6       	in	r0, 0x3f	; 63
 114:	f8 94       	cli
 116:	de bf       	out	0x3e, r29	; 62
 118:	0f be       	out	0x3f, r0	; 63
 11a:	cd bf       	out	0x3d, r28	; 61
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	bf 90       	pop	r11
 12e:	af 90       	pop	r10
 130:	9f 90       	pop	r9
 132:	8f 90       	pop	r8
 134:	7f 90       	pop	r7
 136:	6f 90       	pop	r6
 138:	5f 90       	pop	r5
 13a:	4f 90       	pop	r4
 13c:	08 95       	ret

0000013e <disk_read>:
		pos += bytesToWrite;
		numBytes -= bytesToWrite;
	}
}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 13e:	0f 93       	push	r16
 140:	1f 93       	push	r17
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 142:	f9 e0       	ldi	r31, 0x09	; 9
 144:	44 0f       	add	r20, r20
 146:	55 1f       	adc	r21, r21
 148:	66 1f       	adc	r22, r22
 14a:	77 1f       	adc	r23, r23
 14c:	fa 95       	dec	r31
 14e:	01 f4       	brne	.+0      	; 0x150 <disk_read+0x12>
	i2cEEPROM_readBytes(eeprom,addr,dta,512);
 150:	00 e0       	ldi	r16, 0x00	; 0
 152:	12 e0       	ldi	r17, 0x02	; 2
 154:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 158:	8f ef       	ldi	r24, 0xFF	; 255
 15a:	1f 91       	pop	r17
 15c:	0f 91       	pop	r16
 15e:	08 95       	ret

00000160 <i2cEEPROM_readByte>:

#include "i2cEEPROM.h"



uint8_t i2cEEPROM_readByte(I2C_EEPROM* eeprom, EEPROM_ADDR addr){
 160:	0f 93       	push	r16
 162:	1f 93       	push	r17
 164:	cf 93       	push	r28
 166:	df 93       	push	r29
 168:	1f 92       	push	r1
 16a:	cd b7       	in	r28, 0x3d	; 61
 16c:	de b7       	in	r29, 0x3e	; 62
	uint8_t rtn;
	i2cEEPROM_readBytes(eeprom, addr, &rtn, 1);
 16e:	01 e0       	ldi	r16, 0x01	; 1
 170:	10 e0       	ldi	r17, 0x00	; 0
 172:	9e 01       	movw	r18, r28
 174:	2f 5f       	subi	r18, 0xFF	; 255
 176:	3f 4f       	sbci	r19, 0xFF	; 255
 178:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return rtn;
}
 17c:	89 81       	ldd	r24, Y+1	; 0x01
 17e:	0f 90       	pop	r0
 180:	df 91       	pop	r29
 182:	cf 91       	pop	r28
 184:	1f 91       	pop	r17
 186:	0f 91       	pop	r16
 188:	08 95       	ret

0000018a <i2cEEPROM_writeBytes>:
		numBytes -= bytesToRead;
	}
}

// Write a sequence of bytes
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 18a:	4f 92       	push	r4
 18c:	5f 92       	push	r5
 18e:	6f 92       	push	r6
 190:	7f 92       	push	r7
 192:	8f 92       	push	r8
 194:	9f 92       	push	r9
 196:	af 92       	push	r10
 198:	bf 92       	push	r11
 19a:	cf 92       	push	r12
 19c:	df 92       	push	r13
 19e:	ef 92       	push	r14
 1a0:	ff 92       	push	r15
 1a2:	0f 93       	push	r16
 1a4:	1f 93       	push	r17
 1a6:	cf 93       	push	r28
 1a8:	df 93       	push	r29
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
 1ae:	27 97       	sbiw	r28, 0x07	; 7
 1b0:	0f b6       	in	r0, 0x3f	; 63
 1b2:	f8 94       	cli
 1b4:	de bf       	out	0x3e, r29	; 62
 1b6:	0f be       	out	0x3f, r0	; 63
 1b8:	cd bf       	out	0x3d, r28	; 61
 1ba:	5c 01       	movw	r10, r24
 1bc:	cb 01       	movw	r24, r22
 1be:	ba 01       	movw	r22, r20
 1c0:	49 01       	movw	r8, r18
 1c2:	38 01       	movw	r6, r16
	EEPROM_ADDR dst = addr % eeprom->totalBytes;	/* Put address in range				*/
 1c4:	f5 01       	movw	r30, r10
 1c6:	26 81       	ldd	r18, Z+6	; 0x06
 1c8:	37 81       	ldd	r19, Z+7	; 0x07
 1ca:	40 85       	ldd	r20, Z+8	; 0x08
 1cc:	51 85       	ldd	r21, Z+9	; 0x09
 1ce:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 1d2:	6b 01       	movw	r12, r22
 1d4:	7c 01       	movw	r14, r24
	const uint8_t* pos = src;
 1d6:	24 01       	movw	r4, r8
	uint8_t  buf[4];

	while(numBytes){
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <i2cEEPROM_writeBytes+0x50>
		size_t offset = dst % eeprom->pageSize;			/* Offset into the page						*/
 1da:	f5 01       	movw	r30, r10
 1dc:	84 80       	ldd	r8, Z+4	; 0x04
 1de:	95 80       	ldd	r9, Z+5	; 0x05
 1e0:	94 01       	movw	r18, r8
 1e2:	40 e0       	ldi	r20, 0x00	; 0
 1e4:	50 e0       	ldi	r21, 0x00	; 0
 1e6:	c7 01       	movw	r24, r14
 1e8:	b6 01       	movw	r22, r12
 1ea:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		size_t bytesToWrite = eeprom->pageSize - offset;/* The number of bytes left in page 	  	*/
 1ee:	86 1a       	sub	r8, r22
 1f0:	97 0a       	sbc	r9, r23
 1f2:	68 14       	cp	r6, r8
 1f4:	79 04       	cpc	r7, r9
 1f6:	00 f4       	brcc	.+0      	; 0x1f8 <i2cEEPROM_writeBytes+0x6e>
 1f8:	43 01       	movw	r8, r6
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
}


static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;
 1fa:	f5 01       	movw	r30, r10
 1fc:	a2 81       	ldd	r26, Z+2	; 0x02

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 1fe:	33 81       	ldd	r19, Z+3	; 0x03
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
 200:	83 2f       	mov	r24, r19
 202:	90 e0       	ldi	r25, 0x00	; 0

static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
 204:	b7 01       	movw	r22, r14
 206:	a6 01       	movw	r20, r12
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 208:	21 e0       	ldi	r18, 0x01	; 1
 20a:	00 c0       	rjmp	.+0      	; 0x20c <i2cEEPROM_writeBytes+0x82>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
 20c:	fc 01       	movw	r30, r24
 20e:	e2 1b       	sub	r30, r18
 210:	f1 09       	sbc	r31, r1
 212:	01 e0       	ldi	r16, 0x01	; 1
 214:	10 e0       	ldi	r17, 0x00	; 0
 216:	0c 0f       	add	r16, r28
 218:	1d 1f       	adc	r17, r29
 21a:	e0 0f       	add	r30, r16
 21c:	f1 1f       	adc	r31, r17
 21e:	40 83       	st	Z, r20
		hiBits >>= 8;
 220:	45 2f       	mov	r20, r21
 222:	56 2f       	mov	r21, r22
 224:	67 2f       	mov	r22, r23
 226:	77 27       	eor	r23, r23
static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 228:	2f 5f       	subi	r18, 0xFF	; 255
 22a:	32 17       	cp	r19, r18
 22c:	00 f4       	brcc	.+0      	; 0x22e <i2cEEPROM_writeBytes+0xa4>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
		hiBits >>= 8;
	}
	uint8_t mask = hiBits & 0xff;
	rtn |= (mask<<1);
 22e:	44 0f       	add	r20, r20
 230:	4a 2b       	or	r20, r26
		if(bytesToWrite > numBytes){
			bytesToWrite = numBytes;					/* The number of bytes to write to the page	*/
		}

		// Create dummy i2c device
		I2C_DEVICE i2c = MAKE_I2C_DEVICE(address(eeprom,dst,buf));
 232:	4e 7f       	andi	r20, 0xFE	; 254
 234:	4f 83       	std	Y+7, r20	; 0x07
		i2c.bus = eeprom->i2cInfo.bus;
 236:	f5 01       	movw	r30, r10
 238:	80 81       	ld	r24, Z
 23a:	91 81       	ldd	r25, Z+1	; 0x01
 23c:	9e 83       	std	Y+6, r25	; 0x06
 23e:	8d 83       	std	Y+5, r24	; 0x05

		// Keep sending the data as it may fail if eeprom is busy writing
		// Writes the 'address' and then writes the data
		while(!i2cMasterSendWithPrefix(&i2c, eeprom->addrBytes, buf, bytesToWrite, pos));
 240:	f5 01       	movw	r30, r10
 242:	63 81       	ldd	r22, Z+3	; 0x03
 244:	82 01       	movw	r16, r4
 246:	94 01       	movw	r18, r8
 248:	ae 01       	movw	r20, r28
 24a:	4f 5f       	subi	r20, 0xFF	; 255
 24c:	5f 4f       	sbci	r21, 0xFF	; 255
 24e:	70 e0       	ldi	r23, 0x00	; 0
 250:	ce 01       	movw	r24, r28
 252:	05 96       	adiw	r24, 0x05	; 5
 254:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 258:	88 23       	and	r24, r24
 25a:	01 f0       	breq	.+0      	; 0x25c <i2cEEPROM_writeBytes+0xd2>

		dst += bytesToWrite;
 25c:	c8 0c       	add	r12, r8
 25e:	d9 1c       	adc	r13, r9
 260:	e1 1c       	adc	r14, r1
 262:	f1 1c       	adc	r15, r1
		pos += bytesToWrite;
 264:	48 0c       	add	r4, r8
 266:	59 1c       	adc	r5, r9
		numBytes -= bytesToWrite;
 268:	68 18       	sub	r6, r8
 26a:	79 08       	sbc	r7, r9
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;	/* Put address in range				*/
	const uint8_t* pos = src;
	uint8_t  buf[4];

	while(numBytes){
 26c:	61 14       	cp	r6, r1
 26e:	71 04       	cpc	r7, r1
 270:	01 f0       	breq	.+0      	; 0x272 <i2cEEPROM_writeBytes+0xe8>
 272:	00 c0       	rjmp	.+0      	; 0x274 <i2cEEPROM_writeBytes+0xea>

		dst += bytesToWrite;
		pos += bytesToWrite;
		numBytes -= bytesToWrite;
	}
}
 274:	27 96       	adiw	r28, 0x07	; 7
 276:	0f b6       	in	r0, 0x3f	; 63
 278:	f8 94       	cli
 27a:	de bf       	out	0x3e, r29	; 62
 27c:	0f be       	out	0x3f, r0	; 63
 27e:	cd bf       	out	0x3d, r28	; 61
 280:	df 91       	pop	r29
 282:	cf 91       	pop	r28
 284:	1f 91       	pop	r17
 286:	0f 91       	pop	r16
 288:	ff 90       	pop	r15
 28a:	ef 90       	pop	r14
 28c:	df 90       	pop	r13
 28e:	cf 90       	pop	r12
 290:	bf 90       	pop	r11
 292:	af 90       	pop	r10
 294:	9f 90       	pop	r9
 296:	8f 90       	pop	r8
 298:	7f 90       	pop	r7
 29a:	6f 90       	pop	r6
 29c:	5f 90       	pop	r5
 29e:	4f 90       	pop	r4
 2a0:	08 95       	ret

000002a2 <disk_write>:
	EEPROM_ADDR addr = absSector * 512;
	i2cEEPROM_readBytes(eeprom,addr,dta,512);
	return TRUE;
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 2a2:	0f 93       	push	r16
 2a4:	1f 93       	push	r17
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 2a6:	19 e0       	ldi	r17, 0x09	; 9
 2a8:	44 0f       	add	r20, r20
 2aa:	55 1f       	adc	r21, r21
 2ac:	66 1f       	adc	r22, r22
 2ae:	77 1f       	adc	r23, r23
 2b0:	1a 95       	dec	r17
 2b2:	01 f4       	brne	.+0      	; 0x2b4 <disk_write+0x12>
	i2cEEPROM_writeBytes(eeprom,addr,dta,512);
 2b4:	00 e0       	ldi	r16, 0x00	; 0
 2b6:	12 e0       	ldi	r17, 0x02	; 2
 2b8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 2bc:	8f ef       	ldi	r24, 0xFF	; 255
 2be:	1f 91       	pop	r17
 2c0:	0f 91       	pop	r16
 2c2:	08 95       	ret

000002c4 <i2cEEPROM_writeByte>:
	i2cEEPROM_readBytes(eeprom, addr, &rtn, 1);
	return rtn;
}

// Write a byte to the eeprom
void i2cEEPROM_writeByte(I2C_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
 2c4:	0f 93       	push	r16
 2c6:	1f 93       	push	r17
 2c8:	cf 93       	push	r28
 2ca:	df 93       	push	r29
 2cc:	1f 92       	push	r1
 2ce:	cd b7       	in	r28, 0x3d	; 61
 2d0:	de b7       	in	r29, 0x3e	; 62
 2d2:	29 83       	std	Y+1, r18	; 0x01
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
 2d4:	01 e0       	ldi	r16, 0x01	; 1
 2d6:	10 e0       	ldi	r17, 0x00	; 0
 2d8:	9e 01       	movw	r18, r28
 2da:	2f 5f       	subi	r18, 0xFF	; 255
 2dc:	3f 4f       	sbci	r19, 0xFF	; 255
 2de:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 2e2:	0f 90       	pop	r0
 2e4:	df 91       	pop	r29
 2e6:	cf 91       	pop	r28
 2e8:	1f 91       	pop	r17
 2ea:	0f 91       	pop	r16
 2ec:	08 95       	ret

000002ee <i2cEEPROMGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* i2cEEPROMGetStorageClass(void){
	return &c_i2ceeprom_disk;
}
 2ee:	80 e0       	ldi	r24, 0x00	; 0
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	08 95       	ret

sdCard.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000692  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000006c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000006c6  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  000006c6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001825  00000000  00000000  000006cc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000432  00000000  00000000  00001ef1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000f54  00000000  00000000  00002323  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00003277  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000098  00000000  00000000  00003297  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000029f  00000000  00000000  0000332f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000705  00000000  00000000  000035ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00003cd3  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000240  00000000  00000000  00003d00  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
static boolean disk_write(void* device, uint32_t absSector,const void* dta){
	SD_CARD* card = (SD_CARD*)device;
	return sdCardWrite(card, absSector,dta,1);
}

static uint32_t disk_total_sectors(void* device){
   0:	fc 01       	movw	r30, r24
	SD_CARD* card = (SD_CARD*)device;
	return card->numSectors;
   2:	61 85       	ldd	r22, Z+9	; 0x09
   4:	72 85       	ldd	r23, Z+10	; 0x0a
}
   6:	83 85       	ldd	r24, Z+11	; 0x0b
   8:	94 85       	ldd	r25, Z+12	; 0x0c
   a:	08 95       	ret

0000000c <receive>:
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
   c:	0c 94 00 00 	jmp	0	; 0x0 <disk_total_sectors>

00000010 <wait_ready>:
	rprintf("<0x");rprintfu08(rtn);
	#endif
	return rtn;
}

static uint8_t wait_ready(SD_CARD* card){
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	ec 01       	movw	r28, r24
	uint8_t res;

	TICK_COUNT timer2 = clockGetus();;
  20:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  24:	6b 01       	movw	r12, r22
  26:	7c 01       	movw	r14, r24
	receive(card);
  28:	ce 01       	movw	r24, r28
  2a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	do{
		res = receive(card);			// Timeout after 500ms
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  34:	18 2f       	mov	r17, r24
	}while ((res != 0xFF) && !clockHasElapsed(timer2, 500000));
  36:	8f 3f       	cpi	r24, 0xFF	; 255
  38:	01 f0       	breq	.+0      	; 0x3a <wait_ready+0x2a>
  3a:	20 e2       	ldi	r18, 0x20	; 32
  3c:	31 ea       	ldi	r19, 0xA1	; 161
  3e:	47 e0       	ldi	r20, 0x07	; 7
  40:	50 e0       	ldi	r21, 0x00	; 0
  42:	c7 01       	movw	r24, r14
  44:	b6 01       	movw	r22, r12
  46:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  4a:	88 23       	and	r24, r24
  4c:	01 f0       	breq	.+0      	; 0x4e <wait_ready+0x3e>

	return res;
}
  4e:	81 2f       	mov	r24, r17
  50:	df 91       	pop	r29
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	ff 90       	pop	r15
  58:	ef 90       	pop	r14
  5a:	df 90       	pop	r13
  5c:	cf 90       	pop	r12
  5e:	08 95       	ret

00000060 <deselect>:

static void deselect(SD_CARD* card){
  60:	cf 93       	push	r28
  62:	df 93       	push	r29
  64:	ec 01       	movw	r28, r24
	spiDeviceSelect(card, FALSE);	// deselect the card
  66:	60 e0       	ldi	r22, 0x00	; 0
  68:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	receive(card);
  6c:	ce 01       	movw	r24, r28
}
  6e:	df 91       	pop	r29
  70:	cf 91       	pop	r28
	return res;
}

static void deselect(SD_CARD* card){
	spiDeviceSelect(card, FALSE);	// deselect the card
	receive(card);
  72:	0c 94 00 00 	jmp	0	; 0x0 <disk_total_sectors>

00000076 <send_cmd>:

	return TRUE;
}


static uint8_t send_cmd(SD_CARD *card,uint8_t cmd, uint32_t param){
  76:	bf 92       	push	r11
  78:	cf 92       	push	r12
  7a:	df 92       	push	r13
  7c:	ef 92       	push	r14
  7e:	ff 92       	push	r15
  80:	0f 93       	push	r16
  82:	1f 93       	push	r17
  84:	cf 93       	push	r28
  86:	df 93       	push	r29
  88:	00 d0       	rcall	.+0      	; 0x8a <send_cmd+0x14>
  8a:	00 d0       	rcall	.+0      	; 0x8c <send_cmd+0x16>
  8c:	00 d0       	rcall	.+0      	; 0x8e <send_cmd+0x18>
  8e:	cd b7       	in	r28, 0x3d	; 61
  90:	de b7       	in	r29, 0x3e	; 62
  92:	8c 01       	movw	r16, r24
  94:	f6 2e       	mov	r15, r22
  96:	e2 2e       	mov	r14, r18
  98:	d3 2e       	mov	r13, r19
  9a:	c4 2e       	mov	r12, r20
  9c:	b5 2e       	mov	r11, r21
	uint8_t res;

	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
  9e:	67 ff       	sbrs	r22, 7
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <send_cmd+0x2c>
		cmd &= 0x7F;
		res = send_cmd(card,CMD55, 0);
  a2:	20 e0       	ldi	r18, 0x00	; 0
  a4:	30 e0       	ldi	r19, 0x00	; 0
  a6:	a9 01       	movw	r20, r18
  a8:	67 e7       	ldi	r22, 0x77	; 119
  aa:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		if (res > 1)
  ae:	82 30       	cpi	r24, 0x02	; 2
  b0:	00 f0       	brcs	.+0      	; 0xb2 <send_cmd+0x3c>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <send_cmd+0x3e>

static uint8_t send_cmd(SD_CARD *card,uint8_t cmd, uint32_t param){
	uint8_t res;

	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
  b4:	8f e7       	ldi	r24, 0x7F	; 127
  b6:	f8 22       	and	r15, r24
	#ifdef DEBUG_SD
	rprintf("\nSend cmd %d:",(cmd & 0x3f));
	#endif

	/* Select the card and wait for ready */
	deselect(card);
  b8:	c8 01       	movw	r24, r16
  ba:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if(cmd == CMD0){
  be:	80 e4       	ldi	r24, 0x40	; 64
		spiDeviceSelect(card, TRUE);	// select the card - with no reading of status
  c0:	6f ef       	ldi	r22, 0xFF	; 255
	#endif

	/* Select the card and wait for ready */
	deselect(card);

	if(cmd == CMD0){
  c2:	f8 12       	cpse	r15, r24
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <send_cmd+0x50>
		spiDeviceSelect(card, TRUE);	// select the card - with no reading of status
  c6:	c8 01       	movw	r24, r16
  c8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  cc:	85 e9       	ldi	r24, 0x95	; 149
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <send_cmd+0x5a>
	spiDeviceSelect(card, FALSE);	// deselect the card
	receive(card);
}

static boolean select(SD_CARD* card){	/* TRUE:Successful, FALSE:Timeout */
	spiDeviceSelect(card, TRUE);	// select the card
  d0:	c8 01       	movw	r24, r16
  d2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	if (wait_ready(card) != 0xFF) {
  d6:	c8 01       	movw	r24, r16
  d8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  dc:	8f 3f       	cpi	r24, 0xFF	; 255
  de:	01 f0       	breq	.+0      	; 0xe0 <send_cmd+0x6a>
		deselect(card);
  e0:	c8 01       	movw	r24, r16
  e2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if(cmd == CMD0){
		spiDeviceSelect(card, TRUE);	// select the card - with no reading of status
	}else{
		if (!select(card))
			return 0xFF;
  e6:	8f ef       	ldi	r24, 0xFF	; 255
  e8:	00 c0       	rjmp	.+0      	; 0xea <send_cmd+0x74>
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
  ea:	88 e4       	ldi	r24, 0x48	; 72
  ec:	f8 16       	cp	r15, r24
  ee:	01 f0       	breq	.+0      	; 0xf0 <send_cmd+0x7a>
		if (!select(card))
			return 0xFF;
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <send_cmd+0x7e>
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
  f4:	87 e8       	ldi	r24, 0x87	; 135

	uint8_t cmdBuf[] = { cmd, (param>>24),(param>>16),(param>>8),(param), n};
  f6:	f9 82       	std	Y+1, r15	; 0x01
  f8:	ba 82       	std	Y+2, r11	; 0x02
  fa:	cb 82       	std	Y+3, r12	; 0x03
  fc:	dc 82       	std	Y+4, r13	; 0x04
  fe:	ed 82       	std	Y+5, r14	; 0x05
 100:	8e 83       	std	Y+6, r24	; 0x06
	spiDeviceSendBytes(card, cmdBuf, sizeof(cmdBuf));
 102:	46 e0       	ldi	r20, 0x06	; 6
 104:	50 e0       	ldi	r21, 0x00	; 0
 106:	be 01       	movw	r22, r28
 108:	6f 5f       	subi	r22, 0xFF	; 255
 10a:	7f 4f       	sbci	r23, 0xFF	; 255
 10c:	c8 01       	movw	r24, r16
 10e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	/* Receive command response */
	if (cmd == CMD12)
 112:	8c e4       	ldi	r24, 0x4C	; 76
 114:	f8 12       	cpse	r15, r24
 116:	00 c0       	rjmp	.+0      	; 0x118 <send_cmd+0xa2>
		receive(card);					/* Skip a stuff byte when stop reading */
 118:	c8 01       	movw	r24, r16
 11a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 11e:	8a e0       	ldi	r24, 0x0A	; 10
 120:	f8 2e       	mov	r15, r24
	if (cmd == CMD12)
		receive(card);					/* Skip a stuff byte when stop reading */

	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do{
		res = receive(card);
 122:	c8 01       	movw	r24, r16
 124:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}while ((res & 0x80) && --n);
 128:	87 ff       	sbrs	r24, 7
 12a:	00 c0       	rjmp	.+0      	; 0x12c <send_cmd+0xb6>
 12c:	fa 94       	dec	r15
 12e:	01 f4       	brne	.+0      	; 0x130 <send_cmd+0xba>

	return res;							/* Return with the response value */

}
 130:	26 96       	adiw	r28, 0x06	; 6
 132:	0f b6       	in	r0, 0x3f	; 63
 134:	f8 94       	cli
 136:	de bf       	out	0x3e, r29	; 62
 138:	0f be       	out	0x3f, r0	; 63
 13a:	cd bf       	out	0x3d, r28	; 61
 13c:	df 91       	pop	r29
 13e:	cf 91       	pop	r28
 140:	1f 91       	pop	r17
 142:	0f 91       	pop	r16
 144:	ff 90       	pop	r15
 146:	ef 90       	pop	r14
 148:	df 90       	pop	r13
 14a:	cf 90       	pop	r12
 14c:	bf 90       	pop	r11
 14e:	08 95       	ret

00000150 <rcvr_datablock>:
		return FALSE;
	}
	return TRUE;
}

static boolean rcvr_datablock(SD_CARD* card, uint8_t *buff, size_t btr ){
 150:	af 92       	push	r10
 152:	bf 92       	push	r11
 154:	cf 92       	push	r12
 156:	df 92       	push	r13
 158:	ef 92       	push	r14
 15a:	ff 92       	push	r15
 15c:	0f 93       	push	r16
 15e:	1f 93       	push	r17
 160:	cf 93       	push	r28
 162:	df 93       	push	r29
 164:	b8 2e       	mov	r11, r24
 166:	a9 2e       	mov	r10, r25
 168:	eb 01       	movw	r28, r22
 16a:	8a 01       	movw	r16, r20
	uint8_t token;


	TICK_COUNT Timer1 = clockGetus();
 16c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 170:	6b 01       	movw	r12, r22
 172:	7c 01       	movw	r14, r24
	do {							/* Wait for data packet in timeout of 200ms */
		token = receive(card);
 174:	8b 2d       	mov	r24, r11
 176:	9a 2d       	mov	r25, r10
 178:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	} while ((token != 0xFE) && !clockHasElapsed(Timer1, 200000));
 17c:	8e 3f       	cpi	r24, 0xFE	; 254
 17e:	01 f0       	breq	.+0      	; 0x180 <rcvr_datablock+0x30>
 180:	20 e4       	ldi	r18, 0x40	; 64
 182:	3d e0       	ldi	r19, 0x0D	; 13
 184:	43 e0       	ldi	r20, 0x03	; 3
 186:	50 e0       	ldi	r21, 0x00	; 0
 188:	c7 01       	movw	r24, r14
 18a:	b6 01       	movw	r22, r12
 18c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 190:	88 23       	and	r24, r24
 192:	01 f0       	breq	.+0      	; 0x194 <rcvr_datablock+0x44>

	spiDeviceReceiveBytes(card, buff,btr);
 194:	a8 01       	movw	r20, r16
 196:	be 01       	movw	r22, r28
 198:	8b 2d       	mov	r24, r11
 19a:	9a 2d       	mov	r25, r10
 19c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	spiDeviceReceiveWord(card);		/* Discard CRC */
 1a0:	8b 2d       	mov	r24, r11
 1a2:	9a 2d       	mov	r25, r10
 1a4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	return TRUE;					/* Return with success */
}
 1a8:	8f ef       	ldi	r24, 0xFF	; 255
 1aa:	df 91       	pop	r29
 1ac:	cf 91       	pop	r28
 1ae:	1f 91       	pop	r17
 1b0:	0f 91       	pop	r16
 1b2:	ff 90       	pop	r15
 1b4:	ef 90       	pop	r14
 1b6:	df 90       	pop	r13
 1b8:	cf 90       	pop	r12
 1ba:	bf 90       	pop	r11
 1bc:	af 90       	pop	r10
 1be:	08 95       	ret

000001c0 <xmit_datablock>:

static boolean xmit_datablock(SD_CARD* card, const uint8_t *buff, uint8_t token){
 1c0:	ff 92       	push	r15
 1c2:	0f 93       	push	r16
 1c4:	1f 93       	push	r17
 1c6:	cf 93       	push	r28
 1c8:	df 93       	push	r29
 1ca:	8c 01       	movw	r16, r24
 1cc:	eb 01       	movw	r28, r22
 1ce:	f4 2e       	mov	r15, r20
	if (wait_ready(card) != 0xFF){
 1d0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 1d4:	8f 3f       	cpi	r24, 0xFF	; 255
 1d6:	01 f4       	brne	.+0      	; 0x1d8 <xmit_datablock+0x18>

static void xmit(const SD_CARD* card, uint8_t byte){
	#ifdef DEBUG_SD
	rprintf(">0x");rprintfu08(byte);
	#endif
	spiDeviceSendByte(card,byte);
 1d8:	6f 2d       	mov	r22, r15
 1da:	c8 01       	movw	r24, r16
 1dc:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	if (wait_ready(card) != 0xFF){
		return FALSE;
	}

	xmit(card,token);					/* Xmit data token */
	if (token != 0xFD) {				/* Is data token */
 1e0:	8d ef       	ldi	r24, 0xFD	; 253
 1e2:	f8 16       	cp	r15, r24
 1e4:	01 f0       	breq	.+0      	; 0x1e6 <xmit_datablock+0x26>

		spiDeviceSendBytes(card, buff, 512);
 1e6:	40 e0       	ldi	r20, 0x00	; 0
 1e8:	52 e0       	ldi	r21, 0x02	; 2
 1ea:	be 01       	movw	r22, r28
 1ec:	c8 01       	movw	r24, r16
 1ee:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		spiDeviceSendWord(card,0xFFFF); /* CRC (Dummy)		*/
 1f2:	6f ef       	ldi	r22, 0xFF	; 255
 1f4:	7f ef       	ldi	r23, 0xFF	; 255
 1f6:	c8 01       	movw	r24, r16
 1f8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		uint8_t resp = receive(card);	/* Reveive data response token */
 1fc:	c8 01       	movw	r24, r16
 1fe:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
 202:	8f 71       	andi	r24, 0x1F	; 31
 204:	85 30       	cpi	r24, 0x05	; 5
 206:	01 f0       	breq	.+0      	; 0x208 <xmit_datablock+0x48>
	return TRUE;					/* Return with success */
}

static boolean xmit_datablock(SD_CARD* card, const uint8_t *buff, uint8_t token){
	if (wait_ready(card) != 0xFF){
		return FALSE;
 208:	80 e0       	ldi	r24, 0x00	; 0
 20a:	00 c0       	rjmp	.+0      	; 0x20c <xmit_datablock+0x4c>
		uint8_t resp = receive(card);	/* Reveive data response token */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return FALSE;
	}

	return TRUE;
 20c:	8f ef       	ldi	r24, 0xFF	; 255
}
 20e:	df 91       	pop	r29
 210:	cf 91       	pop	r28
 212:	1f 91       	pop	r17
 214:	0f 91       	pop	r16
 216:	ff 90       	pop	r15
 218:	08 95       	ret

0000021a <sdCardInit>:
	}
	return rtn;
}


boolean sdCardInit(SD_CARD* card){
 21a:	6f 92       	push	r6
 21c:	7f 92       	push	r7
 21e:	8f 92       	push	r8
 220:	9f 92       	push	r9
 222:	af 92       	push	r10
 224:	bf 92       	push	r11
 226:	cf 92       	push	r12
 228:	df 92       	push	r13
 22a:	ef 92       	push	r14
 22c:	ff 92       	push	r15
 22e:	0f 93       	push	r16
 230:	1f 93       	push	r17
 232:	cf 93       	push	r28
 234:	df 93       	push	r29
 236:	cd b7       	in	r28, 0x3d	; 61
 238:	de b7       	in	r29, 0x3e	; 62
 23a:	60 97       	sbiw	r28, 0x10	; 16
 23c:	0f b6       	in	r0, 0x3f	; 63
 23e:	f8 94       	cli
 240:	de bf       	out	0x3e, r29	; 62
 242:	0f be       	out	0x3f, r0	; 63
 244:	cd bf       	out	0x3d, r28	; 61
 246:	8c 01       	movw	r16, r24
 248:	f4 e6       	ldi	r31, 0x64	; 100
 24a:	ff 2e       	mov	r15, r31
	#ifdef DEBUG_SD
	rprintf("\nStart: sdCard init\n");
	#endif

	for (n = 100; n; n--)
		receive(card);							/* dummy clocks */
 24c:	c8 01       	movw	r24, r16
 24e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 252:	fa 94       	dec	r15

	#ifdef DEBUG_SD
	rprintf("\nStart: sdCard init\n");
	#endif

	for (n = 100; n; n--)
 254:	01 f4       	brne	.+0      	; 0x256 <sdCardInit+0x3c>
		receive(card);							/* dummy clocks */

	// Helps fix re-initing a card thats try to do something
	spiDeviceSelect(card, TRUE);				// select the card
 256:	68 01       	movw	r12, r16
 258:	6f ef       	ldi	r22, 0xFF	; 255
 25a:	c8 01       	movw	r24, r16
 25c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 260:	e1 2c       	mov	r14, r1
 262:	e2 e0       	ldi	r30, 0x02	; 2
 264:	fe 2e       	mov	r15, r30
	for(uint16_t i = 512; i; i--)
		receive(card);							/* dummy clocks */
 266:	c8 01       	movw	r24, r16
 268:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	e8 1a       	sub	r14, r24
 270:	f1 08       	sbc	r15, r1
	for (n = 100; n; n--)
		receive(card);							/* dummy clocks */

	// Helps fix re-initing a card thats try to do something
	spiDeviceSelect(card, TRUE);				// select the card
	for(uint16_t i = 512; i; i--)
 272:	01 f4       	brne	.+0      	; 0x274 <sdCardInit+0x5a>
		receive(card);							/* dummy clocks */
	spiDeviceSelect(card, FALSE);				// deselect the card
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	c6 01       	movw	r24, r12
 278:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 27c:	ee 24       	eor	r14, r14
 27e:	ea 94       	dec	r14
 280:	fe 2c       	mov	r15, r14
static boolean enterIdleState(SD_CARD* card){
	for(uint16_t n=0; ; n++){
		if(n == MAX_U16){
			return FALSE;					// Timed out
		}
		if(send_cmd(card, CMD0, 0)==1){		// send command 0 - Enter idle state
 282:	20 e0       	ldi	r18, 0x00	; 0
 284:	30 e0       	ldi	r19, 0x00	; 0
 286:	a9 01       	movw	r20, r18
 288:	60 e4       	ldi	r22, 0x40	; 64
 28a:	c8 01       	movw	r24, r16
 28c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 290:	81 30       	cpi	r24, 0x01	; 1
 292:	01 f4       	brne	.+0      	; 0x294 <sdCardInit+0x7a>
 294:	00 c0       	rjmp	.+0      	; 0x296 <sdCardInit+0x7c>
 296:	e1 e0       	ldi	r30, 0x01	; 1
 298:	ee 1a       	sub	r14, r30
 29a:	f1 08       	sbc	r15, r1

}

static boolean enterIdleState(SD_CARD* card){
	for(uint16_t n=0; ; n++){
		if(n == MAX_U16){
 29c:	01 f4       	brne	.+0      	; 0x29e <sdCardInit+0x84>
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <sdCardInit+0x86>
		uint8_t ocr[4];								// remaining four bytes from R7 response
		#ifdef DEBUG_SD
		rprintf("\n**Version 2'ish**\n");
		#endif
		for (n = 0; n < 4; n++){
			ocr[n] = receive(card);					/* Get trailing return value of R7 resp */
 2a0:	c8 01       	movw	r24, r16
 2a2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2a6:	f4 01       	movw	r30, r8
 2a8:	81 93       	st	Z+, r24
 2aa:	4f 01       	movw	r8, r30
	if( (send_cmd(card,CMD8, 0x1AA)) == 1 ) {			/* SDHC */
		uint8_t ocr[4];								// remaining four bytes from R7 response
		#ifdef DEBUG_SD
		rprintf("\n**Version 2'ish**\n");
		#endif
		for (n = 0; n < 4; n++){
 2ac:	e6 15       	cp	r30, r6
 2ae:	f7 05       	cpc	r31, r7
 2b0:	01 f4       	brne	.+0      	; 0x2b2 <sdCardInit+0x98>
			ocr[n] = receive(card);					/* Get trailing return value of R7 resp */
		}
		if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
 2b2:	8b 81       	ldd	r24, Y+3	; 0x03
 2b4:	81 30       	cpi	r24, 0x01	; 1
 2b6:	01 f0       	breq	.+0      	; 0x2b8 <sdCardInit+0x9e>
 2b8:	00 c0       	rjmp	.+0      	; 0x2ba <sdCardInit+0xa0>
 2ba:	8c 81       	ldd	r24, Y+4	; 0x04
 2bc:	8a 3a       	cpi	r24, 0xAA	; 170
 2be:	01 f0       	breq	.+0      	; 0x2c0 <sdCardInit+0xa6>
 2c0:	00 c0       	rjmp	.+0      	; 0x2c2 <sdCardInit+0xa8>
			#ifdef DEBUG_SD
			rprintf("\nLeave idle state\n");
			#endif
			while(!clockHasElapsed(timer1,1000000) && send_cmd(card, ACMD41, 1UL << 30)){
 2c2:	20 e4       	ldi	r18, 0x40	; 64
 2c4:	32 e4       	ldi	r19, 0x42	; 66
 2c6:	4f e0       	ldi	r20, 0x0F	; 15
 2c8:	50 e0       	ldi	r21, 0x00	; 0
 2ca:	c7 01       	movw	r24, r14
 2cc:	b6 01       	movw	r22, r12
 2ce:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2d2:	88 23       	and	r24, r24
 2d4:	01 f0       	breq	.+0      	; 0x2d6 <sdCardInit+0xbc>
			/* Wait for leaving idle state (ACMD41 with HCS bit) */
			}

			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 2d6:	20 e4       	ldi	r18, 0x40	; 64
 2d8:	32 e4       	ldi	r19, 0x42	; 66
 2da:	4f e0       	ldi	r20, 0x0F	; 15
 2dc:	50 e0       	ldi	r21, 0x00	; 0
 2de:	c7 01       	movw	r24, r14
 2e0:	b6 01       	movw	r22, r12
 2e2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2e6:	81 11       	cpse	r24, r1
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <sdCardInit+0xd0>
 2ea:	00 c0       	rjmp	.+0      	; 0x2ec <sdCardInit+0xd2>
		}
		if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
			#ifdef DEBUG_SD
			rprintf("\nLeave idle state\n");
			#endif
			while(!clockHasElapsed(timer1,1000000) && send_cmd(card, ACMD41, 1UL << 30)){
 2ec:	20 e0       	ldi	r18, 0x00	; 0
 2ee:	30 e0       	ldi	r19, 0x00	; 0
 2f0:	40 e0       	ldi	r20, 0x00	; 0
 2f2:	50 e4       	ldi	r21, 0x40	; 64
 2f4:	69 ee       	ldi	r22, 0xE9	; 233
 2f6:	c8 01       	movw	r24, r16
 2f8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2fc:	81 11       	cpse	r24, r1
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <sdCardInit+0xe6>
 300:	00 c0       	rjmp	.+0      	; 0x302 <sdCardInit+0xe8>
			/* Wait for leaving idle state (ACMD41 with HCS bit) */
			}

			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 302:	20 e0       	ldi	r18, 0x00	; 0
 304:	30 e0       	ldi	r19, 0x00	; 0
 306:	a9 01       	movw	r20, r18
 308:	6a e7       	ldi	r22, 0x7A	; 122
 30a:	c8 01       	movw	r24, r16
 30c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 310:	81 11       	cpse	r24, r1
 312:	00 c0       	rjmp	.+0      	; 0x314 <sdCardInit+0xfa>
				#ifdef DEBUG_SD
				rprintf("\nGet card type\n");
				#endif
				for (n = 0; n < 4; n++){
					ocr[n] = receive(card);
 314:	c8 01       	movw	r24, r16
 316:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 31a:	f5 01       	movw	r30, r10
 31c:	81 93       	st	Z+, r24
 31e:	5f 01       	movw	r10, r30

			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
				#ifdef DEBUG_SD
				rprintf("\nGet card type\n");
				#endif
				for (n = 0; n < 4; n++){
 320:	e6 15       	cp	r30, r6
 322:	f7 05       	cpc	r31, r7
 324:	01 f4       	brne	.+0      	; 0x326 <sdCardInit+0x10c>
					ocr[n] = receive(card);
				}
				cardType = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
 326:	89 81       	ldd	r24, Y+1	; 0x01
 328:	86 ff       	sbrs	r24, 6
 32a:	00 c0       	rjmp	.+0      	; 0x32c <sdCardInit+0x112>
 32c:	7c e0       	ldi	r23, 0x0C	; 12
 32e:	b7 2e       	mov	r11, r23
 330:	00 c0       	rjmp	.+0      	; 0x332 <sdCardInit+0x118>
 332:	64 e0       	ldi	r22, 0x04	; 4
 334:	b6 2e       	mov	r11, r22
 336:	00 c0       	rjmp	.+0      	; 0x338 <sdCardInit+0x11e>
		}
	} else {							/* SDSC or MMC */
		#ifdef DEBUG_SD
		rprintf("\n**Version 1'ish**\n");
		#endif
		if (send_cmd(card, ACMD41, 0) <= 1) 	{
 338:	20 e0       	ldi	r18, 0x00	; 0
 33a:	30 e0       	ldi	r19, 0x00	; 0
 33c:	a9 01       	movw	r20, r18
 33e:	69 ee       	ldi	r22, 0xE9	; 233
 340:	c8 01       	movw	r24, r16
 342:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 346:	82 30       	cpi	r24, 0x02	; 2
 348:	00 f4       	brcc	.+0      	; 0x34a <sdCardInit+0x130>
			cardType = CT_SD1;
 34a:	42 e0       	ldi	r20, 0x02	; 2
 34c:	b4 2e       	mov	r11, r20
			cmd = ACMD41;				/* SDv1 */
 34e:	59 ee       	ldi	r21, 0xE9	; 233
 350:	a5 2e       	mov	r10, r21
 352:	00 c0       	rjmp	.+0      	; 0x354 <sdCardInit+0x13a>
		} else {
			cardType = CT_MMC;
 354:	bb 24       	eor	r11, r11
 356:	b3 94       	inc	r11
			cmd = CMD1;					/* MMCv3 */
 358:	31 e4       	ldi	r19, 0x41	; 65
 35a:	a3 2e       	mov	r10, r19
		}
		#ifdef DEBUG_SD
		rprintf("\nCard type:%u\n",cardType);
		rprintf("\nLeaving idle state\n");
		#endif
		while(!clockHasElapsed(timer1,1000000) && send_cmd(card, cmd, 0)){	/* Wait for leaving idle state */
 35c:	20 e4       	ldi	r18, 0x40	; 64
 35e:	32 e4       	ldi	r19, 0x42	; 66
 360:	4f e0       	ldi	r20, 0x0F	; 15
 362:	50 e0       	ldi	r21, 0x00	; 0
 364:	c7 01       	movw	r24, r14
 366:	b6 01       	movw	r22, r12
 368:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 36c:	88 23       	and	r24, r24
 36e:	01 f0       	breq	.+0      	; 0x370 <sdCardInit+0x156>
		}

		if (clockHasElapsed(timer1,1000000) || send_cmd( card, CMD16, 512) != 0){	/* Set R/W block length to 512 */
 370:	20 e4       	ldi	r18, 0x40	; 64
 372:	32 e4       	ldi	r19, 0x42	; 66
 374:	4f e0       	ldi	r20, 0x0F	; 15
 376:	50 e0       	ldi	r21, 0x00	; 0
 378:	c7 01       	movw	r24, r14
 37a:	b6 01       	movw	r22, r12
 37c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 380:	81 11       	cpse	r24, r1
 382:	00 c0       	rjmp	.+0      	; 0x384 <sdCardInit+0x16a>
 384:	00 c0       	rjmp	.+0      	; 0x386 <sdCardInit+0x16c>
		}
		#ifdef DEBUG_SD
		rprintf("\nCard type:%u\n",cardType);
		rprintf("\nLeaving idle state\n");
		#endif
		while(!clockHasElapsed(timer1,1000000) && send_cmd(card, cmd, 0)){	/* Wait for leaving idle state */
 386:	20 e0       	ldi	r18, 0x00	; 0
 388:	30 e0       	ldi	r19, 0x00	; 0
 38a:	a9 01       	movw	r20, r18
 38c:	6a 2d       	mov	r22, r10
 38e:	c8 01       	movw	r24, r16
 390:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 394:	81 11       	cpse	r24, r1
 396:	00 c0       	rjmp	.+0      	; 0x398 <sdCardInit+0x17e>
 398:	00 c0       	rjmp	.+0      	; 0x39a <sdCardInit+0x180>
		}

		if (clockHasElapsed(timer1,1000000) || send_cmd( card, CMD16, 512) != 0){	/* Set R/W block length to 512 */
 39a:	20 e0       	ldi	r18, 0x00	; 0
 39c:	32 e0       	ldi	r19, 0x02	; 2
 39e:	40 e0       	ldi	r20, 0x00	; 0
 3a0:	50 e0       	ldi	r21, 0x00	; 0
 3a2:	60 e5       	ldi	r22, 0x50	; 80
 3a4:	c8 01       	movw	r24, r16
 3a6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3aa:	81 11       	cpse	r24, r1
 3ac:	00 c0       	rjmp	.+0      	; 0x3ae <sdCardInit+0x194>
static uint32_t getTotalDiskSectors(SD_CARD* card){
	uint32_t rtn = 0;
	uint8_t csd[16];
	uint16_t csize;

	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
 3ae:	20 e0       	ldi	r18, 0x00	; 0
 3b0:	30 e0       	ldi	r19, 0x00	; 0
 3b2:	a9 01       	movw	r20, r18
 3b4:	69 e4       	ldi	r22, 0x49	; 73
 3b6:	c8 01       	movw	r24, r16
 3b8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3bc:	88 23       	and	r24, r24
 3be:	01 f0       	breq	.+0      	; 0x3c0 <sdCardInit+0x1a6>
	}
	return TRUE;
}

static uint32_t getTotalDiskSectors(SD_CARD* card){
	uint32_t rtn = 0;
 3c0:	40 e0       	ldi	r20, 0x00	; 0
 3c2:	50 e0       	ldi	r21, 0x00	; 0
 3c4:	ba 01       	movw	r22, r20
 3c6:	00 c0       	rjmp	.+0      	; 0x3c8 <sdCardInit+0x1ae>
	uint8_t csd[16];
	uint16_t csize;

	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
 3c8:	40 e1       	ldi	r20, 0x10	; 16
 3ca:	50 e0       	ldi	r21, 0x00	; 0
 3cc:	be 01       	movw	r22, r28
 3ce:	6f 5f       	subi	r22, 0xFF	; 255
 3d0:	7f 4f       	sbci	r23, 0xFF	; 255
 3d2:	c8 01       	movw	r24, r16
 3d4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3d8:	88 23       	and	r24, r24
 3da:	01 f0       	breq	.+0      	; 0x3dc <sdCardInit+0x1c2>
		if ((csd[0] >> 6) == 1) {						/* SDC ver 2.00 */
 3dc:	89 81       	ldd	r24, Y+1	; 0x01
 3de:	82 95       	swap	r24
 3e0:	86 95       	lsr	r24
 3e2:	86 95       	lsr	r24
 3e4:	83 70       	andi	r24, 0x03	; 3
 3e6:	29 85       	ldd	r18, Y+9	; 0x09
 3e8:	81 30       	cpi	r24, 0x01	; 1
 3ea:	01 f4       	brne	.+0      	; 0x3ec <sdCardInit+0x1d2>
			csize = csd[9] + ((uint16_t)csd[8] << 8) + 1;
 3ec:	4a 85       	ldd	r20, Y+10	; 0x0a
 3ee:	50 e0       	ldi	r21, 0x00	; 0
 3f0:	4f 5f       	subi	r20, 0xFF	; 255
 3f2:	5f 4f       	sbci	r21, 0xFF	; 255
 3f4:	92 2f       	mov	r25, r18
 3f6:	80 e0       	ldi	r24, 0x00	; 0
 3f8:	48 0f       	add	r20, r24
 3fa:	59 1f       	adc	r21, r25
			rtn = (uint32_t)csize << 10;
 3fc:	60 e0       	ldi	r22, 0x00	; 0
 3fe:	70 e0       	ldi	r23, 0x00	; 0
 400:	2a e0       	ldi	r18, 0x0A	; 10
 402:	44 0f       	add	r20, r20
 404:	55 1f       	adc	r21, r21
 406:	66 1f       	adc	r22, r22
 408:	77 1f       	adc	r23, r23
 40a:	2a 95       	dec	r18
 40c:	01 f4       	brne	.+0      	; 0x40e <sdCardInit+0x1f4>
 40e:	00 c0       	rjmp	.+0      	; 0x410 <sdCardInit+0x1f6>
		} else {										/* SDC ver 1.XX or MMC*/
			uint8_t n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
			csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1;
 410:	22 95       	swap	r18
 412:	26 95       	lsr	r18
 414:	26 95       	lsr	r18
 416:	23 70       	andi	r18, 0x03	; 3
 418:	48 85       	ldd	r20, Y+8	; 0x08
 41a:	f4 e0       	ldi	r31, 0x04	; 4
 41c:	4f 9f       	mul	r20, r31
 41e:	a0 01       	movw	r20, r0
 420:	11 24       	eor	r1, r1
 422:	42 0f       	add	r20, r18
 424:	51 1d       	adc	r21, r1
 426:	4f 5f       	subi	r20, 0xFF	; 255
 428:	5f 4f       	sbci	r21, 0xFF	; 255
 42a:	2f 81       	ldd	r18, Y+7	; 0x07
 42c:	23 70       	andi	r18, 0x03	; 3
 42e:	92 2f       	mov	r25, r18
 430:	99 0f       	add	r25, r25
 432:	99 0f       	add	r25, r25
 434:	80 e0       	ldi	r24, 0x00	; 0
 436:	48 0f       	add	r20, r24
 438:	59 1f       	adc	r21, r25
			rtn = (uint32_t)csize << (n - 9);
 43a:	60 e0       	ldi	r22, 0x00	; 0
 43c:	70 e0       	ldi	r23, 0x00	; 0
	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
		if ((csd[0] >> 6) == 1) {						/* SDC ver 2.00 */
			csize = csd[9] + ((uint16_t)csd[8] << 8) + 1;
			rtn = (uint32_t)csize << 10;
		} else {										/* SDC ver 1.XX or MMC*/
			uint8_t n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 43e:	8e 81       	ldd	r24, Y+6	; 0x06
 440:	8f 70       	andi	r24, 0x0F	; 15
 442:	9b 85       	ldd	r25, Y+11	; 0x0b
 444:	99 1f       	adc	r25, r25
 446:	99 27       	eor	r25, r25
 448:	99 1f       	adc	r25, r25
 44a:	89 0f       	add	r24, r25
 44c:	8e 5f       	subi	r24, 0xFE	; 254
 44e:	9a 85       	ldd	r25, Y+10	; 0x0a
 450:	93 70       	andi	r25, 0x03	; 3
 452:	99 0f       	add	r25, r25
 454:	89 0f       	add	r24, r25
			csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1;
			rtn = (uint32_t)csize << (n - 9);
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	09 97       	sbiw	r24, 0x09	; 9
 45a:	00 c0       	rjmp	.+0      	; 0x45c <sdCardInit+0x242>
 45c:	44 0f       	add	r20, r20
 45e:	55 1f       	adc	r21, r21
 460:	66 1f       	adc	r22, r22
 462:	77 1f       	adc	r23, r23
 464:	8a 95       	dec	r24
 466:	02 f4       	brpl	.+0      	; 0x468 <sdCardInit+0x24e>
			#endif
		}
	}

	if(cardType){
		card->numSectors = getTotalDiskSectors(card);
 468:	f8 01       	movw	r30, r16
 46a:	41 87       	std	Z+9, r20	; 0x09
 46c:	52 87       	std	Z+10, r21	; 0x0a
 46e:	63 87       	std	Z+11, r22	; 0x0b
 470:	74 87       	std	Z+12, r23	; 0x0c
exit:
	#ifdef DEBUG_SD
	rprintf("\nFinished\n");
	#endif

	deselect(card);
 472:	c8 01       	movw	r24, r16
 474:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if (cardType) {			/* Initialization succeded */
 478:	b1 10       	cpse	r11, r1
 47a:	00 c0       	rjmp	.+0      	; 0x47c <sdCardInit+0x262>
	return rtn;
}


boolean sdCardInit(SD_CARD* card){
	boolean rtn = FALSE;
 47c:	80 e0       	ldi	r24, 0x00	; 0
 47e:	00 c0       	rjmp	.+0      	; 0x480 <sdCardInit+0x266>
	#endif

	deselect(card);

	if (cardType) {			/* Initialization succeded */
		rtn = TRUE;
 480:	8f ef       	ldi	r24, 0xFF	; 255
		rprintf("Success: Card Type=%d\n",cardType);
	}else{
		rprintf("Failure\n");
	}
	#endif
	card->cardType = cardType;
 482:	f8 01       	movw	r30, r16
 484:	b5 86       	std	Z+13, r11	; 0x0d
	card->initialised=rtn;
 486:	80 87       	std	Z+8, r24	; 0x08
 488:	00 c0       	rjmp	.+0      	; 0x48a <sdCardInit+0x270>
		rprintf("\nEnter idle state FAILED\n");
		#endif
		goto exit;
	}

	TICK_COUNT timer1 = clockGetus();				/* Initialization timeout of 1 second */
 48a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 48e:	6b 01       	movw	r12, r22
 490:	7c 01       	movw	r14, r24


	// CMD8 is new to version 2
	if( (send_cmd(card,CMD8, 0x1AA)) == 1 ) {			/* SDHC */
 492:	2a ea       	ldi	r18, 0xAA	; 170
 494:	31 e0       	ldi	r19, 0x01	; 1
 496:	40 e0       	ldi	r20, 0x00	; 0
 498:	50 e0       	ldi	r21, 0x00	; 0
 49a:	68 e4       	ldi	r22, 0x48	; 72
 49c:	c8 01       	movw	r24, r16
 49e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 4a2:	81 30       	cpi	r24, 0x01	; 1
 4a4:	01 f0       	breq	.+0      	; 0x4a6 <sdCardInit+0x28c>
 4a6:	00 c0       	rjmp	.+0      	; 0x4a8 <sdCardInit+0x28e>
 4a8:	aa 24       	eor	r10, r10
 4aa:	a3 94       	inc	r10
 4ac:	b1 2c       	mov	r11, r1
 4ae:	ac 0e       	add	r10, r28
 4b0:	bd 1e       	adc	r11, r29
	}
	return rtn;
}


boolean sdCardInit(SD_CARD* card){
 4b2:	3e 01       	movw	r6, r28
 4b4:	f5 e0       	ldi	r31, 0x05	; 5
 4b6:	6f 0e       	add	r6, r31
 4b8:	71 1c       	adc	r7, r1
 4ba:	45 01       	movw	r8, r10
 4bc:	00 c0       	rjmp	.+0      	; 0x4be <sdCardInit+0x2a4>
	boolean rtn = FALSE;

	uint8_t n;
	uint8_t cmd;
	uint8_t cardType = 0;
 4be:	b1 2c       	mov	r11, r1
 4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <sdCardInit+0x2a8>
	card->cardType = cardType;
	card->initialised=rtn;
	return rtn;


}
 4c2:	60 96       	adiw	r28, 0x10	; 16
 4c4:	0f b6       	in	r0, 0x3f	; 63
 4c6:	f8 94       	cli
 4c8:	de bf       	out	0x3e, r29	; 62
 4ca:	0f be       	out	0x3f, r0	; 63
 4cc:	cd bf       	out	0x3d, r28	; 61
 4ce:	df 91       	pop	r29
 4d0:	cf 91       	pop	r28
 4d2:	1f 91       	pop	r17
 4d4:	0f 91       	pop	r16
 4d6:	ff 90       	pop	r15
 4d8:	ef 90       	pop	r14
 4da:	df 90       	pop	r13
 4dc:	cf 90       	pop	r12
 4de:	bf 90       	pop	r11
 4e0:	af 90       	pop	r10
 4e2:	9f 90       	pop	r9
 4e4:	8f 90       	pop	r8
 4e6:	7f 90       	pop	r7
 4e8:	6f 90       	pop	r6
 4ea:	08 95       	ret

000004ec <sdCardRead>:

boolean sdCardRead(SD_CARD* card,uint32_t absSector,void* dta,uint8_t numSectors){
 4ec:	ef 92       	push	r14
 4ee:	ff 92       	push	r15
 4f0:	0f 93       	push	r16
 4f2:	cf 93       	push	r28
 4f4:	df 93       	push	r29
 4f6:	ec 01       	movw	r28, r24
 4f8:	79 01       	movw	r14, r18
	if(card->initialised && numSectors!=0 && dta){
 4fa:	88 85       	ldd	r24, Y+8	; 0x08
 4fc:	88 23       	and	r24, r24
 4fe:	01 f4       	brne	.+0      	; 0x500 <sdCardRead+0x14>
 500:	00 c0       	rjmp	.+0      	; 0x502 <sdCardRead+0x16>
 502:	01 11       	cpse	r16, r1
 504:	00 c0       	rjmp	.+0      	; 0x506 <sdCardRead+0x1a>
				send_cmd(card, CMD12, 0);				/* STOP_TRANSMISSION */
			}
		}
		deselect(card);
	}
	return (numSectors==0) ? TRUE : FALSE;
 506:	8f ef       	ldi	r24, 0xFF	; 255
 508:	00 c0       	rjmp	.+0      	; 0x50a <sdCardRead+0x1e>


}

boolean sdCardRead(SD_CARD* card,uint32_t absSector,void* dta,uint8_t numSectors){
	if(card->initialised && numSectors!=0 && dta){
 50a:	21 15       	cp	r18, r1
 50c:	31 05       	cpc	r19, r1
 50e:	01 f4       	brne	.+0      	; 0x510 <sdCardRead+0x24>
				send_cmd(card, CMD12, 0);				/* STOP_TRANSMISSION */
			}
		}
		deselect(card);
	}
	return (numSectors==0) ? TRUE : FALSE;
 510:	80 e0       	ldi	r24, 0x00	; 0
 512:	00 c0       	rjmp	.+0      	; 0x514 <sdCardRead+0x28>
}

boolean sdCardRead(SD_CARD* card,uint32_t absSector,void* dta,uint8_t numSectors){
	if(card->initialised && numSectors!=0 && dta){
		// convert sector to address
		uint32_t address = (card->cardType & CT_BLOCK) ? absSector : absSector * 512;
 514:	8d 85       	ldd	r24, Y+13	; 0x0d
 516:	9a 01       	movw	r18, r20
 518:	ab 01       	movw	r20, r22
 51a:	83 fd       	sbrc	r24, 3
 51c:	00 c0       	rjmp	.+0      	; 0x51e <sdCardRead+0x32>
 51e:	a9 e0       	ldi	r26, 0x09	; 9
 520:	22 0f       	add	r18, r18
 522:	33 1f       	adc	r19, r19
 524:	44 1f       	adc	r20, r20
 526:	55 1f       	adc	r21, r21
 528:	aa 95       	dec	r26
 52a:	01 f4       	brne	.+0      	; 0x52c <sdCardRead+0x40>

		if(numSectors==1){
 52c:	01 30       	cpi	r16, 0x01	; 1
 52e:	01 f4       	brne	.+0      	; 0x530 <sdCardRead+0x44>
			/* READ_SINGLE_BLOCK */
			if ((send_cmd(card, CMD17, address) == 0)
 530:	61 e5       	ldi	r22, 0x51	; 81
 532:	ce 01       	movw	r24, r28
 534:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 538:	81 11       	cpse	r24, r1
 53a:	00 c0       	rjmp	.+0      	; 0x53c <sdCardRead+0x50>
				&& rcvr_datablock(card,dta, 512)){
 53c:	40 e0       	ldi	r20, 0x00	; 0
 53e:	52 e0       	ldi	r21, 0x02	; 2
 540:	b7 01       	movw	r22, r14
 542:	ce 01       	movw	r24, r28
 544:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 548:	88 23       	and	r24, r24
 54a:	01 f0       	breq	.+0      	; 0x54c <sdCardRead+0x60>
 54c:	00 e0       	ldi	r16, 0x00	; 0
 54e:	00 c0       	rjmp	.+0      	; 0x550 <sdCardRead+0x64>
				numSectors = 0;
			}
		}else{
			/* READ_MULTIPLE_BLOCKS */
			if(send_cmd(card, CMD18, address) == 0){
 550:	62 e5       	ldi	r22, 0x52	; 82
 552:	ce 01       	movw	r24, r28
 554:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 558:	81 11       	cpse	r24, r1
 55a:	00 c0       	rjmp	.+0      	; 0x55c <sdCardRead+0x70>
				do {
					if (!rcvr_datablock(card, dta, 512))
 55c:	40 e0       	ldi	r20, 0x00	; 0
 55e:	52 e0       	ldi	r21, 0x02	; 2
 560:	b7 01       	movw	r22, r14
 562:	ce 01       	movw	r24, r28
 564:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 568:	88 23       	and	r24, r24
 56a:	01 f0       	breq	.+0      	; 0x56c <sdCardRead+0x80>
						break;
					dta += 512;
 56c:	8e ef       	ldi	r24, 0xFE	; 254
 56e:	f8 1a       	sub	r15, r24
				} while (--numSectors);
 570:	01 50       	subi	r16, 0x01	; 1
 572:	01 f4       	brne	.+0      	; 0x574 <sdCardRead+0x88>
				send_cmd(card, CMD12, 0);				/* STOP_TRANSMISSION */
 574:	20 e0       	ldi	r18, 0x00	; 0
 576:	30 e0       	ldi	r19, 0x00	; 0
 578:	a9 01       	movw	r20, r18
 57a:	6c e4       	ldi	r22, 0x4C	; 76
 57c:	ce 01       	movw	r24, r28
 57e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
			}
		}
		deselect(card);
 582:	ce 01       	movw	r24, r28
 584:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}
	return (numSectors==0) ? TRUE : FALSE;
 588:	01 11       	cpse	r16, r1
 58a:	00 c0       	rjmp	.+0      	; 0x58c <sdCardRead+0xa0>
 58c:	00 c0       	rjmp	.+0      	; 0x58e <sdCardRead+0xa2>
}
 58e:	df 91       	pop	r29
 590:	cf 91       	pop	r28
 592:	0f 91       	pop	r16
 594:	ff 90       	pop	r15
 596:	ef 90       	pop	r14
 598:	08 95       	ret

0000059a <disk_read>:
	}

	return (numSectors==0) ? TRUE : FALSE;
}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 59a:	0f 93       	push	r16
	SD_CARD* card = (SD_CARD*)device;
	return sdCardRead(card, absSector,dta,1);
 59c:	01 e0       	ldi	r16, 0x01	; 1
 59e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 5a2:	0f 91       	pop	r16
 5a4:	08 95       	ret

000005a6 <sdCardWrite>:
		deselect(card);
	}
	return (numSectors==0) ? TRUE : FALSE;
}

boolean sdCardWrite(SD_CARD* card, uint32_t absSector,const void* dta,uint8_t numSectors){
 5a6:	af 92       	push	r10
 5a8:	bf 92       	push	r11
 5aa:	cf 92       	push	r12
 5ac:	df 92       	push	r13
 5ae:	ef 92       	push	r14
 5b0:	ff 92       	push	r15
 5b2:	0f 93       	push	r16
 5b4:	cf 93       	push	r28
 5b6:	df 93       	push	r29
 5b8:	ec 01       	movw	r28, r24
 5ba:	59 01       	movw	r10, r18
	if(card->initialised && numSectors!=0 && dta){
 5bc:	88 85       	ldd	r24, Y+8	; 0x08
 5be:	88 23       	and	r24, r24
 5c0:	01 f4       	brne	.+0      	; 0x5c2 <sdCardWrite+0x1c>
 5c2:	00 c0       	rjmp	.+0      	; 0x5c4 <sdCardWrite+0x1e>
 5c4:	01 11       	cpse	r16, r1
 5c6:	00 c0       	rjmp	.+0      	; 0x5c8 <sdCardWrite+0x22>

		}
		deselect(card);
	}

	return (numSectors==0) ? TRUE : FALSE;
 5c8:	8f ef       	ldi	r24, 0xFF	; 255
 5ca:	00 c0       	rjmp	.+0      	; 0x5cc <sdCardWrite+0x26>
	}
	return (numSectors==0) ? TRUE : FALSE;
}

boolean sdCardWrite(SD_CARD* card, uint32_t absSector,const void* dta,uint8_t numSectors){
	if(card->initialised && numSectors!=0 && dta){
 5cc:	21 15       	cp	r18, r1
 5ce:	31 05       	cpc	r19, r1
 5d0:	01 f4       	brne	.+0      	; 0x5d2 <sdCardWrite+0x2c>

		}
		deselect(card);
	}

	return (numSectors==0) ? TRUE : FALSE;
 5d2:	80 e0       	ldi	r24, 0x00	; 0
 5d4:	00 c0       	rjmp	.+0      	; 0x5d6 <sdCardWrite+0x30>
}

boolean sdCardWrite(SD_CARD* card, uint32_t absSector,const void* dta,uint8_t numSectors){
	if(card->initialised && numSectors!=0 && dta){
		// convert sector to address
		uint32_t address = (card->cardType & CT_BLOCK) ? absSector : absSector * 512;
 5d6:	8d 85       	ldd	r24, Y+13	; 0x0d
 5d8:	6a 01       	movw	r12, r20
 5da:	7b 01       	movw	r14, r22
 5dc:	83 fd       	sbrc	r24, 3
 5de:	00 c0       	rjmp	.+0      	; 0x5e0 <sdCardWrite+0x3a>
 5e0:	b9 e0       	ldi	r27, 0x09	; 9
 5e2:	cc 0c       	add	r12, r12
 5e4:	dd 1c       	adc	r13, r13
 5e6:	ee 1c       	adc	r14, r14
 5e8:	ff 1c       	adc	r15, r15
 5ea:	ba 95       	dec	r27
 5ec:	01 f4       	brne	.+0      	; 0x5ee <sdCardWrite+0x48>

		if(numSectors == 1){
 5ee:	01 30       	cpi	r16, 0x01	; 1
 5f0:	01 f4       	brne	.+0      	; 0x5f2 <sdCardWrite+0x4c>
			/* WRITE_BLOCK */
			if ((send_cmd(card, CMD24, address) == 0)
 5f2:	a7 01       	movw	r20, r14
 5f4:	96 01       	movw	r18, r12
 5f6:	68 e5       	ldi	r22, 0x58	; 88
 5f8:	ce 01       	movw	r24, r28
 5fa:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 5fe:	81 11       	cpse	r24, r1
 600:	00 c0       	rjmp	.+0      	; 0x602 <sdCardWrite+0x5c>
				&& xmit_datablock(card, dta, 0xFE)){
 602:	4e ef       	ldi	r20, 0xFE	; 254
 604:	b5 01       	movw	r22, r10
 606:	ce 01       	movw	r24, r28
 608:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 60c:	88 23       	and	r24, r24
 60e:	01 f0       	breq	.+0      	; 0x610 <sdCardWrite+0x6a>
 610:	00 e0       	ldi	r16, 0x00	; 0
 612:	00 c0       	rjmp	.+0      	; 0x614 <sdCardWrite+0x6e>
				numSectors = 0;
			}
		}else{
			if (card->cardType & CT_SDC)
 614:	86 70       	andi	r24, 0x06	; 6
 616:	01 f0       	breq	.+0      	; 0x618 <sdCardWrite+0x72>
				send_cmd(card, ACMD23, numSectors);
 618:	20 2f       	mov	r18, r16
 61a:	30 e0       	ldi	r19, 0x00	; 0
 61c:	40 e0       	ldi	r20, 0x00	; 0
 61e:	50 e0       	ldi	r21, 0x00	; 0
 620:	67 ed       	ldi	r22, 0xD7	; 215
 622:	ce 01       	movw	r24, r28
 624:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

			if (send_cmd(card, CMD25, address) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 628:	a7 01       	movw	r20, r14
 62a:	96 01       	movw	r18, r12
 62c:	69 e5       	ldi	r22, 0x59	; 89
 62e:	ce 01       	movw	r24, r28
 630:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 634:	81 11       	cpse	r24, r1
 636:	00 c0       	rjmp	.+0      	; 0x638 <sdCardWrite+0x92>
				do {
					if (!xmit_datablock(card,dta, 0xFC))
 638:	4c ef       	ldi	r20, 0xFC	; 252
 63a:	b5 01       	movw	r22, r10
 63c:	ce 01       	movw	r24, r28
 63e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 642:	88 23       	and	r24, r24
 644:	01 f0       	breq	.+0      	; 0x646 <sdCardWrite+0xa0>
						break;
					dta += 512;
 646:	8e ef       	ldi	r24, 0xFE	; 254
 648:	b8 1a       	sub	r11, r24
				} while (--numSectors);
 64a:	01 50       	subi	r16, 0x01	; 1
 64c:	01 f4       	brne	.+0      	; 0x64e <sdCardWrite+0xa8>

				if (!xmit_datablock(card, 0, 0xFD))	/* STOP_TRAN token */
 64e:	4d ef       	ldi	r20, 0xFD	; 253
 650:	60 e0       	ldi	r22, 0x00	; 0
 652:	70 e0       	ldi	r23, 0x00	; 0
 654:	ce 01       	movw	r24, r28
 656:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 65a:	81 11       	cpse	r24, r1
 65c:	00 c0       	rjmp	.+0      	; 0x65e <sdCardWrite+0xb8>
					numSectors = 1;					// forced error
 65e:	01 e0       	ldi	r16, 0x01	; 1
			}

		}
		deselect(card);
 660:	ce 01       	movw	r24, r28
 662:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}

	return (numSectors==0) ? TRUE : FALSE;
 666:	01 11       	cpse	r16, r1
 668:	00 c0       	rjmp	.+0      	; 0x66a <sdCardWrite+0xc4>
 66a:	00 c0       	rjmp	.+0      	; 0x66c <sdCardWrite+0xc6>
}
 66c:	df 91       	pop	r29
 66e:	cf 91       	pop	r28
 670:	0f 91       	pop	r16
 672:	ff 90       	pop	r15
 674:	ef 90       	pop	r14
 676:	df 90       	pop	r13
 678:	cf 90       	pop	r12
 67a:	bf 90       	pop	r11
 67c:	af 90       	pop	r10
 67e:	08 95       	ret

00000680 <disk_write>:
static boolean disk_read(void* device,uint32_t absSector,void* dta){
	SD_CARD* card = (SD_CARD*)device;
	return sdCardRead(card, absSector,dta,1);
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 680:	0f 93       	push	r16
	SD_CARD* card = (SD_CARD*)device;
	return sdCardWrite(card, absSector,dta,1);
 682:	01 e0       	ldi	r16, 0x01	; 1
 684:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 688:	0f 91       	pop	r16
 68a:	08 95       	ret

0000068c <sdCardGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* sdCardGetStorageClass(void){
	return &c_sdCard_disk;
}
 68c:	80 e0       	ldi	r24, 0x00	; 0
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	08 95       	ret

spiEEPROM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000039e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003d2  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  000003d2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d4c  00000000  00000000  000003d8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002cd  00000000  00000000  00001124  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000c89  00000000  00000000  000013f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000207a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000060  00000000  00000000  0000209a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001e0  00000000  00000000  000020fa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000051f  00000000  00000000  000022da  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000027f9  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000204  00000000  00000000  00002824  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
	EEPROM_ADDR addr = absSector * 512;
	spiEEPROM_writeBytes(eeprom,addr,dta,512);
	return TRUE;
}

static uint32_t disk_total_sectors(void* device){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes);

static __inline__ EEPROM_ADDR spiEEPROM_totalBytes(const SPI_EEPROM* eeprom){
	return eeprom->totalBytes;
   4:	fc 01       	movw	r30, r24
   6:	03 85       	ldd	r16, Z+11	; 0x0b
   8:	14 85       	ldd	r17, Z+12	; 0x0c
   a:	25 85       	ldd	r18, Z+13	; 0x0d
   c:	36 85       	ldd	r19, Z+14	; 0x0e
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	uint32_t sectors = spiEEPROM_totalBytes(eeprom);
	sectors /= 512;
   e:	89 e0       	ldi	r24, 0x09	; 9
  10:	36 95       	lsr	r19
  12:	27 95       	ror	r18
  14:	17 95       	ror	r17
  16:	07 95       	ror	r16
  18:	8a 95       	dec	r24
  1a:	01 f4       	brne	.+0      	; 0x1c <disk_total_sectors+0x1c>
	return sectors;
}
  1c:	b8 01       	movw	r22, r16
  1e:	c9 01       	movw	r24, r18
  20:	1f 91       	pop	r17
  22:	0f 91       	pop	r16
  24:	08 95       	ret

00000026 <address>:

	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
  26:	cf 92       	push	r12
  28:	df 92       	push	r13
  2a:	ef 92       	push	r14
  2c:	ff 92       	push	r15
  2e:	1f 93       	push	r17
  30:	cf 93       	push	r28
  32:	df 93       	push	r29
  34:	ec 01       	movw	r28, r24
  36:	6a 01       	movw	r12, r20
  38:	7b 01       	movw	r14, r22
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
  3a:	18 85       	ldd	r17, Y+8	; 0x08
  3c:	00 c0       	rjmp	.+0      	; 0x3e <address+0x18>
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
  3e:	61 2f       	mov	r22, r17
  40:	70 e0       	ldi	r23, 0x00	; 0
  42:	61 50       	subi	r22, 0x01	; 1
  44:	71 09       	sbc	r23, r1
  46:	93 e0       	ldi	r25, 0x03	; 3
  48:	66 0f       	add	r22, r22
  4a:	77 1f       	adc	r23, r23
  4c:	9a 95       	dec	r25
  4e:	01 f4       	brne	.+0      	; 0x50 <address+0x2a>
  50:	a7 01       	movw	r20, r14
  52:	96 01       	movw	r18, r12
  54:	00 c0       	rjmp	.+0      	; 0x56 <address+0x30>
  56:	56 95       	lsr	r21
  58:	47 95       	ror	r20
  5a:	37 95       	ror	r19
  5c:	27 95       	ror	r18
  5e:	6a 95       	dec	r22
  60:	02 f4       	brpl	.+0      	; 0x62 <address+0x3c>
  62:	ca 01       	movw	r24, r20
  64:	b9 01       	movw	r22, r18
		spiDeviceSendByte(eeprom, (uint8_t)shft);
  66:	ce 01       	movw	r24, r28
  68:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
  6c:	11 50       	subi	r17, 0x01	; 1
  6e:	11 11       	cpse	r17, r1
  70:	00 c0       	rjmp	.+0      	; 0x72 <address+0x4c>
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
		spiDeviceSendByte(eeprom, (uint8_t)shft);
	}
}
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	ff 90       	pop	r15
  7a:	ef 90       	pop	r14
  7c:	df 90       	pop	r13
  7e:	cf 90       	pop	r12
  80:	08 95       	ret

00000082 <spiEEPROM_readStatus>:
#define SPIEEPROM_STATUS_BP1	0x08	// Block Proection 1
#define SPIEEPROM_STATUS_WPEN	0x80	// Software Write Protect Enable


// Read the status register
static uint8_t spiEEPROM_readStatus(SPI_EEPROM* eeprom){
  82:	1f 93       	push	r17
  84:	cf 93       	push	r28
  86:	df 93       	push	r29
  88:	d8 2f       	mov	r29, r24
  8a:	c9 2f       	mov	r28, r25

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_RDSR);
  8c:	65 e0       	ldi	r22, 0x05	; 5
  8e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	// get status register value
	uint8_t status = spiDeviceReceiveByte(eeprom);
  92:	8d 2f       	mov	r24, r29
  94:	9c 2f       	mov	r25, r28
  96:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  9a:	18 2f       	mov	r17, r24

	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
  9c:	60 e0       	ldi	r22, 0x00	; 0
  9e:	8d 2f       	mov	r24, r29
  a0:	9c 2f       	mov	r25, r28
  a2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return status;
}
  a6:	81 2f       	mov	r24, r17
  a8:	df 91       	pop	r29
  aa:	cf 91       	pop	r28
  ac:	1f 91       	pop	r17
  ae:	08 95       	ret

000000b0 <spiEEPROM_readBytes>:
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
}

// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
  b0:	2f 92       	push	r2
  b2:	3f 92       	push	r3
  b4:	4f 92       	push	r4
  b6:	5f 92       	push	r5
  b8:	6f 92       	push	r6
  ba:	7f 92       	push	r7
  bc:	8f 92       	push	r8
  be:	9f 92       	push	r9
  c0:	af 92       	push	r10
  c2:	bf 92       	push	r11
  c4:	cf 92       	push	r12
  c6:	df 92       	push	r13
  c8:	ef 92       	push	r14
  ca:	ff 92       	push	r15
  cc:	0f 93       	push	r16
  ce:	1f 93       	push	r17
  d0:	cf 93       	push	r28
  d2:	df 93       	push	r29
  d4:	00 d0       	rcall	.+0      	; 0xd6 <spiEEPROM_readBytes+0x26>
  d6:	00 d0       	rcall	.+0      	; 0xd8 <spiEEPROM_readBytes+0x28>
  d8:	cd b7       	in	r28, 0x3d	; 61
  da:	de b7       	in	r29, 0x3e	; 62
  dc:	4c 01       	movw	r8, r24
  de:	cb 01       	movw	r24, r22
  e0:	ba 01       	movw	r22, r20
  e2:	39 01       	movw	r6, r18
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
  e4:	f4 01       	movw	r30, r8
  e6:	23 85       	ldd	r18, Z+11	; 0x0b
  e8:	34 85       	ldd	r19, Z+12	; 0x0c
  ea:	45 85       	ldd	r20, Z+13	; 0x0d
  ec:	56 85       	ldd	r21, Z+14	; 0x0e
  ee:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  f2:	6b 01       	movw	r12, r22
  f4:	7c 01       	movw	r14, r24
	uint8_t* pos = dest;
  f6:	53 01       	movw	r10, r6

		size_t offset = src % eeprom->pageSize;			/* Offset into the page			*/

		while(spiEEPROM_isBusy(eeprom));				/* Wait while busy				*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
  f8:	24 01       	movw	r4, r8
// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;

	while(numBytes){
  fa:	00 c0       	rjmp	.+0      	; 0xfc <spiEEPROM_readBytes+0x4c>


		size_t offset = src % eeprom->pageSize;			/* Offset into the page			*/
  fc:	f4 01       	movw	r30, r8
  fe:	21 85       	ldd	r18, Z+9	; 0x09
 100:	32 85       	ldd	r19, Z+10	; 0x0a
 102:	40 e0       	ldi	r20, 0x00	; 0
 104:	50 e0       	ldi	r21, 0x00	; 0
 106:	c7 01       	movw	r24, r14
 108:	b6 01       	movw	r22, r12
 10a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 10e:	7a 83       	std	Y+2, r23	; 0x02
 110:	69 83       	std	Y+1, r22	; 0x01
	return status;
}

// Is the chip busy doing a write?
static boolean spiEEPROM_isBusy(SPI_EEPROM* eeprom){
	uint8_t status = spiEEPROM_readStatus(eeprom);
 112:	c4 01       	movw	r24, r8
 114:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return (status & SPIEEPROM_STATUS_WIP) ? TRUE : FALSE;
 118:	80 ff       	sbrs	r24, 0
 11a:	00 c0       	rjmp	.+0      	; 0x11c <spiEEPROM_readBytes+0x6c>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <spiEEPROM_readBytes+0x6e>
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
}

// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
 11e:	35 01       	movw	r6, r10
 120:	ff ef       	ldi	r31, 0xFF	; 255
 122:	6f 1a       	sub	r6, r31
 124:	7f 0a       	sbc	r7, r31
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
		address(eeprom,src);							/* send the address				*/

		size_t bytesRead = 0;
		while(numBytes--){
			*pos++ = spiDeviceReceiveByte(eeprom);		/* read the next byte			*/
 126:	c2 01       	movw	r24, r4
 128:	4b 83       	std	Y+3, r20	; 0x03
 12a:	5c 83       	std	Y+4, r21	; 0x04
 12c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 130:	f5 01       	movw	r30, r10
 132:	80 83       	st	Z, r24
			bytesRead++;								/* one more byte read			*/
 134:	4b 81       	ldd	r20, Y+3	; 0x03
 136:	5c 81       	ldd	r21, Y+4	; 0x04
 138:	4f 5f       	subi	r20, 0xFF	; 255
 13a:	5f 4f       	sbci	r21, 0xFF	; 255
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
}

// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
 13c:	29 81       	ldd	r18, Y+1	; 0x01
 13e:	3a 81       	ldd	r19, Y+2	; 0x02
 140:	24 0f       	add	r18, r20
 142:	35 1f       	adc	r19, r21

		size_t bytesRead = 0;
		while(numBytes--){
			*pos++ = spiDeviceReceiveByte(eeprom);		/* read the next byte			*/
			bytesRead++;								/* one more byte read			*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
 144:	f4 01       	movw	r30, r8
 146:	81 85       	ldd	r24, Z+9	; 0x09
 148:	92 85       	ldd	r25, Z+10	; 0x0a
 14a:	28 17       	cp	r18, r24
 14c:	39 07       	cpc	r19, r25
 14e:	01 f0       	breq	.+0      	; 0x150 <spiEEPROM_readBytes+0xa0>
 150:	53 01       	movw	r10, r6
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
		address(eeprom,src);							/* send the address				*/

		size_t bytesRead = 0;
		while(numBytes--){
 152:	f1 e0       	ldi	r31, 0x01	; 1
 154:	2f 1a       	sub	r2, r31
 156:	31 08       	sbc	r3, r1
 158:	40 17       	cp	r20, r16
 15a:	51 07       	cpc	r21, r17
 15c:	01 f4       	brne	.+0      	; 0x15e <spiEEPROM_readBytes+0xae>
 15e:	00 c0       	rjmp	.+0      	; 0x160 <spiEEPROM_readBytes+0xb0>
			*pos++ = spiDeviceReceiveByte(eeprom);		/* read the next byte			*/
 160:	53 01       	movw	r10, r6
			bytesRead++;								/* one more byte read			*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
				break;
			}
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/
 162:	60 e0       	ldi	r22, 0x00	; 0
 164:	c2 01       	movw	r24, r4
 166:	4b 83       	std	Y+3, r20	; 0x03
 168:	5c 83       	std	Y+4, r21	; 0x04
 16a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		src += bytesRead;								/* update the address			*/
 16e:	4b 81       	ldd	r20, Y+3	; 0x03
 170:	5c 81       	ldd	r21, Y+4	; 0x04
 172:	c4 0e       	add	r12, r20
 174:	d5 1e       	adc	r13, r21
 176:	e1 1c       	adc	r14, r1
 178:	f1 1c       	adc	r15, r1
 17a:	81 01       	movw	r16, r2
// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;

	while(numBytes){
 17c:	01 15       	cp	r16, r1
 17e:	11 05       	cpc	r17, r1
 180:	01 f0       	breq	.+0      	; 0x182 <spiEEPROM_readBytes+0xd2>
 182:	00 c0       	rjmp	.+0      	; 0x184 <spiEEPROM_readBytes+0xd4>
 184:	00 c0       	rjmp	.+0      	; 0x186 <spiEEPROM_readBytes+0xd6>

		size_t offset = src % eeprom->pageSize;			/* Offset into the page			*/

		while(spiEEPROM_isBusy(eeprom));				/* Wait while busy				*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
 186:	63 e0       	ldi	r22, 0x03	; 3
 188:	c2 01       	movw	r24, r4
 18a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		address(eeprom,src);							/* send the address				*/
 18e:	b7 01       	movw	r22, r14
 190:	a6 01       	movw	r20, r12
 192:	c4 01       	movw	r24, r8
 194:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 198:	35 01       	movw	r6, r10

		size_t bytesRead = 0;
		while(numBytes--){
 19a:	18 01       	movw	r2, r16
		while(spiEEPROM_isBusy(eeprom));				/* Wait while busy				*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
		address(eeprom,src);							/* send the address				*/

		size_t bytesRead = 0;
 19c:	40 e0       	ldi	r20, 0x00	; 0
 19e:	50 e0       	ldi	r21, 0x00	; 0
		while(numBytes--){
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <spiEEPROM_readBytes+0xf2>
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/

		src += bytesRead;								/* update the address			*/
	}
}
 1a2:	0f 90       	pop	r0
 1a4:	0f 90       	pop	r0
 1a6:	0f 90       	pop	r0
 1a8:	0f 90       	pop	r0
 1aa:	df 91       	pop	r29
 1ac:	cf 91       	pop	r28
 1ae:	1f 91       	pop	r17
 1b0:	0f 91       	pop	r16
 1b2:	ff 90       	pop	r15
 1b4:	ef 90       	pop	r14
 1b6:	df 90       	pop	r13
 1b8:	cf 90       	pop	r12
 1ba:	bf 90       	pop	r11
 1bc:	af 90       	pop	r10
 1be:	9f 90       	pop	r9
 1c0:	8f 90       	pop	r8
 1c2:	7f 90       	pop	r7
 1c4:	6f 90       	pop	r6
 1c6:	5f 90       	pop	r5
 1c8:	4f 90       	pop	r4
 1ca:	3f 90       	pop	r3
 1cc:	2f 90       	pop	r2
 1ce:	08 95       	ret

000001d0 <disk_read>:
		dst += bytesWritten;							/* update the address			*/
	}

}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 1d0:	0f 93       	push	r16
 1d2:	1f 93       	push	r17
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 1d4:	e9 e0       	ldi	r30, 0x09	; 9
 1d6:	44 0f       	add	r20, r20
 1d8:	55 1f       	adc	r21, r21
 1da:	66 1f       	adc	r22, r22
 1dc:	77 1f       	adc	r23, r23
 1de:	ea 95       	dec	r30
 1e0:	01 f4       	brne	.+0      	; 0x1e2 <disk_read+0x12>
	spiEEPROM_readBytes(eeprom,addr,dta,512);
 1e2:	00 e0       	ldi	r16, 0x00	; 0
 1e4:	12 e0       	ldi	r17, 0x02	; 2
 1e6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 1ea:	8f ef       	ldi	r24, 0xFF	; 255
 1ec:	1f 91       	pop	r17
 1ee:	0f 91       	pop	r16
 1f0:	08 95       	ret

000001f2 <spiEEPROM_readByte>:
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
		spiDeviceSendByte(eeprom, (uint8_t)shft);
	}
}

uint8_t spiEEPROM_readByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
 1f2:	0f 93       	push	r16
 1f4:	1f 93       	push	r17
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	1f 92       	push	r1
 1fc:	cd b7       	in	r28, 0x3d	; 61
 1fe:	de b7       	in	r29, 0x3e	; 62
	uint8_t rtn;
	spiEEPROM_readBytes(eeprom, addr, &rtn, 1);
 200:	01 e0       	ldi	r16, 0x01	; 1
 202:	10 e0       	ldi	r17, 0x00	; 0
 204:	9e 01       	movw	r18, r28
 206:	2f 5f       	subi	r18, 0xFF	; 255
 208:	3f 4f       	sbci	r19, 0xFF	; 255
 20a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return rtn;
}
 20e:	89 81       	ldd	r24, Y+1	; 0x01
 210:	0f 90       	pop	r0
 212:	df 91       	pop	r29
 214:	cf 91       	pop	r28
 216:	1f 91       	pop	r17
 218:	0f 91       	pop	r16
 21a:	08 95       	ret

0000021c <spiEEPROM_writeBytes>:
	}
}


// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 21c:	2f 92       	push	r2
 21e:	3f 92       	push	r3
 220:	4f 92       	push	r4
 222:	5f 92       	push	r5
 224:	6f 92       	push	r6
 226:	7f 92       	push	r7
 228:	8f 92       	push	r8
 22a:	9f 92       	push	r9
 22c:	af 92       	push	r10
 22e:	bf 92       	push	r11
 230:	cf 92       	push	r12
 232:	df 92       	push	r13
 234:	ef 92       	push	r14
 236:	ff 92       	push	r15
 238:	0f 93       	push	r16
 23a:	1f 93       	push	r17
 23c:	cf 93       	push	r28
 23e:	df 93       	push	r29
 240:	00 d0       	rcall	.+0      	; 0x242 <spiEEPROM_writeBytes+0x26>
 242:	00 d0       	rcall	.+0      	; 0x244 <spiEEPROM_writeBytes+0x28>
 244:	cd b7       	in	r28, 0x3d	; 61
 246:	de b7       	in	r29, 0x3e	; 62
 248:	4c 01       	movw	r8, r24
 24a:	cb 01       	movw	r24, r22
 24c:	ba 01       	movw	r22, r20
 24e:	39 01       	movw	r6, r18
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
 250:	f4 01       	movw	r30, r8
 252:	23 85       	ldd	r18, Z+11	; 0x0b
 254:	34 85       	ldd	r19, Z+12	; 0x0c
 256:	45 85       	ldd	r20, Z+13	; 0x0d
 258:	56 85       	ldd	r21, Z+14	; 0x0e
 25a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 25e:	6b 01       	movw	r12, r22
 260:	7c 01       	movw	r14, r24
	const uint8_t* pos = src;
 262:	53 01       	movw	r10, r6

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WREN);
 264:	24 01       	movw	r4, r8
// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
	const uint8_t* pos = src;

	while(numBytes){
 266:	00 c0       	rjmp	.+0      	; 0x268 <spiEEPROM_writeBytes+0x4c>

		size_t offset = dst % eeprom->pageSize;			/* Offset into the page			*/
 268:	f4 01       	movw	r30, r8
 26a:	21 85       	ldd	r18, Z+9	; 0x09
 26c:	32 85       	ldd	r19, Z+10	; 0x0a
 26e:	40 e0       	ldi	r20, 0x00	; 0
 270:	50 e0       	ldi	r21, 0x00	; 0
 272:	c7 01       	movw	r24, r14
 274:	b6 01       	movw	r22, r12
 276:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 27a:	7a 83       	std	Y+2, r23	; 0x02
 27c:	69 83       	std	Y+1, r22	; 0x01
	return status;
}

// Is the chip busy doing a write?
static boolean spiEEPROM_isBusy(SPI_EEPROM* eeprom){
	uint8_t status = spiEEPROM_readStatus(eeprom);
 27e:	c4 01       	movw	r24, r8
 280:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return (status & SPIEEPROM_STATUS_WIP) ? TRUE : FALSE;
 284:	80 ff       	sbrs	r24, 0
 286:	00 c0       	rjmp	.+0      	; 0x288 <spiEEPROM_writeBytes+0x6c>
 288:	00 c0       	rjmp	.+0      	; 0x28a <spiEEPROM_writeBytes+0x6e>
	}
}


// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 28a:	35 01       	movw	r6, r10
 28c:	ff ef       	ldi	r31, 0xFF	; 255
 28e:	6f 1a       	sub	r6, r31
 290:	7f 0a       	sbc	r7, r31
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
		address(eeprom,dst);							/* send the address				*/

		size_t bytesWritten = 0;
		while(numBytes--){
			spiDeviceSendByte(eeprom,*pos++);           /* send the byte				*/
 292:	f5 01       	movw	r30, r10
 294:	60 81       	ld	r22, Z
 296:	c2 01       	movw	r24, r4
 298:	4b 83       	std	Y+3, r20	; 0x03
 29a:	5c 83       	std	Y+4, r21	; 0x04
 29c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
			bytesWritten++;								/* one more byte written		*/
 2a0:	4b 81       	ldd	r20, Y+3	; 0x03
 2a2:	5c 81       	ldd	r21, Y+4	; 0x04
 2a4:	4f 5f       	subi	r20, 0xFF	; 255
 2a6:	5f 4f       	sbci	r21, 0xFF	; 255
	}
}


// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 2a8:	29 81       	ldd	r18, Y+1	; 0x01
 2aa:	3a 81       	ldd	r19, Y+2	; 0x02
 2ac:	24 0f       	add	r18, r20
 2ae:	35 1f       	adc	r19, r21

		size_t bytesWritten = 0;
		while(numBytes--){
			spiDeviceSendByte(eeprom,*pos++);           /* send the byte				*/
			bytesWritten++;								/* one more byte written		*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
 2b0:	f4 01       	movw	r30, r8
 2b2:	81 85       	ldd	r24, Z+9	; 0x09
 2b4:	92 85       	ldd	r25, Z+10	; 0x0a
 2b6:	28 17       	cp	r18, r24
 2b8:	39 07       	cpc	r19, r25
 2ba:	01 f0       	breq	.+0      	; 0x2bc <spiEEPROM_writeBytes+0xa0>
 2bc:	53 01       	movw	r10, r6
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
		address(eeprom,dst);							/* send the address				*/

		size_t bytesWritten = 0;
		while(numBytes--){
 2be:	f1 e0       	ldi	r31, 0x01	; 1
 2c0:	2f 1a       	sub	r2, r31
 2c2:	31 08       	sbc	r3, r1
 2c4:	40 17       	cp	r20, r16
 2c6:	51 07       	cpc	r21, r17
 2c8:	01 f4       	brne	.+0      	; 0x2ca <spiEEPROM_writeBytes+0xae>
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <spiEEPROM_writeBytes+0xb0>
			spiDeviceSendByte(eeprom,*pos++);           /* send the byte				*/
 2cc:	53 01       	movw	r10, r6
			bytesWritten++;								/* one more byte written		*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
				break;
			}
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/
 2ce:	60 e0       	ldi	r22, 0x00	; 0
 2d0:	c2 01       	movw	r24, r4
 2d2:	4b 83       	std	Y+3, r20	; 0x03
 2d4:	5c 83       	std	Y+4, r21	; 0x04
 2d6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		dst += bytesWritten;							/* update the address			*/
 2da:	4b 81       	ldd	r20, Y+3	; 0x03
 2dc:	5c 81       	ldd	r21, Y+4	; 0x04
 2de:	c4 0e       	add	r12, r20
 2e0:	d5 1e       	adc	r13, r21
 2e2:	e1 1c       	adc	r14, r1
 2e4:	f1 1c       	adc	r15, r1
 2e6:	81 01       	movw	r16, r2
// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
	const uint8_t* pos = src;

	while(numBytes){
 2e8:	01 15       	cp	r16, r1
 2ea:	11 05       	cpc	r17, r1
 2ec:	01 f0       	breq	.+0      	; 0x2ee <spiEEPROM_writeBytes+0xd2>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <spiEEPROM_writeBytes+0xd4>
 2f0:	00 c0       	rjmp	.+0      	; 0x2f2 <spiEEPROM_writeBytes+0xd6>

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WREN);
 2f2:	66 e0       	ldi	r22, 0x06	; 6
 2f4:	c2 01       	movw	r24, r4
 2f6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
 2fa:	60 e0       	ldi	r22, 0x00	; 0
 2fc:	c2 01       	movw	r24, r4
 2fe:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		size_t offset = dst % eeprom->pageSize;			/* Offset into the page			*/

		writeEnable(eeprom);							/* Allow writes					*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
 302:	62 e0       	ldi	r22, 0x02	; 2
 304:	c2 01       	movw	r24, r4
 306:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		address(eeprom,dst);							/* send the address				*/
 30a:	b7 01       	movw	r22, r14
 30c:	a6 01       	movw	r20, r12
 30e:	c4 01       	movw	r24, r8
 310:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 314:	35 01       	movw	r6, r10

		size_t bytesWritten = 0;
		while(numBytes--){
 316:	18 01       	movw	r2, r16
		writeEnable(eeprom);							/* Allow writes					*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
		address(eeprom,dst);							/* send the address				*/

		size_t bytesWritten = 0;
 318:	40 e0       	ldi	r20, 0x00	; 0
 31a:	50 e0       	ldi	r21, 0x00	; 0
		while(numBytes--){
 31c:	00 c0       	rjmp	.+0      	; 0x31e <spiEEPROM_writeBytes+0x102>
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/

		dst += bytesWritten;							/* update the address			*/
	}

}
 31e:	0f 90       	pop	r0
 320:	0f 90       	pop	r0
 322:	0f 90       	pop	r0
 324:	0f 90       	pop	r0
 326:	df 91       	pop	r29
 328:	cf 91       	pop	r28
 32a:	1f 91       	pop	r17
 32c:	0f 91       	pop	r16
 32e:	ff 90       	pop	r15
 330:	ef 90       	pop	r14
 332:	df 90       	pop	r13
 334:	cf 90       	pop	r12
 336:	bf 90       	pop	r11
 338:	af 90       	pop	r10
 33a:	9f 90       	pop	r9
 33c:	8f 90       	pop	r8
 33e:	7f 90       	pop	r7
 340:	6f 90       	pop	r6
 342:	5f 90       	pop	r5
 344:	4f 90       	pop	r4
 346:	3f 90       	pop	r3
 348:	2f 90       	pop	r2
 34a:	08 95       	ret

0000034c <disk_write>:
	EEPROM_ADDR addr = absSector * 512;
	spiEEPROM_readBytes(eeprom,addr,dta,512);
	return TRUE;
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 34c:	0f 93       	push	r16
 34e:	1f 93       	push	r17
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 350:	f9 e0       	ldi	r31, 0x09	; 9
 352:	44 0f       	add	r20, r20
 354:	55 1f       	adc	r21, r21
 356:	66 1f       	adc	r22, r22
 358:	77 1f       	adc	r23, r23
 35a:	fa 95       	dec	r31
 35c:	01 f4       	brne	.+0      	; 0x35e <disk_write+0x12>
	spiEEPROM_writeBytes(eeprom,addr,dta,512);
 35e:	00 e0       	ldi	r16, 0x00	; 0
 360:	12 e0       	ldi	r17, 0x02	; 2
 362:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 366:	8f ef       	ldi	r24, 0xFF	; 255
 368:	1f 91       	pop	r17
 36a:	0f 91       	pop	r16
 36c:	08 95       	ret

0000036e <spiEEPROM_writeByte>:
	spiEEPROM_readBytes(eeprom, addr, &rtn, 1);
	return rtn;
}

// Write a byte to the eeprom - note the write may be delayed
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
 36e:	0f 93       	push	r16
 370:	1f 93       	push	r17
 372:	cf 93       	push	r28
 374:	df 93       	push	r29
 376:	1f 92       	push	r1
 378:	cd b7       	in	r28, 0x3d	; 61
 37a:	de b7       	in	r29, 0x3e	; 62
 37c:	29 83       	std	Y+1, r18	; 0x01
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
 37e:	01 e0       	ldi	r16, 0x01	; 1
 380:	10 e0       	ldi	r17, 0x00	; 0
 382:	9e 01       	movw	r18, r28
 384:	2f 5f       	subi	r18, 0xFF	; 255
 386:	3f 4f       	sbci	r19, 0xFF	; 255
 388:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 38c:	0f 90       	pop	r0
 38e:	df 91       	pop	r29
 390:	cf 91       	pop	r28
 392:	1f 91       	pop	r17
 394:	0f 91       	pop	r16
 396:	08 95       	ret

00000398 <spiEEPROMGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* spiEEPROMGetStorageClass(void){
	return &c_spieeprom_disk;
}
 398:	80 e0       	ldi	r24, 0x00	; 0
 39a:	90 e0       	ldi	r25, 0x00	; 0
 39c:	08 95       	ret

_i2c_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_info   000000ac  00000000  00000000  00000034  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000061  00000000  00000000  000000e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000018  00000000  00000000  00000141  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_line   0000003f  00000000  00000000  00000159  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    0000012b  00000000  00000000  00000198  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .comment      0000002a  00000000  00000000  000002c3  2**0
                  CONTENTS, READONLY

_spi_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000488  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004bc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000004bc  2**0
                  ALLOC
  3 .debug_info   00000fb5  00000000  00000000  000004bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000032d  00000000  00000000  00001471  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000011fc  00000000  00000000  0000179e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000299a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 000000c0  00000000  00000000  000029ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001cf  00000000  00000000  00002a7a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004c7  00000000  00000000  00002c49  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00003110  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000001fc  00000000  00000000  0000313c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <spiAbstractBusInit>:
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
    return rxData;
}

//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	d6 2e       	mov	r13, r22
	if(spi && !spi->initialised){
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <spiAbstractBusInit+0x16>
  16:	89 85       	ldd	r24, Y+9	; 0x09
  18:	81 11       	cpse	r24, r1
  1a:	00 c0       	rjmp	.+0      	; 0x1c <spiAbstractBusInit+0x1c>
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
  1c:	e8 81       	ld	r30, Y
  1e:	f9 81       	ldd	r31, Y+1	; 0x01
  20:	85 91       	lpm	r24, Z+
  22:	94 91       	lpm	r25, Z
  24:	7c 01       	movw	r14, r24
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
  26:	00 e0       	ldi	r16, 0x00	; 0
  28:	10 e0       	ldi	r17, 0x00	; 0
  2a:	00 c0       	rjmp	.+0      	; 0x2c <spiAbstractBusInit+0x2c>
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
    return rxData;
}

//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
  2c:	c8 01       	movw	r24, r16
  2e:	88 0f       	add	r24, r24
  30:	99 1f       	adc	r25, r25
	if(spi && !spi->initialised){
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
			SPI_ABSTRACT_DEVICE* device = (SPI_ABSTRACT_DEVICE *)pgm_read_word(&spi->devices[deviceNo]);
  32:	ea 81       	ldd	r30, Y+2	; 0x02
  34:	fb 81       	ldd	r31, Y+3	; 0x03
  36:	e8 0f       	add	r30, r24
  38:	f9 1f       	adc	r31, r25
  3a:	85 91       	lpm	r24, Z+
  3c:	94 91       	lpm	r25, Z
  3e:	dc 01       	movw	r26, r24
			device->bus = (struct s_spi_abstract_bus*)spi;
  40:	11 96       	adiw	r26, 0x01	; 1
  42:	dc 93       	st	X, r29
  44:	ce 93       	st	-X, r28
			if(device->select!=null){
  46:	14 96       	adiw	r26, 0x04	; 4
  48:	8d 91       	ld	r24, X+
  4a:	9c 91       	ld	r25, X
  4c:	15 97       	sbiw	r26, 0x05	; 5
  4e:	00 97       	sbiw	r24, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <spiAbstractBusInit+0x52>
				// Make into output pin and deselect
				pin_make_output(device->select, TRUE);
  52:	6f ef       	ldi	r22, 0xFF	; 255
  54:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
	if(spi && !spi->initialised){
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
  58:	0f 5f       	subi	r16, 0xFF	; 255
  5a:	1f 4f       	sbci	r17, 0xFF	; 255
  5c:	8c 81       	ldd	r24, Y+4	; 0x04
  5e:	9d 81       	ldd	r25, Y+5	; 0x05
  60:	08 17       	cp	r16, r24
  62:	19 07       	cpc	r17, r25
  64:	00 f0       	brcs	.+0      	; 0x66 <spiAbstractBusInit+0x66>
			if(device->select!=null){
				// Make into output pin and deselect
				pin_make_output(device->select, TRUE);
			}
		}
		spi->selectedDevice=null;
  66:	1b 86       	std	Y+11, r1	; 0x0b
  68:	1a 86       	std	Y+10, r1	; 0x0a
		fn(spi,master);				// initialise the bus
  6a:	6d 2d       	mov	r22, r13
  6c:	ce 01       	movw	r24, r28
  6e:	f7 01       	movw	r30, r14
  70:	09 95       	icall
		spi->initialised = TRUE;
  72:	8f ef       	ldi	r24, 0xFF	; 255
  74:	89 87       	std	Y+9, r24	; 0x09
	}
}
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	1f 91       	pop	r17
  7c:	0f 91       	pop	r16
  7e:	ff 90       	pop	r15
  80:	ef 90       	pop	r14
  82:	df 90       	pop	r13
  84:	08 95       	ret

00000086 <spiAbstractBusOff>:
void spiAbstractBusOff(SPI_ABSTRACT_BUS* spi){
  86:	cf 93       	push	r28
  88:	df 93       	push	r29
  8a:	ec 01       	movw	r28, r24
	if(spi && spi->initialised){
  8c:	00 97       	sbiw	r24, 0x00	; 0
  8e:	01 f0       	breq	.+0      	; 0x90 <spiAbstractBusOff+0xa>
  90:	89 85       	ldd	r24, Y+9	; 0x09
  92:	88 23       	and	r24, r24
  94:	01 f0       	breq	.+0      	; 0x96 <spiAbstractBusOff+0x10>
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*) = (void (*)(SPI_ABSTRACT_BUS*))pgm_read_word(&class->off);
  96:	e8 81       	ld	r30, Y
  98:	f9 81       	ldd	r31, Y+1	; 0x01
  9a:	32 96       	adiw	r30, 0x02	; 2
  9c:	25 91       	lpm	r18, Z+
  9e:	34 91       	lpm	r19, Z
		fn(spi);
  a0:	ce 01       	movw	r24, r28
  a2:	f9 01       	movw	r30, r18
  a4:	09 95       	icall
		spi->initialised = FALSE;
  a6:	19 86       	std	Y+9, r1	; 0x09
	}
}
  a8:	df 91       	pop	r29
  aa:	cf 91       	pop	r28
  ac:	08 95       	ret

000000ae <spiAbstractBusSetMode>:

void spiAbstractBusSetMode(SPI_ABSTRACT_BUS* bus,SPI_MODE mode){
	if(bus){
  ae:	00 97       	sbiw	r24, 0x00	; 0
  b0:	01 f0       	breq	.+0      	; 0xb2 <spiAbstractBusSetMode+0x4>
		bus->mode = mode;
  b2:	dc 01       	movw	r26, r24
  b4:	17 96       	adiw	r26, 0x07	; 7
  b6:	6c 93       	st	X, r22
  b8:	17 97       	sbiw	r26, 0x07	; 7
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_MODE mode) = (void (*)(SPI_ABSTRACT_BUS*,SPI_MODE mode))pgm_read_word(&class->mode);
  ba:	ed 91       	ld	r30, X+
  bc:	fc 91       	ld	r31, X
  be:	38 96       	adiw	r30, 0x08	; 8
  c0:	25 91       	lpm	r18, Z+
  c2:	34 91       	lpm	r19, Z
		fn(bus,mode);
  c4:	f9 01       	movw	r30, r18
  c6:	09 94       	ijmp
  c8:	08 95       	ret

000000ca <spiAbstractBusSetDataOrder>:
	}
}
void spiAbstractBusSetDataOrder(SPI_ABSTRACT_BUS* bus,SPI_DATA_ORDER order){
	if(bus){
  ca:	00 97       	sbiw	r24, 0x00	; 0
  cc:	01 f0       	breq	.+0      	; 0xce <spiAbstractBusSetDataOrder+0x4>
		bus->order = order;
  ce:	dc 01       	movw	r26, r24
  d0:	18 96       	adiw	r26, 0x08	; 8
  d2:	6c 93       	st	X, r22
  d4:	18 97       	sbiw	r26, 0x08	; 8
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order) = (void (*)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order))pgm_read_word(&class->order);
  d6:	ed 91       	ld	r30, X+
  d8:	fc 91       	ld	r31, X
  da:	36 96       	adiw	r30, 0x06	; 6
  dc:	25 91       	lpm	r18, Z+
  de:	34 91       	lpm	r19, Z
		fn(bus,order);
  e0:	f9 01       	movw	r30, r18
  e2:	09 94       	ijmp
  e4:	08 95       	ret

000000e6 <spiAbstractDeviceSelect>:
#include "_spi_common.h"


//--------------- Implement the virtual functions for an SPI_ABSTRACT_DEVICE -----

void spiAbstractDeviceSelect(const SPI_ABSTRACT_DEVICE* device, boolean active){
  e6:	ef 92       	push	r14
  e8:	ff 92       	push	r15
  ea:	0f 93       	push	r16
  ec:	1f 93       	push	r17
  ee:	cf 93       	push	r28
  f0:	df 93       	push	r29
  f2:	8c 01       	movw	r16, r24
	SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
  f4:	fc 01       	movw	r30, r24
  f6:	c0 81       	ld	r28, Z
  f8:	d1 81       	ldd	r29, Z+1	; 0x01

	if(bus){
  fa:	20 97       	sbiw	r28, 0x00	; 0
  fc:	01 f4       	brne	.+0      	; 0xfe <spiAbstractDeviceSelect+0x18>
  fe:	00 c0       	rjmp	.+0      	; 0x100 <spiAbstractDeviceSelect+0x1a>
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(const SPI_ABSTRACT_DEVICE*,boolean) = (void (*)(const SPI_ABSTRACT_DEVICE*, boolean))pgm_read_word(&class->sel);
 100:	e8 81       	ld	r30, Y
 102:	f9 81       	ldd	r31, Y+1	; 0x01
 104:	70 96       	adiw	r30, 0x10	; 16
 106:	85 91       	lpm	r24, Z+
 108:	94 91       	lpm	r25, Z
 10a:	7c 01       	movw	r14, r24


		if(active){
 10c:	66 23       	and	r22, r22
 10e:	01 f0       	breq	.+0      	; 0x110 <spiAbstractDeviceSelect+0x2a>
			// Deselect the current device
			if(bus->selectedDevice!=null){
 110:	8a 85       	ldd	r24, Y+10	; 0x0a
 112:	9b 85       	ldd	r25, Y+11	; 0x0b
 114:	00 97       	sbiw	r24, 0x00	; 0
 116:	01 f0       	breq	.+0      	; 0x118 <spiAbstractDeviceSelect+0x32>
				spiAbstractDeviceSelect(bus->selectedDevice,FALSE);
 118:	60 e0       	ldi	r22, 0x00	; 0
 11a:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// Now set the mode and order for the bus for this device
			if(bus->mode!=device->mode){
 11e:	f8 01       	movw	r30, r16
 120:	62 81       	ldd	r22, Z+2	; 0x02
 122:	8f 81       	ldd	r24, Y+7	; 0x07
 124:	86 17       	cp	r24, r22
 126:	01 f0       	breq	.+0      	; 0x128 <spiAbstractDeviceSelect+0x42>
				spiAbstractBusSetMode(bus,device->mode);
 128:	ce 01       	movw	r24, r28
 12a:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}
			if(bus->order!=device->order){
 12e:	f8 01       	movw	r30, r16
 130:	63 81       	ldd	r22, Z+3	; 0x03
 132:	88 85       	ldd	r24, Y+8	; 0x08
 134:	86 17       	cp	r24, r22
 136:	01 f0       	breq	.+0      	; 0x138 <spiAbstractDeviceSelect+0x52>
				spiAbstractBusSetDataOrder(bus,device->order);
 138:	ce 01       	movw	r24, r28
 13a:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// Tell the bus the selected device is changing
			if(fn){
 13e:	e1 14       	cp	r14, r1
 140:	f1 04       	cpc	r15, r1
 142:	01 f0       	breq	.+0      	; 0x144 <spiAbstractDeviceSelect+0x5e>
				fn(device,TRUE);
 144:	6f ef       	ldi	r22, 0xFF	; 255
 146:	c8 01       	movw	r24, r16
 148:	f7 01       	movw	r30, r14
 14a:	09 95       	icall
			}

			// Select the chip
			bus->selectedDevice=(SPI_ABSTRACT_DEVICE*)device;
 14c:	1b 87       	std	Y+11, r17	; 0x0b
 14e:	0a 87       	std	Y+10, r16	; 0x0a
			if(device->select!=null){
 150:	f8 01       	movw	r30, r16
 152:	84 81       	ldd	r24, Z+4	; 0x04
 154:	95 81       	ldd	r25, Z+5	; 0x05
 156:	00 97       	sbiw	r24, 0x00	; 0
 158:	01 f0       	breq	.+0      	; 0x15a <spiAbstractDeviceSelect+0x74>
		}
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
	}

}
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	ff 90       	pop	r15
 164:	ef 90       	pop	r14
			}

			// Select the chip
			bus->selectedDevice=(SPI_ABSTRACT_DEVICE*)device;
			if(device->select!=null){
				pin_low(device->select);
 166:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>
			}
		}else{
			// Deselect the chip
			if(device->select!=null){
 16a:	f8 01       	movw	r30, r16
 16c:	84 81       	ldd	r24, Z+4	; 0x04
 16e:	95 81       	ldd	r25, Z+5	; 0x05
 170:	00 97       	sbiw	r24, 0x00	; 0
 172:	01 f0       	breq	.+0      	; 0x174 <spiAbstractDeviceSelect+0x8e>
				pin_high(device->select);
 174:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// If its the currently selected device then notify it
			if(bus->selectedDevice==device){
 178:	8a 85       	ldd	r24, Y+10	; 0x0a
 17a:	9b 85       	ldd	r25, Y+11	; 0x0b
 17c:	80 17       	cp	r24, r16
 17e:	91 07       	cpc	r25, r17
 180:	01 f4       	brne	.+0      	; 0x182 <spiAbstractDeviceSelect+0x9c>
				bus->selectedDevice = NULL;
 182:	1b 86       	std	Y+11, r1	; 0x0b
 184:	1a 86       	std	Y+10, r1	; 0x0a
				// Tell the bus the device is no longer selected
				if(fn){
 186:	e1 14       	cp	r14, r1
 188:	f1 04       	cpc	r15, r1
 18a:	01 f0       	breq	.+0      	; 0x18c <spiAbstractDeviceSelect+0xa6>
					fn(device,FALSE);
 18c:	60 e0       	ldi	r22, 0x00	; 0
 18e:	c8 01       	movw	r24, r16
 190:	f7 01       	movw	r30, r14
		}
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
	}

}
 192:	df 91       	pop	r29
 194:	cf 91       	pop	r28
 196:	1f 91       	pop	r17
 198:	0f 91       	pop	r16
 19a:	ff 90       	pop	r15
 19c:	ef 90       	pop	r14
			// If its the currently selected device then notify it
			if(bus->selectedDevice==device){
				bus->selectedDevice = NULL;
				// Tell the bus the device is no longer selected
				if(fn){
					fn(device,FALSE);
 19e:	09 94       	ijmp
				}
			}
		}
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
 1a0:	82 ee       	ldi	r24, 0xE2	; 226
	}

}
 1a2:	df 91       	pop	r29
 1a4:	cf 91       	pop	r28
 1a6:	1f 91       	pop	r17
 1a8:	0f 91       	pop	r16
 1aa:	ff 90       	pop	r15
 1ac:	ef 90       	pop	r14
					fn(device,FALSE);
				}
			}
		}
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
 1ae:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>
	}

}
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	1f 91       	pop	r17
 1b8:	0f 91       	pop	r16
 1ba:	ff 90       	pop	r15
 1bc:	ef 90       	pop	r14
 1be:	08 95       	ret

000001c0 <spiAbstractDeviceSendBytes>:
			setError(SPI_BUS_NOT_INITIALIZED);
		}

	}
}
void spiAbstractDeviceSendBytes(const SPI_ABSTRACT_DEVICE* device, const void* buff, size_t size){
 1c0:	af 92       	push	r10
 1c2:	bf 92       	push	r11
 1c4:	cf 92       	push	r12
 1c6:	df 92       	push	r13
 1c8:	ef 92       	push	r14
 1ca:	ff 92       	push	r15
 1cc:	0f 93       	push	r16
 1ce:	1f 93       	push	r17
 1d0:	cf 93       	push	r28
 1d2:	df 93       	push	r29
 1d4:	00 d0       	rcall	.+0      	; 0x1d6 <spiAbstractDeviceSendBytes+0x16>
 1d6:	1f 92       	push	r1
 1d8:	cd b7       	in	r28, 0x3d	; 61
 1da:	de b7       	in	r29, 0x3e	; 62
 1dc:	7c 01       	movw	r14, r24
 1de:	d6 2e       	mov	r13, r22
	if(size){
 1e0:	41 15       	cp	r20, r1
 1e2:	51 05       	cpc	r21, r1
 1e4:	01 f4       	brne	.+0      	; 0x1e6 <spiAbstractDeviceSendBytes+0x26>
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <spiAbstractDeviceSendBytes+0x28>
		// Select the device if required
		SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 1e8:	fc 01       	movw	r30, r24
 1ea:	00 81       	ld	r16, Z
 1ec:	11 81       	ldd	r17, Z+1	; 0x01
		if(bus){
 1ee:	01 15       	cp	r16, r1
 1f0:	11 05       	cpc	r17, r1
 1f2:	01 f4       	brne	.+0      	; 0x1f4 <spiAbstractDeviceSendBytes+0x34>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <spiAbstractDeviceSendBytes+0x36>
			if(bus->selectedDevice != device){
 1f6:	f8 01       	movw	r30, r16
 1f8:	82 85       	ldd	r24, Z+10	; 0x0a
 1fa:	93 85       	ldd	r25, Z+11	; 0x0b
 1fc:	8e 15       	cp	r24, r14
 1fe:	9f 05       	cpc	r25, r15
 200:	01 f0       	breq	.+0      	; 0x202 <spiAbstractDeviceSendBytes+0x42>
				spiAbstractDeviceSelect(device,TRUE);
 202:	6f ef       	ldi	r22, 0xFF	; 255
 204:	c7 01       	movw	r24, r14
 206:	49 83       	std	Y+1, r20	; 0x01
 208:	5a 83       	std	Y+2, r21	; 0x02
 20a:	7b 83       	std	Y+3, r23	; 0x03
 20c:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 210:	7b 81       	ldd	r23, Y+3	; 0x03
 212:	5a 81       	ldd	r21, Y+2	; 0x02
 214:	49 81       	ldd	r20, Y+1	; 0x01
			}
			const SPI_CLASS* class = bus->sclass;
 216:	f8 01       	movw	r30, r16
 218:	80 81       	ld	r24, Z
 21a:	91 81       	ldd	r25, Z+1	; 0x01
			void (*fn)(const SPI_ABSTRACT_DEVICE*,const void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, const void*,size_t))pgm_read_word(&class->writeMany);
 21c:	fc 01       	movw	r30, r24
 21e:	3e 96       	adiw	r30, 0x0e	; 14
 220:	25 91       	lpm	r18, Z+
 222:	34 91       	lpm	r19, Z
 224:	f9 01       	movw	r30, r18

			if(fn){
 226:	30 97       	sbiw	r30, 0x00	; 0
 228:	01 f0       	breq	.+0      	; 0x22a <spiAbstractDeviceSendBytes+0x6a>
				// It has a special method for writing many bytes in a row
				fn(device,buff,size);
 22a:	6d 2d       	mov	r22, r13
 22c:	c7 01       	movw	r24, r14
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
		}
	}
}
 22e:	0f 90       	pop	r0
 230:	0f 90       	pop	r0
 232:	0f 90       	pop	r0
 234:	df 91       	pop	r29
 236:	cf 91       	pop	r28
 238:	1f 91       	pop	r17
 23a:	0f 91       	pop	r16
 23c:	ff 90       	pop	r15
 23e:	ef 90       	pop	r14
 240:	df 90       	pop	r13
 242:	cf 90       	pop	r12
 244:	bf 90       	pop	r11
 246:	af 90       	pop	r10
			const SPI_CLASS* class = bus->sclass;
			void (*fn)(const SPI_ABSTRACT_DEVICE*,const void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, const void*,size_t))pgm_read_word(&class->writeMany);

			if(fn){
				// It has a special method for writing many bytes in a row
				fn(device,buff,size);
 248:	09 94       	ijmp
			}else{
				// No special routine so just write each in turn

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 24a:	fc 01       	movw	r30, r24
 24c:	3a 96       	adiw	r30, 0x0a	; 10
 24e:	85 91       	lpm	r24, Z+
 250:	94 91       	lpm	r25, Z
 252:	7c 01       	movw	r14, r24
 254:	ad 2c       	mov	r10, r13
 256:	b7 2e       	mov	r11, r23
			setError(SPI_BUS_NOT_INITIALIZED);
		}

	}
}
void spiAbstractDeviceSendBytes(const SPI_ABSTRACT_DEVICE* device, const void* buff, size_t size){
 258:	65 01       	movw	r12, r10
 25a:	c4 0e       	add	r12, r20
 25c:	d5 1e       	adc	r13, r21

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				const uint8_t* dta = (const uint8_t*)buff;
				while(size--){
 25e:	00 c0       	rjmp	.+0      	; 0x260 <spiAbstractDeviceSendBytes+0xa0>
					fn(bus,*dta++);
 260:	f5 01       	movw	r30, r10
 262:	61 91       	ld	r22, Z+
 264:	5f 01       	movw	r10, r30
 266:	c8 01       	movw	r24, r16
 268:	f7 01       	movw	r30, r14
 26a:	09 95       	icall

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				const uint8_t* dta = (const uint8_t*)buff;
				while(size--){
 26c:	ac 14       	cp	r10, r12
 26e:	bd 04       	cpc	r11, r13
 270:	01 f4       	brne	.+0      	; 0x272 <spiAbstractDeviceSendBytes+0xb2>
 272:	00 c0       	rjmp	.+0      	; 0x274 <spiAbstractDeviceSendBytes+0xb4>
					fn(bus,*dta++);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 274:	82 ee       	ldi	r24, 0xE2	; 226
		}
	}
}
 276:	0f 90       	pop	r0
 278:	0f 90       	pop	r0
 27a:	0f 90       	pop	r0
 27c:	df 91       	pop	r29
 27e:	cf 91       	pop	r28
 280:	1f 91       	pop	r17
 282:	0f 91       	pop	r16
 284:	ff 90       	pop	r15
 286:	ef 90       	pop	r14
 288:	df 90       	pop	r13
 28a:	cf 90       	pop	r12
 28c:	bf 90       	pop	r11
 28e:	af 90       	pop	r10
				while(size--){
					fn(bus,*dta++);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 290:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>
		}
	}
}
 294:	0f 90       	pop	r0
 296:	0f 90       	pop	r0
 298:	0f 90       	pop	r0
 29a:	df 91       	pop	r29
 29c:	cf 91       	pop	r28
 29e:	1f 91       	pop	r17
 2a0:	0f 91       	pop	r16
 2a2:	ff 90       	pop	r15
 2a4:	ef 90       	pop	r14
 2a6:	df 90       	pop	r13
 2a8:	cf 90       	pop	r12
 2aa:	bf 90       	pop	r11
 2ac:	af 90       	pop	r10
 2ae:	08 95       	ret

000002b0 <spiAbstractDeviceReceiveBytes>:
	xmit |= device->fillerByte;

	return spiAbstractDeviceXferWord(device, xmit);
}

void spiAbstractDeviceReceiveBytes(const SPI_ABSTRACT_DEVICE* device, void* buff, size_t size){
 2b0:	8f 92       	push	r8
 2b2:	9f 92       	push	r9
 2b4:	af 92       	push	r10
 2b6:	bf 92       	push	r11
 2b8:	cf 92       	push	r12
 2ba:	df 92       	push	r13
 2bc:	ef 92       	push	r14
 2be:	ff 92       	push	r15
 2c0:	0f 93       	push	r16
 2c2:	1f 93       	push	r17
 2c4:	cf 93       	push	r28
 2c6:	df 93       	push	r29
 2c8:	00 d0       	rcall	.+0      	; 0x2ca <spiAbstractDeviceReceiveBytes+0x1a>
 2ca:	1f 92       	push	r1
 2cc:	cd b7       	in	r28, 0x3d	; 61
 2ce:	de b7       	in	r29, 0x3e	; 62
 2d0:	8c 01       	movw	r16, r24
 2d2:	b6 2e       	mov	r11, r22
	if(size){
 2d4:	41 15       	cp	r20, r1
 2d6:	51 05       	cpc	r21, r1
 2d8:	01 f4       	brne	.+0      	; 0x2da <spiAbstractDeviceReceiveBytes+0x2a>
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <spiAbstractDeviceReceiveBytes+0x2c>
		// Select the device if required
		SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 2dc:	fc 01       	movw	r30, r24
 2de:	e0 80       	ld	r14, Z
 2e0:	f1 80       	ldd	r15, Z+1	; 0x01

		if(bus){
 2e2:	e1 14       	cp	r14, r1
 2e4:	f1 04       	cpc	r15, r1
 2e6:	01 f4       	brne	.+0      	; 0x2e8 <spiAbstractDeviceReceiveBytes+0x38>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <spiAbstractDeviceReceiveBytes+0x3a>
			if(bus->selectedDevice != device){
 2ea:	f7 01       	movw	r30, r14
 2ec:	82 85       	ldd	r24, Z+10	; 0x0a
 2ee:	93 85       	ldd	r25, Z+11	; 0x0b
 2f0:	80 17       	cp	r24, r16
 2f2:	91 07       	cpc	r25, r17
 2f4:	01 f0       	breq	.+0      	; 0x2f6 <spiAbstractDeviceReceiveBytes+0x46>
				spiAbstractDeviceSelect(device,TRUE);
 2f6:	6f ef       	ldi	r22, 0xFF	; 255
 2f8:	c8 01       	movw	r24, r16
 2fa:	49 83       	std	Y+1, r20	; 0x01
 2fc:	5a 83       	std	Y+2, r21	; 0x02
 2fe:	7b 83       	std	Y+3, r23	; 0x03
 300:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 304:	7b 81       	ldd	r23, Y+3	; 0x03
 306:	5a 81       	ldd	r21, Y+2	; 0x02
 308:	49 81       	ldd	r20, Y+1	; 0x01
			}
			const SPI_CLASS* class = bus->sclass;
 30a:	f7 01       	movw	r30, r14
 30c:	80 81       	ld	r24, Z
 30e:	91 81       	ldd	r25, Z+1	; 0x01
			void (*fn)(const SPI_ABSTRACT_DEVICE*,void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, void*,size_t))pgm_read_word(&class->readMany);
 310:	fc 01       	movw	r30, r24
 312:	3c 96       	adiw	r30, 0x0c	; 12
 314:	25 91       	lpm	r18, Z+
 316:	34 91       	lpm	r19, Z
 318:	f9 01       	movw	r30, r18

			if(fn){
 31a:	30 97       	sbiw	r30, 0x00	; 0
 31c:	01 f0       	breq	.+0      	; 0x31e <spiAbstractDeviceReceiveBytes+0x6e>
				// It has a special method for receiving many bytes in a row
				fn(device,buff,size);
 31e:	6b 2d       	mov	r22, r11
 320:	c8 01       	movw	r24, r16
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
		}

	}
}
 322:	0f 90       	pop	r0
 324:	0f 90       	pop	r0
 326:	0f 90       	pop	r0
 328:	df 91       	pop	r29
 32a:	cf 91       	pop	r28
 32c:	1f 91       	pop	r17
 32e:	0f 91       	pop	r16
 330:	ff 90       	pop	r15
 332:	ef 90       	pop	r14
 334:	df 90       	pop	r13
 336:	cf 90       	pop	r12
 338:	bf 90       	pop	r11
 33a:	af 90       	pop	r10
 33c:	9f 90       	pop	r9
 33e:	8f 90       	pop	r8
			const SPI_CLASS* class = bus->sclass;
			void (*fn)(const SPI_ABSTRACT_DEVICE*,void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, void*,size_t))pgm_read_word(&class->readMany);

			if(fn){
				// It has a special method for receiving many bytes in a row
				fn(device,buff,size);
 340:	09 94       	ijmp
			}else{
				// No special routine so just receive each in turn

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 342:	fc 01       	movw	r30, r24
 344:	3a 96       	adiw	r30, 0x0a	; 10
 346:	85 91       	lpm	r24, Z+
 348:	94 91       	lpm	r25, Z
 34a:	6c 01       	movw	r12, r24
 34c:	8b 2c       	mov	r8, r11
 34e:	97 2e       	mov	r9, r23
	xmit |= device->fillerByte;

	return spiAbstractDeviceXferWord(device, xmit);
}

void spiAbstractDeviceReceiveBytes(const SPI_ABSTRACT_DEVICE* device, void* buff, size_t size){
 350:	54 01       	movw	r10, r8
 352:	a4 0e       	add	r10, r20
 354:	b5 1e       	adc	r11, r21

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				uint8_t* dta = (uint8_t*)buff;
				while(size--){
 356:	00 c0       	rjmp	.+0      	; 0x358 <spiAbstractDeviceReceiveBytes+0xa8>
					*dta++ = fn(bus,device->fillerByte);
 358:	f8 01       	movw	r30, r16
 35a:	67 81       	ldd	r22, Z+7	; 0x07
 35c:	c7 01       	movw	r24, r14
 35e:	f6 01       	movw	r30, r12
 360:	09 95       	icall
 362:	f4 01       	movw	r30, r8
 364:	81 93       	st	Z+, r24
 366:	4f 01       	movw	r8, r30

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				uint8_t* dta = (uint8_t*)buff;
				while(size--){
 368:	8a 14       	cp	r8, r10
 36a:	9b 04       	cpc	r9, r11
 36c:	01 f4       	brne	.+0      	; 0x36e <spiAbstractDeviceReceiveBytes+0xbe>
 36e:	00 c0       	rjmp	.+0      	; 0x370 <spiAbstractDeviceReceiveBytes+0xc0>
					*dta++ = fn(bus,device->fillerByte);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 370:	82 ee       	ldi	r24, 0xE2	; 226
		}

	}
}
 372:	0f 90       	pop	r0
 374:	0f 90       	pop	r0
 376:	0f 90       	pop	r0
 378:	df 91       	pop	r29
 37a:	cf 91       	pop	r28
 37c:	1f 91       	pop	r17
 37e:	0f 91       	pop	r16
 380:	ff 90       	pop	r15
 382:	ef 90       	pop	r14
 384:	df 90       	pop	r13
 386:	cf 90       	pop	r12
 388:	bf 90       	pop	r11
 38a:	af 90       	pop	r10
 38c:	9f 90       	pop	r9
 38e:	8f 90       	pop	r8
				while(size--){
					*dta++ = fn(bus,device->fillerByte);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 390:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>
		}

	}
}
 394:	0f 90       	pop	r0
 396:	0f 90       	pop	r0
 398:	0f 90       	pop	r0
 39a:	df 91       	pop	r29
 39c:	cf 91       	pop	r28
 39e:	1f 91       	pop	r17
 3a0:	0f 91       	pop	r16
 3a2:	ff 90       	pop	r15
 3a4:	ef 90       	pop	r14
 3a6:	df 90       	pop	r13
 3a8:	cf 90       	pop	r12
 3aa:	bf 90       	pop	r11
 3ac:	af 90       	pop	r10
 3ae:	9f 90       	pop	r9
 3b0:	8f 90       	pop	r8
 3b2:	08 95       	ret

000003b4 <spiAbstractDeviceXferByte>:
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
}

// Send a byte and receive a response
uint8_t spiAbstractDeviceXferByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
 3b4:	1f 93       	push	r17
 3b6:	cf 93       	push	r28
 3b8:	df 93       	push	r29
 3ba:	16 2f       	mov	r17, r22
	SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 3bc:	fc 01       	movw	r30, r24
 3be:	c0 81       	ld	r28, Z
 3c0:	d1 81       	ldd	r29, Z+1	; 0x01
	uint8_t rtn;
	if(bus){
 3c2:	20 97       	sbiw	r28, 0x00	; 0
 3c4:	01 f0       	breq	.+0      	; 0x3c6 <spiAbstractDeviceXferByte+0x12>
		// Select the device if required
		if(bus->selectedDevice != device){
 3c6:	2a 85       	ldd	r18, Y+10	; 0x0a
 3c8:	3b 85       	ldd	r19, Y+11	; 0x0b
 3ca:	28 17       	cp	r18, r24
 3cc:	39 07       	cpc	r19, r25
 3ce:	01 f0       	breq	.+0      	; 0x3d0 <spiAbstractDeviceXferByte+0x1c>
			spiAbstractDeviceSelect(device,TRUE);
 3d0:	6f ef       	ldi	r22, 0xFF	; 255
 3d2:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		}

		const SPI_CLASS* class = bus->sclass;
		uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 3d6:	e8 81       	ld	r30, Y
 3d8:	f9 81       	ldd	r31, Y+1	; 0x01
 3da:	3a 96       	adiw	r30, 0x0a	; 10
 3dc:	25 91       	lpm	r18, Z+
 3de:	34 91       	lpm	r19, Z
		rtn = fn(bus,data);
 3e0:	61 2f       	mov	r22, r17
 3e2:	ce 01       	movw	r24, r28
 3e4:	f9 01       	movw	r30, r18
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
		rtn = 0;
	}
	return rtn;
}
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	1f 91       	pop	r17
			spiAbstractDeviceSelect(device,TRUE);
		}

		const SPI_CLASS* class = bus->sclass;
		uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
		rtn = fn(bus,data);
 3ec:	09 94       	ijmp
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
 3ee:	82 ee       	ldi	r24, 0xE2	; 226
 3f0:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		rtn = 0;
	}
	return rtn;
}
 3f4:	80 e0       	ldi	r24, 0x00	; 0
 3f6:	df 91       	pop	r29
 3f8:	cf 91       	pop	r28
 3fa:	1f 91       	pop	r17
 3fc:	08 95       	ret

000003fe <spiAbstractDeviceXferWord>:
	spiAbstractDeviceSendByte(device, ((data>>8) & 0xFF) );
	spiAbstractDeviceSendByte(device, (data & 0xFF) );
}

// Send a 16 bit word and receive a response
uint16_t spiAbstractDeviceXferWord(const SPI_ABSTRACT_DEVICE* device, uint16_t data){
 3fe:	ff 92       	push	r15
 400:	0f 93       	push	r16
 402:	1f 93       	push	r17
 404:	cf 93       	push	r28
 406:	df 93       	push	r29
 408:	8c 01       	movw	r16, r24
 40a:	f6 2e       	mov	r15, r22
 40c:	67 2f       	mov	r22, r23
	// Send MSB
	uint16_t rxData = spiAbstractDeviceXferByte( device, ((data>>8) & 0x00FF) )<<8;
 40e:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 412:	d8 2f       	mov	r29, r24
 414:	80 e0       	ldi	r24, 0x00	; 0
 416:	c8 2f       	mov	r28, r24
	// send LSB
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
 418:	6f 2d       	mov	r22, r15
 41a:	c8 01       	movw	r24, r16
 41c:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 420:	c8 2b       	or	r28, r24
    return rxData;
}
 422:	ce 01       	movw	r24, r28
 424:	df 91       	pop	r29
 426:	cf 91       	pop	r28
 428:	1f 91       	pop	r17
 42a:	0f 91       	pop	r16
 42c:	ff 90       	pop	r15
 42e:	08 95       	ret

00000430 <spiAbstractDeviceReceiveWord>:
	return spiAbstractDeviceXferByte(device, device->fillerByte);
}

// Get a word from the device
uint16_t spiAbstractDeviceReceiveWord(const SPI_ABSTRACT_DEVICE* device){
	uint16_t xmit = device->fillerByte;
 430:	fc 01       	movw	r30, r24
 432:	27 81       	ldd	r18, Z+7	; 0x07
 434:	30 e0       	ldi	r19, 0x00	; 0
	xmit <<= 8;
 436:	72 2f       	mov	r23, r18
 438:	66 27       	eor	r22, r22
	xmit |= device->fillerByte;
 43a:	62 2b       	or	r22, r18
 43c:	73 2b       	or	r23, r19

	return spiAbstractDeviceXferWord(device, xmit);
 43e:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>

00000442 <spiAbstractDeviceReceiveByte>:
	return rtn;
}

// Get a byte from the device
uint8_t spiAbstractDeviceReceiveByte(const SPI_ABSTRACT_DEVICE* device){
	return spiAbstractDeviceXferByte(device, device->fillerByte);
 442:	fc 01       	movw	r30, r24
 444:	67 81       	ldd	r22, Z+7	; 0x07
 446:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>

0000044a <spiAbstractDeviceSendByte>:

}

// Send a byte with no response
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
 44a:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>

0000044e <spiAbstractDeviceSendWord>:
}


//-------------- Implement common methonds
// Send a 16 bit word with no response
void spiAbstractDeviceSendWord(const SPI_ABSTRACT_DEVICE* device, uint16_t data){
 44e:	1f 93       	push	r17
 450:	cf 93       	push	r28
 452:	df 93       	push	r29
 454:	ec 01       	movw	r28, r24
 456:	16 2f       	mov	r17, r22
 458:	67 2f       	mov	r22, r23

}

// Send a byte with no response
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
 45a:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 45e:	61 2f       	mov	r22, r17
 460:	ce 01       	movw	r24, r28
//-------------- Implement common methonds
// Send a 16 bit word with no response
void spiAbstractDeviceSendWord(const SPI_ABSTRACT_DEVICE* device, uint16_t data){
	spiAbstractDeviceSendByte(device, ((data>>8) & 0xFF) );
	spiAbstractDeviceSendByte(device, (data & 0xFF) );
}
 462:	df 91       	pop	r29
 464:	cf 91       	pop	r28
 466:	1f 91       	pop	r17

}

// Send a byte with no response
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
 468:	0c 94 00 00 	jmp	0	; 0x0 <spiAbstractBusInit>

0000046c <spiAbstractBusSetClock>:
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order) = (void (*)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order))pgm_read_word(&class->order);
		fn(bus,order);
	}
}
void spiAbstractBusSetClock(SPI_ABSTRACT_BUS* bus,SPI_CLOCK clock){
	if(bus){
 46c:	00 97       	sbiw	r24, 0x00	; 0
 46e:	01 f0       	breq	.+0      	; 0x470 <spiAbstractBusSetClock+0x4>
		bus->clock = clock;
 470:	dc 01       	movw	r26, r24
 472:	16 96       	adiw	r26, 0x06	; 6
 474:	6c 93       	st	X, r22
 476:	16 97       	sbiw	r26, 0x06	; 6
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_CLOCK clock) = (void (*)(SPI_ABSTRACT_BUS*,SPI_CLOCK clock))pgm_read_word(&class->clock);
 478:	ed 91       	ld	r30, X+
 47a:	fc 91       	ld	r31, X
 47c:	34 96       	adiw	r30, 0x04	; 4
 47e:	25 91       	lpm	r18, Z+
 480:	34 91       	lpm	r19, Z
		fn(bus,clock);
 482:	f9 01       	movw	r30, r18
 484:	09 94       	ijmp
 486:	08 95       	ret

_uart_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000332  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000366  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000366  2**0
                  ALLOC
  3 .debug_info   00000cfc  00000000  00000000  00000366  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000325  00000000  00000000  00001062  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000b24  00000000  00000000  00001387  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001eab  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  00001ecb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001be  00000000  00000000  00001efb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000431  00000000  00000000  000020b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000024ea  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000018c  00000000  00000000  00002514  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_uartTransmitBlockStart>:
	void (*fn)(UART*,uint8_t) = (void (*)(UART*,uint8_t))pgm_read_word(&class->startXmit);
	fn(uart,txData);
}

// We are starting to transmit a block
static void _uartTransmitBlockStart(UART* uart){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	uart->readyTx = FALSE;				// indicate we are sending
   6:	88 85       	ldd	r24, Y+8	; 0x08
   8:	8e 7f       	andi	r24, 0xFE	; 254
   a:	88 87       	std	Y+8, r24	; 0x08
	if(uart->xmitCallback){
   c:	ee 89       	ldd	r30, Y+22	; 0x16
   e:	ff 89       	ldd	r31, Y+23	; 0x17
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <_uartTransmitBlockStart+0x14>
		uart->xmitCallback(uart->callbackParam,TRUE);
  14:	6f ef       	ldi	r22, 0xFF	; 255
  16:	88 8d       	ldd	r24, Y+24	; 0x18
  18:	99 8d       	ldd	r25, Y+25	; 0x19
  1a:	09 95       	icall
	}
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->startXmitMode);
  1c:	e9 85       	ldd	r30, Y+9	; 0x09
  1e:	fa 85       	ldd	r31, Y+10	; 0x0a
  20:	38 96       	adiw	r30, 0x08	; 8
  22:	85 91       	lpm	r24, Z+
  24:	94 91       	lpm	r25, Z
  26:	fc 01       	movw	r30, r24
	if(fn){
  28:	00 97       	sbiw	r24, 0x00	; 0
  2a:	01 f0       	breq	.+0      	; 0x2c <_uartTransmitBlockStart+0x2c>
		fn(uart);
  2c:	ce 01       	movw	r24, r28
	}
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
		uart->xmitCallback(uart->callbackParam,TRUE);
	}
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->startXmitMode);
	if(fn){
		fn(uart);
  32:	09 94       	ijmp
	}
}
  34:	df 91       	pop	r29
  36:	cf 91       	pop	r28
  38:	08 95       	ret

0000003a <_uartTransmitBlockEnd>:

// We have finished transmitting a block
static void _uartTransmitBlockEnd(UART* uart){
  3a:	cf 93       	push	r28
  3c:	df 93       	push	r29
  3e:	ec 01       	movw	r28, r24
	uart->readyTx = TRUE;				// indicate we are no longer sending
  40:	88 85       	ldd	r24, Y+8	; 0x08
  42:	9f ef       	ldi	r25, 0xFF	; 255
  44:	90 fb       	bst	r25, 0
  46:	80 f9       	bld	r24, 0
  48:	88 87       	std	Y+8, r24	; 0x08
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->endXmitMode);
  4a:	e9 85       	ldd	r30, Y+9	; 0x09
  4c:	fa 85       	ldd	r31, Y+10	; 0x0a
  4e:	3a 96       	adiw	r30, 0x0a	; 10
  50:	85 91       	lpm	r24, Z+
  52:	94 91       	lpm	r25, Z
  54:	fc 01       	movw	r30, r24
	if(fn){
  56:	00 97       	sbiw	r24, 0x00	; 0
  58:	01 f0       	breq	.+0      	; 0x5a <_uartTransmitBlockEnd+0x20>
		fn(uart);
  5a:	ce 01       	movw	r24, r28
  5c:	09 95       	icall
	}
	if(uart->xmitCallback){
  5e:	ee 89       	ldd	r30, Y+22	; 0x16
  60:	ff 89       	ldd	r31, Y+23	; 0x17
  62:	30 97       	sbiw	r30, 0x00	; 0
  64:	01 f0       	breq	.+0      	; 0x66 <_uartTransmitBlockEnd+0x2c>
		uart->xmitCallback(uart->callbackParam,FALSE);
  66:	60 e0       	ldi	r22, 0x00	; 0
  68:	88 8d       	ldd	r24, Y+24	; 0x18
  6a:	99 8d       	ldd	r25, Y+25	; 0x19
	}

}
  6c:	df 91       	pop	r29
  6e:	cf 91       	pop	r28
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->endXmitMode);
	if(fn){
		fn(uart);
	}
	if(uart->xmitCallback){
		uart->xmitCallback(uart->callbackParam,FALSE);
  70:	09 94       	ijmp
	}

}
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	08 95       	ret

00000078 <_uartStartXmit>:


// Virutal function - start sending the given byte
void _uartStartXmit(UART* uart,uint8_t txData){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,uint8_t) = (void (*)(UART*,uint8_t))pgm_read_word(&class->startXmit);
  78:	dc 01       	movw	r26, r24
  7a:	19 96       	adiw	r26, 0x09	; 9
  7c:	ed 91       	ld	r30, X+
  7e:	fc 91       	ld	r31, X
  80:	1a 97       	sbiw	r26, 0x0a	; 10
  82:	32 96       	adiw	r30, 0x02	; 2
  84:	25 91       	lpm	r18, Z+
  86:	34 91       	lpm	r19, Z
	fn(uart,txData);
  88:	f9 01       	movw	r30, r18
  8a:	09 94       	ijmp

0000008c <__uartReceiveService>:
}



// A byte has been received - interrupts are off
void __uartReceiveService(UART* uart, uint8_t c){
  8c:	cf 93       	push	r28
  8e:	df 93       	push	r29
  90:	ec 01       	movw	r28, r24
  92:	86 2f       	mov	r24, r22
	// if there's a user function to handle this receive event
	if(uart->rxFunc){
  94:	2c 81       	ldd	r18, Y+4	; 0x04
  96:	3d 81       	ldd	r19, Y+5	; 0x05
  98:	23 2b       	or	r18, r19
  9a:	01 f0       	breq	.+0      	; 0x9c <__uartReceiveService+0x10>
		// call it and pass the received data
		uart->rxFunc(c,uart->rxFuncData);
  9c:	ec 81       	ldd	r30, Y+4	; 0x04
  9e:	fd 81       	ldd	r31, Y+5	; 0x05
  a0:	6e 81       	ldd	r22, Y+6	; 0x06
  a2:	7f 81       	ldd	r23, Y+7	; 0x07
		}else{
			uart->rxOverflow=TRUE;
			setError(UART_RECEIVE_OVERFLOW);
		}
	}
}
  a4:	df 91       	pop	r29
  a6:	cf 91       	pop	r28
// A byte has been received - interrupts are off
void __uartReceiveService(UART* uart, uint8_t c){
	// if there's a user function to handle this receive event
	if(uart->rxFunc){
		// call it and pass the received data
		uart->rxFunc(c,uart->rxFuncData);
  a8:	09 94       	ijmp
	}else if( uart->rxBuffer ){
  aa:	28 81       	ld	r18, Y
  ac:	39 81       	ldd	r19, Y+1	; 0x01
  ae:	21 15       	cp	r18, r1
  b0:	31 05       	cpc	r19, r1
  b2:	01 f0       	breq	.+0      	; 0xb4 <__uartReceiveService+0x28>
		// there is a receive buffer so try to append it
		if(bufferPut(__uartGetRxBuffer(uart),c)==FALSE){
  b4:	c9 01       	movw	r24, r18
  b6:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
  ba:	81 11       	cpse	r24, r1
  bc:	00 c0       	rjmp	.+0      	; 0xbe <__uartReceiveService+0x32>
  be:	00 c0       	rjmp	.+0      	; 0xc0 <__uartReceiveService+0x34>
			// track overflows
			uart->rxOverflow=TRUE;
			setError(UART_RECEIVE_OVERFLOW);
		}
	}else{
		if(uart->rxChar == -1){
  c0:	2b 85       	ldd	r18, Y+11	; 0x0b
  c2:	3c 85       	ldd	r19, Y+12	; 0x0c
  c4:	2f 3f       	cpi	r18, 0xFF	; 255
  c6:	3f 4f       	sbci	r19, 0xFF	; 255
  c8:	01 f4       	brne	.+0      	; 0xca <__uartReceiveService+0x3e>
			uart->rxChar = c;
  ca:	70 e0       	ldi	r23, 0x00	; 0
  cc:	7c 87       	std	Y+12, r23	; 0x0c
  ce:	6b 87       	std	Y+11, r22	; 0x0b
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <__uartReceiveService+0x46>
		}else{
			uart->rxOverflow=TRUE;
  d2:	88 85       	ldd	r24, Y+8	; 0x08
  d4:	9f ef       	ldi	r25, 0xFF	; 255
  d6:	90 fb       	bst	r25, 0
  d8:	82 f9       	bld	r24, 2
  da:	88 87       	std	Y+8, r24	; 0x08
			setError(UART_RECEIVE_OVERFLOW);
  dc:	85 ef       	ldi	r24, 0xF5	; 245
		}
	}
}
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
	}else{
		if(uart->rxChar == -1){
			uart->rxChar = c;
		}else{
			uart->rxOverflow=TRUE;
			setError(UART_RECEIVE_OVERFLOW);
  e2:	0c 94 00 00 	jmp	0	; 0x0 <_uartTransmitBlockStart>
		}
	}
}
  e6:	df 91       	pop	r29
  e8:	cf 91       	pop	r28
  ea:	08 95       	ret

000000ec <__uartTransmitService>:

// We have finished transmitting the current byte
void __uartTransmitService(UART* uart){
  ec:	ff 92       	push	r15
  ee:	0f 93       	push	r16
  f0:	1f 93       	push	r17
  f2:	cf 93       	push	r28
  f4:	df 93       	push	r29
  f6:	1f 92       	push	r1
  f8:	cd b7       	in	r28, 0x3d	; 61
  fa:	de b7       	in	r29, 0x3e	; 62
  fc:	8c 01       	movw	r16, r24
	if(uart->sendingBuffer){
  fe:	fc 01       	movw	r30, r24
 100:	80 85       	ldd	r24, Z+8	; 0x08
		// there is a transmit buffer
		uint8_t c;

		CRITICAL_SECTION_START;
 102:	ff b6       	in	r15, 0x3f	; 63
 104:	f8 94       	cli
	}
}

// We have finished transmitting the current byte
void __uartTransmitService(UART* uart){
	if(uart->sendingBuffer){
 106:	81 ff       	sbrs	r24, 1
 108:	00 c0       	rjmp	.+0      	; 0x10a <__uartTransmitService+0x1e>
		// there is a transmit buffer
		uint8_t c;

		CRITICAL_SECTION_START;
		if(bufferGet(__uartGetTxBuffer(uart),&c)){
 10a:	be 01       	movw	r22, r28
 10c:	6f 5f       	subi	r22, 0xFF	; 255
 10e:	7f 4f       	sbci	r23, 0xFF	; 255
 110:	82 81       	ldd	r24, Z+2	; 0x02
 112:	93 81       	ldd	r25, Z+3	; 0x03
 114:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 118:	88 23       	and	r24, r24
 11a:	01 f0       	breq	.+0      	; 0x11c <__uartTransmitService+0x30>
			// send the next byte
			_uartStartXmit(uart,c);
 11c:	69 81       	ldd	r22, Y+1	; 0x01
 11e:	c8 01       	movw	r24, r16
 120:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 124:	00 c0       	rjmp	.+0      	; 0x126 <__uartTransmitService+0x3a>
		}else{
			// all done
			_uartTransmitBlockEnd(uart);		// we have finished sending
 126:	c8 01       	movw	r24, r16
 128:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
			uart->sendingBuffer = FALSE;		// we are not sending a buffer
 12c:	f8 01       	movw	r30, r16
 12e:	80 85       	ldd	r24, Z+8	; 0x08
 130:	8d 7f       	andi	r24, 0xFD	; 253
 132:	80 87       	std	Z+8, r24	; 0x08
 134:	00 c0       	rjmp	.+0      	; 0x136 <__uartTransmitService+0x4a>
		}
		CRITICAL_SECTION_END;
	}else{
		CRITICAL_SECTION_START;
		// indicate transmit complete, back to ready
		_uartTransmitBlockEnd(uart);				// we have finished sending
 136:	c8 01       	movw	r24, r16
 138:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		CRITICAL_SECTION_END;
 13c:	ff be       	out	0x3f, r15	; 63
	}
}
 13e:	0f 90       	pop	r0
 140:	df 91       	pop	r29
 142:	cf 91       	pop	r28
 144:	1f 91       	pop	r17
 146:	0f 91       	pop	r16
 148:	ff 90       	pop	r15
 14a:	08 95       	ret

0000014c <__uartGetByte>:


// Gets a single byte from the uart receive buffer.
// Returns the byte, or -1 if no byte is available (getchar-style).
int __uartGetByte(UART* uart){
 14c:	cf 93       	push	r28
 14e:	df 93       	push	r29
 150:	1f 92       	push	r1
 152:	cd b7       	in	r28, 0x3d	; 61
 154:	de b7       	in	r29, 0x3e	; 62
 156:	fc 01       	movw	r30, r24
}

// Returns pointer to the receive buffer structure.
#define uartGetRxBuffer(uart) __uartGetRxBuffer(&((uart)->_uart_))
static __inline__ cBuffer* __uartGetRxBuffer(const UART* uart){
	return uart->rxBuffer;
 158:	80 81       	ld	r24, Z
 15a:	91 81       	ldd	r25, Z+1	; 0x01
	// get single byte from receive buffer (if available)
	uint8_t c;
	int rtn;

	cBuffer* buffer = __uartGetRxBuffer(uart);
	if(buffer!=null){
 15c:	00 97       	sbiw	r24, 0x00	; 0
 15e:	01 f0       	breq	.+0      	; 0x160 <__uartGetByte+0x14>
		// There is a receive buffer
		if(bufferGet(buffer,&c))
 160:	be 01       	movw	r22, r28
 162:	6f 5f       	subi	r22, 0xFF	; 255
 164:	7f 4f       	sbci	r23, 0xFF	; 255
 166:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 16a:	88 23       	and	r24, r24
 16c:	01 f0       	breq	.+0      	; 0x16e <__uartGetByte+0x22>
			rtn = c;
 16e:	29 81       	ldd	r18, Y+1	; 0x01
 170:	30 e0       	ldi	r19, 0x00	; 0
 172:	00 c0       	rjmp	.+0      	; 0x174 <__uartGetByte+0x28>
		else
			rtn = -1;
	}else{
		CRITICAL_SECTION_START;
 174:	4f b7       	in	r20, 0x3f	; 63
 176:	f8 94       	cli
		rtn = uart->rxChar;		// get the last received char
 178:	23 85       	ldd	r18, Z+11	; 0x0b
 17a:	34 85       	ldd	r19, Z+12	; 0x0c
		uart->rxChar = -1;		// and reset it
 17c:	8f ef       	ldi	r24, 0xFF	; 255
 17e:	9f ef       	ldi	r25, 0xFF	; 255
 180:	94 87       	std	Z+12, r25	; 0x0c
 182:	83 87       	std	Z+11, r24	; 0x0b
		CRITICAL_SECTION_END;
 184:	4f bf       	out	0x3f, r20	; 63
 186:	00 c0       	rjmp	.+0      	; 0x188 <__uartGetByte+0x3c>
	if(buffer!=null){
		// There is a receive buffer
		if(bufferGet(buffer,&c))
			rtn = c;
		else
			rtn = -1;
 188:	2f ef       	ldi	r18, 0xFF	; 255
 18a:	3f ef       	ldi	r19, 0xFF	; 255
		rtn = uart->rxChar;		// get the last received char
		uart->rxChar = -1;		// and reset it
		CRITICAL_SECTION_END;
	}
	return rtn;
}
 18c:	c9 01       	movw	r24, r18
 18e:	0f 90       	pop	r0
 190:	df 91       	pop	r29
 192:	cf 91       	pop	r28
 194:	08 95       	ret

00000196 <_uartSendByte>:
	}
}


// Sends a single byte over the uart.
uint8_t _uartSendByte(UART* uart, uint8_t txData){
 196:	0f 93       	push	r16
 198:	1f 93       	push	r17
 19a:	cf 93       	push	r28
 19c:	df 93       	push	r29
 19e:	ec 01       	movw	r28, r24
 1a0:	16 2f       	mov	r17, r22
	if(uart->txBuffer){
 1a2:	2a 81       	ldd	r18, Y+2	; 0x02
 1a4:	3b 81       	ldd	r19, Y+3	; 0x03
 1a6:	23 2b       	or	r18, r19
 1a8:	01 f4       	brne	.+0      	; 0x1aa <_uartSendByte+0x14>
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <_uartSendByte+0x16>
		// Wait if the buffer is full
		while(bufferIsFull(uart->txBuffer)){
			breathe();
 1ac:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>

// Sends a single byte over the uart.
uint8_t _uartSendByte(UART* uart, uint8_t txData){
	if(uart->txBuffer){
		// Wait if the buffer is full
		while(bufferIsFull(uart->txBuffer)){
 1b0:	8a 81       	ldd	r24, Y+2	; 0x02
 1b2:	9b 81       	ldd	r25, Y+3	; 0x03
 1b4:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 1b8:	81 11       	cpse	r24, r1
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <_uartSendByte+0x26>
			breathe();
		}

		CRITICAL_SECTION_START;
 1bc:	0f b7       	in	r16, 0x3f	; 63
 1be:	f8 94       	cli
		if(!uart->sendingBuffer){
 1c0:	88 85       	ldd	r24, Y+8	; 0x08
 1c2:	81 fd       	sbrc	r24, 1
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <_uartSendByte+0x30>
			// Not already transmitting so start sending the buffer
			uart->sendingBuffer = TRUE;			// we are sending a buffer
 1c6:	88 85       	ldd	r24, Y+8	; 0x08
 1c8:	9f ef       	ldi	r25, 0xFF	; 255
 1ca:	90 fb       	bst	r25, 0
 1cc:	81 f9       	bld	r24, 1
 1ce:	88 87       	std	Y+8, r24	; 0x08
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <_uartSendByte+0x3c>
			_uartTransmitBlockStart(uart);			// indicate we are sending
			_uartStartXmit(uart,txData);		// put the byte
		}else{
			// add char to the output queue
			bufferPut(uart->txBuffer,txData);
 1d2:	61 2f       	mov	r22, r17
 1d4:	8a 81       	ldd	r24, Y+2	; 0x02
 1d6:	9b 81       	ldd	r25, Y+3	; 0x03
 1d8:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <_uartSendByte+0x48>
	}else{
		// There is no xmit buffer - just send now

		// Wait till sending has stopped
		while(!uart->readyTx){
			breathe();
 1de:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>

	}else{
		// There is no xmit buffer - just send now

		// Wait till sending has stopped
		while(!uart->readyTx){
 1e2:	88 85       	ldd	r24, Y+8	; 0x08
 1e4:	80 ff       	sbrs	r24, 0
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <_uartSendByte+0x52>
			breathe();
		}
		CRITICAL_SECTION_START;
 1e8:	0f b7       	in	r16, 0x3f	; 63
 1ea:	f8 94       	cli
		_uartTransmitBlockStart(uart);			// indicate we are sending
 1ec:	ce 01       	movw	r24, r28
 1ee:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		_uartStartXmit(uart,txData);		// put the byte
 1f2:	61 2f       	mov	r22, r17
 1f4:	ce 01       	movw	r24, r28
 1f6:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		CRITICAL_SECTION_END;
 1fa:	0f bf       	out	0x3f, r16	; 63
	}
	return txData;
}
 1fc:	81 2f       	mov	r24, r17
 1fe:	df 91       	pop	r29
 200:	cf 91       	pop	r28
 202:	1f 91       	pop	r17
 204:	0f 91       	pop	r16
 206:	08 95       	ret

00000208 <_uartSendBuffer>:
	}
	return rtn;
}

// Send a block of data
void _uartSendBuffer(UART* uart, const uint8_t* data, size_t count){
 208:	ef 92       	push	r14
 20a:	ff 92       	push	r15
 20c:	0f 93       	push	r16
 20e:	1f 93       	push	r17
 210:	cf 93       	push	r28
 212:	df 93       	push	r29
 214:	7c 01       	movw	r14, r24
 216:	8a 01       	movw	r16, r20
 218:	eb 01       	movw	r28, r22
 21a:	06 0f       	add	r16, r22
 21c:	17 1f       	adc	r17, r23
	while(count--){
 21e:	00 c0       	rjmp	.+0      	; 0x220 <_uartSendBuffer+0x18>
		_uartSendByte(uart,*data++);
 220:	69 91       	ld	r22, Y+
 222:	c7 01       	movw	r24, r14
 224:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
	return rtn;
}

// Send a block of data
void _uartSendBuffer(UART* uart, const uint8_t* data, size_t count){
	while(count--){
 228:	c0 17       	cp	r28, r16
 22a:	d1 07       	cpc	r29, r17
 22c:	01 f4       	brne	.+0      	; 0x22e <_uartSendBuffer+0x26>
		_uartSendByte(uart,*data++);
	}
}
 22e:	df 91       	pop	r29
 230:	cf 91       	pop	r28
 232:	1f 91       	pop	r17
 234:	0f 91       	pop	r16
 236:	ff 90       	pop	r15
 238:	ef 90       	pop	r14
 23a:	08 95       	ret

0000023c <_uartSetBaudRate>:
	return txData;
}

void _uartSetBaudRate(UART* uart, BAUD_RATE baud){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,BAUD_RATE) = (void (*)(UART*,BAUD_RATE))pgm_read_word(&class->setBaudRate);
 23c:	dc 01       	movw	r26, r24
 23e:	19 96       	adiw	r26, 0x09	; 9
 240:	ed 91       	ld	r30, X+
 242:	fc 91       	ld	r31, X
 244:	1a 97       	sbiw	r26, 0x0a	; 10
 246:	25 91       	lpm	r18, Z+
 248:	34 91       	lpm	r19, Z
	fn(uart,baud);
 24a:	f9 01       	movw	r30, r18
 24c:	09 94       	ijmp

0000024e <_uartOff>:
}

void _uartOff(UART* uart){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->off);
 24e:	dc 01       	movw	r26, r24
 250:	19 96       	adiw	r26, 0x09	; 9
 252:	ed 91       	ld	r30, X+
 254:	fc 91       	ld	r31, X
 256:	1a 97       	sbiw	r26, 0x0a	; 10
 258:	36 96       	adiw	r30, 0x06	; 6
 25a:	25 91       	lpm	r18, Z+
 25c:	34 91       	lpm	r19, Z
 25e:	f9 01       	movw	r30, r18

	// Wait till everything has been sent
	INTERRUPTABLE_SECTION_START;
 260:	2f b7       	in	r18, 0x3f	; 63
 262:	78 94       	sei
int __uartGetByte(UART* uart);

// Is the UART busy doing something?
#define uartIsBusy(uart) __uartIsBusy(&((uart)->_uart_))
static __inline__ boolean __uartIsBusy(UART* uart){
	return (uart->readyTx) ? FALSE : TRUE;
 264:	dc 01       	movw	r26, r24
 266:	18 96       	adiw	r26, 0x08	; 8
 268:	3c 91       	ld	r19, X
 26a:	30 ff       	sbrs	r19, 0
 26c:	00 c0       	rjmp	.+0      	; 0x26e <_uartOff+0x20>
	while(__uartIsBusy(uart));
	INTERRUPTABLE_SECTION_END;
 26e:	2f bf       	out	0x3f, r18	; 63

	fn(uart);
 270:	09 94       	ijmp

00000272 <_uartInit>:
}


void _uartInit(UART* uart, BAUD_RATE baud){
 272:	cf 92       	push	r12
 274:	df 92       	push	r13
 276:	ef 92       	push	r14
 278:	ff 92       	push	r15
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
 27e:	ec 01       	movw	r28, r24
 280:	6a 01       	movw	r12, r20
 282:	7b 01       	movw	r14, r22
	cli();
 284:	f8 94       	cli

	// For one wire Make the pins into inputs with pullups enabled
	if(_uartIsOneWire(uart)){
 286:	8d 89       	ldd	r24, Y+21	; 0x15
 288:	88 23       	and	r24, r24
 28a:	01 f0       	breq	.+0      	; 0x28c <_uartInit+0x1a>
		if(uart->rx_pin != uart->tx_pin){
 28c:	8d 85       	ldd	r24, Y+13	; 0x0d
 28e:	9e 85       	ldd	r25, Y+14	; 0x0e
 290:	2f 85       	ldd	r18, Y+15	; 0x0f
 292:	38 89       	ldd	r19, Y+16	; 0x10
 294:	82 17       	cp	r24, r18
 296:	93 07       	cpc	r25, r19
 298:	01 f0       	breq	.+0      	; 0x29a <_uartInit+0x28>
			pin_make_input(uart->rx_pin,FALSE);
 29a:	60 e0       	ldi	r22, 0x00	; 0
 29c:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		}
		pin_make_input(uart->tx_pin,TRUE);
 2a0:	6f ef       	ldi	r22, 0xFF	; 255
 2a2:	8f 85       	ldd	r24, Y+15	; 0x0f
 2a4:	98 89       	ldd	r25, Y+16	; 0x10
 2a6:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
	}

	// Initialise local variable
	uart->readyTx = TRUE;
 2aa:	88 85       	ldd	r24, Y+8	; 0x08
 2ac:	9f ef       	ldi	r25, 0xFF	; 255
 2ae:	90 fb       	bst	r25, 0
 2b0:	80 f9       	bld	r24, 0
 2b2:	88 87       	std	Y+8, r24	; 0x08
	uart->rxOverflow = FALSE;
 2b4:	88 85       	ldd	r24, Y+8	; 0x08
 2b6:	8b 7f       	andi	r24, 0xFB	; 251
 2b8:	88 87       	std	Y+8, r24	; 0x08
	uart->sendingBuffer = FALSE;
 2ba:	88 85       	ldd	r24, Y+8	; 0x08
 2bc:	8d 7f       	andi	r24, 0xFD	; 253
 2be:	88 87       	std	Y+8, r24	; 0x08
//	uart->rxFunc = null;

	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,BAUD_RATE) = (void (*)(UART*,BAUD_RATE))pgm_read_word(&class->init);
 2c0:	e9 85       	ldd	r30, Y+9	; 0x09
 2c2:	fa 85       	ldd	r31, Y+10	; 0x0a
 2c4:	34 96       	adiw	r30, 0x04	; 4
 2c6:	25 91       	lpm	r18, Z+
 2c8:	34 91       	lpm	r19, Z

	fn(uart,baud);
 2ca:	b7 01       	movw	r22, r14
 2cc:	a6 01       	movw	r20, r12
 2ce:	ce 01       	movw	r24, r28
 2d0:	f9 01       	movw	r30, r18
 2d2:	09 95       	icall
	sei();
 2d4:	78 94       	sei
}
 2d6:	df 91       	pop	r29
 2d8:	cf 91       	pop	r28
 2da:	ff 90       	pop	r15
 2dc:	ef 90       	pop	r14
 2de:	df 90       	pop	r13
 2e0:	cf 90       	pop	r12
 2e2:	08 95       	ret

000002e4 <__uartFlushReceiveBuffer>:

void __uartFlushReceiveBuffer(UART* uart){
 2e4:	fc 01       	movw	r30, r24
}

// Returns pointer to the receive buffer structure.
#define uartGetRxBuffer(uart) __uartGetRxBuffer(&((uart)->_uart_))
static __inline__ cBuffer* __uartGetRxBuffer(const UART* uart){
	return uart->rxBuffer;
 2e6:	80 81       	ld	r24, Z
 2e8:	91 81       	ldd	r25, Z+1	; 0x01
	if(__uartGetRxBuffer(uart)){
 2ea:	00 97       	sbiw	r24, 0x00	; 0
 2ec:	01 f0       	breq	.+0      	; 0x2ee <__uartFlushReceiveBuffer+0xa>
		// flush all data from receive buffer
		bufferFlush(__uartGetRxBuffer(uart));
 2ee:	0c 94 00 00 	jmp	0	; 0x0 <_uartTransmitBlockStart>
	}else{
		CRITICAL_SECTION_START;
 2f2:	2f b7       	in	r18, 0x3f	; 63
 2f4:	f8 94       	cli
		uart->rxChar = -1;
 2f6:	8f ef       	ldi	r24, 0xFF	; 255
 2f8:	9f ef       	ldi	r25, 0xFF	; 255
 2fa:	94 87       	std	Z+12, r25	; 0x0c
 2fc:	83 87       	std	Z+11, r24	; 0x0b
		CRITICAL_SECTION_END;
 2fe:	2f bf       	out	0x3f, r18	; 63
 300:	08 95       	ret

00000302 <__uartReceiveBufferIsEmpty>:
	}
}

boolean __uartReceiveBufferIsEmpty(const UART* uart){
 302:	fc 01       	movw	r30, r24
	boolean rtn;
	if(__uartGetRxBuffer(uart)){
 304:	80 81       	ld	r24, Z
 306:	91 81       	ldd	r25, Z+1	; 0x01
		CRITICAL_SECTION_START;
 308:	2f b7       	in	r18, 0x3f	; 63
 30a:	f8 94       	cli
	}
}

boolean __uartReceiveBufferIsEmpty(const UART* uart){
	boolean rtn;
	if(__uartGetRxBuffer(uart)){
 30c:	89 2b       	or	r24, r25
 30e:	01 f0       	breq	.+0      	; 0x310 <__uartReceiveBufferIsEmpty+0xe>
		CRITICAL_SECTION_START;
		rtn = (__uartGetRxBuffer(uart)->datalength == 0) ? TRUE : FALSE;
 310:	01 90       	ld	r0, Z+
 312:	f0 81       	ld	r31, Z
 314:	e0 2d       	mov	r30, r0
 316:	84 81       	ldd	r24, Z+4	; 0x04
 318:	95 81       	ldd	r25, Z+5	; 0x05
 31a:	89 2b       	or	r24, r25
 31c:	01 f4       	brne	.+0      	; 0x31e <__uartReceiveBufferIsEmpty+0x1c>
 31e:	00 c0       	rjmp	.+0      	; 0x320 <__uartReceiveBufferIsEmpty+0x1e>
		CRITICAL_SECTION_END;
	}else{
		CRITICAL_SECTION_START;
		rtn = (uart->rxChar == -1) ? TRUE : FALSE;
 320:	83 85       	ldd	r24, Z+11	; 0x0b
 322:	94 85       	ldd	r25, Z+12	; 0x0c
 324:	01 96       	adiw	r24, 0x01	; 1
 326:	01 f4       	brne	.+0      	; 0x328 <__uartReceiveBufferIsEmpty+0x26>
 328:	8f ef       	ldi	r24, 0xFF	; 255
 32a:	00 c0       	rjmp	.+0      	; 0x32c <__uartReceiveBufferIsEmpty+0x2a>
 32c:	80 e0       	ldi	r24, 0x00	; 0
		CRITICAL_SECTION_END;
 32e:	2f bf       	out	0x3f, r18	; 63
	}
	return rtn;
}
 330:	08 95       	ret

a2d.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000009a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ce  2**0
                  ALLOC
  3 .text.startup 00000066  00000000  00000000  000000ce  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .ctors        00000002  00000000  00000000  00000134  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  5 .debug_info   000002da  00000000  00000000  00000136  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_abbrev 000001dd  00000000  00000000  00000410  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    0000011d  00000000  00000000  000005ed  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_aranges 00000028  00000000  00000000  0000070a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_ranges 00000030  00000000  00000000  00000732  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_line   000000ea  00000000  00000000  00000762  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000239  00000000  00000000  0000084c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      0000002a  00000000  00000000  00000a85  2**0
                  CONTENTS, READONLY
 13 .debug_frame  00000090  00000000  00000000  00000ab0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <a2dOff>:

volatile uint8_t a2dCompleteFlag;

// turn off a2d converter
void a2dOff(void){
	cbi(ADCSR, ADIE);				// disable ADC interrupts
   0:	ea e7       	ldi	r30, 0x7A	; 122
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	87 7f       	andi	r24, 0xF7	; 247
   8:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
   a:	80 81       	ld	r24, Z
   c:	8f 77       	andi	r24, 0x7F	; 127
   e:	80 83       	st	Z, r24
  10:	08 95       	ret

00000012 <a2dSetPrescaler>:
}

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(ADC_PRESCALE prescale){
	ADCSR =  (ADCSR & ~ADC_PRESCALE_MASK) | (prescale & ADC_PRESCALE_MASK);
  12:	ea e7       	ldi	r30, 0x7A	; 122
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	90 81       	ld	r25, Z
  18:	87 70       	andi	r24, 0x07	; 7
  1a:	98 7f       	andi	r25, 0xF8	; 248
  1c:	89 2b       	or	r24, r25
  1e:	80 83       	st	Z, r24
  20:	08 95       	ret

00000022 <a2dConvert10bit>:

// sets the a2d input channel
static void a2dSetChannel(ADC_CHANNEL ch){
#ifdef MUX5
	if(ch & 0x20){
    	ADCSRB |= _BV(MUX5);
  22:	90 91 7b 00 	lds	r25, 0x007B


// sets the a2d input channel
static void a2dSetChannel(ADC_CHANNEL ch){
#ifdef MUX5
	if(ch & 0x20){
  26:	85 ff       	sbrs	r24, 5
  28:	00 c0       	rjmp	.+0      	; 0x2a <a2dConvert10bit+0x8>
    	ADCSRB |= _BV(MUX5);
  2a:	98 60       	ori	r25, 0x08	; 8
  2c:	00 c0       	rjmp	.+0      	; 0x2e <a2dConvert10bit+0xc>
	}else{
    	ADCSRB &= ~_BV(MUX5);
  2e:	97 7f       	andi	r25, 0xF7	; 247
  30:	90 93 7b 00 	sts	0x007B, r25
	}
#endif
	ADMUX = (ADMUX & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK);	// set channel
  34:	90 91 7c 00 	lds	r25, 0x007C
  38:	8f 71       	andi	r24, 0x1F	; 31
  3a:	90 7e       	andi	r25, 0xE0	; 224
  3c:	89 2b       	or	r24, r25
  3e:	80 93 7c 00 	sts	0x007C, r24
}

// start a conversion on the current a2d input channel
static void a2dStartConvert(void){
	a2dCompleteFlag = FALSE;		// clear conversion complete flag
  42:	10 92 00 00 	sts	0x0000, r1
	sbi(ADCSR, ADIF);				// clear hardware "conversion complete" flag
  46:	80 91 7a 00 	lds	r24, 0x007A
  4a:	80 61       	ori	r24, 0x10	; 16
  4c:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);				// start conversion
  50:	80 91 7a 00 	lds	r24, 0x007A
  54:	80 64       	ori	r24, 0x40	; 64
  56:	80 93 7a 00 	sts	0x007A, r24
}

static boolean a2dIsComplete(void){
	return bit_is_set(ADCSR, ADSC) ? FALSE : TRUE;
  5a:	80 91 7a 00 	lds	r24, 0x007A
  5e:	86 fd       	sbrc	r24, 6
  60:	00 c0       	rjmp	.+0      	; 0x62 <a2dConvert10bit+0x40>
uint16_t a2dConvert10bit(ADC_CHANNEL ch)
{
	a2dSetChannel(ch);						// set the channel
	a2dStartConvert();						// start the conversion
	while( !a2dIsComplete() );				// wait until conversion complete
	return ADC;
  62:	20 91 78 00 	lds	r18, 0x0078
  66:	30 91 79 00 	lds	r19, 0x0079
}
  6a:	c9 01       	movw	r24, r18
  6c:	08 95       	ret

0000006e <a2dConvert8bit>:

// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
uint8_t a2dConvert8bit(ADC_CHANNEL ch){
 	uint16_t rtn = a2dConvert10bit(ch)>>2;
  6e:	0e 94 00 00 	call	0	; 0x0 <a2dOff>
  72:	96 95       	lsr	r25
  74:	87 95       	ror	r24
  76:	96 95       	lsr	r25
  78:	87 95       	ror	r24
	return (uint8_t)rtn;
}
  7a:	08 95       	ret

0000007c <__vector_29>:
// Interrupt handler for ADC complete interrupt.
#ifndef ADC_vect
#  error Missing ADC_vect
#endif
ISR(ADC_vect)
{
  7c:	1f 92       	push	r1
  7e:	0f 92       	push	r0
  80:	0f b6       	in	r0, 0x3f	; 63
  82:	0f 92       	push	r0
  84:	11 24       	eor	r1, r1
  86:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
  88:	8f ef       	ldi	r24, 0xFF	; 255
  8a:	80 93 00 00 	sts	0x0000, r24
}
  8e:	8f 91       	pop	r24
  90:	0f 90       	pop	r0
  92:	0f be       	out	0x3f, r0	; 63
  94:	0f 90       	pop	r0
  96:	1f 90       	pop	r1
  98:	18 95       	reti

Disassembly of section .text.startup:

00000000 <a2dInit>:


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
   4:	80 91 7a 00 	lds	r24, 0x007A
   8:	80 68       	ori	r24, 0x80	; 128
   a:	80 93 7a 00 	sts	0x007A, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
   e:	80 91 7a 00 	lds	r24, 0x007A
  12:	8f 7d       	andi	r24, 0xDF	; 223
  14:	80 93 7a 00 	sts	0x007A, r24
	a2dSetPrescaler(ADC_DEFAULT_PRESCALE);	// set default prescaler
  18:	86 e0       	ldi	r24, 0x06	; 6
  1a:	0e 94 00 00 	call	0	; 0x0 <a2dInit>
	ADCSR =  (ADCSR & ~ADC_PRESCALE_MASK) | (prescale & ADC_PRESCALE_MASK);
}

// configure A2D converter voltage reference
static void a2dSetReference(uint8_t ref){
	ADMUX = (ADMUX & ~ADC_REFERENCE_MASK) | ((ref<<REFS0) & ADC_REFERENCE_MASK);
  1e:	80 91 7c 00 	lds	r24, 0x007C
  22:	8f 73       	andi	r24, 0x3F	; 63
  24:	80 64       	ori	r24, 0x40	; 64
  26:	80 93 7c 00 	sts	0x007C, r24
void __attribute__ ((constructor)) a2dInit(void){
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_DEFAULT_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_DEFAULT_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
  2a:	80 91 7c 00 	lds	r24, 0x007C
  2e:	8f 7d       	andi	r24, 0xDF	; 223
  30:	80 93 7c 00 	sts	0x007C, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
  34:	80 91 7a 00 	lds	r24, 0x007A
  38:	88 60       	ori	r24, 0x08	; 8
  3a:	80 93 7a 00 	sts	0x007A, r24
	a2dCompleteFlag = TRUE;			// not doing an a2d
  3e:	8f ef       	ldi	r24, 0xFF	; 255
  40:	80 93 00 00 	sts	0x0000, r24
	sei();							// turn on interrupts (if not already on)
  44:	78 94       	sei

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
  46:	c0 91 00 00 	lds	r28, 0x0000
  4a:	d0 e0       	ldi	r29, 0x00	; 0
  4c:	00 c0       	rjmp	.+0      	; 0x4e <a2dInit+0x4e>
	a2dCompleteFlag = TRUE;
}


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
  4e:	8c 2f       	mov	r24, r28
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
  50:	c8 30       	cpi	r28, 0x08	; 8
  52:	d1 05       	cpc	r29, r1
  54:	04 f0       	brlt	.+0      	; 0x56 <a2dInit+0x56>
	a2dCompleteFlag = TRUE;
}


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
  56:	88 5e       	subi	r24, 0xE8	; 232
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
  58:	0e 94 00 00 	call	0	; 0x0 <a2dInit>
	a2dCompleteFlag = TRUE;			// not doing an a2d
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
  5c:	21 97       	sbiw	r28, 0x01	; 1
  5e:	00 f4       	brcc	.+0      	; 0x60 <a2dInit+0x60>
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
	}
}
  60:	df 91       	pop	r29
  62:	cf 91       	pop	r28
  64:	08 95       	ret

a2dReadMv.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000028  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000005c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000005c  2**0
                  ALLOC
  3 .debug_info   000001c8  00000000  00000000  0000005c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000012f  00000000  00000000  00000224  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000068  00000000  00000000  00000353  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000003bb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000b0  00000000  00000000  000003db  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000014f  00000000  00000000  0000048b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000005da  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000030  00000000  00000000  00000604  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <a2dReadMv>:
 *  Read a voltage on an a2d input in millivolts
 *  This requires a specification of what AVcc actually is ie 100%
 */
#include "a2d.h"
#include "core.h"
uint16_t a2dReadMv(ADC_CHANNEL channel){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

	uint16_t val10 = a2dConvert10bit(channel);	// 0..1023
   4:	0e 94 00 00 	call	0	; 0x0 <a2dReadMv>
// Read the input voltage in mV ie 1000 = 1V based on  AVcc
uint16_t a2dReadMv(ADC_CHANNEL channel);

// Get AVcc in mV. This is constant.
static __inline__ uint16_t a2dGetAVcc(void){
	return pgm_read_word(&AVcc_MV);
   8:	e0 e0       	ldi	r30, 0x00	; 0
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	25 91       	lpm	r18, Z+
   e:	34 91       	lpm	r19, Z
	uint16_t avcc = a2dGetAVcc();
	return interpolateU(val10,0,1023, 0,avcc);
  10:	89 01       	movw	r16, r18
  12:	20 e0       	ldi	r18, 0x00	; 0
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	4f ef       	ldi	r20, 0xFF	; 255
  18:	53 e0       	ldi	r21, 0x03	; 3
  1a:	60 e0       	ldi	r22, 0x00	; 0
  1c:	70 e0       	ldi	r23, 0x00	; 0
  1e:	0e 94 00 00 	call	0	; 0x0 <a2dReadMv>

}
  22:	1f 91       	pop	r17
  24:	0f 91       	pop	r16
  26:	08 95       	ret

actuators.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000062  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000096  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000096  2**0
                  ALLOC
  3 .debug_info   000002a1  00000000  00000000  00000096  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000013a  00000000  00000000  00000337  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001e2  00000000  00000000  00000471  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000653  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000b9  00000000  00000000  00000673  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000001b5  00000000  00000000  0000072c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000008e1  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000044  00000000  00000000  0000090c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__act_setSpeed>:
 *      Author: Clive Webster
 */
#include "actuators.h"


void __act_setSpeed(__ACTUATOR* act, DRIVE_SPEED speed){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	// clamp it to the given range
	speed = CLAMP(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX);
   a:	61 38       	cpi	r22, 0x81	; 129
   c:	04 f4       	brge	.+0      	; 0xe <__act_setSpeed+0xe>
   e:	11 e8       	ldi	r17, 0x81	; 129

	// Get the driver class
	const __ACTUATOR_DRIVER_CLASS* driver=act->class;
  10:	e8 81       	ld	r30, Y
  12:	f9 81       	ldd	r31, Y+1	; 0x01

	// Call the setSpeed method on the class
	if(driver){
  14:	30 97       	sbiw	r30, 0x00	; 0
  16:	01 f0       	breq	.+0      	; 0x18 <__act_setSpeed+0x18>
		void (*fn)(__ACTUATOR*,DRIVE_SPEED speed) = (void (*)(__ACTUATOR*, DRIVE_SPEED speed))pgm_read_word(&driver->setSpeed);
  18:	85 91       	lpm	r24, Z+
  1a:	94 91       	lpm	r25, Z
  1c:	fc 01       	movw	r30, r24
		if(fn!=null){
  1e:	00 97       	sbiw	r24, 0x00	; 0
  20:	01 f0       	breq	.+0      	; 0x22 <__act_setSpeed+0x22>
			fn(act,(act->inverted) ? speed*-1 : speed);
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	61 2f       	mov	r22, r17
  26:	81 fd       	sbrc	r24, 1
  28:	61 95       	neg	r22
  2a:	ce 01       	movw	r24, r28
  2c:	09 95       	icall
		}
	}

	// Store the new speed - do this at the end so that the setSpeed method
	// can access the previous speed
	act->required_speed = speed;
  2e:	1a 83       	std	Y+2, r17	; 0x02
}
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	1f 91       	pop	r17
  36:	08 95       	ret

00000038 <__act_setConnected>:


void __act_setConnected(__ACTUATOR* act,boolean connected){
	// Change the variable
	act->connected = connected;
  38:	dc 01       	movw	r26, r24
  3a:	13 96       	adiw	r26, 0x03	; 3
  3c:	2c 91       	ld	r18, X
  3e:	13 97       	sbiw	r26, 0x03	; 3
  40:	60 fb       	bst	r22, 0
  42:	20 f9       	bld	r18, 0
  44:	13 96       	adiw	r26, 0x03	; 3
  46:	2c 93       	st	X, r18
  48:	13 97       	sbiw	r26, 0x03	; 3

	// Get the driver class
	const __ACTUATOR_DRIVER_CLASS* driver=act->class;
  4a:	ed 91       	ld	r30, X+
  4c:	fc 91       	ld	r31, X

	// Call the setSpeed method on the class
	if(driver){
  4e:	30 97       	sbiw	r30, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <__act_setConnected+0x1a>
		void (*fn)(__ACTUATOR*,boolean connected) = (void (*)(__ACTUATOR*, boolean connected))pgm_read_word(&driver->setConnected);
  52:	32 96       	adiw	r30, 0x02	; 2
  54:	25 91       	lpm	r18, Z+
  56:	34 91       	lpm	r19, Z
  58:	f9 01       	movw	r30, r18
		if(fn!=null){
  5a:	30 97       	sbiw	r30, 0x00	; 0
  5c:	01 f0       	breq	.+0      	; 0x5e <__act_setConnected+0x26>
			fn(act,connected);
  5e:	09 94       	ijmp
  60:	08 95       	ret

buffer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000112  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000146  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000146  2**0
                  ALLOC
  3 .debug_info   0000041c  00000000  00000000  00000146  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000019d  00000000  00000000  00000562  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000323  00000000  00000000  000006ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000a22  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000150  00000000  00000000  00000a42  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000001b8  00000000  00000000  00000b92  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000d4a  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000090  00000000  00000000  00000d74  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferInit>:
 *      Author: Clive Webster
 */
#include "buffer.h"

// initialize a buffer to start at a given address and have given size
void bufferInit(cBuffer* buffer, uint8_t* start, size_t size){
   0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
   2:	8f b7       	in	r24, 0x3f	; 63
   4:	f8 94       	cli
		// set start pointer of the buffer
		buffer->dataptr = start;
   6:	71 83       	std	Z+1, r23	; 0x01
   8:	60 83       	st	Z, r22
		buffer->size = size;
   a:	53 83       	std	Z+3, r21	; 0x03
   c:	42 83       	std	Z+2, r20	; 0x02
		// initialize index and length
		buffer->dataindex = buffer->datalength = 0;
   e:	15 82       	std	Z+5, r1	; 0x05
  10:	14 82       	std	Z+4, r1	; 0x04
  12:	17 82       	std	Z+7, r1	; 0x07
  14:	16 82       	std	Z+6, r1	; 0x06
		// end critical section
	CRITICAL_SECTION_END;
  16:	8f bf       	out	0x3f, r24	; 63
  18:	08 95       	ret

0000001a <bufferGet>:
}


boolean bufferGet(cBuffer* buffer, uint8_t* rtn){
  1a:	fc 01       	movw	r30, r24
	boolean ok=FALSE;
	// begin critical section
	CRITICAL_SECTION_START;
  1c:	2f b7       	in	r18, 0x3f	; 63
  1e:	f8 94       	cli
	// make sure we have a receive buffer
	if(buffer && buffer->size){
  20:	00 97       	sbiw	r24, 0x00	; 0
  22:	01 f0       	breq	.+0      	; 0x24 <bufferGet+0xa>
  24:	82 81       	ldd	r24, Z+2	; 0x02
  26:	93 81       	ldd	r25, Z+3	; 0x03
  28:	89 2b       	or	r24, r25
  2a:	01 f0       	breq	.+0      	; 0x2c <bufferGet+0x12>
		// make sure we have data
		if(buffer->datalength){
  2c:	84 81       	ldd	r24, Z+4	; 0x04
  2e:	95 81       	ldd	r25, Z+5	; 0x05
  30:	89 2b       	or	r24, r25
  32:	01 f0       	breq	.+0      	; 0x34 <bufferGet+0x1a>
			// get the first character from buffer
			*rtn = buffer->dataptr[buffer->dataindex];
  34:	a0 81       	ld	r26, Z
  36:	b1 81       	ldd	r27, Z+1	; 0x01
  38:	86 81       	ldd	r24, Z+6	; 0x06
  3a:	97 81       	ldd	r25, Z+7	; 0x07
  3c:	a8 0f       	add	r26, r24
  3e:	b9 1f       	adc	r27, r25
  40:	8c 91       	ld	r24, X
  42:	db 01       	movw	r26, r22
  44:	8c 93       	st	X, r24
			// move index down and decrement length
			buffer->dataindex = (buffer->dataindex + 1) % buffer->size;
  46:	86 81       	ldd	r24, Z+6	; 0x06
  48:	97 81       	ldd	r25, Z+7	; 0x07
  4a:	01 96       	adiw	r24, 0x01	; 1
  4c:	62 81       	ldd	r22, Z+2	; 0x02
  4e:	73 81       	ldd	r23, Z+3	; 0x03
  50:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  54:	97 83       	std	Z+7, r25	; 0x07
  56:	86 83       	std	Z+6, r24	; 0x06
			buffer->datalength--;
  58:	84 81       	ldd	r24, Z+4	; 0x04
  5a:	95 81       	ldd	r25, Z+5	; 0x05
  5c:	01 97       	sbiw	r24, 0x01	; 1
  5e:	95 83       	std	Z+5, r25	; 0x05
  60:	84 83       	std	Z+4, r24	; 0x04
			ok = TRUE;
  62:	8f ef       	ldi	r24, 0xFF	; 255
  64:	00 c0       	rjmp	.+0      	; 0x66 <bufferGet+0x4c>
	CRITICAL_SECTION_END;
}


boolean bufferGet(cBuffer* buffer, uint8_t* rtn){
	boolean ok=FALSE;
  66:	80 e0       	ldi	r24, 0x00	; 0
			ok = TRUE;
		}
	}

	// end critical section
	CRITICAL_SECTION_END;
  68:	2f bf       	out	0x3f, r18	; 63
	return ok;
}
  6a:	08 95       	ret

0000006c <bufferPut>:


// add a byte to the end of the buffer
boolean	bufferPut(cBuffer* buffer, uint8_t data){
  6c:	cf 93       	push	r28
  6e:	df 93       	push	r29
  70:	fc 01       	movw	r30, r24
  72:	d6 2f       	mov	r29, r22
	boolean rtn=FALSE; // failure

	// begin critical section
	CRITICAL_SECTION_START;
  74:	cf b7       	in	r28, 0x3f	; 63
  76:	f8 94       	cli

		// make sure the buffer has room
		if(buffer->datalength < buffer->size)
  78:	44 81       	ldd	r20, Z+4	; 0x04
  7a:	55 81       	ldd	r21, Z+5	; 0x05
  7c:	62 81       	ldd	r22, Z+2	; 0x02
  7e:	73 81       	ldd	r23, Z+3	; 0x03
  80:	46 17       	cp	r20, r22
  82:	57 07       	cpc	r21, r23
  84:	00 f4       	brcc	.+0      	; 0x86 <bufferPut+0x1a>
		{
			// save data byte at end of buffer
			buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
  86:	86 81       	ldd	r24, Z+6	; 0x06
  88:	97 81       	ldd	r25, Z+7	; 0x07
  8a:	84 0f       	add	r24, r20
  8c:	95 1f       	adc	r25, r21
  8e:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  92:	a0 81       	ld	r26, Z
  94:	b1 81       	ldd	r27, Z+1	; 0x01
  96:	a8 0f       	add	r26, r24
  98:	b9 1f       	adc	r27, r25
  9a:	dc 93       	st	X, r29
			// increment the length
			buffer->datalength++;
  9c:	84 81       	ldd	r24, Z+4	; 0x04
  9e:	95 81       	ldd	r25, Z+5	; 0x05
  a0:	01 96       	adiw	r24, 0x01	; 1
  a2:	95 83       	std	Z+5, r25	; 0x05
  a4:	84 83       	std	Z+4, r24	; 0x04
			// return success
			rtn = TRUE;
  a6:	8f ef       	ldi	r24, 0xFF	; 255
  a8:	00 c0       	rjmp	.+0      	; 0xaa <bufferPut+0x3e>
}


// add a byte to the end of the buffer
boolean	bufferPut(cBuffer* buffer, uint8_t data){
	boolean rtn=FALSE; // failure
  aa:	80 e0       	ldi	r24, 0x00	; 0
			buffer->datalength++;
			// return success
			rtn = TRUE;
		}
		// end critical section
	CRITICAL_SECTION_END;
  ac:	cf bf       	out	0x3f, r28	; 63
	return rtn;
}
  ae:	df 91       	pop	r29
  b0:	cf 91       	pop	r28
  b2:	08 95       	ret

000000b4 <bufferFreeSpace>:

size_t bufferFreeSpace(const cBuffer* buffer){
	size_t rtn;
	CRITICAL_SECTION{
  b4:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  b6:	f8 94       	cli
		rtn =  (buffer) ? buffer->size - buffer->datalength : 0;
  b8:	00 97       	sbiw	r24, 0x00	; 0
  ba:	01 f0       	breq	.+0      	; 0xbc <bufferFreeSpace+0x8>
  bc:	fc 01       	movw	r30, r24
  be:	22 81       	ldd	r18, Z+2	; 0x02
  c0:	33 81       	ldd	r19, Z+3	; 0x03
  c2:	84 81       	ldd	r24, Z+4	; 0x04
  c4:	95 81       	ldd	r25, Z+5	; 0x05
  c6:	28 1b       	sub	r18, r24
  c8:	39 0b       	sbc	r19, r25
  ca:	00 c0       	rjmp	.+0      	; 0xcc <bufferFreeSpace+0x18>
  cc:	20 e0       	ldi	r18, 0x00	; 0
  ce:	30 e0       	ldi	r19, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  d0:	4f bf       	out	0x3f, r20	; 63
	}
	return rtn;
}
  d2:	c9 01       	movw	r24, r18
  d4:	08 95       	ret

000000d6 <bufferBytesUsed>:

size_t bufferBytesUsed(const cBuffer* buffer){
	size_t rtn;
	CRITICAL_SECTION{
  d6:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  d8:	f8 94       	cli
		rtn =  (buffer) ? buffer->datalength : 0;
  da:	00 97       	sbiw	r24, 0x00	; 0
  dc:	01 f0       	breq	.+0      	; 0xde <bufferBytesUsed+0x8>
  de:	fc 01       	movw	r30, r24
  e0:	24 81       	ldd	r18, Z+4	; 0x04
  e2:	35 81       	ldd	r19, Z+5	; 0x05
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <bufferBytesUsed+0x10>
  e6:	20 e0       	ldi	r18, 0x00	; 0
  e8:	30 e0       	ldi	r19, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  ea:	4f bf       	out	0x3f, r20	; 63
	}
	return rtn;
}
  ec:	c9 01       	movw	r24, r18
  ee:	08 95       	ret

000000f0 <bufferIsFull>:

boolean bufferIsFull(const cBuffer* buffer){
	return (bufferFreeSpace(buffer)==0) ? TRUE : FALSE;
  f0:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  f4:	89 2b       	or	r24, r25
  f6:	01 f4       	brne	.+0      	; 0xf8 <bufferIsFull+0x8>
  f8:	8f ef       	ldi	r24, 0xFF	; 255
  fa:	08 95       	ret
  fc:	80 e0       	ldi	r24, 0x00	; 0
}
  fe:	08 95       	ret

00000100 <bufferFlush>:

// flush (clear) the contents of the buffer
void bufferFlush(cBuffer* buffer){
	if(buffer){
 100:	00 97       	sbiw	r24, 0x00	; 0
 102:	01 f0       	breq	.+0      	; 0x104 <bufferFlush+0x4>
		// begin critical section
		CRITICAL_SECTION{
 104:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 106:	f8 94       	cli
			// flush contents of the buffer
			buffer->datalength = 0;
 108:	fc 01       	movw	r30, r24
 10a:	15 82       	std	Z+5, r1	; 0x05
 10c:	14 82       	std	Z+4, r1	; 0x04
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 10e:	2f bf       	out	0x3f, r18	; 63
 110:	08 95       	ret

buffer2.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000a2  2**0
                  ALLOC
  3 .debug_info   000001f9  00000000  00000000  000000a2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000125  00000000  00000000  0000029b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000176  00000000  00000000  000003c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000536  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000fd  00000000  00000000  00000556  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000177  00000000  00000000  00000653  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000007ca  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000040  00000000  00000000  000007f4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferDump>:
 *      Author: Clive Webster
 */
#include "buffer.h"

// dump (discard) the first numbytes from the front of the buffer
void bufferDump(cBuffer* buffer, size_t numbytes){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
   6:	9b 01       	movw	r18, r22
	// begin critical section
	CRITICAL_SECTION_START;
   8:	4f b7       	in	r20, 0x3f	; 63
   a:	f8 94       	cli
		// dump numbytes from the front of the buffer
		// are we dumping less than the entire buffer?
		if(numbytes < buffer->datalength){
   c:	c4 81       	ldd	r28, Z+4	; 0x04
   e:	d5 81       	ldd	r29, Z+5	; 0x05
  10:	6c 17       	cp	r22, r28
  12:	7d 07       	cpc	r23, r29
  14:	00 f4       	brcc	.+0      	; 0x16 <bufferDump+0x16>
			// move index down by numbytes and decrement length by numbytes
			buffer->dataindex = (buffer->dataindex + numbytes) % buffer->size;
  16:	86 81       	ldd	r24, Z+6	; 0x06
  18:	97 81       	ldd	r25, Z+7	; 0x07
  1a:	86 0f       	add	r24, r22
  1c:	97 1f       	adc	r25, r23
  1e:	62 81       	ldd	r22, Z+2	; 0x02
  20:	73 81       	ldd	r23, Z+3	; 0x03
  22:	0e 94 00 00 	call	0	; 0x0 <bufferDump>
  26:	97 83       	std	Z+7, r25	; 0x07
  28:	86 83       	std	Z+6, r24	; 0x06
			buffer->datalength -= numbytes;
  2a:	c2 1b       	sub	r28, r18
  2c:	d3 0b       	sbc	r29, r19
  2e:	d5 83       	std	Z+5, r29	; 0x05
  30:	c4 83       	std	Z+4, r28	; 0x04
  32:	00 c0       	rjmp	.+0      	; 0x34 <bufferDump+0x34>
		}else{
			// flush the whole buffer
			buffer->datalength = 0;
  34:	15 82       	std	Z+5, r1	; 0x05
  36:	14 82       	std	Z+4, r1	; 0x04
		}
		// end critical section
	CRITICAL_SECTION_END;
  38:	4f bf       	out	0x3f, r20	; 63
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	08 95       	ret

00000040 <bufferGetAtIndex>:

// get a byte at the specified index in the buffer (kind of like array access)
// ** note: this does not remove the byte that was read from the buffer
uint8_t	bufferGetAtIndex(const cBuffer* buffer, size_t index){
  40:	fc 01       	movw	r30, r24
	uint8_t data;

	// begin critical section
	CRITICAL_SECTION{
  42:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  44:	f8 94       	cli
		// return character at index in buffer
		data = (buffer) ? buffer->dataptr[(buffer->dataindex+index)%(buffer->size)] : 0;
  46:	00 97       	sbiw	r24, 0x00	; 0
  48:	01 f0       	breq	.+0      	; 0x4a <bufferGetAtIndex+0xa>
  4a:	86 81       	ldd	r24, Z+6	; 0x06
  4c:	97 81       	ldd	r25, Z+7	; 0x07
  4e:	86 0f       	add	r24, r22
  50:	97 1f       	adc	r25, r23
  52:	62 81       	ldd	r22, Z+2	; 0x02
  54:	73 81       	ldd	r23, Z+3	; 0x03
  56:	0e 94 00 00 	call	0	; 0x0 <bufferDump>
  5a:	01 90       	ld	r0, Z+
  5c:	f0 81       	ld	r31, Z
  5e:	e0 2d       	mov	r30, r0
  60:	e8 0f       	add	r30, r24
  62:	f9 1f       	adc	r31, r25
  64:	80 81       	ld	r24, Z
  66:	00 c0       	rjmp	.+0      	; 0x68 <bufferGetAtIndex+0x28>
  68:	80 e0       	ldi	r24, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  6a:	2f bf       	out	0x3f, r18	; 63
		// end critical section
	}
	return data;
}
  6c:	08 95       	ret

color1.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000020e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000242  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000242  2**0
                  ALLOC
  3 .debug_info   00000275  00000000  00000000  00000242  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000013b  00000000  00000000  000004b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002e6  00000000  00000000  000005f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000008d8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000aa  00000000  00000000  000008f8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000149  00000000  00000000  000009a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000aeb  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000084  00000000  00000000  00000b18  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <color2rgb>:
#include "color.h"
#include <string.h>		// for memcpy


// Convert the color to RGB
COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest){		// Convert the color to RGB
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <color2rgb+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <color2rgb+0x28>
  28:	cd b7       	in	r28, 0x3d	; 61
  2a:	de b7       	in	r29, 0x3e	; 62
  2c:	2c 01       	movw	r4, r24
  2e:	7c 83       	std	Y+4, r23	; 0x04
  30:	6b 83       	std	Y+3, r22	; 0x03
	switch(src->colorSpace){
  32:	fc 01       	movw	r30, r24
  34:	80 81       	ld	r24, Z
  36:	88 23       	and	r24, r24
  38:	01 f0       	breq	.+0      	; 0x3a <color2rgb+0x3a>
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <color2rgb+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <color2rgb+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <color2rgb+0x42>

	case RGB:{
		// Nothing to do
		if(dest!=src){
  42:	8b 81       	ldd	r24, Y+3	; 0x03
  44:	9c 81       	ldd	r25, Y+4	; 0x04
  46:	84 15       	cp	r24, r4
  48:	95 05       	cpc	r25, r5
  4a:	01 f4       	brne	.+0      	; 0x4c <color2rgb+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <color2rgb+0x4e>
			memcpy(dest, src, sizeof(COLOR));
  4e:	f2 01       	movw	r30, r4
  50:	80 81       	ld	r24, Z
  52:	91 81       	ldd	r25, Z+1	; 0x01
  54:	a2 81       	ldd	r26, Z+2	; 0x02
  56:	b3 81       	ldd	r27, Z+3	; 0x03
  58:	eb 81       	ldd	r30, Y+3	; 0x03
  5a:	fc 81       	ldd	r31, Y+4	; 0x04
  5c:	80 83       	st	Z, r24
  5e:	91 83       	std	Z+1, r25	; 0x01
  60:	a2 83       	std	Z+2, r26	; 0x02
  62:	b3 83       	std	Z+3, r27	; 0x03
  64:	00 c0       	rjmp	.+0      	; 0x66 <color2rgb+0x66>
		r = (int) (( 298.082 * Y               + 408.583 * V  ) / 256 - 222.921);
		g = (int) (( 298.082 * Y - 100.291 * U - 208.120 * V  ) / 256 + 135.576);
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
  66:	f2 01       	movw	r30, r4
  68:	61 81       	ldd	r22, Z+1	; 0x01
		int Cb = src->bands.yuv.u;
		int Cr = src->bands.yuv.v;

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
  6a:	70 e0       	ldi	r23, 0x00	; 0
  6c:	80 e0       	ldi	r24, 0x00	; 0
  6e:	90 e0       	ldi	r25, 0x00	; 0
  70:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  74:	2f e7       	ldi	r18, 0x7F	; 127
  76:	3a e0       	ldi	r19, 0x0A	; 10
  78:	45 e9       	ldi	r20, 0x95	; 149
  7a:	53 e4       	ldi	r21, 0x43	; 67
  7c:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  80:	8b 01       	movw	r16, r22
  82:	3c 01       	movw	r6, r24
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
		int Cb = src->bands.yuv.u;
		int Cr = src->bands.yuv.v;
  84:	f2 01       	movw	r30, r4
  86:	63 81       	ldd	r22, Z+3	; 0x03

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
  88:	70 e0       	ldi	r23, 0x00	; 0
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  92:	4b 01       	movw	r8, r22
  94:	5c 01       	movw	r10, r24
  96:	20 ea       	ldi	r18, 0xA0	; 160
  98:	3a e4       	ldi	r19, 0x4A	; 74
  9a:	4c ec       	ldi	r20, 0xCC	; 204
  9c:	53 e4       	ldi	r21, 0x43	; 67
  9e:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  a2:	9b 01       	movw	r18, r22
  a4:	ac 01       	movw	r20, r24
  a6:	60 2f       	mov	r22, r16
  a8:	71 2f       	mov	r23, r17
  aa:	86 2d       	mov	r24, r6
  ac:	97 2d       	mov	r25, r7
  ae:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  b2:	20 e0       	ldi	r18, 0x00	; 0
  b4:	30 e0       	ldi	r19, 0x00	; 0
  b6:	40 e8       	ldi	r20, 0x80	; 128
  b8:	5b e3       	ldi	r21, 0x3B	; 59
  ba:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  be:	27 ec       	ldi	r18, 0xC7	; 199
  c0:	3b ee       	ldi	r19, 0xEB	; 235
  c2:	4e e5       	ldi	r20, 0x5E	; 94
  c4:	53 e4       	ldi	r21, 0x43	; 67
  c6:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  ca:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  ce:	69 83       	std	Y+1, r22	; 0x01
  d0:	7a 83       	std	Y+2, r23	; 0x02
		g = (int) (( 298.082 * Y - 100.291 * U - 208.120 * V  ) / 256 + 135.576);
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
		int Cb = src->bands.yuv.u;
  d2:	f2 01       	movw	r30, r4
  d4:	62 81       	ldd	r22, Z+2	; 0x02
		int Cr = src->bands.yuv.v;

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
		g = (int) (( 298.082 * Y - 100.291 * Cb - 208.120 * Cr ) / 256 + 135.576);
  d6:	70 e0       	ldi	r23, 0x00	; 0
  d8:	80 e0       	ldi	r24, 0x00	; 0
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  e0:	1b 01       	movw	r2, r22
  e2:	2c 01       	movw	r4, r24
  e4:	2e ef       	ldi	r18, 0xFE	; 254
  e6:	34 e9       	ldi	r19, 0x94	; 148
  e8:	48 ec       	ldi	r20, 0xC8	; 200
  ea:	52 e4       	ldi	r21, 0x42	; 66
  ec:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  f0:	9b 01       	movw	r18, r22
  f2:	ac 01       	movw	r20, r24
  f4:	60 2f       	mov	r22, r16
  f6:	71 2f       	mov	r23, r17
  f8:	86 2d       	mov	r24, r6
  fa:	97 2d       	mov	r25, r7
  fc:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 100:	6b 01       	movw	r12, r22
 102:	7c 01       	movw	r14, r24
 104:	28 eb       	ldi	r18, 0xB8	; 184
 106:	3e e1       	ldi	r19, 0x1E	; 30
 108:	40 e5       	ldi	r20, 0x50	; 80
 10a:	53 e4       	ldi	r21, 0x43	; 67
 10c:	c5 01       	movw	r24, r10
 10e:	b4 01       	movw	r22, r8
 110:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 114:	9b 01       	movw	r18, r22
 116:	ac 01       	movw	r20, r24
 118:	c7 01       	movw	r24, r14
 11a:	b6 01       	movw	r22, r12
 11c:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 120:	20 e0       	ldi	r18, 0x00	; 0
 122:	30 e0       	ldi	r19, 0x00	; 0
 124:	40 e8       	ldi	r20, 0x80	; 128
 126:	5b e3       	ldi	r21, 0x3B	; 59
 128:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 12c:	25 e7       	ldi	r18, 0x75	; 117
 12e:	33 e9       	ldi	r19, 0x93	; 147
 130:	47 e0       	ldi	r20, 0x07	; 7
 132:	53 e4       	ldi	r21, 0x43	; 67
 134:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 138:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 13c:	7b 01       	movw	r14, r22
		b = (int) (( 298.082 * Y + 516.412 * Cb                ) / 256 - 276.836);
 13e:	2e e5       	ldi	r18, 0x5E	; 94
 140:	3a e1       	ldi	r19, 0x1A	; 26
 142:	41 e0       	ldi	r20, 0x01	; 1
 144:	54 e4       	ldi	r21, 0x44	; 68
 146:	c2 01       	movw	r24, r4
 148:	b1 01       	movw	r22, r2
 14a:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 14e:	9b 01       	movw	r18, r22
 150:	ac 01       	movw	r20, r24
 152:	60 2f       	mov	r22, r16
 154:	71 2f       	mov	r23, r17
 156:	86 2d       	mov	r24, r6
 158:	97 2d       	mov	r25, r7
 15a:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 15e:	20 e0       	ldi	r18, 0x00	; 0
 160:	30 e0       	ldi	r19, 0x00	; 0
 162:	40 e8       	ldi	r20, 0x80	; 128
 164:	5b e3       	ldi	r21, 0x3B	; 59
 166:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 16a:	22 e0       	ldi	r18, 0x02	; 2
 16c:	3b e6       	ldi	r19, 0x6B	; 107
 16e:	4a e8       	ldi	r20, 0x8A	; 138
 170:	53 e4       	ldi	r21, 0x43	; 67
 172:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 176:	0e 94 00 00 	call	0	; 0x0 <color2rgb>

		r = CLAMP(r,0,255);
 17a:	49 81       	ldd	r20, Y+1	; 0x01
 17c:	5a 81       	ldd	r21, Y+2	; 0x02
 17e:	4f 3f       	cpi	r20, 0xFF	; 255
 180:	51 05       	cpc	r21, r1
 182:	01 f0       	breq	.+0      	; 0x184 <color2rgb+0x184>
 184:	04 f0       	brlt	.+0      	; 0x186 <color2rgb+0x186>
 186:	4f ef       	ldi	r20, 0xFF	; 255
 188:	50 e0       	ldi	r21, 0x00	; 0
		g = CLAMP(g,0,255);
 18a:	97 01       	movw	r18, r14
 18c:	2f 3f       	cpi	r18, 0xFF	; 255
 18e:	31 05       	cpc	r19, r1
 190:	01 f0       	breq	.+0      	; 0x192 <color2rgb+0x192>
 192:	04 f0       	brlt	.+0      	; 0x194 <color2rgb+0x194>
 194:	2f ef       	ldi	r18, 0xFF	; 255
 196:	30 e0       	ldi	r19, 0x00	; 0
		b = CLAMP(b,0,255);
 198:	cb 01       	movw	r24, r22
 19a:	6f 3f       	cpi	r22, 0xFF	; 255
 19c:	71 05       	cpc	r23, r1
 19e:	01 f0       	breq	.+0      	; 0x1a0 <color2rgb+0x1a0>
 1a0:	04 f0       	brlt	.+0      	; 0x1a2 <color2rgb+0x1a2>
 1a2:	8f ef       	ldi	r24, 0xFF	; 255
 1a4:	90 e0       	ldi	r25, 0x00	; 0

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 1a6:	eb 81       	ldd	r30, Y+3	; 0x03
 1a8:	fc 81       	ldd	r31, Y+4	; 0x04
 1aa:	10 82       	st	Z, r1
		colorSetRGB(dest,r,g,b);
 1ac:	57 ff       	sbrs	r21, 7
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <color2rgb+0x1b0>
 1b0:	40 e0       	ldi	r20, 0x00	; 0
 1b2:	50 e0       	ldi	r21, 0x00	; 0
 1b4:	eb 81       	ldd	r30, Y+3	; 0x03
 1b6:	fc 81       	ldd	r31, Y+4	; 0x04
 1b8:	41 83       	std	Z+1, r20	; 0x01
 1ba:	37 ff       	sbrs	r19, 7
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <color2rgb+0x1be>
 1be:	20 e0       	ldi	r18, 0x00	; 0
 1c0:	30 e0       	ldi	r19, 0x00	; 0
 1c2:	eb 81       	ldd	r30, Y+3	; 0x03
 1c4:	fc 81       	ldd	r31, Y+4	; 0x04
 1c6:	22 83       	std	Z+2, r18	; 0x02
 1c8:	97 ff       	sbrs	r25, 7
 1ca:	00 c0       	rjmp	.+0      	; 0x1cc <color2rgb+0x1cc>
 1cc:	80 e0       	ldi	r24, 0x00	; 0
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	eb 81       	ldd	r30, Y+3	; 0x03
 1d2:	fc 81       	ldd	r31, Y+4	; 0x04
 1d4:	83 83       	std	Z+3, r24	; 0x03
		break;
		}
	}
	return &dest->bands.rgb;
 1d6:	2b 81       	ldd	r18, Y+3	; 0x03
 1d8:	3c 81       	ldd	r19, Y+4	; 0x04
 1da:	2f 5f       	subi	r18, 0xFF	; 255
 1dc:	3f 4f       	sbci	r19, 0xFF	; 255
}
 1de:	c9 01       	movw	r24, r18
 1e0:	0f 90       	pop	r0
 1e2:	0f 90       	pop	r0
 1e4:	0f 90       	pop	r0
 1e6:	0f 90       	pop	r0
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	1f 91       	pop	r17
 1ee:	0f 91       	pop	r16
 1f0:	ff 90       	pop	r15
 1f2:	ef 90       	pop	r14
 1f4:	df 90       	pop	r13
 1f6:	cf 90       	pop	r12
 1f8:	bf 90       	pop	r11
 1fa:	af 90       	pop	r10
 1fc:	9f 90       	pop	r9
 1fe:	8f 90       	pop	r8
 200:	7f 90       	pop	r7
 202:	6f 90       	pop	r6
 204:	5f 90       	pop	r5
 206:	4f 90       	pop	r4
 208:	3f 90       	pop	r3
 20a:	2f 90       	pop	r2
 20c:	08 95       	ret

color2.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000028a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002be  2**0
                  ALLOC
  3 .debug_info   00000273  00000000  00000000  000002be  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000013b  00000000  00000000  00000531  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000032b  00000000  00000000  0000066c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000997  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000ae  00000000  00000000  000009b7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000149  00000000  00000000  00000a65  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000bae  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000084  00000000  00000000  00000bd8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <color2yuv>:
 */
#include "color.h"
#include <string.h>		// for memcpy

// Convert the color to YUV
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <color2yuv+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <color2yuv+0x28>
  28:	1f 92       	push	r1
  2a:	cd b7       	in	r28, 0x3d	; 61
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	8c 01       	movw	r16, r24
  30:	1b 01       	movw	r2, r22
	switch(src->colorSpace){
  32:	fc 01       	movw	r30, r24
  34:	80 81       	ld	r24, Z
  36:	88 23       	and	r24, r24
  38:	01 f0       	breq	.+0      	; 0x3a <color2yuv+0x3a>
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <color2yuv+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <color2yuv+0x40>
	case YUV:
		// Nothing to do
		if(src != dest){
  40:	06 17       	cp	r16, r22
  42:	17 07       	cpc	r17, r23
  44:	01 f4       	brne	.+0      	; 0x46 <color2yuv+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <color2yuv+0x48>
			memcpy(dest, src, sizeof(COLOR));
  48:	80 81       	ld	r24, Z
  4a:	91 81       	ldd	r25, Z+1	; 0x01
  4c:	a2 81       	ldd	r26, Z+2	; 0x02
  4e:	b3 81       	ldd	r27, Z+3	; 0x03
  50:	fb 01       	movw	r30, r22
  52:	80 83       	st	Z, r24
  54:	91 83       	std	Z+1, r25	; 0x01
  56:	a2 83       	std	Z+2, r26	; 0x02
  58:	b3 83       	std	Z+3, r27	; 0x03
  5a:	00 c0       	rjmp	.+0      	; 0x5c <color2yuv+0x5c>
			Y  =  16 + 1/256 * (  65.738 * R'd + 129.057 * G'd +  25.064 * B'd)
			Cb = 128 + 1/256 * (- 37.945 * R'd -  74.494 * G'd + 112.439 * B'd)
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
  5c:	f8 01       	movw	r30, r16
  5e:	61 81       	ldd	r22, Z+1	; 0x01
			int g = src->bands.rgb.g;
			int b = src->bands.rgb.b;


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  60:	70 e0       	ldi	r23, 0x00	; 0
  62:	80 e0       	ldi	r24, 0x00	; 0
  64:	90 e0       	ldi	r25, 0x00	; 0
  66:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  6a:	2b 01       	movw	r4, r22
  6c:	3c 01       	movw	r6, r24
			Cb = 128 + 1/256 * (- 37.945 * R'd -  74.494 * G'd + 112.439 * B'd)
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
			int g = src->bands.rgb.g;
  6e:	f8 01       	movw	r30, r16
  70:	62 81       	ldd	r22, Z+2	; 0x02
			int b = src->bands.rgb.b;


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  72:	70 e0       	ldi	r23, 0x00	; 0
  74:	80 e0       	ldi	r24, 0x00	; 0
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  7c:	4b 01       	movw	r8, r22
  7e:	5c 01       	movw	r10, r24
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
			int g = src->bands.rgb.g;
			int b = src->bands.rgb.b;
  80:	f8 01       	movw	r30, r16
  82:	63 81       	ldd	r22, Z+3	; 0x03


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  84:	70 e0       	ldi	r23, 0x00	; 0
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	90 e0       	ldi	r25, 0x00	; 0
  8a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  8e:	6b 01       	movw	r12, r22
  90:	7c 01       	movw	r14, r24
  92:	2b ed       	ldi	r18, 0xDB	; 219
  94:	39 e7       	ldi	r19, 0x79	; 121
  96:	43 e8       	ldi	r20, 0x83	; 131
  98:	52 e4       	ldi	r21, 0x42	; 66
  9a:	c3 01       	movw	r24, r6
  9c:	b2 01       	movw	r22, r4
  9e:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  a2:	69 83       	std	Y+1, r22	; 0x01
  a4:	7a 83       	std	Y+2, r23	; 0x02
  a6:	8b 83       	std	Y+3, r24	; 0x03
  a8:	9c 83       	std	Y+4, r25	; 0x04
  aa:	28 e9       	ldi	r18, 0x98	; 152
  ac:	3e e0       	ldi	r19, 0x0E	; 14
  ae:	41 e0       	ldi	r20, 0x01	; 1
  b0:	53 e4       	ldi	r21, 0x43	; 67
  b2:	c5 01       	movw	r24, r10
  b4:	b4 01       	movw	r22, r8
  b6:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  ba:	9b 01       	movw	r18, r22
  bc:	ac 01       	movw	r20, r24
  be:	69 81       	ldd	r22, Y+1	; 0x01
  c0:	7a 81       	ldd	r23, Y+2	; 0x02
  c2:	8b 81       	ldd	r24, Y+3	; 0x03
  c4:	9c 81       	ldd	r25, Y+4	; 0x04
  c6:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  ca:	69 83       	std	Y+1, r22	; 0x01
  cc:	7a 83       	std	Y+2, r23	; 0x02
  ce:	8b 83       	std	Y+3, r24	; 0x03
  d0:	9c 83       	std	Y+4, r25	; 0x04
  d2:	22 e1       	ldi	r18, 0x12	; 18
  d4:	33 e8       	ldi	r19, 0x83	; 131
  d6:	48 ec       	ldi	r20, 0xC8	; 200
  d8:	51 e4       	ldi	r21, 0x41	; 65
  da:	c7 01       	movw	r24, r14
  dc:	b6 01       	movw	r22, r12
  de:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  e2:	9b 01       	movw	r18, r22
  e4:	ac 01       	movw	r20, r24
  e6:	69 81       	ldd	r22, Y+1	; 0x01
  e8:	7a 81       	ldd	r23, Y+2	; 0x02
  ea:	8b 81       	ldd	r24, Y+3	; 0x03
  ec:	9c 81       	ldd	r25, Y+4	; 0x04
  ee:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  f2:	20 e0       	ldi	r18, 0x00	; 0
  f4:	30 e0       	ldi	r19, 0x00	; 0
  f6:	40 e8       	ldi	r20, 0x80	; 128
  f8:	5b e3       	ldi	r21, 0x3B	; 59
  fa:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  fe:	20 e0       	ldi	r18, 0x00	; 0
 100:	30 e0       	ldi	r19, 0x00	; 0
 102:	40 e8       	ldi	r20, 0x80	; 128
 104:	51 e4       	ldi	r21, 0x41	; 65
 106:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 10a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 10e:	8b 01       	movw	r16, r22
			int u = 128.0 + 1.0/256.0 * (- 37.945 * r -  74.494 * g + 112.439 * b);
 110:	2e ea       	ldi	r18, 0xAE	; 174
 112:	37 ec       	ldi	r19, 0xC7	; 199
 114:	47 e1       	ldi	r20, 0x17	; 23
 116:	52 ec       	ldi	r21, 0xC2	; 194
 118:	c3 01       	movw	r24, r6
 11a:	b2 01       	movw	r22, r4
 11c:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 120:	69 83       	std	Y+1, r22	; 0x01
 122:	7a 83       	std	Y+2, r23	; 0x02
 124:	8b 83       	std	Y+3, r24	; 0x03
 126:	9c 83       	std	Y+4, r25	; 0x04
 128:	2e ee       	ldi	r18, 0xEE	; 238
 12a:	3c ef       	ldi	r19, 0xFC	; 252
 12c:	44 e9       	ldi	r20, 0x94	; 148
 12e:	52 e4       	ldi	r21, 0x42	; 66
 130:	c5 01       	movw	r24, r10
 132:	b4 01       	movw	r22, r8
 134:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 138:	9b 01       	movw	r18, r22
 13a:	ac 01       	movw	r20, r24
 13c:	69 81       	ldd	r22, Y+1	; 0x01
 13e:	7a 81       	ldd	r23, Y+2	; 0x02
 140:	8b 81       	ldd	r24, Y+3	; 0x03
 142:	9c 81       	ldd	r25, Y+4	; 0x04
 144:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 148:	69 83       	std	Y+1, r22	; 0x01
 14a:	7a 83       	std	Y+2, r23	; 0x02
 14c:	8b 83       	std	Y+3, r24	; 0x03
 14e:	9c 83       	std	Y+4, r25	; 0x04
 150:	25 ec       	ldi	r18, 0xC5	; 197
 152:	30 ee       	ldi	r19, 0xE0	; 224
 154:	40 ee       	ldi	r20, 0xE0	; 224
 156:	52 e4       	ldi	r21, 0x42	; 66
 158:	c7 01       	movw	r24, r14
 15a:	b6 01       	movw	r22, r12
 15c:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 160:	9b 01       	movw	r18, r22
 162:	ac 01       	movw	r20, r24
 164:	69 81       	ldd	r22, Y+1	; 0x01
 166:	7a 81       	ldd	r23, Y+2	; 0x02
 168:	8b 81       	ldd	r24, Y+3	; 0x03
 16a:	9c 81       	ldd	r25, Y+4	; 0x04
 16c:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 170:	20 e0       	ldi	r18, 0x00	; 0
 172:	30 e0       	ldi	r19, 0x00	; 0
 174:	40 e8       	ldi	r20, 0x80	; 128
 176:	5b e3       	ldi	r21, 0x3B	; 59
 178:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 17c:	20 e0       	ldi	r18, 0x00	; 0
 17e:	30 e0       	ldi	r19, 0x00	; 0
 180:	40 e0       	ldi	r20, 0x00	; 0
 182:	53 e4       	ldi	r21, 0x43	; 67
 184:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 188:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 18c:	6d 83       	std	Y+5, r22	; 0x05
 18e:	79 83       	std	Y+1, r23	; 0x01
			int v = 128.0 + 1.0/256.0 * ( 112.439 * r -  94.154 * g -  18.285 * b);
 190:	25 ec       	ldi	r18, 0xC5	; 197
 192:	30 ee       	ldi	r19, 0xE0	; 224
 194:	40 ee       	ldi	r20, 0xE0	; 224
 196:	52 e4       	ldi	r21, 0x42	; 66
 198:	c3 01       	movw	r24, r6
 19a:	b2 01       	movw	r22, r4
 19c:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1a0:	2b 01       	movw	r4, r22
 1a2:	3c 01       	movw	r6, r24
 1a4:	29 ed       	ldi	r18, 0xD9	; 217
 1a6:	3e e4       	ldi	r19, 0x4E	; 78
 1a8:	4c eb       	ldi	r20, 0xBC	; 188
 1aa:	52 e4       	ldi	r21, 0x42	; 66
 1ac:	c5 01       	movw	r24, r10
 1ae:	b4 01       	movw	r22, r8
 1b0:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1b4:	9b 01       	movw	r18, r22
 1b6:	ac 01       	movw	r20, r24
 1b8:	c3 01       	movw	r24, r6
 1ba:	b2 01       	movw	r22, r4
 1bc:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1c0:	4b 01       	movw	r8, r22
 1c2:	5c 01       	movw	r10, r24
 1c4:	2e ea       	ldi	r18, 0xAE	; 174
 1c6:	37 e4       	ldi	r19, 0x47	; 71
 1c8:	42 e9       	ldi	r20, 0x92	; 146
 1ca:	51 e4       	ldi	r21, 0x41	; 65
 1cc:	c7 01       	movw	r24, r14
 1ce:	b6 01       	movw	r22, r12
 1d0:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1d4:	9b 01       	movw	r18, r22
 1d6:	ac 01       	movw	r20, r24
 1d8:	c5 01       	movw	r24, r10
 1da:	b4 01       	movw	r22, r8
 1dc:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1e0:	20 e0       	ldi	r18, 0x00	; 0
 1e2:	30 e0       	ldi	r19, 0x00	; 0
 1e4:	40 e8       	ldi	r20, 0x80	; 128
 1e6:	5b e3       	ldi	r21, 0x3B	; 59
 1e8:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1ec:	20 e0       	ldi	r18, 0x00	; 0
 1ee:	30 e0       	ldi	r19, 0x00	; 0
 1f0:	40 e0       	ldi	r20, 0x00	; 0
 1f2:	53 e4       	ldi	r21, 0x43	; 67
 1f4:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1f8:	0e 94 00 00 	call	0	; 0x0 <color2yuv>

			y = CLAMP(y,0,255);
 1fc:	a8 01       	movw	r20, r16
 1fe:	0f 3f       	cpi	r16, 0xFF	; 255
 200:	11 05       	cpc	r17, r1
 202:	01 f0       	breq	.+0      	; 0x204 <color2yuv+0x204>
 204:	04 f0       	brlt	.+0      	; 0x206 <color2yuv+0x206>
 206:	4f ef       	ldi	r20, 0xFF	; 255
 208:	50 e0       	ldi	r21, 0x00	; 0
			u = CLAMP(u,0,255);
 20a:	2d 81       	ldd	r18, Y+5	; 0x05
 20c:	39 81       	ldd	r19, Y+1	; 0x01
 20e:	2f 3f       	cpi	r18, 0xFF	; 255
 210:	31 05       	cpc	r19, r1
 212:	01 f0       	breq	.+0      	; 0x214 <color2yuv+0x214>
 214:	04 f0       	brlt	.+0      	; 0x216 <color2yuv+0x216>
 216:	2f ef       	ldi	r18, 0xFF	; 255
 218:	30 e0       	ldi	r19, 0x00	; 0
			v = CLAMP(v,0,255);
 21a:	cb 01       	movw	r24, r22
 21c:	6f 3f       	cpi	r22, 0xFF	; 255
 21e:	71 05       	cpc	r23, r1
 220:	01 f0       	breq	.+0      	; 0x222 <color2yuv+0x222>
 222:	04 f0       	brlt	.+0      	; 0x224 <color2yuv+0x224>
 224:	8f ef       	ldi	r24, 0xFF	; 255
 226:	90 e0       	ldi	r25, 0x00	; 0
	color->bands.rgb.g = g;
	color->bands.rgb.b = b;
}

static __inline__ void colorSetYUV(COLOR* color, uint8_t y, uint8_t u, uint8_t v ){
	color->colorSpace = YUV;
 228:	61 e0       	ldi	r22, 0x01	; 1
 22a:	f1 01       	movw	r30, r2
 22c:	60 83       	st	Z, r22

			// Convert rgb to yuv
			colorSetYUV(dest,y,u,v);
 22e:	57 ff       	sbrs	r21, 7
 230:	00 c0       	rjmp	.+0      	; 0x232 <color2yuv+0x232>
 232:	40 e0       	ldi	r20, 0x00	; 0
 234:	50 e0       	ldi	r21, 0x00	; 0
 236:	f1 01       	movw	r30, r2
 238:	41 83       	std	Z+1, r20	; 0x01
 23a:	37 ff       	sbrs	r19, 7
 23c:	00 c0       	rjmp	.+0      	; 0x23e <color2yuv+0x23e>
 23e:	20 e0       	ldi	r18, 0x00	; 0
 240:	30 e0       	ldi	r19, 0x00	; 0
 242:	f1 01       	movw	r30, r2
 244:	22 83       	std	Z+2, r18	; 0x02
 246:	97 ff       	sbrs	r25, 7
 248:	00 c0       	rjmp	.+0      	; 0x24a <color2yuv+0x24a>
 24a:	80 e0       	ldi	r24, 0x00	; 0
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	f1 01       	movw	r30, r2
 250:	83 83       	std	Z+3, r24	; 0x03
			break;
		}
	}
	return &dest->bands.yuv;
 252:	ff ef       	ldi	r31, 0xFF	; 255
 254:	2f 1a       	sub	r2, r31
 256:	3f 0a       	sbc	r3, r31

}
 258:	c1 01       	movw	r24, r2
 25a:	0f 90       	pop	r0
 25c:	0f 90       	pop	r0
 25e:	0f 90       	pop	r0
 260:	0f 90       	pop	r0
 262:	0f 90       	pop	r0
 264:	df 91       	pop	r29
 266:	cf 91       	pop	r28
 268:	1f 91       	pop	r17
 26a:	0f 91       	pop	r16
 26c:	ff 90       	pop	r15
 26e:	ef 90       	pop	r14
 270:	df 90       	pop	r13
 272:	cf 90       	pop	r12
 274:	bf 90       	pop	r11
 276:	af 90       	pop	r10
 278:	9f 90       	pop	r9
 27a:	8f 90       	pop	r8
 27c:	7f 90       	pop	r7
 27e:	6f 90       	pop	r6
 280:	5f 90       	pop	r5
 282:	4f 90       	pop	r4
 284:	3f 90       	pop	r3
 286:	2f 90       	pop	r2
 288:	08 95       	ret

color3.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000003c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000070  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000070  2**0
                  ALLOC
  3 .debug_info   000001cd  00000000  00000000  00000070  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000ef  00000000  00000000  0000023d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000003c  00000000  00000000  0000032c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000368  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000a7  00000000  00000000  00000388  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000143  00000000  00000000  0000042f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000572  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000024  00000000  00000000  0000059c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <colorEquals>:
 *      Author: Clive Webster
 */
#include "color.h"

// Test if two colors are identical
boolean colorEquals(const COLOR* c1, const COLOR* c2){
   0:	fc 01       	movw	r30, r24
   2:	db 01       	movw	r26, r22
	if(c1 == c2){
   4:	86 17       	cp	r24, r22
   6:	97 07       	cpc	r25, r23
   8:	01 f0       	breq	.+0      	; 0xa <colorEquals+0xa>
		return TRUE;
	}

	if(c1->colorSpace != c2->colorSpace){
   a:	80 81       	ld	r24, Z
   c:	9c 91       	ld	r25, X
   e:	89 17       	cp	r24, r25
  10:	01 f0       	breq	.+0      	; 0x12 <colorEquals+0x12>
		return FALSE;
  12:	80 e0       	ldi	r24, 0x00	; 0
  14:	08 95       	ret
	}

	boolean rtn = FALSE;
	if(c1->colorSpace == RGB){
		// RGB
		if(c1->bands.rgb.r == c2->bands.rgb.r &&
  16:	91 81       	ldd	r25, Z+1	; 0x01
  18:	11 96       	adiw	r26, 0x01	; 1
  1a:	8c 91       	ld	r24, X
  1c:	11 97       	sbiw	r26, 0x01	; 1
  1e:	98 13       	cpse	r25, r24
  20:	00 c0       	rjmp	.+0      	; 0x22 <colorEquals+0x22>
  22:	92 81       	ldd	r25, Z+2	; 0x02
  24:	12 96       	adiw	r26, 0x02	; 2
  26:	8c 91       	ld	r24, X
  28:	12 97       	sbiw	r26, 0x02	; 2
  2a:	98 13       	cpse	r25, r24
  2c:	00 c0       	rjmp	.+0      	; 0x2e <colorEquals+0x2e>
		   c1->bands.rgb.g == c2->bands.rgb.g &&
  2e:	93 81       	ldd	r25, Z+3	; 0x03
  30:	13 96       	adiw	r26, 0x03	; 3
  32:	8c 91       	ld	r24, X
  34:	98 13       	cpse	r25, r24
  36:	00 c0       	rjmp	.+0      	; 0x38 <colorEquals+0x38>
		   c1->bands.rgb.b == c2->bands.rgb.b){
			rtn = TRUE;
  38:	8f ef       	ldi	r24, 0xFF	; 255
		   c1->bands.yuv.v == c2->bands.yuv.v){
			rtn = TRUE;
		}
	}
	return rtn;
}
  3a:	08 95       	ret

color_dump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000074  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000a8  2**0
                  ALLOC
  3 .progmem.data 0000001c  00000000  00000000  000000a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000197  00000000  00000000  000000c4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000000cf  00000000  00000000  0000025b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000119  00000000  00000000  0000032a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000443  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000094  00000000  00000000  00000463  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000013c  00000000  00000000  000004f7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00000633  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000060  00000000  00000000  00000660  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <colorDump>:
 *      Author: Clive Webster
 */
#include "color.h"
#include "rprintf.h"

void colorDump(const COLOR* color){
   0:	fc 01       	movw	r30, r24
	switch(color->colorSpace){
   2:	20 81       	ld	r18, Z
   4:	22 23       	and	r18, r18
   6:	01 f0       	breq	.+0      	; 0x8 <colorDump+0x8>
   8:	21 30       	cpi	r18, 0x01	; 1
   a:	01 f4       	brne	.+0      	; 0xc <colorDump+0xc>
   c:	00 c0       	rjmp	.+0      	; 0xe <colorDump+0xe>
	case RGB:
		rprintf("RGB(%d,%d,%d)",(int)(color->bands.rgb.r), (int)(color->bands.rgb.g), (int)(color->bands.rgb.b));
   e:	83 81       	ldd	r24, Z+3	; 0x03
  10:	1f 92       	push	r1
  12:	8f 93       	push	r24
  14:	82 81       	ldd	r24, Z+2	; 0x02
  16:	1f 92       	push	r1
  18:	8f 93       	push	r24
  1a:	81 81       	ldd	r24, Z+1	; 0x01
  1c:	1f 92       	push	r1
  1e:	8f 93       	push	r24
  20:	80 e0       	ldi	r24, 0x00	; 0
  22:	90 e0       	ldi	r25, 0x00	; 0
  24:	9f 93       	push	r25
  26:	8f 93       	push	r24
  28:	81 e0       	ldi	r24, 0x01	; 1
  2a:	8f 93       	push	r24
  2c:	0e 94 00 00 	call	0	; 0x0 <colorDump>
		break;
  30:	8d b7       	in	r24, 0x3d	; 61
  32:	9e b7       	in	r25, 0x3e	; 62
  34:	09 96       	adiw	r24, 0x09	; 9
  36:	0f b6       	in	r0, 0x3f	; 63
  38:	f8 94       	cli
  3a:	9e bf       	out	0x3e, r25	; 62
  3c:	0f be       	out	0x3f, r0	; 63
  3e:	8d bf       	out	0x3d, r24	; 61
  40:	08 95       	ret
	case YUV:
		rprintf("YUV(%d,%d,%d)",(int)(color->bands.yuv.y), (int)(color->bands.yuv.u), (int)(color->bands.yuv.v));
  42:	83 81       	ldd	r24, Z+3	; 0x03
  44:	1f 92       	push	r1
  46:	8f 93       	push	r24
  48:	82 81       	ldd	r24, Z+2	; 0x02
  4a:	1f 92       	push	r1
  4c:	8f 93       	push	r24
  4e:	81 81       	ldd	r24, Z+1	; 0x01
  50:	1f 92       	push	r1
  52:	8f 93       	push	r24
  54:	80 e0       	ldi	r24, 0x00	; 0
  56:	90 e0       	ldi	r25, 0x00	; 0
  58:	9f 93       	push	r25
  5a:	8f 93       	push	r24
  5c:	2f 93       	push	r18
  5e:	0e 94 00 00 	call	0	; 0x0 <colorDump>
		break;
  62:	8d b7       	in	r24, 0x3d	; 61
  64:	9e b7       	in	r25, 0x3e	; 62
  66:	09 96       	adiw	r24, 0x09	; 9
  68:	0f b6       	in	r0, 0x3f	; 63
  6a:	f8 94       	cli
  6c:	9e bf       	out	0x3e, r25	; 62
  6e:	0f be       	out	0x3f, r0	; 63
  70:	8d bf       	out	0x3d, r24	; 61
  72:	08 95       	ret

core.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000060  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000094  2**0
                  ALLOC
  3 .text.startup 00000076  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .debug_info   00000813  00000000  00000000  0000010a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000025d  00000000  00000000  0000091d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000167  00000000  00000000  00000b7a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000028  00000000  00000000  00000ce1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00000d09  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_line   000000fb  00000000  00000000  00000d21  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000003d9  00000000  00000000  00000e1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000011f5  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000064  00000000  00000000  00001220  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <breathe>:
#include "core.h"
#include "timer.h"


void breathe(void){
	INTERRUPTABLE_SECTION{
   0:	8f b7       	in	r24, 0x3f	; 63
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
   2:	78 94       	sei
	...
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
  10:	00 00       	nop
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  12:	8f bf       	out	0x3f, r24	; 63
  14:	08 95       	ret

00000016 <__portMaskSet>:
}



void __portMaskSet(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  16:	fc 01       	movw	r30, r24
  18:	25 91       	lpm	r18, Z+
  1a:	34 91       	lpm	r19, Z
	register PIN  mask    = pgm_read_byte(&pm->mask);
  1c:	fc 01       	movw	r30, r24
  1e:	32 96       	adiw	r30, 0x02	; 2
  20:	84 91       	lpm	r24, Z
	_SFR_MEM8(port) |= mask;
  22:	d9 01       	movw	r26, r18
  24:	9c 91       	ld	r25, X
  26:	98 2b       	or	r25, r24
  28:	9c 93       	st	X, r25
  2a:	08 95       	ret

0000002c <__portMaskGet>:
}

boolean __portMaskGet(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  2c:	fc 01       	movw	r30, r24
  2e:	25 91       	lpm	r18, Z+
  30:	34 91       	lpm	r19, Z
	register PIN  mask    = pgm_read_byte(&pm->mask);
  32:	fc 01       	movw	r30, r24
  34:	32 96       	adiw	r30, 0x02	; 2
  36:	84 91       	lpm	r24, Z
	return (_SFR_MEM8(port) & mask) ? TRUE : FALSE;
  38:	d9 01       	movw	r26, r18
  3a:	9c 91       	ld	r25, X
  3c:	98 23       	and	r25, r24
  3e:	01 f0       	breq	.+0      	; 0x40 <__portMaskGet+0x14>
  40:	8f ef       	ldi	r24, 0xFF	; 255
  42:	08 95       	ret
  44:	80 e0       	ldi	r24, 0x00	; 0
}
  46:	08 95       	ret

00000048 <__portMaskClear>:

void __portMaskClear(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  48:	fc 01       	movw	r30, r24
  4a:	25 91       	lpm	r18, Z+
  4c:	34 91       	lpm	r19, Z
	register PIN  mask = pgm_read_byte(&pm->mask);
  4e:	fc 01       	movw	r30, r24
  50:	32 96       	adiw	r30, 0x02	; 2
  52:	84 91       	lpm	r24, Z
	_SFR_MEM8(port) &= ~mask;
  54:	d9 01       	movw	r26, r18
  56:	9c 91       	ld	r25, X
  58:	80 95       	com	r24
  5a:	98 23       	and	r25, r24
  5c:	9c 93       	st	X, r25
  5e:	08 95       	ret

Disassembly of section .text.startup:

00000000 <main>:
	TICK_COUNT loopStart;
	TICK_COUNT delay;


	// Configure the states of the initial ports according to the system ie axon.h
	configure_ports();
   0:	0e 94 00 00 	call	0	; 0x0 <main>
	registerLED();
   4:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the general timers
	initTimers();
   8:	0e 94 00 00 	call	0	; 0x0 <main>
//		uartInit(&(Uarts[i]) ,UART_DEFAULT_BAUD_RATE);
//	}


	// Initialise the hardware declared by the board
	sysInitHardware();
   c:	0e 94 00 00 	call	0	; 0x0 <main>
	// Initialise the hardware declared by the application
	appInitHardware();
  10:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the heartbeat with whatever is left
	__clockInit();
  14:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the software
	loopStart = clockGetus();
  18:	0e 94 00 00 	call	0	; 0x0 <main>
  1c:	6b 01       	movw	r12, r22
  1e:	7c 01       	movw	r14, r24
	delay = appInitSoftware(loopStart);
  20:	0e 94 00 00 	call	0	; 0x0 <main>
  24:	2b 01       	movw	r4, r22
  26:	3c 01       	movw	r6, r24
}


//  This is the main loop for the application
int main(void){
	LOOP_COUNT loopCount=0;
  28:	81 2c       	mov	r8, r1
  2a:	91 2c       	mov	r9, r1
  2c:	54 01       	movw	r10, r8
	// Initialise the software
	loopStart = clockGetus();
	delay = appInitSoftware(loopStart);

	do{
		breathe();
  2e:	0e 94 00 00 	call	0	; 0x0 <main>
		if(delay!=0){
  32:	41 14       	cp	r4, r1
  34:	51 04       	cpc	r5, r1
  36:	61 04       	cpc	r6, r1
  38:	71 04       	cpc	r7, r1
  3a:	01 f4       	brne	.+0      	; 0x3c <main+0x3c>
			while(!clockHasElapsed(loopStart,delay)){
				// Allow interrupts to breathe
				breathe();
			}
		}
		loopStart = clockGetus();
  3c:	0e 94 00 00 	call	0	; 0x0 <main>
  40:	6b 01       	movw	r12, r22
  42:	7c 01       	movw	r14, r24
		delay = appControl(++loopCount,loopStart);
  44:	8f ef       	ldi	r24, 0xFF	; 255
  46:	88 1a       	sub	r8, r24
  48:	98 0a       	sbc	r9, r24
  4a:	a8 0a       	sbc	r10, r24
  4c:	b8 0a       	sbc	r11, r24
  4e:	a7 01       	movw	r20, r14
  50:	96 01       	movw	r18, r12
  52:	c5 01       	movw	r24, r10
  54:	b4 01       	movw	r22, r8
  56:	0e 94 00 00 	call	0	; 0x0 <main>
  5a:	2b 01       	movw	r4, r22
  5c:	3c 01       	movw	r6, r24
	}while(1);
  5e:	00 c0       	rjmp	.+0      	; 0x60 <main+0x60>
	do{
		breathe();
		if(delay!=0){
			while(!clockHasElapsed(loopStart,delay)){
				// Allow interrupts to breathe
				breathe();
  60:	0e 94 00 00 	call	0	; 0x0 <main>
	delay = appInitSoftware(loopStart);

	do{
		breathe();
		if(delay!=0){
			while(!clockHasElapsed(loopStart,delay)){
  64:	a3 01       	movw	r20, r6
  66:	92 01       	movw	r18, r4
  68:	c7 01       	movw	r24, r14
  6a:	b6 01       	movw	r22, r12
  6c:	0e 94 00 00 	call	0	; 0x0 <main>
  70:	88 23       	and	r24, r24
  72:	01 f0       	breq	.+0      	; 0x74 <main+0x74>
  74:	00 c0       	rjmp	.+0      	; 0x76 <__portMaskClear+0x2e>

core_interp.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000052  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000086  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000086  2**0
                  ALLOC
  3 .debug_info   0000010e  00000000  00000000  00000086  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000006f  00000000  00000000  00000194  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000032f  00000000  00000000  00000203  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000532  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000008a  00000000  00000000  00000552  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000127  00000000  00000000  000005dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000703  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000044  00000000  00000000  00000730  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <interpolate>:
*   maxVal - the maximum that 'value' can be
*   minRtn - the return value if 'value = minVal'
*   maxRtn - the return value if 'value = maxVal'
*   return a value in the range minRtn to maxRtn
*/
int16_t interpolate(int16_t value, int16_t minVal, int16_t maxVal, int16_t minRtn, int16_t maxRtn){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	fb 01       	movw	r30, r22
	register int32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
   e:	02 1b       	sub	r16, r18
  10:	13 0b       	sbc	r17, r19
	lValRange = maxVal - minVal;
	lRelVal = value - minVal;
  12:	dc 01       	movw	r26, r24
  14:	a6 1b       	sub	r26, r22
  16:	b7 0b       	sbc	r27, r23
	lRtnRange =  minRtn + ( lRtnRange * lRelVal / lValRange );
  18:	69 01       	movw	r12, r18
  1a:	ee 24       	eor	r14, r14
  1c:	d7 fc       	sbrc	r13, 7
  1e:	e0 94       	com	r14
  20:	fe 2c       	mov	r15, r14
  22:	98 01       	movw	r18, r16
  24:	0e 94 00 00 	call	0	; 0x0 <interpolate>
	register int32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
	lValRange = maxVal - minVal;
  28:	4e 1b       	sub	r20, r30
  2a:	5f 0b       	sbc	r21, r31
  2c:	9a 01       	movw	r18, r20
  2e:	44 27       	eor	r20, r20
  30:	37 fd       	sbrc	r19, 7
  32:	40 95       	com	r20
  34:	54 2f       	mov	r21, r20
	lRelVal = value - minVal;
	lRtnRange =  minRtn + ( lRtnRange * lRelVal / lValRange );
  36:	0e 94 00 00 	call	0	; 0x0 <interpolate>
  3a:	c2 0e       	add	r12, r18
  3c:	d3 1e       	adc	r13, r19
  3e:	e4 1e       	adc	r14, r20
  40:	f5 1e       	adc	r15, r21
	return (int16_t)lRtnRange;
}
  42:	c6 01       	movw	r24, r12
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	ff 90       	pop	r15
  4a:	ef 90       	pop	r14
  4c:	df 90       	pop	r13
  4e:	cf 90       	pop	r12
  50:	08 95       	ret

core_interpU.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000042  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000076  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000076  2**0
                  ALLOC
  3 .debug_info   00000124  00000000  00000000  00000076  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000006f  00000000  00000000  0000019a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000310  00000000  00000000  00000209  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000519  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000008c  00000000  00000000  00000539  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000013b  00000000  00000000  000005c5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000700  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000038  00000000  00000000  0000072c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <interpolateU>:
*   maxVal - the maximum that 'value' can be
*   minRtn - the return value if 'value = minVal'
*   maxRtn - the return value if 'value = maxVal'
*   return a value in the range minRtn to maxRtn
*/
uint16_t interpolateU(int16_t value, int16_t minVal, int16_t maxVal, uint16_t minRtn, uint16_t maxRtn){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	fb 01       	movw	r30, r22
   a:	e9 01       	movw	r28, r18
	register uint32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
   c:	02 1b       	sub	r16, r18
   e:	13 0b       	sbc	r17, r19
	lValRange = maxVal - minVal;
	lRelVal = value - minVal;
  10:	dc 01       	movw	r26, r24
  12:	a6 1b       	sub	r26, r22
  14:	b7 0b       	sbc	r27, r23

	// Break into smaller operations - as doing in one statement gives wrong answers
	lRelVal *= lRtnRange;
  16:	98 01       	movw	r18, r16
  18:	0e 94 00 00 	call	0	; 0x0 <interpolateU>
	register uint32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
	lValRange = maxVal - minVal;
  1c:	4e 1b       	sub	r20, r30
  1e:	5f 0b       	sbc	r21, r31
  20:	9a 01       	movw	r18, r20
  22:	44 27       	eor	r20, r20
  24:	37 fd       	sbrc	r19, 7
  26:	40 95       	com	r20
  28:	54 2f       	mov	r21, r20
	lRelVal = value - minVal;

	// Break into smaller operations - as doing in one statement gives wrong answers
	lRelVal *= lRtnRange;
	lRelVal /= lValRange;
  2a:	0e 94 00 00 	call	0	; 0x0 <interpolateU>

	lRtnRange =  minRtn + lRelVal;
  2e:	2c 0f       	add	r18, r28
  30:	3d 1f       	adc	r19, r29
  32:	41 1d       	adc	r20, r1
  34:	51 1d       	adc	r21, r1

	return (uint16_t)lRtnRange;
}
  36:	c9 01       	movw	r24, r18
  38:	df 91       	pop	r29
  3a:	cf 91       	pop	r28
  3c:	1f 91       	pop	r17
  3e:	0f 91       	pop	r16
  40:	08 95       	ret

core_isqrt.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000a0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000d4  2**0
                  ALLOC
  3 .debug_info   000000cc  00000000  00000000  000000d4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000006f  00000000  00000000  000001a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000140  00000000  00000000  0000020f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000034f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000091  00000000  00000000  0000036f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000e3  00000000  00000000  00000400  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000004e3  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000058  00000000  00000000  00000510  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <isqrt>:
 *  Perform an integer square root without requiring the floating point library
 *
 */
#include "core.h"

uint32_t isqrt(uint32_t x){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	40 e1       	ldi	r20, 0x10	; 16
  16:	50 e0       	ldi	r21, 0x00	; 0
	  register uint32_t xr;  // result register
	  register uint32_t q2;  // scan-bit register
	  register uint8_t  f;   // flag (one bit)

	  xr = 0;                     // clear result
	  q2 = 0x40000000L;           // higest possible result bit
  18:	c1 2c       	mov	r12, r1
  1a:	d1 2c       	mov	r13, r1
  1c:	e1 2c       	mov	r14, r1
  1e:	a0 e4       	ldi	r26, 0x40	; 64
  20:	fa 2e       	mov	r15, r26
uint32_t isqrt(uint32_t x){
	  register uint32_t xr;  // result register
	  register uint32_t q2;  // scan-bit register
	  register uint8_t  f;   // flag (one bit)

	  xr = 0;                     // clear result
  22:	00 e0       	ldi	r16, 0x00	; 0
  24:	10 e0       	ldi	r17, 0x00	; 0
  26:	98 01       	movw	r18, r16
	  q2 = 0x40000000L;           // higest possible result bit
	  do
	  {
	    if((xr + q2) <= x)
  28:	46 01       	movw	r8, r12
  2a:	57 01       	movw	r10, r14
  2c:	80 0e       	add	r8, r16
  2e:	91 1e       	adc	r9, r17
  30:	a2 1e       	adc	r10, r18
  32:	b3 1e       	adc	r11, r19
  34:	68 15       	cp	r22, r8
  36:	79 05       	cpc	r23, r9
  38:	8a 05       	cpc	r24, r10
  3a:	9b 05       	cpc	r25, r11
  3c:	00 f0       	brcs	.+0      	; 0x3e <isqrt+0x3e>
	    {
	      x -= xr + q2;
  3e:	68 19       	sub	r22, r8
  40:	79 09       	sbc	r23, r9
  42:	8a 09       	sbc	r24, r10
  44:	9b 09       	sbc	r25, r11
	      f = 1;                  // set flag
  46:	e1 e0       	ldi	r30, 0x01	; 1
  48:	00 c0       	rjmp	.+0      	; 0x4a <isqrt+0x4a>
	    }
	    else{
	      f = 0;                  // clear flag
  4a:	e0 e0       	ldi	r30, 0x00	; 0
	    }
	    xr >>= 1;
  4c:	36 95       	lsr	r19
  4e:	27 95       	ror	r18
  50:	17 95       	ror	r17
  52:	07 95       	ror	r16
	    if(f){
  54:	ee 23       	and	r30, r30
  56:	01 f0       	breq	.+0      	; 0x58 <isqrt+0x58>
	      xr += q2;               // test flag
  58:	0c 0d       	add	r16, r12
  5a:	1d 1d       	adc	r17, r13
  5c:	2e 1d       	adc	r18, r14
  5e:	3f 1d       	adc	r19, r15
	    }
	  } while(q2 >>= 2);          // shift twice
  60:	e2 e0       	ldi	r30, 0x02	; 2
  62:	f6 94       	lsr	r15
  64:	e7 94       	ror	r14
  66:	d7 94       	ror	r13
  68:	c7 94       	ror	r12
  6a:	ea 95       	dec	r30
  6c:	01 f4       	brne	.+0      	; 0x6e <isqrt+0x6e>
  6e:	41 50       	subi	r20, 0x01	; 1
  70:	51 09       	sbc	r21, r1
  72:	01 f4       	brne	.+0      	; 0x74 <isqrt+0x74>
	  if(xr < x){
  74:	06 17       	cp	r16, r22
  76:	17 07       	cpc	r17, r23
  78:	28 07       	cpc	r18, r24
  7a:	39 07       	cpc	r19, r25
  7c:	00 f4       	brcc	.+0      	; 0x7e <isqrt+0x7e>
	    return xr +1;             // add for rounding
  7e:	0f 5f       	subi	r16, 0xFF	; 255
  80:	1f 4f       	sbci	r17, 0xFF	; 255
  82:	2f 4f       	sbci	r18, 0xFF	; 255
  84:	3f 4f       	sbci	r19, 0xFF	; 255
	  }
	  else{
	    return xr;
	  }

}
  86:	b8 01       	movw	r22, r16
  88:	c9 01       	movw	r24, r18
  8a:	1f 91       	pop	r17
  8c:	0f 91       	pop	r16
  8e:	ff 90       	pop	r15
  90:	ef 90       	pop	r14
  92:	df 90       	pop	r13
  94:	cf 90       	pop	r12
  96:	bf 90       	pop	r11
  98:	af 90       	pop	r10
  9a:	9f 90       	pop	r9
  9c:	8f 90       	pop	r8
  9e:	08 95       	ret

fraction32.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000009a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ce  2**0
                  ALLOC
  3 .debug_info   000001b4  00000000  00000000  000000ce  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000ab  00000000  00000000  00000282  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002da  00000000  00000000  0000032d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000607  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000627  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000000aa  00000000  00000000  0000063f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000139  00000000  00000000  000006e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00000822  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000044  00000000  00000000  0000084c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <fraction32>:

// Value is the value to multiply by the fraction
// Fraction is the fraction (in Progmem) where the first element is the integer element to the left of
// the decimal point, and the remainding elements are the divisors where 0 denotes the end of the list
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	eb 01       	movw	r28, r22
	int32_t rtn = 0;
	if(value != 0){
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <fraction32+0x12>
		boolean isNeg = FALSE;

		// The unsigned value
		uint16_t absValue;

		if(value<0){
  12:	97 ff       	sbrs	r25, 7
  14:	00 c0       	rjmp	.+0      	; 0x16 <fraction32+0x16>
			int32_t tmp = value;
  16:	aa 27       	eor	r26, r26
  18:	97 fd       	sbrc	r25, 7
  1a:	a0 95       	com	r26
  1c:	ba 2f       	mov	r27, r26
			tmp = 0 - tmp;
  1e:	b0 95       	com	r27
  20:	a0 95       	com	r26
  22:	90 95       	com	r25
  24:	81 95       	neg	r24
  26:	9f 4f       	sbci	r25, 0xFF	; 255
  28:	af 4f       	sbci	r26, 0xFF	; 255
  2a:	bf 4f       	sbci	r27, 0xFF	; 255
			absValue=tmp;
  2c:	7c 01       	movw	r14, r24
			isNeg=TRUE;
  2e:	4f ef       	ldi	r20, 0xFF	; 255
  30:	00 c0       	rjmp	.+0      	; 0x32 <fraction32+0x32>
		}else{
			absValue = value;
  32:	7c 01       	movw	r14, r24
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
	int32_t rtn = 0;
	if(value != 0){
		uint16_t term;
		boolean isNeg = FALSE;
  34:	40 e0       	ldi	r20, 0x00	; 0
		}else{
			absValue = value;
		}

		// first parameter is whole number
		rtn = ((uint16_t)(pgm_read_word(fraction))) * absValue;
  36:	fe 01       	movw	r30, r28
  38:	85 91       	lpm	r24, Z+
  3a:	94 91       	lpm	r25, Z
  3c:	8e 9d       	mul	r24, r14
  3e:	80 01       	movw	r16, r0
  40:	8f 9d       	mul	r24, r15
  42:	10 0d       	add	r17, r0
  44:	9e 9d       	mul	r25, r14
  46:	10 0d       	add	r17, r0
  48:	11 24       	eor	r1, r1
  4a:	20 e0       	ldi	r18, 0x00	; 0
  4c:	30 e0       	ldi	r19, 0x00	; 0

		// Remainder are the fraction
		do{
			fraction++;
  4e:	22 96       	adiw	r28, 0x02	; 2

			term= ( (uint16_t)(pgm_read_word(fraction) ));
  50:	fe 01       	movw	r30, r28
  52:	65 91       	lpm	r22, Z+
  54:	74 91       	lpm	r23, Z
			if(term != 0){
  56:	61 15       	cp	r22, r1
  58:	71 05       	cpc	r23, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <fraction32+0x5c>
				uint16_t frac = absValue / term;
  5c:	c7 01       	movw	r24, r14
  5e:	0e 94 00 00 	call	0	; 0x0 <fraction32>
				rtn += frac;
  62:	06 0f       	add	r16, r22
  64:	17 1f       	adc	r17, r23
  66:	21 1d       	adc	r18, r1
  68:	31 1d       	adc	r19, r1
  6a:	00 c0       	rjmp	.+0      	; 0x6c <fraction32+0x6c>
			}
		}while(term!=0);

		if(isNeg){
			rtn = -rtn;
  6c:	30 95       	com	r19
  6e:	20 95       	com	r18
  70:	10 95       	com	r17
  72:	01 95       	neg	r16
  74:	1f 4f       	sbci	r17, 0xFF	; 255
  76:	2f 4f       	sbci	r18, 0xFF	; 255
  78:	3f 4f       	sbci	r19, 0xFF	; 255
  7a:	00 c0       	rjmp	.+0      	; 0x7c <fraction32+0x7c>
// Value is the value to multiply by the fraction
// Fraction is the fraction (in Progmem) where the first element is the integer element to the left of
// the decimal point, and the remainding elements are the divisors where 0 denotes the end of the list
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
	int32_t rtn = 0;
  7c:	00 e0       	ldi	r16, 0x00	; 0
  7e:	10 e0       	ldi	r17, 0x00	; 0
  80:	98 01       	movw	r18, r16
  82:	00 c0       	rjmp	.+0      	; 0x84 <fraction32+0x84>
				uint16_t frac = absValue / term;
				rtn += frac;
			}
		}while(term!=0);

		if(isNeg){
  84:	41 11       	cpse	r20, r1
  86:	00 c0       	rjmp	.+0      	; 0x88 <fraction32+0x88>
			rtn = -rtn;
		}

	}
	return rtn;
}
  88:	b8 01       	movw	r22, r16
  8a:	c9 01       	movw	r24, r18
  8c:	df 91       	pop	r29
  8e:	cf 91       	pop	r28
  90:	1f 91       	pop	r17
  92:	0f 91       	pop	r16
  94:	ff 90       	pop	r15
  96:	ef 90       	pop	r14
  98:	08 95       	ret

i2cBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004bc  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000004f0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000004f0  2**0
                  ALLOC
  3 .debug_info   00000e53  00000000  00000000  000004f0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000002b8  00000000  00000000  00001343  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00001486  00000000  00000000  000015fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00002a81  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 000000d8  00000000  00000000  00002aa1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001dd  00000000  00000000  00002b79  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000309  00000000  00000000  00002d56  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  0000305f  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000254  00000000  00000000  0000308c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <i2cAbstractBusInit>:

#include "errors.h"


//--- Helper methods to redirect the call to the correct bus -----
void i2cAbstractBusInit(I2C_ABSTRACT_BUS* i2c){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
	if(i2c && !i2c->initialised){
   8:	00 97       	sbiw	r24, 0x00	; 0
   a:	01 f4       	brne	.+0      	; 0xc <i2cAbstractBusInit+0xc>
   c:	00 c0       	rjmp	.+0      	; 0xe <i2cAbstractBusInit+0xe>
   e:	8d 81       	ldd	r24, Y+5	; 0x05
  10:	81 11       	cpse	r24, r1
  12:	00 c0       	rjmp	.+0      	; 0x14 <i2cAbstractBusInit+0x14>
		const I2C_CLASS* class = i2c->class;
  14:	18 81       	ld	r17, Y
  16:	79 81       	ldd	r23, Y+1	; 0x01

		// Put each device on this bus
		for(uint8_t i=0; i<i2c->numDevices;i++){
  18:	20 e0       	ldi	r18, 0x00	; 0
  1a:	00 c0       	rjmp	.+0      	; 0x1c <i2cAbstractBusInit+0x1c>
			I2C_DEVICE* device = (I2C_DEVICE*)pgm_read_word(&i2c->devices[i]);
  1c:	5a 81       	ldd	r21, Y+2	; 0x02
  1e:	6b 81       	ldd	r22, Y+3	; 0x03
  20:	e5 2f       	mov	r30, r21
  22:	f6 2f       	mov	r31, r22
  24:	e2 0f       	add	r30, r18
  26:	f1 1d       	adc	r31, r1
  28:	e2 0f       	add	r30, r18
  2a:	f1 1d       	adc	r31, r1
  2c:	85 91       	lpm	r24, Z+
  2e:	94 91       	lpm	r25, Z
  30:	dc 01       	movw	r26, r24
			if(device){
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <i2cAbstractBusInit+0x36>

				// Check for address conflicts
				for(uint8_t j=i+1; j<i2c->numDevices;j++){
  36:	32 2f       	mov	r19, r18
  38:	00 c0       	rjmp	.+0      	; 0x3a <i2cAbstractBusInit+0x3a>
					I2C_DEVICE* other = (I2C_DEVICE*)pgm_read_word(&i2c->devices[j]);
  3a:	e5 2f       	mov	r30, r21
  3c:	f6 2f       	mov	r31, r22
  3e:	e3 0f       	add	r30, r19
  40:	f1 1d       	adc	r31, r1
  42:	e3 0f       	add	r30, r19
  44:	f1 1d       	adc	r31, r1
  46:	85 91       	lpm	r24, Z+
  48:	94 91       	lpm	r25, Z
  4a:	fc 01       	movw	r30, r24
					if(other){
  4c:	00 97       	sbiw	r24, 0x00	; 0
  4e:	01 f0       	breq	.+0      	; 0x50 <i2cAbstractBusInit+0x50>
						if(device->addr == other->addr){
  50:	12 96       	adiw	r26, 0x02	; 2
  52:	9c 91       	ld	r25, X
  54:	12 97       	sbiw	r26, 0x02	; 2
  56:	82 81       	ldd	r24, Z+2	; 0x02
  58:	98 13       	cpse	r25, r24
  5a:	00 c0       	rjmp	.+0      	; 0x5c <i2cAbstractBusInit+0x5c>
							setError(I2C_DUP_ADDR);
  5c:	81 ee       	ldi	r24, 0xE1	; 225
		if(fn){
			fn(i2c);						// initialise the bus
		}
		i2c->initialised = TRUE;
	}
}
  5e:	df 91       	pop	r29
  60:	cf 91       	pop	r28
  62:	1f 91       	pop	r17
				// Check for address conflicts
				for(uint8_t j=i+1; j<i2c->numDevices;j++){
					I2C_DEVICE* other = (I2C_DEVICE*)pgm_read_word(&i2c->devices[j]);
					if(other){
						if(device->addr == other->addr){
							setError(I2C_DUP_ADDR);
  64:	0c 94 00 00 	jmp	0	; 0x0 <i2cAbstractBusInit>
		for(uint8_t i=0; i<i2c->numDevices;i++){
			I2C_DEVICE* device = (I2C_DEVICE*)pgm_read_word(&i2c->devices[i]);
			if(device){

				// Check for address conflicts
				for(uint8_t j=i+1; j<i2c->numDevices;j++){
  68:	3f 5f       	subi	r19, 0xFF	; 255
  6a:	34 13       	cpse	r19, r20
  6c:	00 c0       	rjmp	.+0      	; 0x6e <i2cAbstractBusInit+0x6e>
							return;
						}
					}
				}

				device->bus = i2c;
  6e:	cd 93       	st	X+, r28
  70:	dc 93       	st	X, r29
void i2cAbstractBusInit(I2C_ABSTRACT_BUS* i2c){
	if(i2c && !i2c->initialised){
		const I2C_CLASS* class = i2c->class;

		// Put each device on this bus
		for(uint8_t i=0; i<i2c->numDevices;i++){
  72:	2f 5f       	subi	r18, 0xFF	; 255
  74:	4c 81       	ldd	r20, Y+4	; 0x04
  76:	24 17       	cp	r18, r20
  78:	00 f0       	brcs	.+0      	; 0x7a <i2cAbstractBusInit+0x7a>
				device->bus = i2c;
			}
		}

		// Call the initialisation method for the actual class
		void (*fn)(I2C_ABSTRACT_BUS*) = (void (*)(I2C_ABSTRACT_BUS*))pgm_read_word(&class->init);
  7a:	e1 2f       	mov	r30, r17
  7c:	f7 2f       	mov	r31, r23
  7e:	85 91       	lpm	r24, Z+
  80:	94 91       	lpm	r25, Z
  82:	fc 01       	movw	r30, r24
		if(fn){
  84:	00 97       	sbiw	r24, 0x00	; 0
  86:	01 f0       	breq	.+0      	; 0x88 <i2cAbstractBusInit+0x88>
			fn(i2c);						// initialise the bus
  88:	ce 01       	movw	r24, r28
  8a:	09 95       	icall
		}
		i2c->initialised = TRUE;
  8c:	8f ef       	ldi	r24, 0xFF	; 255
  8e:	8d 83       	std	Y+5, r24	; 0x05
	}
}
  90:	df 91       	pop	r29
  92:	cf 91       	pop	r28
  94:	1f 91       	pop	r17
  96:	08 95       	ret

00000098 <i2cStop>:

void 	i2cStop(const I2C_ABSTRACT_BUS* i2c){
	if(i2c){
  98:	00 97       	sbiw	r24, 0x00	; 0
  9a:	01 f0       	breq	.+0      	; 0x9c <i2cStop+0x4>
		if(i2c->initialised){
  9c:	dc 01       	movw	r26, r24
  9e:	15 96       	adiw	r26, 0x05	; 5
  a0:	2c 91       	ld	r18, X
  a2:	15 97       	sbiw	r26, 0x05	; 5
  a4:	22 23       	and	r18, r18
  a6:	01 f0       	breq	.+0      	; 0xa8 <i2cStop+0x10>
			const I2C_CLASS* class = i2c->class;
			void (*fn)(const I2C_ABSTRACT_BUS*) =
					(void (*)(const I2C_ABSTRACT_BUS*))pgm_read_word(&class->stop);
  a8:	ed 91       	ld	r30, X+
  aa:	fc 91       	ld	r31, X
  ac:	34 96       	adiw	r30, 0x04	; 4
  ae:	25 91       	lpm	r18, Z+
  b0:	34 91       	lpm	r19, Z
			fn(i2c); 	// call the stop method
  b2:	f9 01       	movw	r30, r18
  b4:	09 94       	ijmp
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
  b6:	80 ee       	ldi	r24, 0xE0	; 224
  b8:	0c 94 00 00 	jmp	0	; 0x0 <i2cAbstractBusInit>
  bc:	08 95       	ret

000000be <i2cGet>:
	}
}

uint8_t i2cGet(const I2C_ABSTRACT_BUS* i2c, boolean isLastByte){
	uint8_t rtn = 0;
	if(i2c){
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	01 f0       	breq	.+0      	; 0xc2 <i2cGet+0x4>
		if(i2c->initialised){
  c2:	dc 01       	movw	r26, r24
  c4:	15 96       	adiw	r26, 0x05	; 5
  c6:	2c 91       	ld	r18, X
  c8:	15 97       	sbiw	r26, 0x05	; 5
  ca:	22 23       	and	r18, r18
  cc:	01 f0       	breq	.+0      	; 0xce <i2cGet+0x10>
			const I2C_CLASS* class = i2c->class;
			uint8_t (*fn)(const I2C_ABSTRACT_BUS*, boolean) =
					(uint8_t (*)(const I2C_ABSTRACT_BUS*,boolean))pgm_read_word(&class->get);
  ce:	ed 91       	ld	r30, X+
  d0:	fc 91       	ld	r31, X
  d2:	36 96       	adiw	r30, 0x06	; 6
  d4:	25 91       	lpm	r18, Z+
  d6:	34 91       	lpm	r19, Z
			rtn = fn(i2c, isLastByte); 	// call the get method
  d8:	f9 01       	movw	r30, r18
  da:	09 94       	ijmp
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
  dc:	80 ee       	ldi	r24, 0xE0	; 224
  de:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
		}
	}
	return rtn;
}
  e2:	80 e0       	ldi	r24, 0x00	; 0
  e4:	08 95       	ret

000000e6 <i2cPut>:
boolean i2cPut(const I2C_ABSTRACT_BUS* i2c, uint8_t b){
	boolean rtn = FALSE;
	if(i2c){
  e6:	00 97       	sbiw	r24, 0x00	; 0
  e8:	01 f0       	breq	.+0      	; 0xea <i2cPut+0x4>
		if(i2c->initialised){
  ea:	dc 01       	movw	r26, r24
  ec:	15 96       	adiw	r26, 0x05	; 5
  ee:	2c 91       	ld	r18, X
  f0:	15 97       	sbiw	r26, 0x05	; 5
  f2:	22 23       	and	r18, r18
  f4:	01 f0       	breq	.+0      	; 0xf6 <i2cPut+0x10>
			const I2C_CLASS* class = i2c->class;
			boolean (*fn)(const I2C_ABSTRACT_BUS*, uint8_t) =
					(boolean (*)(const I2C_ABSTRACT_BUS*,uint8_t))pgm_read_word(&class->put);
  f6:	ed 91       	ld	r30, X+
  f8:	fc 91       	ld	r31, X
  fa:	38 96       	adiw	r30, 0x08	; 8
  fc:	25 91       	lpm	r18, Z+
  fe:	34 91       	lpm	r19, Z
			rtn = fn(i2c, b); 	// call the put method
 100:	f9 01       	movw	r30, r18
 102:	09 94       	ijmp
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
 104:	80 ee       	ldi	r24, 0xE0	; 224
 106:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
		}
	}
	return rtn;
}
 10a:	80 e0       	ldi	r24, 0x00	; 0
 10c:	08 95       	ret

0000010e <i2cStart>:

boolean  i2cStart(const I2C_DEVICE* device, boolean writeMode){
	boolean rtn = FALSE;
	if(device){
 10e:	00 97       	sbiw	r24, 0x00	; 0
 110:	01 f0       	breq	.+0      	; 0x112 <i2cStart+0x4>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 112:	dc 01       	movw	r26, r24
 114:	ed 91       	ld	r30, X+
 116:	fc 91       	ld	r31, X
		if(i2c){
 118:	30 97       	sbiw	r30, 0x00	; 0
 11a:	01 f0       	breq	.+0      	; 0x11c <i2cStart+0xe>
			if(i2c->initialised){
 11c:	25 81       	ldd	r18, Z+5	; 0x05
 11e:	22 23       	and	r18, r18
 120:	01 f0       	breq	.+0      	; 0x122 <i2cStart+0x14>
				const I2C_CLASS* class = i2c->class;
				boolean	 (*fn)(const I2C_DEVICE*,boolean) =
						(boolean (*)(const I2C_DEVICE*,boolean))pgm_read_word(&class->start);
 122:	01 90       	ld	r0, Z+
 124:	f0 81       	ld	r31, Z
 126:	e0 2d       	mov	r30, r0
 128:	32 96       	adiw	r30, 0x02	; 2
 12a:	25 91       	lpm	r18, Z+
 12c:	34 91       	lpm	r19, Z
				rtn = fn(device,writeMode); 	// start
 12e:	f9 01       	movw	r30, r18
 130:	09 94       	ijmp
			}else{
				setError(I2C_BUS_NOT_INITIALIZED);
 132:	80 ee       	ldi	r24, 0xE0	; 224
 134:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
			}
		}
	}
	return rtn;
}
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	08 95       	ret

0000013c <i2cAbstractSetBitrate>:

void 	i2cAbstractSetBitrate(I2C_ABSTRACT_BUS* i2c,uint16_t bitrateKHz){
	if(i2c){
 13c:	00 97       	sbiw	r24, 0x00	; 0
 13e:	01 f0       	breq	.+0      	; 0x140 <i2cAbstractSetBitrate+0x4>

		const I2C_CLASS* class = i2c->class;

		// Call the  method for the actual class
		void (*fn)(const I2C_ABSTRACT_BUS*,uint16_t) = (void (*)(const I2C_ABSTRACT_BUS*,uint16_t))pgm_read_word(&class->speed);
 140:	dc 01       	movw	r26, r24
 142:	ed 91       	ld	r30, X+
 144:	fc 91       	ld	r31, X
 146:	3a 96       	adiw	r30, 0x0a	; 10
 148:	25 91       	lpm	r18, Z+
 14a:	34 91       	lpm	r19, Z
 14c:	f9 01       	movw	r30, r18
		if(fn){
 14e:	30 97       	sbiw	r30, 0x00	; 0
 150:	01 f0       	breq	.+0      	; 0x152 <i2cAbstractSetBitrate+0x16>
			fn(i2c,bitrateKHz);						// initialise the bus
 152:	09 94       	ijmp
 154:	08 95       	ret

00000156 <i2cMasterReceive>:
}


// --- High level routines ----

boolean i2cMasterReceive(const I2C_DEVICE* device, size_t length, uint8_t *data){
 156:	af 92       	push	r10
 158:	bf 92       	push	r11
 15a:	df 92       	push	r13
 15c:	ef 92       	push	r14
 15e:	ff 92       	push	r15
 160:	0f 93       	push	r16
 162:	1f 93       	push	r17
 164:	cf 93       	push	r28
 166:	df 93       	push	r29
 168:	00 d0       	rcall	.+0      	; 0x16a <i2cMasterReceive+0x14>
 16a:	cd b7       	in	r28, 0x3d	; 61
 16c:	de b7       	in	r29, 0x3e	; 62
 16e:	8b 01       	movw	r16, r22
	boolean ack = FALSE;
	if(device){
 170:	00 97       	sbiw	r24, 0x00	; 0
 172:	01 f0       	breq	.+0      	; 0x174 <i2cMasterReceive+0x1e>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 174:	fc 01       	movw	r30, r24
 176:	e0 80       	ld	r14, Z
 178:	f1 80       	ldd	r15, Z+1	; 0x01
		ack = i2cStart(device,FALSE);
 17a:	60 e0       	ldi	r22, 0x00	; 0
 17c:	49 83       	std	Y+1, r20	; 0x01
 17e:	5a 83       	std	Y+2, r21	; 0x02
 180:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 184:	d8 2e       	mov	r13, r24
		if(ack){
 186:	49 81       	ldd	r20, Y+1	; 0x01
 188:	5a 81       	ldd	r21, Y+2	; 0x02
 18a:	81 11       	cpse	r24, r1
 18c:	00 c0       	rjmp	.+0      	; 0x18e <i2cMasterReceive+0x38>
			// receive data bytes
			while(length--){
				*data++ = i2cGet(i2c, (length) ? FALSE : TRUE);
			}
		}
		i2cStop(i2c);											// Send stop bit
 18e:	c7 01       	movw	r24, r14
 190:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 194:	00 c0       	rjmp	.+0      	; 0x196 <i2cMasterReceive+0x40>
 196:	01 50       	subi	r16, 0x01	; 1
 198:	11 09       	sbc	r17, r1
 19a:	5a 01       	movw	r10, r20
 19c:	00 c0       	rjmp	.+0      	; 0x19e <i2cMasterReceive+0x48>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,FALSE);
		if(ack){
			// receive data bytes
			while(length--){
				*data++ = i2cGet(i2c, (length) ? FALSE : TRUE);
 19e:	01 15       	cp	r16, r1
 1a0:	11 05       	cpc	r17, r1
 1a2:	01 f4       	brne	.+0      	; 0x1a4 <i2cMasterReceive+0x4e>
 1a4:	6f ef       	ldi	r22, 0xFF	; 255
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <i2cMasterReceive+0x52>
 1a8:	60 e0       	ldi	r22, 0x00	; 0
 1aa:	c7 01       	movw	r24, r14
 1ac:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 1b0:	f5 01       	movw	r30, r10
 1b2:	81 93       	st	Z+, r24
 1b4:	5f 01       	movw	r10, r30
 1b6:	01 50       	subi	r16, 0x01	; 1
 1b8:	11 09       	sbc	r17, r1
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,FALSE);
		if(ack){
			// receive data bytes
			while(length--){
 1ba:	0f 3f       	cpi	r16, 0xFF	; 255
 1bc:	ff ef       	ldi	r31, 0xFF	; 255
 1be:	1f 07       	cpc	r17, r31
 1c0:	01 f4       	brne	.+0      	; 0x1c2 <i2cMasterReceive+0x6c>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <i2cMasterReceive+0x6e>


// --- High level routines ----

boolean i2cMasterReceive(const I2C_DEVICE* device, size_t length, uint8_t *data){
	boolean ack = FALSE;
 1c4:	d1 2c       	mov	r13, r1
			}
		}
		i2cStop(i2c);											// Send stop bit
	}
	return ack;
}
 1c6:	8d 2d       	mov	r24, r13
 1c8:	0f 90       	pop	r0
 1ca:	0f 90       	pop	r0
 1cc:	df 91       	pop	r29
 1ce:	cf 91       	pop	r28
 1d0:	1f 91       	pop	r17
 1d2:	0f 91       	pop	r16
 1d4:	ff 90       	pop	r15
 1d6:	ef 90       	pop	r14
 1d8:	df 90       	pop	r13
 1da:	bf 90       	pop	r11
 1dc:	af 90       	pop	r10
 1de:	08 95       	ret

000001e0 <i2cMasterSend>:

boolean i2cMasterSend(const I2C_DEVICE* device, size_t length, const uint8_t *data){
 1e0:	af 92       	push	r10
 1e2:	bf 92       	push	r11
 1e4:	df 92       	push	r13
 1e6:	ef 92       	push	r14
 1e8:	ff 92       	push	r15
 1ea:	0f 93       	push	r16
 1ec:	1f 93       	push	r17
 1ee:	cf 93       	push	r28
 1f0:	df 93       	push	r29
 1f2:	00 d0       	rcall	.+0      	; 0x1f4 <i2cMasterSend+0x14>
 1f4:	cd b7       	in	r28, 0x3d	; 61
 1f6:	de b7       	in	r29, 0x3e	; 62
 1f8:	7b 01       	movw	r14, r22
	boolean ack = FALSE;
	if(device){
 1fa:	00 97       	sbiw	r24, 0x00	; 0
 1fc:	01 f0       	breq	.+0      	; 0x1fe <i2cMasterSend+0x1e>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 1fe:	fc 01       	movw	r30, r24
 200:	00 81       	ld	r16, Z
 202:	11 81       	ldd	r17, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 204:	6f ef       	ldi	r22, 0xFF	; 255
 206:	49 83       	std	Y+1, r20	; 0x01
 208:	5a 83       	std	Y+2, r21	; 0x02
 20a:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 20e:	d8 2e       	mov	r13, r24
		if(ack){
 210:	49 81       	ldd	r20, Y+1	; 0x01
 212:	5a 81       	ldd	r21, Y+2	; 0x02
 214:	81 11       	cpse	r24, r1
 216:	00 c0       	rjmp	.+0      	; 0x218 <i2cMasterSend+0x38>
		i2cStop(i2c);											// Send stop bit
	}
	return ack;
}

boolean i2cMasterSend(const I2C_DEVICE* device, size_t length, const uint8_t *data){
 218:	d1 2c       	mov	r13, r1
 21a:	00 c0       	rjmp	.+0      	; 0x21c <i2cMasterSend+0x3c>
 21c:	5a 01       	movw	r10, r20
 21e:	ea 0c       	add	r14, r10
 220:	fb 1c       	adc	r15, r11
 222:	00 c0       	rjmp	.+0      	; 0x224 <i2cMasterSend+0x44>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && length--){
				ack &= i2cPut(i2c,*data++);
 224:	f5 01       	movw	r30, r10
 226:	61 91       	ld	r22, Z+
 228:	5f 01       	movw	r10, r30
 22a:	c8 01       	movw	r24, r16
 22c:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 230:	d8 22       	and	r13, r24
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && length--){
 232:	01 f0       	breq	.+0      	; 0x234 <i2cMasterSend+0x54>
 234:	ae 14       	cp	r10, r14
 236:	bf 04       	cpc	r11, r15
 238:	01 f4       	brne	.+0      	; 0x23a <i2cMasterSend+0x5a>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 23a:	c8 01       	movw	r24, r16
 23c:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 240:	00 c0       	rjmp	.+0      	; 0x242 <i2cMasterSend+0x62>
	}
	return ack;
}

boolean i2cMasterSend(const I2C_DEVICE* device, size_t length, const uint8_t *data){
	boolean ack = FALSE;
 242:	d1 2c       	mov	r13, r1
			}
		}
		i2cStop(i2c);
	}
	return ack;
}
 244:	8d 2d       	mov	r24, r13
 246:	0f 90       	pop	r0
 248:	0f 90       	pop	r0
 24a:	df 91       	pop	r29
 24c:	cf 91       	pop	r28
 24e:	1f 91       	pop	r17
 250:	0f 91       	pop	r16
 252:	ff 90       	pop	r15
 254:	ef 90       	pop	r14
 256:	df 90       	pop	r13
 258:	bf 90       	pop	r11
 25a:	af 90       	pop	r10
 25c:	08 95       	ret

0000025e <i2cMasterTransfer>:


boolean i2cMasterTransfer(const I2C_DEVICE* device, size_t wlen, const uint8_t *wdata, size_t rlen, uint8_t * rdata){
 25e:	4f 92       	push	r4
 260:	5f 92       	push	r5
 262:	7f 92       	push	r7
 264:	8f 92       	push	r8
 266:	9f 92       	push	r9
 268:	af 92       	push	r10
 26a:	bf 92       	push	r11
 26c:	cf 92       	push	r12
 26e:	df 92       	push	r13
 270:	ef 92       	push	r14
 272:	ff 92       	push	r15
 274:	0f 93       	push	r16
 276:	1f 93       	push	r17
 278:	cf 93       	push	r28
 27a:	df 93       	push	r29
 27c:	00 d0       	rcall	.+0      	; 0x27e <i2cMasterTransfer+0x20>
 27e:	cd b7       	in	r28, 0x3d	; 61
 280:	de b7       	in	r29, 0x3e	; 62
 282:	7c 01       	movw	r14, r24
 284:	5b 01       	movw	r10, r22
 286:	49 01       	movw	r8, r18
	boolean ack = false;
	if(device){
 288:	00 97       	sbiw	r24, 0x00	; 0
 28a:	01 f0       	breq	.+0      	; 0x28c <i2cMasterTransfer+0x2e>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 28c:	fc 01       	movw	r30, r24
 28e:	c0 80       	ld	r12, Z
 290:	d1 80       	ldd	r13, Z+1	; 0x01

		// Write the data
		ack = i2cStart(device,TRUE);
 292:	6f ef       	ldi	r22, 0xFF	; 255
 294:	49 83       	std	Y+1, r20	; 0x01
 296:	5a 83       	std	Y+2, r21	; 0x02
 298:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 29c:	78 2e       	mov	r7, r24
		if(ack){
 29e:	49 81       	ldd	r20, Y+1	; 0x01
 2a0:	5a 81       	ldd	r21, Y+2	; 0x02
 2a2:	88 23       	and	r24, r24
 2a4:	01 f0       	breq	.+0      	; 0x2a6 <i2cMasterTransfer+0x48>
 2a6:	2a 01       	movw	r4, r20
	}
	return ack;
}


boolean i2cMasterTransfer(const I2C_DEVICE* device, size_t wlen, const uint8_t *wdata, size_t rlen, uint8_t * rdata){
 2a8:	a4 0c       	add	r10, r4
 2aa:	b5 1c       	adc	r11, r5
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <i2cMasterTransfer+0x50>
		// Write the data
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && wlen--){
				ack &= i2cPut(i2c,*wdata++);
 2ae:	f2 01       	movw	r30, r4
 2b0:	61 91       	ld	r22, Z+
 2b2:	2f 01       	movw	r4, r30
 2b4:	c6 01       	movw	r24, r12
 2b6:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 2ba:	78 22       	and	r7, r24

		// Write the data
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && wlen--){
 2bc:	01 f0       	breq	.+0      	; 0x2be <i2cMasterTransfer+0x60>
 2be:	4a 14       	cp	r4, r10
 2c0:	5b 04       	cpc	r5, r11
 2c2:	01 f4       	brne	.+0      	; 0x2c4 <i2cMasterTransfer+0x66>
 2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <i2cMasterTransfer+0x68>
			ack = i2cStart(device,FALSE);	// repeated start
		}
		if(ack){
			// Read the data
			while(rlen--){
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
 2c6:	e1 14       	cp	r14, r1
 2c8:	f1 04       	cpc	r15, r1
 2ca:	01 f4       	brne	.+0      	; 0x2cc <i2cMasterTransfer+0x6e>
 2cc:	6f ef       	ldi	r22, 0xFF	; 255
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <i2cMasterTransfer+0x72>
 2d0:	60 e0       	ldi	r22, 0x00	; 0
 2d2:	c6 01       	movw	r24, r12
 2d4:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 2d8:	f4 01       	movw	r30, r8
 2da:	81 93       	st	Z+, r24
 2dc:	4f 01       	movw	r8, r30
 2de:	f1 e0       	ldi	r31, 0x01	; 1
 2e0:	ef 1a       	sub	r14, r31
 2e2:	f1 08       	sbc	r15, r1
		if(ack){
			ack = i2cStart(device,FALSE);	// repeated start
		}
		if(ack){
			// Read the data
			while(rlen--){
 2e4:	8f ef       	ldi	r24, 0xFF	; 255
 2e6:	e8 16       	cp	r14, r24
 2e8:	f8 06       	cpc	r15, r24
 2ea:	01 f4       	brne	.+0      	; 0x2ec <i2cMasterTransfer+0x8e>
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
			}
		}

		// Stop
		i2cStop(i2c);
 2ec:	c6 01       	movw	r24, r12
 2ee:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 2f2:	00 c0       	rjmp	.+0      	; 0x2f4 <i2cMasterTransfer+0x96>
	return ack;
}


boolean i2cMasterTransfer(const I2C_DEVICE* device, size_t wlen, const uint8_t *wdata, size_t rlen, uint8_t * rdata){
	boolean ack = false;
 2f4:	b1 2c       	mov	r11, r1
 2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <i2cMasterTransfer+0x9a>
			}
		}

		// Read the response
		if(ack){
			ack = i2cStart(device,FALSE);	// repeated start
 2f8:	60 e0       	ldi	r22, 0x00	; 0
 2fa:	c7 01       	movw	r24, r14
 2fc:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 300:	b8 2e       	mov	r11, r24
		}
		if(ack){
 302:	88 23       	and	r24, r24
 304:	01 f0       	breq	.+0      	; 0x306 <i2cMasterTransfer+0xa8>
 306:	74 01       	movw	r14, r8
 308:	e1 e0       	ldi	r30, 0x01	; 1
 30a:	ee 1a       	sub	r14, r30
 30c:	f1 08       	sbc	r15, r1
 30e:	48 01       	movw	r8, r16
 310:	00 c0       	rjmp	.+0      	; 0x312 <i2cMasterTransfer+0xb4>
			// Read the data
			while(rlen--){
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
 312:	b1 2c       	mov	r11, r1
 314:	00 c0       	rjmp	.+0      	; 0x316 <i2cMasterTransfer+0xb8>

		// Stop
		i2cStop(i2c);
	}
	return ack;
}
 316:	8b 2d       	mov	r24, r11
 318:	0f 90       	pop	r0
 31a:	0f 90       	pop	r0
 31c:	df 91       	pop	r29
 31e:	cf 91       	pop	r28
 320:	1f 91       	pop	r17
 322:	0f 91       	pop	r16
 324:	ff 90       	pop	r15
 326:	ef 90       	pop	r14
 328:	df 90       	pop	r13
 32a:	cf 90       	pop	r12
 32c:	bf 90       	pop	r11
 32e:	af 90       	pop	r10
 330:	9f 90       	pop	r9
 332:	8f 90       	pop	r8
 334:	7f 90       	pop	r7
 336:	5f 90       	pop	r5
 338:	4f 90       	pop	r4
 33a:	08 95       	ret

0000033c <i2cMasterSendWithPrefix>:

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
 33c:	6f 92       	push	r6
 33e:	7f 92       	push	r7
 340:	9f 92       	push	r9
 342:	af 92       	push	r10
 344:	bf 92       	push	r11
 346:	cf 92       	push	r12
 348:	df 92       	push	r13
 34a:	ef 92       	push	r14
 34c:	ff 92       	push	r15
 34e:	0f 93       	push	r16
 350:	1f 93       	push	r17
 352:	cf 93       	push	r28
 354:	df 93       	push	r29
 356:	00 d0       	rcall	.+0      	; 0x358 <i2cMasterSendWithPrefix+0x1c>
 358:	cd b7       	in	r28, 0x3d	; 61
 35a:	de b7       	in	r29, 0x3e	; 62
 35c:	6b 01       	movw	r12, r22
 35e:	59 01       	movw	r10, r18
	boolean ack = FALSE;
	if(device){
 360:	00 97       	sbiw	r24, 0x00	; 0
 362:	01 f0       	breq	.+0      	; 0x364 <i2cMasterSendWithPrefix+0x28>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 364:	fc 01       	movw	r30, r24
 366:	e0 80       	ld	r14, Z
 368:	f1 80       	ldd	r15, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 36a:	6f ef       	ldi	r22, 0xFF	; 255
 36c:	49 83       	std	Y+1, r20	; 0x01
 36e:	5a 83       	std	Y+2, r21	; 0x02
 370:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 374:	98 2e       	mov	r9, r24
		if(ack){
 376:	49 81       	ldd	r20, Y+1	; 0x01
 378:	5a 81       	ldd	r21, Y+2	; 0x02
 37a:	81 11       	cpse	r24, r1
 37c:	00 c0       	rjmp	.+0      	; 0x37e <i2cMasterSendWithPrefix+0x42>
		i2cStop(i2c);
	}
	return ack;
}

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
 37e:	91 2c       	mov	r9, r1
 380:	00 c0       	rjmp	.+0      	; 0x382 <i2cMasterSendWithPrefix+0x46>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// Put the first block of data
			while(ack && prefixLen--){
				ack &= i2cPut(i2c,*prefix++);
 382:	f3 01       	movw	r30, r6
 384:	61 91       	ld	r22, Z+
 386:	3f 01       	movw	r6, r30
 388:	c7 01       	movw	r24, r14
 38a:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 38e:	98 22       	and	r9, r24
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// Put the first block of data
			while(ack && prefixLen--){
 390:	01 f4       	brne	.+0      	; 0x392 <i2cMasterSendWithPrefix+0x56>
 392:	68 01       	movw	r12, r16
		i2cStop(i2c);
	}
	return ack;
}

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
 394:	a0 0e       	add	r10, r16
 396:	b1 1e       	adc	r11, r17
 398:	00 c0       	rjmp	.+0      	; 0x39a <i2cMasterSendWithPrefix+0x5e>
 39a:	3a 01       	movw	r6, r20
 39c:	c6 0c       	add	r12, r6
 39e:	d7 1c       	adc	r13, r7
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// Put the first block of data
			while(ack && prefixLen--){
 3a0:	6c 14       	cp	r6, r12
 3a2:	7d 04       	cpc	r7, r13
 3a4:	01 f4       	brne	.+0      	; 0x3a6 <i2cMasterSendWithPrefix+0x6a>
 3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <i2cMasterSendWithPrefix+0x6c>
				ack &= i2cPut(i2c,*prefix++);
			}

			// send the second block of data
			while(ack && length--){
				ack &= i2cPut(i2c,*data++);
 3a8:	f6 01       	movw	r30, r12
 3aa:	61 91       	ld	r22, Z+
 3ac:	6f 01       	movw	r12, r30
 3ae:	c7 01       	movw	r24, r14
 3b0:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 3b4:	98 22       	and	r9, r24
			while(ack && prefixLen--){
				ack &= i2cPut(i2c,*prefix++);
			}

			// send the second block of data
			while(ack && length--){
 3b6:	99 20       	and	r9, r9
 3b8:	01 f0       	breq	.+0      	; 0x3ba <i2cMasterSendWithPrefix+0x7e>
 3ba:	ca 14       	cp	r12, r10
 3bc:	db 04       	cpc	r13, r11
 3be:	01 f4       	brne	.+0      	; 0x3c0 <i2cMasterSendWithPrefix+0x84>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 3c0:	c7 01       	movw	r24, r14
 3c2:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 3c6:	00 c0       	rjmp	.+0      	; 0x3c8 <i2cMasterSendWithPrefix+0x8c>
	}
	return ack;
}

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
	boolean ack = FALSE;
 3c8:	91 2c       	mov	r9, r1
		}
		i2cStop(i2c);
	}
	return ack;

}
 3ca:	89 2d       	mov	r24, r9
 3cc:	0f 90       	pop	r0
 3ce:	0f 90       	pop	r0
 3d0:	df 91       	pop	r29
 3d2:	cf 91       	pop	r28
 3d4:	1f 91       	pop	r17
 3d6:	0f 91       	pop	r16
 3d8:	ff 90       	pop	r15
 3da:	ef 90       	pop	r14
 3dc:	df 90       	pop	r13
 3de:	cf 90       	pop	r12
 3e0:	bf 90       	pop	r11
 3e2:	af 90       	pop	r10
 3e4:	9f 90       	pop	r9
 3e6:	7f 90       	pop	r7
 3e8:	6f 90       	pop	r6
 3ea:	08 95       	ret

000003ec <i2cMasterWriteRegisters>:


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
 3ec:	bf 92       	push	r11
 3ee:	cf 92       	push	r12
 3f0:	df 92       	push	r13
 3f2:	ef 92       	push	r14
 3f4:	ff 92       	push	r15
 3f6:	0f 93       	push	r16
 3f8:	1f 93       	push	r17
 3fa:	cf 93       	push	r28
 3fc:	df 93       	push	r29
 3fe:	c6 2f       	mov	r28, r22
 400:	7a 01       	movw	r14, r20
 402:	b2 2e       	mov	r11, r18
 404:	c3 2e       	mov	r12, r19
	boolean ack = FALSE;
	if(device){
 406:	00 97       	sbiw	r24, 0x00	; 0
 408:	01 f0       	breq	.+0      	; 0x40a <i2cMasterWriteRegisters+0x1e>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 40a:	fc 01       	movw	r30, r24
 40c:	00 81       	ld	r16, Z
 40e:	11 81       	ldd	r17, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 410:	6f ef       	ldi	r22, 0xFF	; 255
 412:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 416:	d8 2e       	mov	r13, r24
		if(ack){
 418:	81 11       	cpse	r24, r1
 41a:	00 c0       	rjmp	.+0      	; 0x41c <i2cMasterWriteRegisters+0x30>

}


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
 41c:	d1 2c       	mov	r13, r1
 41e:	00 c0       	rjmp	.+0      	; 0x420 <i2cMasterWriteRegisters+0x34>
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// Put the first register number
			ack &= i2cPut(i2c,startReg);
 420:	6c 2f       	mov	r22, r28
 422:	c8 01       	movw	r24, r16
 424:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 428:	d8 22       	and	r13, r24
 42a:	cb 2d       	mov	r28, r11
 42c:	dc 2d       	mov	r29, r12

}


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
 42e:	ec 0e       	add	r14, r28
 430:	fd 1e       	adc	r15, r29
		if(ack){
			// Put the first register number
			ack &= i2cPut(i2c,startReg);

			// send the data
			while(ack && numBytes--){
 432:	00 c0       	rjmp	.+0      	; 0x434 <i2cMasterWriteRegisters+0x48>
				ack &= i2cPut(i2c,*data++);
 434:	69 91       	ld	r22, Y+
 436:	c8 01       	movw	r24, r16
 438:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 43c:	d8 22       	and	r13, r24
		if(ack){
			// Put the first register number
			ack &= i2cPut(i2c,startReg);

			// send the data
			while(ack && numBytes--){
 43e:	dd 20       	and	r13, r13
 440:	01 f0       	breq	.+0      	; 0x442 <i2cMasterWriteRegisters+0x56>
 442:	ce 15       	cp	r28, r14
 444:	df 05       	cpc	r29, r15
 446:	01 f4       	brne	.+0      	; 0x448 <i2cMasterWriteRegisters+0x5c>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 448:	c8 01       	movw	r24, r16
 44a:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 44e:	00 c0       	rjmp	.+0      	; 0x450 <i2cMasterWriteRegisters+0x64>
}


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
	boolean ack = FALSE;
 450:	d1 2c       	mov	r13, r1
			}
		}
		i2cStop(i2c);
	}
	return ack;
}
 452:	8d 2d       	mov	r24, r13
 454:	df 91       	pop	r29
 456:	cf 91       	pop	r28
 458:	1f 91       	pop	r17
 45a:	0f 91       	pop	r16
 45c:	ff 90       	pop	r15
 45e:	ef 90       	pop	r14
 460:	df 90       	pop	r13
 462:	cf 90       	pop	r12
 464:	bf 90       	pop	r11
 466:	08 95       	ret

00000468 <i2cMasterReadRegisters>:

boolean i2cMasterReadRegisters(const I2C_DEVICE* device, uint8_t startReg, size_t numBytes, uint8_t* response){
 468:	0f 93       	push	r16
 46a:	1f 93       	push	r17
 46c:	cf 93       	push	r28
 46e:	df 93       	push	r29
 470:	1f 92       	push	r1
 472:	cd b7       	in	r28, 0x3d	; 61
 474:	de b7       	in	r29, 0x3e	; 62
 476:	69 83       	std	Y+1, r22	; 0x01
	return i2cMasterTransfer(device, 1, &startReg, numBytes, response);
 478:	89 01       	movw	r16, r18
 47a:	9a 01       	movw	r18, r20
 47c:	ae 01       	movw	r20, r28
 47e:	4f 5f       	subi	r20, 0xFF	; 255
 480:	5f 4f       	sbci	r21, 0xFF	; 255
 482:	61 e0       	ldi	r22, 0x01	; 1
 484:	70 e0       	ldi	r23, 0x00	; 0
 486:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
}
 48a:	0f 90       	pop	r0
 48c:	df 91       	pop	r29
 48e:	cf 91       	pop	r28
 490:	1f 91       	pop	r17
 492:	0f 91       	pop	r16
 494:	08 95       	ret

00000496 <i2cMasterWriteRegister>:
boolean i2cMasterWriteRegister(const I2C_DEVICE* device, uint8_t reg, uint8_t value){
 496:	cf 93       	push	r28
 498:	df 93       	push	r29
 49a:	00 d0       	rcall	.+0      	; 0x49c <i2cMasterWriteRegister+0x6>
 49c:	cd b7       	in	r28, 0x3d	; 61
 49e:	de b7       	in	r29, 0x3e	; 62
	uint8_t data[2] = {reg,value};
 4a0:	69 83       	std	Y+1, r22	; 0x01
 4a2:	4a 83       	std	Y+2, r20	; 0x02
	return i2cMasterSend(device, sizeof(data), data);
 4a4:	ae 01       	movw	r20, r28
 4a6:	4f 5f       	subi	r20, 0xFF	; 255
 4a8:	5f 4f       	sbci	r21, 0xFF	; 255
 4aa:	62 e0       	ldi	r22, 0x02	; 2
 4ac:	70 e0       	ldi	r23, 0x00	; 0
 4ae:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
}
 4b2:	0f 90       	pop	r0
 4b4:	0f 90       	pop	r0
 4b6:	df 91       	pop	r29
 4b8:	cf 91       	pop	r28
 4ba:	08 95       	ret

i2cHwBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000160  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000194  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000194  2**0
                  ALLOC
  3 .text.startup 00000018  00000000  00000000  00000194  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .ctors        00000002  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  5 .progmem.data 0000000c  00000000  00000000  000001ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  6 .debug_info   000004cd  00000000  00000000  000001ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_abbrev 000001bc  00000000  00000000  00000687  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000002c8  00000000  00000000  00000843  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_aranges 00000028  00000000  00000000  00000b0b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00000b33  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_line   00000103  00000000  00000000  00000b4b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    00000279  00000000  00000000  00000c4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      0000002a  00000000  00000000  00000ec7  2**0
                  CONTENTS, READONLY
 14 .debug_frame  000000b4  00000000  00000000  00000ef4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <speed>:
static void speed(const I2C_ABSTRACT_BUS* bus,uint16_t bitrateKHz){
	// TWBR x 4pow(TWPS) = ((cpudiv1000/ bitrateKHz) - 16) /2
	uint16_t bitrate_div;

	// calculate bitrate division
	bitrate_div = cpu_speed_div_1000 / bitrateKHz;
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	90 91 00 00 	lds	r25, 0x0000
   8:	0e 94 00 00 	call	0	; 0x0 <speed>

	if(bitrate_div >= 16){
   c:	60 31       	cpi	r22, 0x10	; 16
   e:	71 05       	cpc	r23, r1
  10:	00 f0       	brcs	.+0      	; 0x12 <speed+0x12>
		bitrate_div = (bitrate_div-16)/2;
  12:	60 51       	subi	r22, 0x10	; 16
  14:	71 09       	sbc	r23, r1
  16:	76 95       	lsr	r23
  18:	67 95       	ror	r22
  1a:	00 c0       	rjmp	.+0      	; 0x1c <speed+0x1c>
	}else{
		bitrate_div=0;
  1c:	60 e0       	ldi	r22, 0x00	; 0
  1e:	70 e0       	ldi	r23, 0x00	; 0
	}

	// Turn prescaler off by default
	#ifdef TWPS0
		cbi(TWSR, TWPS0);
  20:	80 91 b9 00 	lds	r24, 0x00B9
  24:	8e 7f       	andi	r24, 0xFE	; 254
  26:	80 93 b9 00 	sts	0x00B9, r24
	#endif
	#ifdef TWPS1
		cbi(TWSR, TWPS1);
  2a:	80 91 b9 00 	lds	r24, 0x00B9
  2e:	8d 7f       	andi	r24, 0xFD	; 253
  30:	80 93 b9 00 	sts	0x00B9, r24
	#endif

	// Check if need to use the prescaler
	#ifdef TWPS0
	if(bitrate_div > 255){
  34:	6f 3f       	cpi	r22, 0xFF	; 255
  36:	71 05       	cpc	r23, r1
  38:	01 f0       	breq	.+0      	; 0x3a <speed+0x3a>
  3a:	00 f0       	brcs	.+0      	; 0x3c <speed+0x3c>
		sbi(TWSR, TWPS0);
  3c:	80 91 b9 00 	lds	r24, 0x00B9
  40:	81 60       	ori	r24, 0x01	; 1
  42:	80 93 b9 00 	sts	0x00B9, r24
		bitrate_div /= 4;
  46:	76 95       	lsr	r23
  48:	67 95       	ror	r22
  4a:	76 95       	lsr	r23
  4c:	67 95       	ror	r22
	}
	#endif
	#ifdef TWPS1
	if(bitrate_div > 255){
  4e:	6f 3f       	cpi	r22, 0xFF	; 255
  50:	71 05       	cpc	r23, r1
  52:	01 f0       	breq	.+0      	; 0x54 <speed+0x54>
  54:	00 f0       	brcs	.+0      	; 0x56 <speed+0x56>
		sbi(TWSR, TWPS1);
  56:	80 91 b9 00 	lds	r24, 0x00B9
  5a:	82 60       	ori	r24, 0x02	; 2
  5c:	80 93 b9 00 	sts	0x00B9, r24
		bitrate_div /= 16;
  60:	84 e0       	ldi	r24, 0x04	; 4
  62:	76 95       	lsr	r23
  64:	67 95       	ror	r22
  66:	8a 95       	dec	r24
  68:	01 f4       	brne	.+0      	; 0x6a <speed+0x6a>
	}
	#endif

	// Cannot prescale it on some devices - so just go as slow as possible
	if(bitrate_div > 255){
  6a:	6f 3f       	cpi	r22, 0xFF	; 255
  6c:	71 05       	cpc	r23, r1
  6e:	01 f0       	breq	.+0      	; 0x70 <speed+0x70>
  70:	00 f0       	brcs	.+0      	; 0x72 <speed+0x72>
		bitrate_div = 255;
  72:	6f ef       	ldi	r22, 0xFF	; 255
  74:	70 e0       	ldi	r23, 0x00	; 0
	}

	outb(TWBR, (uint8_t)(bitrate_div) );
  76:	60 93 b8 00 	sts	0x00B8, r22
  7a:	08 95       	ret

0000007c <init>:
//	sei();
}

static void init(I2C_ABSTRACT_BUS* bus){
	// set i2c bit rate to 100KHz
	speed(bus,100);
  7c:	64 e6       	ldi	r22, 0x64	; 100
  7e:	70 e0       	ldi	r23, 0x00	; 0
  80:	0c 94 00 00 	jmp	0	; 0x0 <speed>

00000084 <i2cWaitForComplete>:
}

static inline void i2cWaitForComplete(void){
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
  84:	80 91 bc 00 	lds	r24, 0x00BC
  88:	87 ff       	sbrs	r24, 7
  8a:	00 c0       	rjmp	.+0      	; 0x8c <i2cWaitForComplete+0x8>
}
  8c:	08 95       	ret

0000008e <getByte>:

static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	// begin receive over i2c
	if( isLastByte ){
		// ackFlag = FALSE: NACK the received data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  8e:	80 91 bc 00 	lds	r24, 0x00BC
  92:	8f 70       	andi	r24, 0x0F	; 15
	while( !(inb(TWCR) & BV(TWINT)) );
}

static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	// begin receive over i2c
	if( isLastByte ){
  94:	66 23       	and	r22, r22
  96:	01 f0       	breq	.+0      	; 0x98 <getByte+0xa>
		// ackFlag = FALSE: NACK the received data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  98:	80 68       	ori	r24, 0x80	; 128
  9a:	00 c0       	rjmp	.+0      	; 0x9c <getByte+0xe>
	}else{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
  9c:	80 6c       	ori	r24, 0xC0	; 192
  9e:	80 93 bc 00 	sts	0x00BC, r24
	}
	i2cWaitForComplete();
  a2:	0e 94 00 00 	call	0	; 0x0 <speed>
	return inb(TWDR);
  a6:	80 91 bb 00 	lds	r24, 0x00BB
}
  aa:	08 95       	ret

000000ac <putByte>:


static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t data){
	// save data to the TWDR
	outb(TWDR, data);
  ac:	60 93 bb 00 	sts	0x00BB, r22
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  b0:	80 91 bc 00 	lds	r24, 0x00BC
  b4:	8f 70       	andi	r24, 0x0F	; 15
  b6:	80 68       	ori	r24, 0x80	; 128
  b8:	80 93 bc 00 	sts	0x00BC, r24

	i2cWaitForComplete();
  bc:	0e 94 00 00 	call	0	; 0x0 <speed>

	uint8_t got = inb(TWSR) & TWSR_STATUS_MASK;	// get the status
  c0:	80 91 b9 00 	lds	r24, 0x00B9
  c4:	88 7f       	andi	r24, 0xF8	; 248

    return( (got == TW_MT_DATA_ACK) ? TRUE : FALSE );
  c6:	88 32       	cpi	r24, 0x28	; 40
  c8:	01 f4       	brne	.+0      	; 0xca <putByte+0x1e>
  ca:	8f ef       	ldi	r24, 0xFF	; 255
  cc:	08 95       	ret
  ce:	80 e0       	ldi	r24, 0x00	; 0

}
  d0:	08 95       	ret

000000d2 <start>:

static boolean start(const I2C_DEVICE* device, boolean writeMode){
  d2:	ef 92       	push	r14
  d4:	ff 92       	push	r15
  d6:	1f 93       	push	r17
  d8:	cf 93       	push	r28
  da:	df 93       	push	r29
  dc:	1f 92       	push	r1
  de:	cd b7       	in	r28, 0x3d	; 61
  e0:	de b7       	in	r29, 0x3e	; 62
  e2:	7c 01       	movw	r14, r24
	uint8_t expect;
	if(writeMode){
  e4:	66 23       	and	r22, r22
  e6:	01 f0       	breq	.+0      	; 0xe8 <start+0x16>
		i2cState = I2C_MASTER_TX;
  e8:	82 e0       	ldi	r24, 0x02	; 2
  ea:	80 93 00 00 	sts	0x0000, r24
		expect = TW_MT_SLA_ACK;
  ee:	18 e1       	ldi	r17, 0x18	; 24
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <start+0x20>
	}else{
		i2cState = I2C_MASTER_RX;
  f2:	83 e0       	ldi	r24, 0x03	; 3
  f4:	80 93 00 00 	sts	0x0000, r24
		expect = TW_MR_SLA_ACK;
  f8:	10 e4       	ldi	r17, 0x40	; 64
	}

	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
  fa:	80 91 bc 00 	lds	r24, 0x00BC
  fe:	8f 70       	andi	r24, 0x0F	; 15
 100:	80 6a       	ori	r24, 0xA0	; 160
 102:	80 93 bc 00 	sts	0x00BC, r24
	i2cWaitForComplete();
 106:	69 83       	std	Y+1, r22	; 0x01
 108:	0e 94 00 00 	call	0	; 0x0 <speed>

	// Send the device addr and direction
	uint8_t addr = device->addr;
 10c:	f7 01       	movw	r30, r14
 10e:	82 81       	ldd	r24, Z+2	; 0x02
	if(writeMode==FALSE){
 110:	69 81       	ldd	r22, Y+1	; 0x01
 112:	61 11       	cpse	r22, r1
 114:	00 c0       	rjmp	.+0      	; 0x116 <start+0x44>
		addr |= 1;
 116:	81 60       	ori	r24, 0x01	; 1
 118:	00 c0       	rjmp	.+0      	; 0x11a <start+0x48>
	}else{
		addr &= 0xfe;
 11a:	8e 7f       	andi	r24, 0xFE	; 254
	}
	outb(TWDR, addr);
 11c:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 120:	80 91 bc 00 	lds	r24, 0x00BC
 124:	8f 70       	andi	r24, 0x0F	; 15
 126:	80 68       	ori	r24, 0x80	; 128
 128:	80 93 bc 00 	sts	0x00BC, r24
	i2cWaitForComplete();
 12c:	0e 94 00 00 	call	0	; 0x0 <speed>

	uint8_t got = inb(TWSR) & TWSR_STATUS_MASK;	// get the status
 130:	80 91 b9 00 	lds	r24, 0x00B9
 134:	88 7f       	andi	r24, 0xF8	; 248
    return( (got == expect) ? TRUE : FALSE );
 136:	81 13       	cpse	r24, r17
 138:	00 c0       	rjmp	.+0      	; 0x13a <start+0x68>
 13a:	8f ef       	ldi	r24, 0xFF	; 255
 13c:	00 c0       	rjmp	.+0      	; 0x13e <start+0x6c>
 13e:	80 e0       	ldi	r24, 0x00	; 0

}
 140:	0f 90       	pop	r0
 142:	df 91       	pop	r29
 144:	cf 91       	pop	r28
 146:	1f 91       	pop	r17
 148:	ff 90       	pop	r15
 14a:	ef 90       	pop	r14
 14c:	08 95       	ret

0000014e <stop>:

static void stop(const I2C_ABSTRACT_BUS* bus){
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
 14e:	ec eb       	ldi	r30, 0xBC	; 188
 150:	f0 e0       	ldi	r31, 0x00	; 0
 152:	80 81       	ld	r24, Z
 154:	8f 70       	andi	r24, 0x0F	; 15
 156:	80 6d       	ori	r24, 0xD0	; 208
 158:	80 83       	st	Z, r24
	i2cState = I2C_IDLE;
 15a:	10 92 00 00 	sts	0x0000, r1
 15e:	08 95       	ret

Disassembly of section .text.startup:

00000000 <_private_i2cMasterInit>:

// Initialiase I2C hardware
void __attribute__ ((constructor)) _private_i2cMasterInit(void){

	// Make the 2 wires into inputs
	cbi(SCL_DDR,SCL_PIN);
   0:	50 98       	cbi	0x0a, 0	; 10
	cbi(SDA_DDR,SDA_PIN);
   2:	51 98       	cbi	0x0a, 1	; 10
	// and turn on the pullups
	sbi(SCL_PORT,SCL_PIN);
   4:	58 9a       	sbi	0x0b, 0	; 11
	sbi(SDA_PORT,SDA_PIN);
   6:	59 9a       	sbi	0x0b, 1	; 11


	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
   8:	ec eb       	ldi	r30, 0xBC	; 188
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	84 60       	ori	r24, 0x04	; 4
  10:	80 83       	st	Z, r24

	// set state
	i2cState = I2C_IDLE;
  12:	10 92 00 00 	sts	0x0000, r1
  16:	08 95       	ret

i2cSwBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000214  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000248  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000248  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000248  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d2c  00000000  00000000  00000254  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002e4  00000000  00000000  00000f80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000005ab  00000000  00000000  00001264  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000180f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  0000182f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000154  00000000  00000000  00001847  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000406  00000000  00000000  0000199b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00001da1  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000118  00000000  00000000  00001dcc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <halfDelay>:
	pin_make_output(i2c->sda,FALSE);
}

// Wait for at least 5uS
static void halfDelay(){
	delay_us(5);
   0:	65 e0       	ldi	r22, 0x05	; 5
   2:	70 e0       	ldi	r23, 0x00	; 0
   4:	80 e0       	ldi	r24, 0x00	; 0
   6:	90 e0       	ldi	r25, 0x00	; 0
   8:	0c 94 00 00 	jmp	0	; 0x0 <halfDelay>

0000000c <sda_high.isra.0>:
	}while(pin_is_low(i2c->scl));
}

// Make the data line high
static void sda_high(const I2C_SOFTWARE_BUS* i2c){
	pin_make_input(i2c->sda,FALSE);			// Assumes external resistor (works)
   c:	60 e0       	ldi	r22, 0x00	; 0
   e:	0c 94 00 00 	jmp	0	; 0x0 <halfDelay>

00000012 <scl_high.isra.3>:
#include "i2cBus.h"
#include "iopin.h"
#include "timer.h"

// Make the clock high
static void scl_high(const I2C_SOFTWARE_BUS* i2c){
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	ec 01       	movw	r28, r24
	do{
		pin_make_input(i2c->scl,FALSE);		// Assumes external resistor (works)
  18:	60 e0       	ldi	r22, 0x00	; 0
  1a:	88 81       	ld	r24, Y
  1c:	99 81       	ldd	r25, Y+1	; 0x01
  1e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	}while(pin_is_low(i2c->scl));
  22:	88 81       	ld	r24, Y
  24:	99 81       	ldd	r25, Y+1	; 0x01
  26:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  2a:	88 23       	and	r24, r24
  2c:	01 f0       	breq	.+0      	; 0x2e <scl_high.isra.3+0x1c>
}
  2e:	df 91       	pop	r29
  30:	cf 91       	pop	r28
  32:	08 95       	ret

00000034 <init>:
	halfDelay();
	sda_high(i2c);
	halfDelay();
}

static void init(I2C_ABSTRACT_BUS* bus){
  34:	cf 93       	push	r28
  36:	df 93       	push	r29
  38:	ec 01       	movw	r28, r24
	const I2C_SOFTWARE_BUS* i2c = (I2C_SOFTWARE_BUS*)bus;

	// Make both pins high
	sda_high(i2c);
  3a:	88 85       	ldd	r24, Y+8	; 0x08
  3c:	99 85       	ldd	r25, Y+9	; 0x09
  3e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
  42:	ce 01       	movw	r24, r28
  44:	06 96       	adiw	r24, 0x06	; 6
}
  46:	df 91       	pop	r29
  48:	cf 91       	pop	r28
static void init(I2C_ABSTRACT_BUS* bus){
	const I2C_SOFTWARE_BUS* i2c = (I2C_SOFTWARE_BUS*)bus;

	// Make both pins high
	sda_high(i2c);
	scl_high(i2c);
  4a:	0c 94 00 00 	jmp	0	; 0x0 <halfDelay>

0000004e <getByte>:
	}
	return rtn;
}


static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
  4e:	df 92       	push	r13
  50:	ef 92       	push	r14
  52:	ff 92       	push	r15
  54:	0f 93       	push	r16
  56:	1f 93       	push	r17
  58:	cf 93       	push	r28
  5a:	df 93       	push	r29
  5c:	ec 01       	movw	r28, r24
  5e:	d6 2e       	mov	r13, r22
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
  60:	88 85       	ldd	r24, Y+8	; 0x08
  62:	99 85       	ldd	r25, Y+9	; 0x09
  64:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  68:	88 e0       	ldi	r24, 0x08	; 8
  6a:	e8 2e       	mov	r14, r24


static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;
  6c:	f1 2c       	mov	r15, r1
}



// Expose this implementation to the linker
const I2C_CLASS c_sw_i2c = MAKE_I2C_CLASS(&init, &start,&stop, &getByte, &putByte, null);
  6e:	8e 01       	movw	r16, r28
  70:	0a 5f       	subi	r16, 0xFA	; 250
  72:	1f 4f       	sbci	r17, 0xFF	; 255
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
	for(i=7; i>=0; i--){
		b <<= 1;
  74:	ff 0c       	add	r15, r15
		scl_high(i2c);
  76:	c8 01       	movw	r24, r16
  78:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
  7c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		if(pin_is_high(i2c->sda)){
  80:	88 85       	ldd	r24, Y+8	; 0x08
  82:	99 85       	ldd	r25, Y+9	; 0x09
  84:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  88:	88 23       	and	r24, r24
  8a:	01 f0       	breq	.+0      	; 0x8c <getByte+0x3e>
			b |= 1;
  8c:	81 e0       	ldi	r24, 0x01	; 1
  8e:	f8 2a       	or	r15, r24
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
  90:	60 e0       	ldi	r22, 0x00	; 0
  92:	8e 81       	ldd	r24, Y+6	; 0x06
  94:	9f 81       	ldd	r25, Y+7	; 0x07
  96:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		if(pin_is_high(i2c->sda)){
			b |= 1;
		}
		scl_low(i2c);
		halfDelay();
  9a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  9e:	ea 94       	dec	r14
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
	for(i=7; i>=0; i--){
  a0:	01 f4       	brne	.+0      	; 0xa2 <getByte+0x54>
  a2:	8e 01       	movw	r16, r28
  a4:	0a 5f       	subi	r16, 0xFA	; 250
  a6:	1f 4f       	sbci	r17, 0xFF	; 255
  a8:	88 85       	ldd	r24, Y+8	; 0x08
  aa:	99 85       	ldd	r25, Y+9	; 0x09
		scl_low(i2c);
		halfDelay();
	}

	// Put the ACK
	if(isLastByte){
  ac:	dd 20       	and	r13, r13
  ae:	01 f0       	breq	.+0      	; 0xb0 <getByte+0x62>
		sda_high(i2c);
  b0:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <getByte+0x68>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
  b6:	60 e0       	ldi	r22, 0x00	; 0
  b8:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	if(isLastByte){
		sda_high(i2c);
	}else{
		sda_low(i2c);
	}
	scl_high(i2c);
  bc:	c8 01       	movw	r24, r16
  be:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay(i2c);
  c2:	ce 01       	movw	r24, r28
  c4:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
  c8:	60 e0       	ldi	r22, 0x00	; 0
  ca:	8e 81       	ldd	r24, Y+6	; 0x06
  cc:	9f 81       	ldd	r25, Y+7	; 0x07
  ce:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		sda_low(i2c);
	}
	scl_high(i2c);
	halfDelay(i2c);
	scl_low(i2c);
	sda_high(i2c);
  d2:	88 85       	ldd	r24, Y+8	; 0x08
  d4:	99 85       	ldd	r25, Y+9	; 0x09
  d6:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

	return b;						// return received byte
}
  da:	8f 2d       	mov	r24, r15
  dc:	df 91       	pop	r29
  de:	cf 91       	pop	r28
  e0:	1f 91       	pop	r17
  e2:	0f 91       	pop	r16
  e4:	ff 90       	pop	r15
  e6:	ef 90       	pop	r14
  e8:	df 90       	pop	r13
  ea:	08 95       	ret

000000ec <putByte>:
	return rtn;
}

// Put a byte across the wire
// Return true if the slave acknowledges
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
  ec:	ef 92       	push	r14
  ee:	ff 92       	push	r15
  f0:	0f 93       	push	r16
  f2:	1f 93       	push	r17
  f4:	cf 93       	push	r28
  f6:	df 93       	push	r29
  f8:	ec 01       	movw	r28, r24
  fa:	e6 2e       	mov	r14, r22
  fc:	98 e0       	ldi	r25, 0x08	; 8
  fe:	f9 2e       	mov	r15, r25
}



// Expose this implementation to the linker
const I2C_CLASS c_sw_i2c = MAKE_I2C_CLASS(&init, &start,&stop, &getByte, &putByte, null);
 100:	8e 01       	movw	r16, r28
 102:	0a 5f       	subi	r16, 0xFA	; 250
 104:	1f 4f       	sbci	r17, 0xFF	; 255
 106:	88 85       	ldd	r24, Y+8	; 0x08
 108:	99 85       	ldd	r25, Y+9	; 0x09
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;

	for(i=7; i>=0; i--){
		if( b & 0x80 ){
 10a:	e7 fe       	sbrs	r14, 7
 10c:	00 c0       	rjmp	.+0      	; 0x10e <putByte+0x22>
			sda_high(i2c);
 10e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 112:	00 c0       	rjmp	.+0      	; 0x114 <putByte+0x28>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 114:	60 e0       	ldi	r22, 0x00	; 0
 116:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		if( b & 0x80 ){
			sda_high(i2c);
		}else{
			sda_low(i2c);
		}
		scl_high(i2c);
 11a:	c8 01       	movw	r24, r16
 11c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		b <<= 1;
 120:	ee 0c       	add	r14, r14
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 122:	60 e0       	ldi	r22, 0x00	; 0
 124:	8e 81       	ldd	r24, Y+6	; 0x06
 126:	9f 81       	ldd	r25, Y+7	; 0x07
 128:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 12c:	fa 94       	dec	r15
// Return true if the slave acknowledges
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;

	for(i=7; i>=0; i--){
 12e:	01 f4       	brne	.+0      	; 0x130 <putByte+0x44>
}


// Return true if the slave acknowledges
static boolean getAck(const I2C_SOFTWARE_BUS* i2c){
	sda_high(i2c);	// allow slave to drive sda
 130:	88 85       	ldd	r24, Y+8	; 0x08
 132:	99 85       	ldd	r25, Y+9	; 0x09
 134:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
 138:	c8 01       	movw	r24, r16
 13a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
 13e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	boolean rtn = pin_is_low(i2c->sda);
 142:	88 85       	ldd	r24, Y+8	; 0x08
 144:	99 85       	ldd	r25, Y+9	; 0x09
 146:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 14a:	18 2f       	mov	r17, r24
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 14c:	60 e0       	ldi	r22, 0x00	; 0
 14e:	8e 81       	ldd	r24, Y+6	; 0x06
 150:	9f 81       	ldd	r25, Y+7	; 0x07
 152:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
// Return true if the slave acknowledges
static boolean getAck(const I2C_SOFTWARE_BUS* i2c){
	sda_high(i2c);	// allow slave to drive sda
	scl_high(i2c);
	halfDelay();
	boolean rtn = pin_is_low(i2c->sda);
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	11 11       	cpse	r17, r1
 15a:	80 e0       	ldi	r24, 0x00	; 0
		scl_high(i2c);
		b <<= 1;
		scl_low(i2c);
	}
	return getAck(i2c);						// return ACK value
}
 15c:	df 91       	pop	r29
 15e:	cf 91       	pop	r28
 160:	1f 91       	pop	r17
 162:	0f 91       	pop	r16
 164:	ff 90       	pop	r15
 166:	ef 90       	pop	r14
 168:	08 95       	ret

0000016a <stop>:

	return b;						// return received byte
}

// Send the stop
static void stop(const I2C_ABSTRACT_BUS* bus){
 16a:	cf 93       	push	r28
 16c:	df 93       	push	r29
 16e:	ec 01       	movw	r28, r24
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 170:	60 e0       	ldi	r22, 0x00	; 0
 172:	88 85       	ldd	r24, Y+8	; 0x08
 174:	99 85       	ldd	r25, Y+9	; 0x09
 176:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

// Send the stop
static void stop(const I2C_ABSTRACT_BUS* bus){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	sda_low(i2c);
	halfDelay();
 17a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
 17e:	ce 01       	movw	r24, r28
 180:	06 96       	adiw	r24, 0x06	; 6
 182:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
 186:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	sda_high(i2c);
 18a:	88 85       	ldd	r24, Y+8	; 0x08
 18c:	99 85       	ldd	r25, Y+9	; 0x09
 18e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
}
 192:	df 91       	pop	r29
 194:	cf 91       	pop	r28
	sda_low(i2c);
	halfDelay();
	scl_high(i2c);
	halfDelay();
	sda_high(i2c);
	halfDelay();
 196:	0c 94 00 00 	jmp	0	; 0x0 <halfDelay>

0000019a <start>:
	return getAck(i2c);						// return ACK value
}

// Send the start and address
// return TRUE if acknowledged
static boolean start(const I2C_DEVICE* device, boolean writeMode){
 19a:	ff 92       	push	r15
 19c:	0f 93       	push	r16
 19e:	1f 93       	push	r17
 1a0:	cf 93       	push	r28
 1a2:	df 93       	push	r29
 1a4:	8c 01       	movw	r16, r24
 1a6:	f6 2e       	mov	r15, r22
	boolean rtn = FALSE;

	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)(device->bus);
 1a8:	fc 01       	movw	r30, r24
 1aa:	c0 81       	ld	r28, Z
 1ac:	d1 81       	ldd	r29, Z+1	; 0x01
	if(i2c){
 1ae:	20 97       	sbiw	r28, 0x00	; 0
 1b0:	01 f0       	breq	.+0      	; 0x1b2 <start+0x18>
		sda_high(i2c);
 1b2:	88 85       	ldd	r24, Y+8	; 0x08
 1b4:	99 85       	ldd	r25, Y+9	; 0x09
 1b6:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
 1ba:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		scl_high(i2c);
 1be:	ce 01       	movw	r24, r28
 1c0:	06 96       	adiw	r24, 0x06	; 6
 1c2:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
 1c6:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 1ca:	60 e0       	ldi	r22, 0x00	; 0
 1cc:	88 85       	ldd	r24, Y+8	; 0x08
 1ce:	99 85       	ldd	r25, Y+9	; 0x09
 1d0:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
		scl_high(i2c);
		halfDelay();

		sda_low(i2c);
		halfDelay();
 1d4:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 1d8:	60 e0       	ldi	r22, 0x00	; 0
 1da:	8e 81       	ldd	r24, Y+6	; 0x06
 1dc:	9f 81       	ldd	r25, Y+7	; 0x07
 1de:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();

		sda_low(i2c);
		halfDelay();
		scl_low(i2c);
		halfDelay();
 1e2:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		// Send the device addr and direction
		uint8_t addr = device->addr & 0xfe;
 1e6:	f8 01       	movw	r30, r16
 1e8:	62 81       	ldd	r22, Z+2	; 0x02
 1ea:	6e 7f       	andi	r22, 0xFE	; 254
		if(writeMode==FALSE){
 1ec:	f1 10       	cpse	r15, r1
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <start+0x56>
			addr |= 1;
 1f0:	61 60       	ori	r22, 0x01	; 1
		}
		rtn = putByte(device->bus, addr);
 1f2:	f8 01       	movw	r30, r16
 1f4:	80 81       	ld	r24, Z
 1f6:	91 81       	ldd	r25, Z+1	; 0x01
	}
	return rtn;
}
 1f8:	df 91       	pop	r29
 1fa:	cf 91       	pop	r28
 1fc:	1f 91       	pop	r17
 1fe:	0f 91       	pop	r16
 200:	ff 90       	pop	r15
		// Send the device addr and direction
		uint8_t addr = device->addr & 0xfe;
		if(writeMode==FALSE){
			addr |= 1;
		}
		rtn = putByte(device->bus, addr);
 202:	0c 94 00 00 	jmp	0	; 0x0 <halfDelay>
	}
	return rtn;
}
 206:	80 e0       	ldi	r24, 0x00	; 0
 208:	df 91       	pop	r29
 20a:	cf 91       	pop	r28
 20c:	1f 91       	pop	r17
 20e:	0f 91       	pop	r16
 210:	ff 90       	pop	r15
 212:	08 95       	ret

i2c_slave.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000009e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  0000009e  2**0
                  ALLOC
  3 .debug_info   00000319  00000000  00000000  0000009e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000165  00000000  00000000  000003b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000061  00000000  00000000  0000051c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000057d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000121  00000000  00000000  0000059d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000255  00000000  00000000  000006be  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000913  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000044  00000000  00000000  00000940  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <i2cSlaveSetReceiveHandler>:
static cBuffer* txBuffer;
static void (*i2cSlaveReceive)(cBuffer* data);
static void (*i2cSlaveTransmit)(cBuffer* data);

void i2cSlaveSetReceiveHandler(void (*i2cSlaveRx_func)(cBuffer* data)){
	CRITICAL_SECTION{
   0:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
   2:	f8 94       	cli
		i2cSlaveReceive = i2cSlaveRx_func;
   4:	90 93 00 00 	sts	0x0000, r25
   8:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
   c:	2f bf       	out	0x3f, r18	; 63
   e:	08 95       	ret

00000010 <i2cSlaveSetTransmitHandler>:
	}
}
void i2cSlaveSetTransmitHandler(void (*i2cSlaveTx_func)(cBuffer* data)){
	CRITICAL_SECTION{
  10:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  12:	f8 94       	cli
		i2cSlaveTransmit = i2cSlaveTx_func;
  14:	90 93 00 00 	sts	0x0000, r25
  18:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  1c:	2f bf       	out	0x3f, r18	; 63
  1e:	08 95       	ret

00000020 <i2cSlaveInit>:
	}
}

void i2cSlaveInit(uint8_t deviceAddr, boolean generalCall, cBuffer* rx, cBuffer* tx){
	// Make the 2 wires into inputs
	cbi(SCL_DDR,SCL_PIN);
  20:	50 98       	cbi	0x0a, 0	; 10
	cbi(SDA_DDR,SDA_PIN);
  22:	51 98       	cbi	0x0a, 1	; 10

	// Save the buffer addresses
	rxBuffer = rx;
  24:	50 93 00 00 	sts	0x0000, r21
  28:	40 93 00 00 	sts	0x0000, r20
	txBuffer = tx;
  2c:	30 93 00 00 	sts	0x0000, r19
  30:	20 93 00 00 	sts	0x0000, r18
	// set i2c bit rate to 100KHz
	// not for slaves as their bit rate is set by the master
//	i2cMasterSetBitrate(100);

	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
  34:	90 91 bc 00 	lds	r25, 0x00BC
  38:	94 60       	ori	r25, 0x04	; 4
  3a:	90 93 bc 00 	sts	0x00BC, r25

	// set state
	i2cState = I2C_IDLE;
  3e:	10 92 00 00 	sts	0x0000, r1

	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
  42:	90 91 bc 00 	lds	r25, 0x00BC
  46:	91 60       	ori	r25, 0x01	; 1
  48:	90 93 bc 00 	sts	0x00BC, r25
	sbi(TWCR, TWEA);
  4c:	90 91 bc 00 	lds	r25, 0x00BC
  50:	90 64       	ori	r25, 0x40	; 64
  52:	90 93 bc 00 	sts	0x00BC, r25

	// Set the device address
	outb(TWAR, ((deviceAddr&0xFE) | (generalCall?1:0)) );
  56:	91 e0       	ldi	r25, 0x01	; 1
  58:	61 11       	cpse	r22, r1
  5a:	00 c0       	rjmp	.+0      	; 0x5c <i2cSlaveInit+0x3c>
  5c:	90 e0       	ldi	r25, 0x00	; 0
  5e:	8e 7f       	andi	r24, 0xFE	; 254
  60:	89 2b       	or	r24, r25
  62:	80 93 ba 00 	sts	0x00BA, r24

	// enable interrupts
	sei();
  66:	78 94       	sei
  68:	08 95       	ret

iopin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001c0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001f4  2**0
                  ALLOC
  3 .debug_info   0000096b  00000000  00000000  000001f4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000018d  00000000  00000000  00000b5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000006f2  00000000  00000000  00000cec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000013de  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f3  00000000  00000000  000013fe  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000001ac  00000000  00000000  000014f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  0000169d  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000094  00000000  00000000  000016c8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_high>:

	Set a port pin to high

******************************************************/
void pin_high(const IOPin* io){
	if(io){
   0:	00 97       	sbiw	r24, 0x00	; 0
   2:	01 f0       	breq	.+0      	; 0x4 <pin_high+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
   4:	fc 01       	movw	r30, r24
   6:	45 91       	lpm	r20, Z+
   8:	54 91       	lpm	r21, Z
   a:	9a 01       	movw	r18, r20
		PORT port = pgm_read_word(&portDef->port);
   c:	fa 01       	movw	r30, r20
   e:	45 91       	lpm	r20, Z+
  10:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  12:	2e 5f       	subi	r18, 0xFE	; 254
  14:	3f 4f       	sbci	r19, 0xFF	; 255
  16:	f9 01       	movw	r30, r18
  18:	25 91       	lpm	r18, Z+
  1a:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
  1c:	fc 01       	movw	r30, r24
  1e:	32 96       	adiw	r30, 0x02	; 2
  20:	84 91       	lpm	r24, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  22:	d9 01       	movw	r26, r18
  24:	9c 91       	ld	r25, X
  26:	98 23       	and	r25, r24
  28:	01 f0       	breq	.+0      	; 0x2a <pin_high+0x2a>
			CRITICAL_SECTION_START;
  2a:	2f b7       	in	r18, 0x3f	; 63
  2c:	f8 94       	cli
			// set the bit
			_SFR_MEM8(port) |= mask;
  2e:	da 01       	movw	r26, r20
  30:	9c 91       	ld	r25, X
  32:	98 2b       	or	r25, r24
  34:	9c 93       	st	X, r25
			CRITICAL_SECTION_END;
  36:	2f bf       	out	0x3f, r18	; 63
			// Allow any output to be reflected on the input pin
			nop();
  38:	00 00       	nop
  3a:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  3c:	87 ef       	ldi	r24, 0xF7	; 247
  3e:	0c 94 00 00 	jmp	0	; 0x0 <pin_high>
  42:	08 95       	ret

00000044 <pin_low>:

	Set a port pin to low

******************************************************/
void pin_low(const IOPin* io){
	if(io){
  44:	00 97       	sbiw	r24, 0x00	; 0
  46:	01 f0       	breq	.+0      	; 0x48 <pin_low+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  48:	fc 01       	movw	r30, r24
  4a:	45 91       	lpm	r20, Z+
  4c:	54 91       	lpm	r21, Z
  4e:	9a 01       	movw	r18, r20
		PORT port = pgm_read_word(&portDef->port);
  50:	fa 01       	movw	r30, r20
  52:	45 91       	lpm	r20, Z+
  54:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  56:	2e 5f       	subi	r18, 0xFE	; 254
  58:	3f 4f       	sbci	r19, 0xFF	; 255
  5a:	f9 01       	movw	r30, r18
  5c:	25 91       	lpm	r18, Z+
  5e:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
  60:	fc 01       	movw	r30, r24
  62:	32 96       	adiw	r30, 0x02	; 2
  64:	84 91       	lpm	r24, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  66:	d9 01       	movw	r26, r18
  68:	9c 91       	ld	r25, X
  6a:	98 23       	and	r25, r24
  6c:	01 f0       	breq	.+0      	; 0x6e <pin_low+0x2a>
			CRITICAL_SECTION_START;
  6e:	2f b7       	in	r18, 0x3f	; 63
  70:	f8 94       	cli
			// clear the bit
			_SFR_MEM8(port) &= ~mask;
  72:	da 01       	movw	r26, r20
  74:	9c 91       	ld	r25, X
  76:	80 95       	com	r24
  78:	98 23       	and	r25, r24
  7a:	9c 93       	st	X, r25
			CRITICAL_SECTION_END;
  7c:	2f bf       	out	0x3f, r18	; 63
			// Allow any output to be reflected on the input pin
			nop();
  7e:	00 00       	nop
  80:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  82:	87 ef       	ldi	r24, 0xF7	; 247
  84:	0c 94 00 00 	jmp	0	; 0x0 <pin_high>
  88:	08 95       	ret

0000008a <pin_toggle>:
	eg
	pin_toggle(B2); // Toggle PortB pin 2

******************************************************/
void pin_toggle(const IOPin* io) {
	if(io){
  8a:	00 97       	sbiw	r24, 0x00	; 0
  8c:	01 f0       	breq	.+0      	; 0x8e <pin_toggle+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  8e:	fc 01       	movw	r30, r24
  90:	45 91       	lpm	r20, Z+
  92:	54 91       	lpm	r21, Z
  94:	9a 01       	movw	r18, r20
		PORT port = pgm_read_word(&portDef->port);
  96:	fa 01       	movw	r30, r20
  98:	45 91       	lpm	r20, Z+
  9a:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  9c:	2e 5f       	subi	r18, 0xFE	; 254
  9e:	3f 4f       	sbci	r19, 0xFF	; 255
  a0:	f9 01       	movw	r30, r18
  a2:	25 91       	lpm	r18, Z+
  a4:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
  a6:	fc 01       	movw	r30, r24
  a8:	32 96       	adiw	r30, 0x02	; 2
  aa:	84 91       	lpm	r24, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  ac:	d9 01       	movw	r26, r18
  ae:	9c 91       	ld	r25, X
  b0:	98 23       	and	r25, r24
  b2:	01 f0       	breq	.+0      	; 0xb4 <pin_toggle+0x2a>
			CRITICAL_SECTION_START;
  b4:	2f b7       	in	r18, 0x3f	; 63
  b6:	f8 94       	cli
			// toggle the bit
			_SFR_MEM8(port) ^= mask;
  b8:	da 01       	movw	r26, r20
  ba:	9c 91       	ld	r25, X
  bc:	98 27       	eor	r25, r24
  be:	9c 93       	st	X, r25
			CRITICAL_SECTION_END;
  c0:	2f bf       	out	0x3f, r18	; 63
			// Allow any output to be reflected on the input pin
			nop();
  c2:	00 00       	nop
  c4:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  c6:	87 ef       	ldi	r24, 0xF7	; 247
  c8:	0c 94 00 00 	jmp	0	; 0x0 <pin_high>
  cc:	08 95       	ret

000000ce <pin_is_high>:
	Read the value of an I/O pin and
	return TRUE if it is high or FALSE if low

******************************************************/
boolean pin_is_high(const IOPin* io){
	if(io){
  ce:	00 97       	sbiw	r24, 0x00	; 0
  d0:	01 f0       	breq	.+0      	; 0xd2 <pin_is_high+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  d2:	fc 01       	movw	r30, r24
  d4:	25 91       	lpm	r18, Z+
  d6:	34 91       	lpm	r19, Z
		PORT pin = pgm_read_word(&portDef->pin);
  d8:	2c 5f       	subi	r18, 0xFC	; 252
  da:	3f 4f       	sbci	r19, 0xFF	; 255
  dc:	f9 01       	movw	r30, r18
  de:	25 91       	lpm	r18, Z+
  e0:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
  e2:	fc 01       	movw	r30, r24
  e4:	32 96       	adiw	r30, 0x02	; 2
  e6:	84 91       	lpm	r24, Z

		return  (_SFR_MEM8(pin) & mask) ? TRUE : FALSE;
  e8:	d9 01       	movw	r26, r18
  ea:	9c 91       	ld	r25, X
  ec:	98 23       	and	r25, r24
  ee:	01 f0       	breq	.+0      	; 0xf0 <pin_is_high+0x22>
  f0:	8f ef       	ldi	r24, 0xFF	; 255
  f2:	08 95       	ret
  f4:	80 e0       	ldi	r24, 0x00	; 0
	}
	return FALSE;
}
  f6:	08 95       	ret

000000f8 <pin_set>:
	Set an output pin high or low
	eg
	pin_set(B2, TRUE); // To set PortB pin 2 high
******************************************************/
void pin_set(const IOPin* io, boolean val){
	if(val){
  f8:	61 11       	cpse	r22, r1
		pin_high(io);
  fa:	0c 94 00 00 	jmp	0	; 0x0 <pin_high>
	}else{
		pin_low(io);
  fe:	0c 94 00 00 	jmp	0	; 0x0 <pin_high>

00000102 <pin_make_input>:
	a pullup resistor (TRUE/FALSE)

	ie pin_make_input(B2, TRUE); // to  make B2 an input with pullup
******************************************************/
void pin_make_input(const IOPin* io, boolean pullup){
	if(io){
 102:	00 97       	sbiw	r24, 0x00	; 0
 104:	01 f0       	breq	.+0      	; 0x106 <pin_make_input+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 106:	fc 01       	movw	r30, r24
 108:	45 91       	lpm	r20, Z+
 10a:	54 91       	lpm	r21, Z
 10c:	9a 01       	movw	r18, r20
		PORT ddr = pgm_read_word(&portDef->ddr);
 10e:	fa 01       	movw	r30, r20
 110:	32 96       	adiw	r30, 0x02	; 2
 112:	45 91       	lpm	r20, Z+
 114:	54 91       	lpm	r21, Z
		PORT port = pgm_read_word(&portDef->port);
 116:	f9 01       	movw	r30, r18
 118:	25 91       	lpm	r18, Z+
 11a:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
 11c:	fc 01       	movw	r30, r24
 11e:	32 96       	adiw	r30, 0x02	; 2
 120:	84 91       	lpm	r24, Z

		CRITICAL_SECTION_START;
 122:	7f b7       	in	r23, 0x3f	; 63
 124:	f8 94       	cli
			// Clear pin in DDR
			_SFR_MEM8(ddr) &= ~ mask;	// make an input pin
 126:	da 01       	movw	r26, r20
 128:	9c 91       	ld	r25, X
 12a:	48 2f       	mov	r20, r24
 12c:	40 95       	com	r20
 12e:	94 23       	and	r25, r20
 130:	9c 93       	st	X, r25

			if(pullup){
 132:	66 23       	and	r22, r22
 134:	01 f0       	breq	.+0      	; 0x136 <pin_make_input+0x34>
				_SFR_MEM8(port) |= mask; // turn on pullup if needed
 136:	d9 01       	movw	r26, r18
 138:	9c 91       	ld	r25, X
 13a:	98 2b       	or	r25, r24
 13c:	9c 93       	st	X, r25
 13e:	00 c0       	rjmp	.+0      	; 0x140 <pin_make_input+0x3e>
			}else{
				_SFR_MEM8(port) &= ~ mask;	 // turn off pullup
 140:	f9 01       	movw	r30, r18
 142:	80 81       	ld	r24, Z
 144:	84 23       	and	r24, r20
 146:	80 83       	st	Z, r24
			}
		CRITICAL_SECTION_END;
 148:	7f bf       	out	0x3f, r23	; 63
 14a:	08 95       	ret

0000014c <pin_make_output>:

	Set the pin as an output pin

******************************************************/
void pin_make_output(const IOPin* io, boolean val){
	if(io){
 14c:	00 97       	sbiw	r24, 0x00	; 0
 14e:	01 f0       	breq	.+0      	; 0x150 <pin_make_output+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 150:	fc 01       	movw	r30, r24
 152:	45 91       	lpm	r20, Z+
 154:	54 91       	lpm	r21, Z
 156:	9a 01       	movw	r18, r20
		PORT ddr = pgm_read_word(&portDef->ddr);
 158:	fa 01       	movw	r30, r20
 15a:	32 96       	adiw	r30, 0x02	; 2
 15c:	45 91       	lpm	r20, Z+
 15e:	54 91       	lpm	r21, Z
 160:	74 2f       	mov	r23, r20
 162:	45 2f       	mov	r20, r21
		PORT port = pgm_read_word(&portDef->port);
 164:	f9 01       	movw	r30, r18
 166:	25 91       	lpm	r18, Z+
 168:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
 16a:	fc 01       	movw	r30, r24
 16c:	32 96       	adiw	r30, 0x02	; 2
 16e:	84 91       	lpm	r24, Z

		CRITICAL_SECTION_START;
 170:	5f b7       	in	r21, 0x3f	; 63
 172:	f8 94       	cli
			if(val){
				_SFR_MEM8(port) |= mask;
 174:	d9 01       	movw	r26, r18
 176:	9c 91       	ld	r25, X
		PORT ddr = pgm_read_word(&portDef->ddr);
		PORT port = pgm_read_word(&portDef->port);
		PIN mask = pgm_read_byte(&io->pin);

		CRITICAL_SECTION_START;
			if(val){
 178:	66 23       	and	r22, r22
 17a:	01 f0       	breq	.+0      	; 0x17c <pin_make_output+0x30>
				_SFR_MEM8(port) |= mask;
 17c:	98 2b       	or	r25, r24
 17e:	00 c0       	rjmp	.+0      	; 0x180 <pin_make_output+0x34>
			}else{
				_SFR_MEM8(port) &= ~ mask;
 180:	28 2f       	mov	r18, r24
 182:	20 95       	com	r18
 184:	92 23       	and	r25, r18
 186:	9c 93       	st	X, r25
			}
			_SFR_MEM8(ddr) |= mask;	// make an output pin
 188:	a7 2f       	mov	r26, r23
 18a:	b4 2f       	mov	r27, r20
 18c:	9c 91       	ld	r25, X
 18e:	98 2b       	or	r25, r24
 190:	9c 93       	st	X, r25
		CRITICAL_SECTION_END;
 192:	5f bf       	out	0x3f, r21	; 63
 194:	08 95       	ret

00000196 <pin_is_output>:


******************************************************/

boolean pin_is_output(const IOPin* io){
	if(io){
 196:	00 97       	sbiw	r24, 0x00	; 0
 198:	01 f0       	breq	.+0      	; 0x19a <pin_is_output+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 19a:	fc 01       	movw	r30, r24
 19c:	25 91       	lpm	r18, Z+
 19e:	34 91       	lpm	r19, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
 1a0:	2e 5f       	subi	r18, 0xFE	; 254
 1a2:	3f 4f       	sbci	r19, 0xFF	; 255
 1a4:	f9 01       	movw	r30, r18
 1a6:	25 91       	lpm	r18, Z+
 1a8:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
 1aa:	fc 01       	movw	r30, r24
 1ac:	32 96       	adiw	r30, 0x02	; 2
 1ae:	84 91       	lpm	r24, Z

		return (_SFR_MEM8(ddr) & mask) ? TRUE : FALSE;
 1b0:	d9 01       	movw	r26, r18
 1b2:	9c 91       	ld	r25, X
 1b4:	98 23       	and	r25, r24
 1b6:	01 f0       	breq	.+0      	; 0x1b8 <pin_is_output+0x22>
 1b8:	8f ef       	ldi	r24, 0xFF	; 255
 1ba:	08 95       	ret
 1bc:	80 e0       	ldi	r24, 0x00	; 0
	}
	return FALSE;
}
 1be:	08 95       	ret

iopin_pulseIn.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000062  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000096  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000096  2**0
                  ALLOC
  3 .debug_info   000004fb  00000000  00000000  00000096  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001ae  00000000  00000000  00000591  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000152  00000000  00000000  0000073f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000891  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000c2  00000000  00000000  000008b1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000301  00000000  00000000  00000973  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000c74  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000048  00000000  00000000  00000ca0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_pulseIn>:
 *      Author: Clive Webster
 */
#include "iopin.h"
#include "timer.h"

TICK_COUNT pin_pulseIn(const IOPin* pin, boolean activeHigh){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	8c 01       	movw	r16, r24
  10:	c6 2f       	mov	r28, r22
	TICK_COUNT start;
	TICK_COUNT end;
	TICK_COUNT duration;

	pin_make_input(pin,FALSE);				// Switch pin to INPUT with no pull up
  12:	60 e0       	ldi	r22, 0x00	; 0
  14:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
	while(pin_get(pin)==activeHigh);		// Loop until the the pin goes inactive
  18:	c8 01       	movw	r24, r16
  1a:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  1e:	8c 17       	cp	r24, r28
  20:	01 f0       	breq	.+0      	; 0x22 <pin_pulseIn+0x22>
	while(pin_get(pin)!=activeHigh);		// Loop until the the pin goes active
  22:	c8 01       	movw	r24, r16
  24:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  28:	8c 13       	cpse	r24, r28
  2a:	00 c0       	rjmp	.+0      	; 0x2c <pin_pulseIn+0x2c>
	start = clockGetus();					// Get the start time
  2c:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  30:	6b 01       	movw	r12, r22
  32:	7c 01       	movw	r14, r24
	while(pin_get(pin)==activeHigh);		// Loop until the the pin goes inactive
  34:	c8 01       	movw	r24, r16
  36:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  3a:	8c 17       	cp	r24, r28
  3c:	01 f0       	breq	.+0      	; 0x3e <pin_pulseIn+0x3e>
	end = clockGetus();						// Get the end time
  3e:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  42:	8b 01       	movw	r16, r22
  44:	9c 01       	movw	r18, r24

	duration = end - start;					// Get the duration in uS
  46:	0c 19       	sub	r16, r12
  48:	1d 09       	sbc	r17, r13
  4a:	2e 09       	sbc	r18, r14
  4c:	3f 09       	sbc	r19, r15
	return duration;
}
  4e:	b8 01       	movw	r22, r16
  50:	c9 01       	movw	r24, r18
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	0f 91       	pop	r16
  58:	ff 90       	pop	r15
  5a:	ef 90       	pop	r14
  5c:	df 90       	pop	r13
  5e:	cf 90       	pop	r12
  60:	08 95       	ret

iopin_pulseOut.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000004e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000082  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000082  2**0
                  ALLOC
  3 .debug_info   000004e0  00000000  00000000  00000082  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000017a  00000000  00000000  00000562  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000010c  00000000  00000000  000006dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000007e8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000d9  00000000  00000000  00000808  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000002f2  00000000  00000000  000008e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000bd3  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000044  00000000  00000000  00000c00  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_pulseOut>:
 *      Author: Clive Webster
 */
#include "iopin.h"
#include "timer.h"

void pin_pulseOut(const IOPin* pin, TICK_COUNT us, boolean activeHigh){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	6a 01       	movw	r12, r20
  10:	7b 01       	movw	r14, r22
	pin_make_output(pin,(activeHigh)
  12:	22 23       	and	r18, r18
  14:	01 f0       	breq	.+0      	; 0x16 <pin_pulseOut+0x16>
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	00 c0       	rjmp	.+0      	; 0x1a <pin_pulseOut+0x1a>
  1a:	6f ef       	ldi	r22, 0xFF	; 255
  1c:	ce 01       	movw	r24, r28
  1e:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
			? FALSE : TRUE);				// Make it an output pin with the inactive state
	delay_us(2);							// wait a bit
  22:	62 e0       	ldi	r22, 0x02	; 2
  24:	70 e0       	ldi	r23, 0x00	; 0
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	90 e0       	ldi	r25, 0x00	; 0
  2a:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	pin_toggle(pin);						// Bring pin to active state
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	delay_us(us);       					// Wait for duration
  34:	c7 01       	movw	r24, r14
  36:	b6 01       	movw	r22, r12
  38:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	pin_toggle(pin);						// Bring pin to inactive state
  3c:	ce 01       	movw	r24, r28
}
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	ff 90       	pop	r15
  44:	ef 90       	pop	r14
  46:	df 90       	pop	r13
  48:	cf 90       	pop	r12
	pin_make_output(pin,(activeHigh)
			? FALSE : TRUE);				// Make it an output pin with the inactive state
	delay_us(2);							// wait a bit
	pin_toggle(pin);						// Bring pin to active state
	delay_us(us);       					// Wait for duration
	pin_toggle(pin);						// Bring pin to inactive state
  4a:	0c 94 00 00 	jmp	0	; 0x0 <pin_pulseOut>

led.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000004c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000080  2**0
                  ALLOC
  3 .debug_info   00000226  00000000  00000000  00000080  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000015c  00000000  00000000  000002a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000cf  00000000  00000000  00000402  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000004d1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000a7  00000000  00000000  000004f1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000015a  00000000  00000000  00000598  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000006f2  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000034  00000000  00000000  0000071c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <LED_set>:
#include "led.h"

// Create the status LED
LED statusLED; // All empty MAKE_LED(null,FALSE);

void LED_set(LED* led,	boolean value){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	if(led->pin){
   a:	88 81       	ld	r24, Y
   c:	99 81       	ldd	r25, Y+1	; 0x01
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <LED_set+0x12>

		if(!led->activeHigh){
  12:	2a 81       	ldd	r18, Y+2	; 0x02
  14:	20 fd       	sbrc	r18, 0
  16:	00 c0       	rjmp	.+0      	; 0x18 <LED_set+0x18>
		 	value=!value;
  18:	31 e0       	ldi	r19, 0x01	; 1
  1a:	61 11       	cpse	r22, r1
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	13 2f       	mov	r17, r19
		}

		if(!led->initialised){
  20:	21 fd       	sbrc	r18, 1
  22:	00 c0       	rjmp	.+0      	; 0x24 <LED_set+0x24>
			pin_make_output(led->pin,value);
  24:	61 2f       	mov	r22, r17
  26:	0e 94 00 00 	call	0	; 0x0 <LED_set>
			led->initialised=TRUE;
  2a:	8a 81       	ldd	r24, Y+2	; 0x02
  2c:	9f ef       	ldi	r25, 0xFF	; 255
  2e:	90 fb       	bst	r25, 0
  30:	81 f9       	bld	r24, 1
  32:	8a 83       	std	Y+2, r24	; 0x02
		}
		pin_set(led->pin,value);
  34:	61 2f       	mov	r22, r17
  36:	88 81       	ld	r24, Y
  38:	99 81       	ldd	r25, Y+1	; 0x01
	}
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	1f 91       	pop	r17

		if(!led->initialised){
			pin_make_output(led->pin,value);
			led->initialised=TRUE;
		}
		pin_set(led->pin,value);
  40:	0c 94 00 00 	jmp	0	; 0x0 <LED_set>
	}
}
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	1f 91       	pop	r17
  4a:	08 95       	ret

motorPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002f4  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000328  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000328  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000328  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000d95  00000000  00000000  0000032c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002f4  00000000  00000000  000010c1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000006a3  00000000  00000000  000013b5  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001a58  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000040  00000000  00000000  00001a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000016b  00000000  00000000  00001ab8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000760  00000000  00000000  00001c23  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002383  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000d8  00000000  00000000  000023b0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
   a:	fc 01       	movw	r30, r24
   c:	84 81       	ldd	r24, Z+4	; 0x04
   e:	95 81       	ldd	r25, Z+5	; 0x05
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
static void setConnected(__ACTUATOR *actuator, boolean connected){
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  28:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

0000002c <setSpeed>:
#include "iopin.h"
#include "timer.h"
#include "core.h"

// Call back - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2c:	df 92       	push	r13
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	0f 93       	push	r16
  34:	1f 93       	push	r17
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	ec 01       	movw	r28, r24
  3c:	d6 2e       	mov	r13, r22
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  3e:	8c 81       	ldd	r24, Y+4	; 0x04
  40:	9d 81       	ldd	r25, Y+5	; 0x05
  42:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  46:	7c 01       	movw	r14, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  48:	fc 01       	movw	r30, r24
  4a:	32 96       	adiw	r30, 0x02	; 2
  4c:	84 91       	lpm	r24, Z
	const Timer* timer = compareGetTimer(channel);
  4e:	2c e2       	ldi	r18, 0x2C	; 44
  50:	82 9f       	mul	r24, r18
  52:	c0 01       	movw	r24, r0
  54:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  56:	80 50       	subi	r24, 0x00	; 0
  58:	90 40       	sbci	r25, 0x00	; 0
  5a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  5e:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  60:	1d 14       	cp	r1, r13
  62:	04 f4       	brge	.+0      	; 0x64 <setSpeed+0x38>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  64:	20 e0       	ldi	r18, 0x00	; 0
  66:	30 e0       	ldi	r19, 0x00	; 0
  68:	4f e7       	ldi	r20, 0x7F	; 127
  6a:	50 e0       	ldi	r21, 0x00	; 0
  6c:	60 e0       	ldi	r22, 0x00	; 0
  6e:	70 e0       	ldi	r23, 0x00	; 0
  70:	8d 2d       	mov	r24, r13
  72:	99 27       	eor	r25, r25
  74:	87 fd       	sbrc	r24, 7
  76:	90 95       	com	r25
  78:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  7c:	8c 01       	movw	r16, r24

		// Set direction1 high, direction2 low
		pin_make_output(motor->direction1,TRUE);
  7e:	6f ef       	ldi	r22, 0xFF	; 255
  80:	8e 81       	ldd	r24, Y+6	; 0x06
  82:	9f 81       	ldd	r25, Y+7	; 0x07
  84:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,FALSE);
  88:	60 e0       	ldi	r22, 0x00	; 0
  8a:	00 c0       	rjmp	.+0      	; 0x8c <setSpeed+0x60>
	}else if(speed < 0){
  8c:	dd 20       	and	r13, r13
  8e:	01 f0       	breq	.+0      	; 0x90 <setSpeed+0x64>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	41 e8       	ldi	r20, 0x81	; 129
  96:	5f ef       	ldi	r21, 0xFF	; 255
  98:	60 e0       	ldi	r22, 0x00	; 0
  9a:	70 e0       	ldi	r23, 0x00	; 0
  9c:	8d 2d       	mov	r24, r13
  9e:	99 27       	eor	r25, r25
  a0:	87 fd       	sbrc	r24, 7
  a2:	90 95       	com	r25
  a4:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  a8:	8c 01       	movw	r16, r24

		// Set direction1 low, direction2 high low
		pin_make_output(motor->direction1,FALSE);
  aa:	60 e0       	ldi	r22, 0x00	; 0
  ac:	8e 81       	ldd	r24, Y+6	; 0x06
  ae:	9f 81       	ldd	r25, Y+7	; 0x07
  b0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,TRUE);
  b4:	6f ef       	ldi	r22, 0xFF	; 255
  b6:	88 85       	ldd	r24, Y+8	; 0x08
  b8:	99 85       	ldd	r25, Y+9	; 0x09
  ba:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  be:	00 c0       	rjmp	.+0      	; 0xc0 <setSpeed+0x94>
	}else{
		// brake

		if(motor->direction2){
  c0:	28 85       	ldd	r18, Y+8	; 0x08
  c2:	39 85       	ldd	r19, Y+9	; 0x09
  c4:	8e 81       	ldd	r24, Y+6	; 0x06
  c6:	9f 81       	ldd	r25, Y+7	; 0x07
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  c8:	60 e0       	ldi	r22, 0x00	; 0
		pin_make_output(motor->direction1,FALSE);
		pin_make_output(motor->direction2,TRUE);
	}else{
		// brake

		if(motor->direction2){
  ca:	23 2b       	or	r18, r19
  cc:	01 f0       	breq	.+0      	; 0xce <setSpeed+0xa2>
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  ce:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2,FALSE);
  d2:	60 e0       	ldi	r22, 0x00	; 0
  d4:	88 85       	ldd	r24, Y+8	; 0x08
  d6:	99 85       	ldd	r25, Y+9	; 0x09
  d8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  dc:	00 c0       	rjmp	.+0      	; 0xde <setSpeed+0xb2>
		}else{
			// Only has one direction pin
			// Set direction1 to an input with no pullup ie disconnect
			pin_make_input(motor->direction1,FALSE);
  de:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
	const Timer* timer = compareGetTimer(channel);
	uint16_t top = timerGetTOP(timer);

	// New compare threshold
	uint16_t delay=0;
  e2:	00 e0       	ldi	r16, 0x00	; 0
  e4:	10 e0       	ldi	r17, 0x00	; 0
			pin_make_input(motor->direction1,FALSE);
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  e6:	b8 01       	movw	r22, r16
  e8:	c7 01       	movw	r24, r14
}
  ea:	df 91       	pop	r29
  ec:	cf 91       	pop	r28
  ee:	1f 91       	pop	r17
  f0:	0f 91       	pop	r16
  f2:	ff 90       	pop	r15
  f4:	ef 90       	pop	r14
  f6:	df 90       	pop	r13
			pin_make_input(motor->direction1,FALSE);
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  f8:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

000000fc <motorPWMInit>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
  fc:	2f 92       	push	r2
  fe:	3f 92       	push	r3
 100:	4f 92       	push	r4
 102:	5f 92       	push	r5
 104:	6f 92       	push	r6
 106:	7f 92       	push	r7
 108:	8f 92       	push	r8
 10a:	9f 92       	push	r9
 10c:	af 92       	push	r10
 10e:	bf 92       	push	r11
 110:	cf 92       	push	r12
 112:	df 92       	push	r13
 114:	ef 92       	push	r14
 116:	ff 92       	push	r15
 118:	0f 93       	push	r16
 11a:	1f 93       	push	r17
 11c:	cf 93       	push	r28
 11e:	df 93       	push	r29
 120:	cd b7       	in	r28, 0x3d	; 61
 122:	de b7       	in	r29, 0x3e	; 62
 124:	2d 97       	sbiw	r28, 0x0d	; 13
 126:	0f b6       	in	r0, 0x3f	; 63
 128:	f8 94       	cli
 12a:	de bf       	out	0x3e, r29	; 62
 12c:	0f be       	out	0x3f, r0	; 63
 12e:	cd bf       	out	0x3d, r28	; 61
 130:	4c 01       	movw	r8, r24
	uint32_t deciHertz = freq * 10;
 132:	aa e0       	ldi	r26, 0x0A	; 10
 134:	b0 e0       	ldi	r27, 0x00	; 0
 136:	9a 01       	movw	r18, r20
 138:	ab 01       	movw	r20, r22
 13a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 13e:	6e 83       	std	Y+6, r22	; 0x06
 140:	7f 83       	std	Y+7, r23	; 0x07
 142:	88 87       	std	Y+8, r24	; 0x08
 144:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 146:	d4 01       	movw	r26, r8
 148:	12 96       	adiw	r26, 0x02	; 2
 14a:	8c 91       	ld	r24, X
 14c:	a1 2c       	mov	r10, r1
 14e:	b1 2c       	mov	r11, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 150:	90 e0       	ldi	r25, 0x00	; 0
 152:	fc 01       	movw	r30, r24
 154:	31 97       	sbiw	r30, 0x01	; 1
 156:	fb 87       	std	Y+11, r31	; 0x0b
 158:	ea 87       	std	Y+10, r30	; 0x0a
 15a:	9c 01       	movw	r18, r24
 15c:	21 50       	subi	r18, 0x01	; 1
 15e:	30 48       	sbci	r19, 0x80	; 128
 160:	3d 87       	std	Y+13, r19	; 0x0d
 162:	2c 87       	std	Y+12, r18	; 0x0c
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 164:	00 c0       	rjmp	.+0      	; 0x166 <motorPWMInit+0x6a>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 166:	2c 85       	ldd	r18, Y+12	; 0x0c
 168:	3d 85       	ldd	r19, Y+13	; 0x0d
 16a:	2a 19       	sub	r18, r10
 16c:	3b 09       	sbc	r19, r11
 16e:	22 0f       	add	r18, r18
 170:	33 1f       	adc	r19, r19
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		MOTOR* motor = (MOTOR*)pgm_read_word(&driver->motors[i]);
 172:	d4 01       	movw	r26, r8
 174:	ed 91       	ld	r30, X+
 176:	fc 91       	ld	r31, X
 178:	e2 0f       	add	r30, r18
 17a:	f3 1f       	adc	r31, r19
 17c:	85 91       	lpm	r24, Z+
 17e:	94 91       	lpm	r25, Z
 180:	3c 01       	movw	r6, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 182:	fc 01       	movw	r30, r24
 184:	84 81       	ldd	r24, Z+4	; 0x04
 186:	95 81       	ldd	r25, Z+5	; 0x05
 188:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 18c:	1c 01       	movw	r2, r24
		if(channel==null){
 18e:	00 97       	sbiw	r24, 0x00	; 0
 190:	01 f4       	brne	.+0      	; 0x192 <motorPWMInit+0x96>
			setError(PWM_PIN_NOT_AVAILABLE);
 192:	84 ef       	ldi	r24, 0xF4	; 244
 194:	00 c0       	rjmp	.+0      	; 0x196 <motorPWMInit+0x9a>
			continue;
		}
		if(compareIsInUse(channel)){
 196:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 19a:	88 23       	and	r24, r24
 19c:	01 f0       	breq	.+0      	; 0x19e <motorPWMInit+0xa2>
			setError(PWM_PIN_IN_USE);
 19e:	83 ef       	ldi	r24, 0xF3	; 243
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <motorPWMInit+0xa6>
 1a2:	f1 01       	movw	r30, r2
 1a4:	32 96       	adiw	r30, 0x02	; 2
 1a6:	44 90       	lpm	r4, Z

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 1a8:	fc e2       	ldi	r31, 0x2C	; 44
 1aa:	f4 9d       	mul	r31, r4
 1ac:	20 01       	movw	r4, r0
 1ae:	11 24       	eor	r1, r1
 1b0:	20 e0       	ldi	r18, 0x00	; 0
 1b2:	30 e0       	ldi	r19, 0x00	; 0
 1b4:	42 0e       	add	r4, r18
 1b6:	53 1e       	adc	r5, r19

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1b8:	cc 24       	eor	r12, r12
 1ba:	c3 94       	inc	r12
 1bc:	d1 2c       	mov	r13, r1
 1be:	cc 0e       	add	r12, r28
 1c0:	dd 1e       	adc	r13, r29
 1c2:	93 e0       	ldi	r25, 0x03	; 3
 1c4:	e9 2e       	mov	r14, r25
 1c6:	f1 2c       	mov	r15, r1
 1c8:	ec 0e       	add	r14, r28
 1ca:	fd 1e       	adc	r15, r29
 1cc:	8e 01       	movw	r16, r28
 1ce:	0b 5f       	subi	r16, 0xFB	; 251
 1d0:	1f 4f       	sbci	r17, 0xFF	; 255
 1d2:	20 e8       	ldi	r18, 0x80	; 128
 1d4:	30 e0       	ldi	r19, 0x00	; 0
 1d6:	4e 81       	ldd	r20, Y+6	; 0x06
 1d8:	5f 81       	ldd	r21, Y+7	; 0x07
 1da:	68 85       	ldd	r22, Y+8	; 0x08
 1dc:	79 85       	ldd	r23, Y+9	; 0x09
 1de:	c2 01       	movw	r24, r4
 1e0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1e4:	f2 01       	movw	r30, r4
 1e6:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 1e8:	81 11       	cpse	r24, r1
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <motorPWMInit+0xf0>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 1ec:	85 91       	lpm	r24, Z+
 1ee:	94 91       	lpm	r25, Z
 1f0:	fc 01       	movw	r30, r24
 1f2:	80 81       	ld	r24, Z
 1f4:	87 70       	andi	r24, 0x07	; 7
 1f6:	01 f4       	brne	.+0      	; 0x1f8 <motorPWMInit+0xfc>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 1f8:	83 ee       	ldi	r24, 0xE3	; 227
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <motorPWMInit+0x100>
 1fc:	82 ef       	ldi	r24, 0xF2	; 242
 1fe:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 202:	00 c0       	rjmp	.+0      	; 0x204 <motorPWMInit+0x108>
 204:	85 91       	lpm	r24, Z+
 206:	94 91       	lpm	r25, Z
 208:	fc 01       	movw	r30, r24
 20a:	80 81       	ld	r24, Z
 20c:	87 70       	andi	r24, 0x07	; 7
 20e:	01 f4       	brne	.+0      	; 0x210 <motorPWMInit+0x114>
 210:	00 c0       	rjmp	.+0      	; 0x212 <motorPWMInit+0x116>
 212:	00 c0       	rjmp	.+0      	; 0x214 <motorPWMInit+0x118>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 214:	f2 01       	movw	r30, r4
 216:	7f 96       	adiw	r30, 0x1f	; 31
 218:	85 91       	lpm	r24, Z+
 21a:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 21c:	fc 01       	movw	r30, r24
 21e:	8b 81       	ldd	r24, Y+3	; 0x03
 220:	9c 81       	ldd	r25, Y+4	; 0x04
 222:	91 83       	std	Z+1, r25	; 0x01
 224:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 226:	e0 e0       	ldi	r30, 0x00	; 0
 228:	f0 e0       	ldi	r31, 0x00	; 0
 22a:	d3 01       	movw	r26, r6
 22c:	11 96       	adiw	r26, 0x01	; 1
 22e:	fc 93       	st	X, r31
 230:	ee 93       	st	-X, r30

			// Make sure the motor pin is an output pin
			pin_make_output(motor->pwm, FALSE);
 232:	60 e0       	ldi	r22, 0x00	; 0
 234:	14 96       	adiw	r26, 0x04	; 4
 236:	8d 91       	ld	r24, X+
 238:	9c 91       	ld	r25, X
 23a:	15 97       	sbiw	r26, 0x05	; 5
 23c:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Make sure the direction pin is set as an output pin
			pin_make_output(motor->direction1, FALSE);
 240:	60 e0       	ldi	r22, 0x00	; 0
 242:	d3 01       	movw	r26, r6
 244:	16 96       	adiw	r26, 0x06	; 6
 246:	8d 91       	ld	r24, X+
 248:	9c 91       	ld	r25, X
 24a:	17 97       	sbiw	r26, 0x07	; 7
 24c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2, FALSE);
 250:	60 e0       	ldi	r22, 0x00	; 0
 252:	f3 01       	movw	r30, r6
 254:	80 85       	ldd	r24, Z+8	; 0x08
 256:	91 85       	ldd	r25, Z+9	; 0x09
 258:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 25c:	20 e0       	ldi	r18, 0x00	; 0
 25e:	30 e0       	ldi	r19, 0x00	; 0
 260:	40 e0       	ldi	r20, 0x00	; 0
 262:	50 e0       	ldi	r21, 0x00	; 0
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	70 e0       	ldi	r23, 0x00	; 0
 268:	c1 01       	movw	r24, r2
 26a:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 26e:	69 81       	ldd	r22, Y+1	; 0x01
 270:	7a 81       	ldd	r23, Y+2	; 0x02
 272:	c2 01       	movw	r24, r4
 274:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 278:	60 e0       	ldi	r22, 0x00	; 0
 27a:	c3 01       	movw	r24, r6
 27c:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 280:	6f ef       	ldi	r22, 0xFF	; 255
 282:	c3 01       	movw	r24, r6
 284:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 288:	ff ef       	ldi	r31, 0xFF	; 255
 28a:	af 1a       	sub	r10, r31
 28c:	bf 0a       	sbc	r11, r31
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 28e:	8a 85       	ldd	r24, Y+10	; 0x0a
 290:	9b 85       	ldd	r25, Y+11	; 0x0b
 292:	8a 19       	sub	r24, r10
 294:	9b 09       	sbc	r25, r11
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 296:	01 96       	adiw	r24, 0x01	; 1
 298:	01 f0       	breq	.+0      	; 0x29a <motorPWMInit+0x19e>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <motorPWMInit+0x1a0>
 29c:	00 c0       	rjmp	.+0      	; 0x29e <motorPWMInit+0x1a2>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 29e:	6d 81       	ldd	r22, Y+5	; 0x05
 2a0:	c2 01       	movw	r24, r4
 2a2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 2a6:	21 e0       	ldi	r18, 0x01	; 1
 2a8:	30 e0       	ldi	r19, 0x00	; 0
 2aa:	0d 80       	ldd	r0, Y+5	; 0x05
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <motorPWMInit+0x1b2>
 2ae:	22 0f       	add	r18, r18
 2b0:	33 1f       	adc	r19, r19
 2b2:	0a 94       	dec	r0
 2b4:	02 f4       	brpl	.+0      	; 0x2b6 <motorPWMInit+0x1ba>
 2b6:	22 27       	eor	r18, r18
 2b8:	35 75       	andi	r19, 0x55	; 85
 2ba:	23 2b       	or	r18, r19
 2bc:	01 f0       	breq	.+0      	; 0x2be <motorPWMInit+0x1c2>
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <motorPWMInit+0x1c4>
 2c0:	00 c0       	rjmp	.+0      	; 0x2c2 <motorPWMInit+0x1c6>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 2c2:	2d 96       	adiw	r28, 0x0d	; 13
 2c4:	0f b6       	in	r0, 0x3f	; 63
 2c6:	f8 94       	cli
 2c8:	de bf       	out	0x3e, r29	; 62
 2ca:	0f be       	out	0x3f, r0	; 63
 2cc:	cd bf       	out	0x3d, r28	; 61
 2ce:	df 91       	pop	r29
 2d0:	cf 91       	pop	r28
 2d2:	1f 91       	pop	r17
 2d4:	0f 91       	pop	r16
 2d6:	ff 90       	pop	r15
 2d8:	ef 90       	pop	r14
 2da:	df 90       	pop	r13
 2dc:	cf 90       	pop	r12
 2de:	bf 90       	pop	r11
 2e0:	af 90       	pop	r10
 2e2:	9f 90       	pop	r9
 2e4:	8f 90       	pop	r8
 2e6:	7f 90       	pop	r7
 2e8:	6f 90       	pop	r6
 2ea:	5f 90       	pop	r5
 2ec:	4f 90       	pop	r4
 2ee:	3f 90       	pop	r3
 2f0:	2f 90       	pop	r2
 2f2:	08 95       	ret

pid.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000035c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000390  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000390  2**0
                  ALLOC
  3 .debug_info   00000661  00000000  00000000  00000390  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000231  00000000  00000000  000009f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000036b  00000000  00000000  00000c22  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000f8d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000010e  00000000  00000000  00000fad  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000396  00000000  00000000  000010bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00001451  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000094  00000000  00000000  0000147c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pidSetTarget>:
#include "pid.h"
#include "timer.h"

// Update the PID with the desired target position - the setPoint
void pidSetTarget(PID* pid,float setPoint){
	CRITICAL_SECTION_START;					//Just in case PID is used in interrupts
   0:	2f b7       	in	r18, 0x3f	; 63
   2:	f8 94       	cli
	pid->setPoint = setPoint; 				//set goal
   4:	fc 01       	movw	r30, r24
   6:	41 a3       	std	Z+33, r20	; 0x21
   8:	52 a3       	std	Z+34, r21	; 0x22
   a:	63 a3       	std	Z+35, r22	; 0x23
   c:	74 a3       	std	Z+36, r23	; 0x24
	CRITICAL_SECTION_END;
   e:	2f bf       	out	0x3f, r18	; 63
  10:	08 95       	ret

00000012 <pidSetActual>:
}

// Update the PID with the actual position and return the new output
float pidSetActual(PID* pid,float actual){
  12:	2f 92       	push	r2
  14:	3f 92       	push	r3
  16:	4f 92       	push	r4
  18:	5f 92       	push	r5
  1a:	6f 92       	push	r6
  1c:	7f 92       	push	r7
  1e:	8f 92       	push	r8
  20:	9f 92       	push	r9
  22:	af 92       	push	r10
  24:	bf 92       	push	r11
  26:	cf 92       	push	r12
  28:	df 92       	push	r13
  2a:	ef 92       	push	r14
  2c:	ff 92       	push	r15
  2e:	0f 93       	push	r16
  30:	1f 93       	push	r17
  32:	cf 93       	push	r28
  34:	df 93       	push	r29
  36:	cd b7       	in	r28, 0x3d	; 61
  38:	de b7       	in	r29, 0x3e	; 62
  3a:	2a 97       	sbiw	r28, 0x0a	; 10
  3c:	0f b6       	in	r0, 0x3f	; 63
  3e:	f8 94       	cli
  40:	de bf       	out	0x3e, r29	; 62
  42:	0f be       	out	0x3f, r0	; 63
  44:	cd bf       	out	0x3d, r28	; 61
  46:	1c 01       	movw	r2, r24
  48:	9a 01       	movw	r18, r20
  4a:	ab 01       	movw	r20, r22

	// Find time difference since last call
	TICK_COUNT dt;

	if(g_heartbeat){
  4c:	80 91 00 00 	lds	r24, 0x0000
  50:	90 91 00 00 	lds	r25, 0x0000
  54:	89 2b       	or	r24, r25
  56:	01 f0       	breq	.+0      	; 0x58 <pidSetActual+0x46>
		// We have got a timer
		TICK_COUNT now = clockGetus();
  58:	2d 83       	std	Y+5, r18	; 0x05
  5a:	3e 83       	std	Y+6, r19	; 0x06
  5c:	4f 83       	std	Y+7, r20	; 0x07
  5e:	58 87       	std	Y+8, r21	; 0x08
  60:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
	 	dt = now - pid->lastTime;
  64:	d1 01       	movw	r26, r2
  66:	99 96       	adiw	r26, 0x29	; 41
  68:	cd 90       	ld	r12, X+
  6a:	dd 90       	ld	r13, X+
  6c:	ed 90       	ld	r14, X+
  6e:	fc 90       	ld	r15, X
  70:	9c 97       	sbiw	r26, 0x2c	; 44
  72:	4b 01       	movw	r8, r22
  74:	5c 01       	movw	r10, r24
  76:	8c 18       	sub	r8, r12
  78:	9d 08       	sbc	r9, r13
  7a:	ae 08       	sbc	r10, r14
  7c:	bf 08       	sbc	r11, r15
		pid->lastTime = now;
  7e:	f1 01       	movw	r30, r2
  80:	61 a7       	std	Z+41, r22	; 0x29
  82:	72 a7       	std	Z+42, r23	; 0x2a
  84:	83 a7       	std	Z+43, r24	; 0x2b
  86:	94 a7       	std	Z+44, r25	; 0x2c
  88:	2d 81       	ldd	r18, Y+5	; 0x05
  8a:	3e 81       	ldd	r19, Y+6	; 0x06
  8c:	4f 81       	ldd	r20, Y+7	; 0x07
  8e:	58 85       	ldd	r21, Y+8	; 0x08
  90:	00 c0       	rjmp	.+0      	; 0x92 <pidSetActual+0x80>
	}else{
		// There is no timer - so assume called every 10ms
		dt = (TICK_COUNT)10000;
  92:	80 e1       	ldi	r24, 0x10	; 16
  94:	88 2e       	mov	r8, r24
  96:	87 e2       	ldi	r24, 0x27	; 39
  98:	98 2e       	mov	r9, r24
  9a:	a1 2c       	mov	r10, r1
  9c:	b1 2c       	mov	r11, r1
	}
	
	float target;
	CRITICAL_SECTION{
  9e:	ef b7       	in	r30, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  a0:	f8 94       	cli
		target = pid->setPoint;
  a2:	d1 01       	movw	r26, r2
  a4:	91 96       	adiw	r26, 0x21	; 33
  a6:	6d 91       	ld	r22, X+
  a8:	7d 91       	ld	r23, X+
  aa:	8d 91       	ld	r24, X+
  ac:	9c 91       	ld	r25, X
  ae:	94 97       	sbiw	r26, 0x24	; 36
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  b0:	ef bf       	out	0x3f, r30	; 63
	}
	float error =  target - actual;  		//find error
  b2:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  b6:	8b 01       	movw	r16, r22
  b8:	8a 87       	std	Y+10, r24	; 0x0a
  ba:	99 87       	std	Y+9, r25	; 0x09

	//if circular control system, check for and handle wrap around
	if (pid->isCircular){
  bc:	f1 01       	movw	r30, r2
  be:	84 8d       	ldd	r24, Z+28	; 0x1c
  c0:	88 23       	and	r24, r24
  c2:	01 f4       	brne	.+0      	; 0xc4 <pidSetActual+0xb2>
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <pidSetActual+0xb4>
		float spanDiv2 = pid->inSpan / 2;
  c6:	44 84       	ldd	r4, Z+12	; 0x0c
  c8:	55 84       	ldd	r5, Z+13	; 0x0d
  ca:	66 84       	ldd	r6, Z+14	; 0x0e
  cc:	77 84       	ldd	r7, Z+15	; 0x0f
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	40 e0       	ldi	r20, 0x00	; 0
  d4:	5f e3       	ldi	r21, 0x3F	; 63
  d6:	c3 01       	movw	r24, r6
  d8:	b2 01       	movw	r22, r4
  da:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  de:	c6 2e       	mov	r12, r22
  e0:	d7 2e       	mov	r13, r23
  e2:	e8 2e       	mov	r14, r24
  e4:	f9 2e       	mov	r15, r25
		if (error < -spanDiv2){
  e6:	a7 01       	movw	r20, r14
  e8:	96 01       	movw	r18, r12
  ea:	50 58       	subi	r21, 0x80	; 128
  ec:	fa 85       	ldd	r31, Y+10	; 0x0a
  ee:	e9 85       	ldd	r30, Y+9	; 0x09
  f0:	60 2f       	mov	r22, r16
  f2:	71 2f       	mov	r23, r17
  f4:	8f 2f       	mov	r24, r31
  f6:	9e 2f       	mov	r25, r30
  f8:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  fc:	87 ff       	sbrs	r24, 7
  fe:	00 c0       	rjmp	.+0      	; 0x100 <pidSetActual+0xee>
			error += pid->inSpan;
 100:	a3 01       	movw	r20, r6
 102:	92 01       	movw	r18, r4
 104:	fa 85       	ldd	r31, Y+10	; 0x0a
 106:	e9 85       	ldd	r30, Y+9	; 0x09
 108:	60 2f       	mov	r22, r16
 10a:	71 2f       	mov	r23, r17
 10c:	8f 2f       	mov	r24, r31
 10e:	9e 2f       	mov	r25, r30
 110:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 114:	8b 01       	movw	r16, r22
 116:	8a 87       	std	Y+10, r24	; 0x0a
 118:	99 87       	std	Y+9, r25	; 0x09
		}
  		if (error > spanDiv2){
 11a:	a7 01       	movw	r20, r14
 11c:	96 01       	movw	r18, r12
 11e:	fa 85       	ldd	r31, Y+10	; 0x0a
 120:	e9 85       	ldd	r30, Y+9	; 0x09
 122:	60 2f       	mov	r22, r16
 124:	71 2f       	mov	r23, r17
 126:	8f 2f       	mov	r24, r31
 128:	9e 2f       	mov	r25, r30
 12a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 12e:	18 16       	cp	r1, r24
 130:	04 f4       	brge	.+0      	; 0x132 <pidSetActual+0x120>
  			error -= pid->inSpan;
 132:	a3 01       	movw	r20, r6
 134:	92 01       	movw	r18, r4
 136:	fa 85       	ldd	r31, Y+10	; 0x0a
 138:	e9 85       	ldd	r30, Y+9	; 0x09
 13a:	60 2f       	mov	r22, r16
 13c:	71 2f       	mov	r23, r17
 13e:	8f 2f       	mov	r24, r31
 140:	9e 2f       	mov	r25, r30
 142:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 146:	8b 01       	movw	r16, r22
 148:	8a 87       	std	Y+10, r24	; 0x0a
 14a:	99 87       	std	Y+9, r25	; 0x09
  		}
	}
	pid->prevError = error;				// save error for next go around
 14c:	9a 85       	ldd	r25, Y+10	; 0x0a
 14e:	89 85       	ldd	r24, Y+9	; 0x09
 150:	40 2f       	mov	r20, r16
 152:	51 2f       	mov	r21, r17
 154:	69 2f       	mov	r22, r25
 156:	78 2f       	mov	r23, r24
 158:	d1 01       	movw	r26, r2
 15a:	95 96       	adiw	r26, 0x25	; 37
 15c:	4d 93       	st	X+, r20
 15e:	5d 93       	st	X+, r21
 160:	6d 93       	st	X+, r22
 162:	7c 93       	st	X, r23
 164:	98 97       	sbiw	r26, 0x28	; 40

	//sum the errors for integral and clamp to limit
	pid->integral += error;
 166:	5d 96       	adiw	r26, 0x1d	; 29
 168:	2d 91       	ld	r18, X+
 16a:	3d 91       	ld	r19, X+
 16c:	4d 91       	ld	r20, X+
 16e:	5c 91       	ld	r21, X
 170:	90 97       	sbiw	r26, 0x20	; 32
 172:	e8 2f       	mov	r30, r24
 174:	60 2f       	mov	r22, r16
 176:	71 2f       	mov	r23, r17
 178:	89 2f       	mov	r24, r25
 17a:	9e 2f       	mov	r25, r30
 17c:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 180:	2b 01       	movw	r4, r22
 182:	3c 01       	movw	r6, r24
	pid->integral = CLAMP( pid->integral, -(pid->iLimit), pid->iLimit);
 184:	f1 01       	movw	r30, r2
 186:	c0 8c       	ldd	r12, Z+24	; 0x18
 188:	d1 8c       	ldd	r13, Z+25	; 0x19
 18a:	e2 8c       	ldd	r14, Z+26	; 0x1a
 18c:	f3 8c       	ldd	r15, Z+27	; 0x1b
 18e:	a7 01       	movw	r20, r14
 190:	96 01       	movw	r18, r12
 192:	75 2d       	mov	r23, r5
 194:	97 2d       	mov	r25, r7
 196:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 19a:	87 ff       	sbrs	r24, 7
 19c:	00 c0       	rjmp	.+0      	; 0x19e <pidSetActual+0x18c>
 19e:	74 2d       	mov	r23, r4
 1a0:	65 2d       	mov	r22, r5
 1a2:	96 2d       	mov	r25, r6
 1a4:	87 2d       	mov	r24, r7
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <pidSetActual+0x196>
 1a8:	7c 2d       	mov	r23, r12
 1aa:	6d 2d       	mov	r22, r13
 1ac:	9e 2d       	mov	r25, r14
 1ae:	8f 2d       	mov	r24, r15
 1b0:	a7 01       	movw	r20, r14
 1b2:	96 01       	movw	r18, r12
 1b4:	50 58       	subi	r21, 0x80	; 128
 1b6:	29 83       	std	Y+1, r18	; 0x01
 1b8:	3a 83       	std	Y+2, r19	; 0x02
 1ba:	4b 83       	std	Y+3, r20	; 0x03
 1bc:	5c 83       	std	Y+4, r21	; 0x04
 1be:	db 01       	movw	r26, r22
 1c0:	fc 01       	movw	r30, r24
 1c2:	6b 2f       	mov	r22, r27
 1c4:	7a 2f       	mov	r23, r26
 1c6:	8f 2f       	mov	r24, r31
 1c8:	9e 2f       	mov	r25, r30
 1ca:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 1ce:	18 16       	cp	r1, r24
 1d0:	04 f4       	brge	.+0      	; 0x1d2 <pidSetActual+0x1c0>
 1d2:	a7 01       	movw	r20, r14
 1d4:	96 01       	movw	r18, r12
 1d6:	64 2d       	mov	r22, r4
 1d8:	75 2d       	mov	r23, r5
 1da:	86 2d       	mov	r24, r6
 1dc:	97 2d       	mov	r25, r7
 1de:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 1e2:	87 ff       	sbrs	r24, 7
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <pidSetActual+0x1d4>
 1e6:	c4 2c       	mov	r12, r4
 1e8:	d5 2c       	mov	r13, r5
 1ea:	e6 2c       	mov	r14, r6
 1ec:	f7 2c       	mov	r15, r7
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <pidSetActual+0x1de>
 1f0:	c9 80       	ldd	r12, Y+1	; 0x01
 1f2:	da 80       	ldd	r13, Y+2	; 0x02
 1f4:	eb 80       	ldd	r14, Y+3	; 0x03
 1f6:	fc 80       	ldd	r15, Y+4	; 0x04
 1f8:	d1 01       	movw	r26, r2
 1fa:	5d 96       	adiw	r26, 0x1d	; 29
 1fc:	cd 92       	st	X+, r12
 1fe:	dd 92       	st	X+, r13
 200:	ed 92       	st	X+, r14
 202:	fc 92       	st	X, r15
 204:	90 97       	sbiw	r26, 0x20	; 32


	//find slope of error over time
	float derivative = (error - pid->prevError) / dt;

	float out = (pid->kP * error) + (pid->kI * pid->integral) + (pid->kD * derivative);
 206:	2d 91       	ld	r18, X+
 208:	3d 91       	ld	r19, X+
 20a:	4d 91       	ld	r20, X+
 20c:	5c 91       	ld	r21, X
 20e:	fa 85       	ldd	r31, Y+10	; 0x0a
 210:	e9 85       	ldd	r30, Y+9	; 0x09
 212:	60 2f       	mov	r22, r16
 214:	71 2f       	mov	r23, r17
 216:	8f 2f       	mov	r24, r31
 218:	9e 2f       	mov	r25, r30
 21a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 21e:	2b 01       	movw	r4, r22
 220:	3c 01       	movw	r6, r24
 222:	f1 01       	movw	r30, r2
 224:	24 81       	ldd	r18, Z+4	; 0x04
 226:	35 81       	ldd	r19, Z+5	; 0x05
 228:	46 81       	ldd	r20, Z+6	; 0x06
 22a:	57 81       	ldd	r21, Z+7	; 0x07
 22c:	c7 01       	movw	r24, r14
 22e:	b6 01       	movw	r22, r12
 230:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 234:	9b 01       	movw	r18, r22
 236:	ac 01       	movw	r20, r24
 238:	c3 01       	movw	r24, r6
 23a:	b2 01       	movw	r22, r4
 23c:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 240:	2b 01       	movw	r4, r22
 242:	3c 01       	movw	r6, r24
	pid->integral += error;
	pid->integral = CLAMP( pid->integral, -(pid->iLimit), pid->iLimit);


	//find slope of error over time
	float derivative = (error - pid->prevError) / dt;
 244:	9a 85       	ldd	r25, Y+10	; 0x0a
 246:	89 85       	ldd	r24, Y+9	; 0x09
 248:	20 2f       	mov	r18, r16
 24a:	31 2f       	mov	r19, r17
 24c:	49 2f       	mov	r20, r25
 24e:	58 2f       	mov	r21, r24
 250:	fc 01       	movw	r30, r24
 252:	60 2f       	mov	r22, r16
 254:	71 2f       	mov	r23, r17
 256:	8f 2f       	mov	r24, r31
 258:	9e 2f       	mov	r25, r30
 25a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 25e:	6b 01       	movw	r12, r22
 260:	7c 01       	movw	r14, r24
 262:	c5 01       	movw	r24, r10
 264:	b4 01       	movw	r22, r8
 266:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 26a:	9b 01       	movw	r18, r22
 26c:	ac 01       	movw	r20, r24
 26e:	c7 01       	movw	r24, r14
 270:	b6 01       	movw	r22, r12
 272:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>

	float out = (pid->kP * error) + (pid->kI * pid->integral) + (pid->kD * derivative);
 276:	d1 01       	movw	r26, r2
 278:	18 96       	adiw	r26, 0x08	; 8
 27a:	2d 91       	ld	r18, X+
 27c:	3d 91       	ld	r19, X+
 27e:	4d 91       	ld	r20, X+
 280:	5c 91       	ld	r21, X
 282:	1b 97       	sbiw	r26, 0x0b	; 11
 284:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 288:	9b 01       	movw	r18, r22
 28a:	ac 01       	movw	r20, r24
 28c:	c3 01       	movw	r24, r6
 28e:	b2 01       	movw	r22, r4
 290:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 294:	6b 01       	movw	r12, r22
 296:	7c 01       	movw	r14, r24

	//compare output to limits
	out = CLAMP(out, pid->outMin, pid->outMax);
 298:	f1 01       	movw	r30, r2
 29a:	00 89       	ldd	r16, Z+16	; 0x10
 29c:	11 89       	ldd	r17, Z+17	; 0x11
 29e:	62 88       	ldd	r6, Z+18	; 0x12
 2a0:	73 88       	ldd	r7, Z+19	; 0x13
 2a2:	20 2f       	mov	r18, r16
 2a4:	31 2f       	mov	r19, r17
 2a6:	46 2d       	mov	r20, r6
 2a8:	57 2d       	mov	r21, r7
 2aa:	6c 2d       	mov	r22, r12
 2ac:	7d 2d       	mov	r23, r13
 2ae:	8e 2d       	mov	r24, r14
 2b0:	9f 2d       	mov	r25, r15
 2b2:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 2b6:	87 ff       	sbrs	r24, 7
 2b8:	00 c0       	rjmp	.+0      	; 0x2ba <pidSetActual+0x2a8>
 2ba:	7c 2d       	mov	r23, r12
 2bc:	6d 2d       	mov	r22, r13
 2be:	9e 2d       	mov	r25, r14
 2c0:	8f 2d       	mov	r24, r15
 2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <pidSetActual+0x2b2>
 2c4:	70 2f       	mov	r23, r16
 2c6:	61 2f       	mov	r22, r17
 2c8:	96 2d       	mov	r25, r6
 2ca:	87 2d       	mov	r24, r7
 2cc:	d1 01       	movw	r26, r2
 2ce:	54 96       	adiw	r26, 0x14	; 20
 2d0:	8c 90       	ld	r8, X
 2d2:	54 97       	sbiw	r26, 0x14	; 20
 2d4:	55 96       	adiw	r26, 0x15	; 21
 2d6:	9c 90       	ld	r9, X
 2d8:	55 97       	sbiw	r26, 0x15	; 21
 2da:	56 96       	adiw	r26, 0x16	; 22
 2dc:	ac 90       	ld	r10, X
 2de:	56 97       	sbiw	r26, 0x16	; 22
 2e0:	57 96       	adiw	r26, 0x17	; 23
 2e2:	bc 90       	ld	r11, X
 2e4:	28 2d       	mov	r18, r8
 2e6:	39 2d       	mov	r19, r9
 2e8:	4a 2d       	mov	r20, r10
 2ea:	5b 2d       	mov	r21, r11
 2ec:	db 01       	movw	r26, r22
 2ee:	fc 01       	movw	r30, r24
 2f0:	6b 2f       	mov	r22, r27
 2f2:	7a 2f       	mov	r23, r26
 2f4:	8f 2f       	mov	r24, r31
 2f6:	9e 2f       	mov	r25, r30
 2f8:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 2fc:	18 16       	cp	r1, r24
 2fe:	04 f4       	brge	.+0      	; 0x300 <pidSetActual+0x2ee>
 300:	20 2f       	mov	r18, r16
 302:	31 2f       	mov	r19, r17
 304:	46 2d       	mov	r20, r6
 306:	57 2d       	mov	r21, r7
 308:	6c 2d       	mov	r22, r12
 30a:	7d 2d       	mov	r23, r13
 30c:	8e 2d       	mov	r24, r14
 30e:	9f 2d       	mov	r25, r15
 310:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 314:	87 ff       	sbrs	r24, 7
 316:	00 c0       	rjmp	.+0      	; 0x318 <pidSetActual+0x306>
 318:	86 01       	movw	r16, r12
 31a:	37 01       	movw	r6, r14
 31c:	00 c0       	rjmp	.+0      	; 0x31e <pidSetActual+0x30c>
 31e:	84 01       	movw	r16, r8
 320:	35 01       	movw	r6, r10



	return out;

}
 322:	60 2f       	mov	r22, r16
 324:	71 2f       	mov	r23, r17
 326:	86 2d       	mov	r24, r6
 328:	97 2d       	mov	r25, r7
 32a:	2a 96       	adiw	r28, 0x0a	; 10
 32c:	0f b6       	in	r0, 0x3f	; 63
 32e:	f8 94       	cli
 330:	de bf       	out	0x3e, r29	; 62
 332:	0f be       	out	0x3f, r0	; 63
 334:	cd bf       	out	0x3d, r28	; 61
 336:	df 91       	pop	r29
 338:	cf 91       	pop	r28
 33a:	1f 91       	pop	r17
 33c:	0f 91       	pop	r16
 33e:	ff 90       	pop	r15
 340:	ef 90       	pop	r14
 342:	df 90       	pop	r13
 344:	cf 90       	pop	r12
 346:	bf 90       	pop	r11
 348:	af 90       	pop	r10
 34a:	9f 90       	pop	r9
 34c:	8f 90       	pop	r8
 34e:	7f 90       	pop	r7
 350:	6f 90       	pop	r6
 352:	5f 90       	pop	r5
 354:	4f 90       	pop	r4
 356:	3f 90       	pop	r3
 358:	2f 90       	pop	r2
 35a:	08 95       	ret

pinChange.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000035e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000392  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000392  2**0
                  ALLOC
  3 .debug_info   00000525  00000000  00000000  00000392  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001e6  00000000  00000000  000008b7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000065c  00000000  00000000  00000a9d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000010f9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  00001119  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000114  00000000  00000000  00001149  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000022f  00000000  00000000  0000125d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  0000148c  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000001d4  00000000  00000000  000014b8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__io_to_pc_index>:
#include "pinChange.h"
#include <avr/interrupt.h>


// Convert an IOPin to the PCINT it uses or -1 if it doesn't have one
int __io_to_pc_index(const IOPin* io){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
	for(int i=0; i<NUM_PCINT_PINS;i++){
   4:	c0 91 00 00 	lds	r28, 0x0000
   8:	d0 e0       	ldi	r29, 0x00	; 0
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	70 e0       	ldi	r23, 0x00	; 0
   e:	20 e0       	ldi	r18, 0x00	; 0
  10:	30 e0       	ldi	r19, 0x00	; 0
  12:	00 c0       	rjmp	.+0      	; 0x14 <__io_to_pc_index+0x14>
		const IOPin* aPin = (const IOPin*)pgm_read_word(&PCINT_PINS[i]);
  14:	fb 01       	movw	r30, r22
  16:	a5 91       	lpm	r26, Z+
  18:	b4 91       	lpm	r27, Z
		if(aPin!=null && aPin==io){
  1a:	10 97       	sbiw	r26, 0x00	; 0
  1c:	01 f0       	breq	.+0      	; 0x1e <__io_to_pc_index+0x1e>
  1e:	a8 17       	cp	r26, r24
  20:	b9 07       	cpc	r27, r25
  22:	01 f0       	breq	.+0      	; 0x24 <__io_to_pc_index+0x24>
#include <avr/interrupt.h>


// Convert an IOPin to the PCINT it uses or -1 if it doesn't have one
int __io_to_pc_index(const IOPin* io){
	for(int i=0; i<NUM_PCINT_PINS;i++){
  24:	2f 5f       	subi	r18, 0xFF	; 255
  26:	3f 4f       	sbci	r19, 0xFF	; 255
  28:	6e 5f       	subi	r22, 0xFE	; 254
  2a:	7f 4f       	sbci	r23, 0xFF	; 255
  2c:	2c 17       	cp	r18, r28
  2e:	3d 07       	cpc	r19, r29
  30:	04 f0       	brlt	.+0      	; 0x32 <__io_to_pc_index+0x32>
		const IOPin* aPin = (const IOPin*)pgm_read_word(&PCINT_PINS[i]);
		if(aPin!=null && aPin==io){
			return i;
		}
	}
	return -1;
  32:	2f ef       	ldi	r18, 0xFF	; 255
  34:	3f ef       	ldi	r19, 0xFF	; 255
}
  36:	c9 01       	movw	r24, r18
  38:	df 91       	pop	r29
  3a:	cf 91       	pop	r28
  3c:	08 95       	ret

0000003e <pin_change_attach>:

void pin_change_attach(const IOPin* io,PinChangeCallback callback, void* data){
  3e:	af 92       	push	r10
  40:	bf 92       	push	r11
  42:	cf 92       	push	r12
  44:	df 92       	push	r13
  46:	ef 92       	push	r14
  48:	ff 92       	push	r15
  4a:	0f 93       	push	r16
  4c:	1f 93       	push	r17
  4e:	cf 93       	push	r28
  50:	df 93       	push	r29
  52:	7c 01       	movw	r14, r24
  54:	5b 01       	movw	r10, r22
  56:	6a 01       	movw	r12, r20
	cli();
  58:	f8 94       	cli
	int inx = __io_to_pc_index(io);
  5a:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  5e:	ec 01       	movw	r28, r24
	if(inx==-1){
  60:	8f 3f       	cpi	r24, 0xFF	; 255
  62:	3f ef       	ldi	r19, 0xFF	; 255
  64:	93 07       	cpc	r25, r19
  66:	01 f4       	brne	.+0      	; 0x68 <pin_change_attach+0x2a>
		setError(PIN_HAS_NO_PCINT);
  68:	8c ee       	ldi	r24, 0xEC	; 236
  6a:	00 c0       	rjmp	.+0      	; 0x6c <pin_change_attach+0x2e>
	}else if(pcCallbacks[inx].callback!=null){
  6c:	85 e0       	ldi	r24, 0x05	; 5
  6e:	8c 9f       	mul	r24, r28
  70:	80 01       	movw	r16, r0
  72:	8d 9f       	mul	r24, r29
  74:	10 0d       	add	r17, r0
  76:	11 24       	eor	r1, r1
  78:	00 50       	subi	r16, 0x00	; 0
  7a:	10 40       	sbci	r17, 0x00	; 0
  7c:	f8 01       	movw	r30, r16
  7e:	80 81       	ld	r24, Z
  80:	91 81       	ldd	r25, Z+1	; 0x01
  82:	89 2b       	or	r24, r25
  84:	01 f0       	breq	.+0      	; 0x86 <pin_change_attach+0x48>
		setError(PIN_HAS_CALLBACK);
  86:	8b ee       	ldi	r24, 0xEB	; 235
  88:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <pin_change_attach+0x50>
	}else{
		pcCallbacks[inx].callback = callback;
  8e:	f8 01       	movw	r30, r16
  90:	b1 82       	std	Z+1, r11	; 0x01
  92:	a0 82       	st	Z, r10
		pcCallbacks[inx].data = data;
  94:	d3 82       	std	Z+3, r13	; 0x03
  96:	c2 82       	std	Z+2, r12	; 0x02
		pcCallbacks[inx].lastValue = pin_is_high(io);
  98:	c7 01       	movw	r24, r14
  9a:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  9e:	f8 01       	movw	r30, r16
  a0:	84 83       	std	Z+4, r24	; 0x04
		if(inx<=7){
  a2:	c8 30       	cpi	r28, 0x08	; 8
  a4:	d1 05       	cpc	r29, r1
  a6:	04 f4       	brge	.+0      	; 0xa8 <pin_change_attach+0x6a>
#ifdef PCMSK0
			PCMSK0 |= BV(inx);		// enable iterrupts for this pin
  a8:	20 91 6b 00 	lds	r18, 0x006B
  ac:	81 e0       	ldi	r24, 0x01	; 1
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	0c 2e       	mov	r0, r28
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <pin_change_attach+0x76>
  b4:	88 0f       	add	r24, r24
  b6:	0a 94       	dec	r0
  b8:	02 f4       	brpl	.+0      	; 0xba <pin_change_attach+0x7c>
  ba:	28 2b       	or	r18, r24
  bc:	20 93 6b 00 	sts	0x006B, r18
			PCICR  |= BV(PCIE0);	// enable iterrupts for PCINT0..7
  c0:	80 91 68 00 	lds	r24, 0x0068
  c4:	81 60       	ori	r24, 0x01	; 1
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <pin_change_attach+0x8a>
#endif
#ifdef PCMSK1
		}else if(inx<=15){
  c8:	c0 31       	cpi	r28, 0x10	; 16
  ca:	d1 05       	cpc	r29, r1
  cc:	04 f4       	brge	.+0      	; 0xce <pin_change_attach+0x90>
			PCMSK1 |= BV((inx & 7));// enable iterrupts for this pin
  ce:	20 91 6c 00 	lds	r18, 0x006C
  d2:	c7 70       	andi	r28, 0x07	; 7
  d4:	dd 27       	eor	r29, r29
  d6:	81 e0       	ldi	r24, 0x01	; 1
  d8:	90 e0       	ldi	r25, 0x00	; 0
  da:	0c 2e       	mov	r0, r28
  dc:	00 c0       	rjmp	.+0      	; 0xde <pin_change_attach+0xa0>
  de:	88 0f       	add	r24, r24
  e0:	0a 94       	dec	r0
  e2:	02 f4       	brpl	.+0      	; 0xe4 <pin_change_attach+0xa6>
  e4:	28 2b       	or	r18, r24
  e6:	20 93 6c 00 	sts	0x006C, r18
			PCICR  |= BV(PCIE1);	// enable iterrupts for PCINT8..15
  ea:	80 91 68 00 	lds	r24, 0x0068
  ee:	82 60       	ori	r24, 0x02	; 2
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <pin_change_attach+0xb4>
#endif
#ifdef PCMSK2
		}else if(inx<=23){
  f2:	c8 31       	cpi	r28, 0x18	; 24
  f4:	d1 05       	cpc	r29, r1
  f6:	04 f4       	brge	.+0      	; 0xf8 <pin_change_attach+0xba>
			PCMSK2 |= BV((inx & 7));// enable iterrupts for this pin
  f8:	20 91 6d 00 	lds	r18, 0x006D
  fc:	c7 70       	andi	r28, 0x07	; 7
  fe:	dd 27       	eor	r29, r29
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	00 c0       	rjmp	.+0      	; 0x106 <pin_change_attach+0xc8>
 106:	88 0f       	add	r24, r24
 108:	ca 95       	dec	r28
 10a:	02 f4       	brpl	.+0      	; 0x10c <pin_change_attach+0xce>
 10c:	28 2b       	or	r18, r24
 10e:	20 93 6d 00 	sts	0x006D, r18
			PCICR  |= BV(PCIE2);	// enable iterrupts for PCINT16...23
 112:	80 91 68 00 	lds	r24, 0x0068
 116:	84 60       	ori	r24, 0x04	; 4
 118:	80 93 68 00 	sts	0x0068, r24
			PCMSK3 |= BV((inx & 7));// enable iterrupts for this pin
			PCICR  |= BV(PCIE3);	// enable iterrupts for PCINT24..31
#endif
		}
	}
	sei();						// make sure interrupts are enabled
 11c:	78 94       	sei
}
 11e:	df 91       	pop	r29
 120:	cf 91       	pop	r28
 122:	1f 91       	pop	r17
 124:	0f 91       	pop	r16
 126:	ff 90       	pop	r15
 128:	ef 90       	pop	r14
 12a:	df 90       	pop	r13
 12c:	cf 90       	pop	r12
 12e:	bf 90       	pop	r11
 130:	af 90       	pop	r10
 132:	08 95       	ret

00000134 <pin_change_dettach>:

void pin_change_dettach(const IOPin* io){
 134:	cf 93       	push	r28
	CRITICAL_SECTION_START;
 136:	cf b7       	in	r28, 0x3f	; 63
 138:	f8 94       	cli
	int inx = __io_to_pc_index(io);
 13a:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
	if(inx!=-1){
 13e:	8f 3f       	cpi	r24, 0xFF	; 255
 140:	2f ef       	ldi	r18, 0xFF	; 255
 142:	92 07       	cpc	r25, r18
 144:	01 f4       	brne	.+0      	; 0x146 <pin_change_dettach+0x12>
 146:	00 c0       	rjmp	.+0      	; 0x148 <pin_change_dettach+0x14>
		pcCallbacks[inx].callback = null;
 148:	25 e0       	ldi	r18, 0x05	; 5
 14a:	28 9f       	mul	r18, r24
 14c:	f0 01       	movw	r30, r0
 14e:	29 9f       	mul	r18, r25
 150:	f0 0d       	add	r31, r0
 152:	11 24       	eor	r1, r1
 154:	e0 50       	subi	r30, 0x00	; 0
 156:	f0 40       	sbci	r31, 0x00	; 0
 158:	11 82       	std	Z+1, r1	; 0x01
 15a:	10 82       	st	Z, r1
		pcCallbacks[inx].data = null;
 15c:	13 82       	std	Z+3, r1	; 0x03
 15e:	12 82       	std	Z+2, r1	; 0x02
		if(inx<=7){
 160:	88 30       	cpi	r24, 0x08	; 8
 162:	91 05       	cpc	r25, r1
 164:	04 f4       	brge	.+0      	; 0x166 <pin_change_dettach+0x32>
#ifdef PCMSK0
			PCMSK0 &= ~BV(inx);		// disable iterrupts for this pin
 166:	90 91 6b 00 	lds	r25, 0x006B
 16a:	21 e0       	ldi	r18, 0x01	; 1
 16c:	30 e0       	ldi	r19, 0x00	; 0
 16e:	08 2e       	mov	r0, r24
 170:	00 c0       	rjmp	.+0      	; 0x172 <pin_change_dettach+0x3e>
 172:	22 0f       	add	r18, r18
 174:	0a 94       	dec	r0
 176:	02 f4       	brpl	.+0      	; 0x178 <pin_change_dettach+0x44>
 178:	20 95       	com	r18
 17a:	29 23       	and	r18, r25
 17c:	20 93 6b 00 	sts	0x006B, r18
 180:	00 c0       	rjmp	.+0      	; 0x182 <pin_change_dettach+0x4e>
#endif
#ifdef PCMSK1
		}else if(inx<=15){
 182:	80 31       	cpi	r24, 0x10	; 16
 184:	91 05       	cpc	r25, r1
 186:	04 f4       	brge	.+0      	; 0x188 <pin_change_dettach+0x54>
			PCMSK1 &= ~BV((inx & 7));// disable iterrupts for this pin
 188:	40 91 6c 00 	lds	r20, 0x006C
 18c:	87 70       	andi	r24, 0x07	; 7
 18e:	99 27       	eor	r25, r25
 190:	21 e0       	ldi	r18, 0x01	; 1
 192:	30 e0       	ldi	r19, 0x00	; 0
 194:	08 2e       	mov	r0, r24
 196:	00 c0       	rjmp	.+0      	; 0x198 <pin_change_dettach+0x64>
 198:	22 0f       	add	r18, r18
 19a:	0a 94       	dec	r0
 19c:	02 f4       	brpl	.+0      	; 0x19e <pin_change_dettach+0x6a>
 19e:	20 95       	com	r18
 1a0:	24 23       	and	r18, r20
 1a2:	20 93 6c 00 	sts	0x006C, r18
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <pin_change_dettach+0x74>
#endif
#ifdef PCMSK2
		}else if(inx<=23){
 1a8:	88 31       	cpi	r24, 0x18	; 24
 1aa:	91 05       	cpc	r25, r1
 1ac:	04 f4       	brge	.+0      	; 0x1ae <pin_change_dettach+0x7a>
			PCMSK2 &= ~BV((inx & 7));// disable iterrupts for this pin
 1ae:	40 91 6d 00 	lds	r20, 0x006D
 1b2:	87 70       	andi	r24, 0x07	; 7
 1b4:	99 27       	eor	r25, r25
 1b6:	21 e0       	ldi	r18, 0x01	; 1
 1b8:	30 e0       	ldi	r19, 0x00	; 0
 1ba:	08 2e       	mov	r0, r24
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <pin_change_dettach+0x8a>
 1be:	22 0f       	add	r18, r18
 1c0:	0a 94       	dec	r0
 1c2:	02 f4       	brpl	.+0      	; 0x1c4 <pin_change_dettach+0x90>
 1c4:	20 95       	com	r18
 1c6:	24 23       	and	r18, r20
 1c8:	20 93 6d 00 	sts	0x006D, r18
		}else if(inx<=31){
			PCMSK3 &= ~BV((inx & 7));// disable iterrupts for this pin
#endif
		}
	}
	CRITICAL_SECTION_END;
 1cc:	cf bf       	out	0x3f, r28	; 63
}
 1ce:	cf 91       	pop	r28
 1d0:	08 95       	ret

000001d2 <pin_change_service>:

void pin_change_service(int inx, uint8_t mask){
 1d2:	bf 92       	push	r11
 1d4:	cf 92       	push	r12
 1d6:	df 92       	push	r13
 1d8:	ef 92       	push	r14
 1da:	ff 92       	push	r15
 1dc:	0f 93       	push	r16
 1de:	1f 93       	push	r17
 1e0:	cf 93       	push	r28
 1e2:	df 93       	push	r29
 1e4:	b6 2e       	mov	r11, r22
 1e6:	9c 01       	movw	r18, r24
 1e8:	85 e0       	ldi	r24, 0x05	; 5
 1ea:	82 9f       	mul	r24, r18
 1ec:	e0 01       	movw	r28, r0
 1ee:	83 9f       	mul	r24, r19
 1f0:	d0 0d       	add	r29, r0
 1f2:	11 24       	eor	r1, r1
 1f4:	c0 50       	subi	r28, 0x00	; 0
 1f6:	d0 40       	sbci	r29, 0x00	; 0
 1f8:	69 01       	movw	r12, r18
 1fa:	cc 0c       	add	r12, r12
 1fc:	dd 1c       	adc	r13, r13
 1fe:	e1 2c       	mov	r14, r1
 200:	f1 2c       	mov	r15, r1
 202:	80 e0       	ldi	r24, 0x00	; 0
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	c8 0e       	add	r12, r24
 208:	d9 1e       	adc	r13, r25

	for(int i=0; i<8; i++,inx++){
		if(mask & 1){
 20a:	b0 fe       	sbrs	r11, 0
 20c:	00 c0       	rjmp	.+0      	; 0x20e <pin_change_service+0x3c>
		}
	}
	CRITICAL_SECTION_END;
}

void pin_change_service(int inx, uint8_t mask){
 20e:	f6 01       	movw	r30, r12
 210:	ee 0d       	add	r30, r14
 212:	ff 1d       	adc	r31, r15

	for(int i=0; i<8; i++,inx++){
		if(mask & 1){
			PIN_CHANGE* pc = &pcCallbacks[inx];
			const IOPin* io = (const IOPin*)pgm_read_word(&PCINT_PINS[inx]);
 214:	85 91       	lpm	r24, Z+
 216:	94 91       	lpm	r25, Z
 218:	8c 01       	movw	r16, r24
			if(io!=null && pc->callback!=null){
 21a:	00 97       	sbiw	r24, 0x00	; 0
 21c:	01 f0       	breq	.+0      	; 0x21e <pin_change_service+0x4c>
 21e:	88 81       	ld	r24, Y
 220:	99 81       	ldd	r25, Y+1	; 0x01
 222:	89 2b       	or	r24, r25
 224:	01 f0       	breq	.+0      	; 0x226 <pin_change_service+0x54>
				boolean newVal = pin_get(io);
 226:	c8 01       	movw	r24, r16
 228:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
				if(newVal != pc->lastValue){
 22c:	9c 81       	ldd	r25, Y+4	; 0x04
 22e:	89 17       	cp	r24, r25
 230:	01 f0       	breq	.+0      	; 0x232 <pin_change_service+0x60>
					// The value has changed
					pc->callback(io,newVal,pc->data); 		// call the callback routine
 232:	e8 81       	ld	r30, Y
 234:	f9 81       	ldd	r31, Y+1	; 0x01
 236:	4a 81       	ldd	r20, Y+2	; 0x02
 238:	5b 81       	ldd	r21, Y+3	; 0x03
 23a:	68 2f       	mov	r22, r24
 23c:	c8 01       	movw	r24, r16
 23e:	09 95       	icall
					pc->lastValue = pin_get(io);	// set the last value
 240:	c8 01       	movw	r24, r16
 242:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
 246:	8c 83       	std	Y+4, r24	; 0x04
				}
			}
		}
		mask>>=1;
 248:	b6 94       	lsr	r11
 24a:	25 96       	adiw	r28, 0x05	; 5
 24c:	92 e0       	ldi	r25, 0x02	; 2
 24e:	e9 0e       	add	r14, r25
 250:	f1 1c       	adc	r15, r1
	CRITICAL_SECTION_END;
}

void pin_change_service(int inx, uint8_t mask){

	for(int i=0; i<8; i++,inx++){
 252:	80 e1       	ldi	r24, 0x10	; 16
 254:	e8 16       	cp	r14, r24
 256:	f1 04       	cpc	r15, r1
 258:	01 f4       	brne	.+0      	; 0x25a <pin_change_service+0x88>
				}
			}
		}
		mask>>=1;
	}
}
 25a:	df 91       	pop	r29
 25c:	cf 91       	pop	r28
 25e:	1f 91       	pop	r17
 260:	0f 91       	pop	r16
 262:	ff 90       	pop	r15
 264:	ef 90       	pop	r14
 266:	df 90       	pop	r13
 268:	cf 90       	pop	r12
 26a:	bf 90       	pop	r11
 26c:	08 95       	ret

0000026e <__vector_9>:

#ifdef PCINT0_vect
ISR(PCINT0_vect){
 26e:	1f 92       	push	r1
 270:	0f 92       	push	r0
 272:	0f b6       	in	r0, 0x3f	; 63
 274:	0f 92       	push	r0
 276:	11 24       	eor	r1, r1
 278:	2f 93       	push	r18
 27a:	3f 93       	push	r19
 27c:	4f 93       	push	r20
 27e:	5f 93       	push	r21
 280:	6f 93       	push	r22
 282:	7f 93       	push	r23
 284:	8f 93       	push	r24
 286:	9f 93       	push	r25
 288:	af 93       	push	r26
 28a:	bf 93       	push	r27
 28c:	ef 93       	push	r30
 28e:	ff 93       	push	r31
	// Handle it
	pin_change_service(0,PCMSK0);
 290:	60 91 6b 00 	lds	r22, 0x006B
 294:	80 e0       	ldi	r24, 0x00	; 0
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 29c:	ff 91       	pop	r31
 29e:	ef 91       	pop	r30
 2a0:	bf 91       	pop	r27
 2a2:	af 91       	pop	r26
 2a4:	9f 91       	pop	r25
 2a6:	8f 91       	pop	r24
 2a8:	7f 91       	pop	r23
 2aa:	6f 91       	pop	r22
 2ac:	5f 91       	pop	r21
 2ae:	4f 91       	pop	r20
 2b0:	3f 91       	pop	r19
 2b2:	2f 91       	pop	r18
 2b4:	0f 90       	pop	r0
 2b6:	0f be       	out	0x3f, r0	; 63
 2b8:	0f 90       	pop	r0
 2ba:	1f 90       	pop	r1
 2bc:	18 95       	reti

000002be <__vector_10>:
#endif

#ifdef PCINT1_vect
ISR(PCINT1_vect){
 2be:	1f 92       	push	r1
 2c0:	0f 92       	push	r0
 2c2:	0f b6       	in	r0, 0x3f	; 63
 2c4:	0f 92       	push	r0
 2c6:	11 24       	eor	r1, r1
 2c8:	2f 93       	push	r18
 2ca:	3f 93       	push	r19
 2cc:	4f 93       	push	r20
 2ce:	5f 93       	push	r21
 2d0:	6f 93       	push	r22
 2d2:	7f 93       	push	r23
 2d4:	8f 93       	push	r24
 2d6:	9f 93       	push	r25
 2d8:	af 93       	push	r26
 2da:	bf 93       	push	r27
 2dc:	ef 93       	push	r30
 2de:	ff 93       	push	r31
	// Handle it
	pin_change_service(8,PCMSK1);
 2e0:	60 91 6c 00 	lds	r22, 0x006C
 2e4:	88 e0       	ldi	r24, 0x08	; 8
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 2ec:	ff 91       	pop	r31
 2ee:	ef 91       	pop	r30
 2f0:	bf 91       	pop	r27
 2f2:	af 91       	pop	r26
 2f4:	9f 91       	pop	r25
 2f6:	8f 91       	pop	r24
 2f8:	7f 91       	pop	r23
 2fa:	6f 91       	pop	r22
 2fc:	5f 91       	pop	r21
 2fe:	4f 91       	pop	r20
 300:	3f 91       	pop	r19
 302:	2f 91       	pop	r18
 304:	0f 90       	pop	r0
 306:	0f be       	out	0x3f, r0	; 63
 308:	0f 90       	pop	r0
 30a:	1f 90       	pop	r1
 30c:	18 95       	reti

0000030e <__vector_11>:
#endif

#ifdef PCINT2_vect
ISR(PCINT2_vect){
 30e:	1f 92       	push	r1
 310:	0f 92       	push	r0
 312:	0f b6       	in	r0, 0x3f	; 63
 314:	0f 92       	push	r0
 316:	11 24       	eor	r1, r1
 318:	2f 93       	push	r18
 31a:	3f 93       	push	r19
 31c:	4f 93       	push	r20
 31e:	5f 93       	push	r21
 320:	6f 93       	push	r22
 322:	7f 93       	push	r23
 324:	8f 93       	push	r24
 326:	9f 93       	push	r25
 328:	af 93       	push	r26
 32a:	bf 93       	push	r27
 32c:	ef 93       	push	r30
 32e:	ff 93       	push	r31
	// Handle it
	pin_change_service(16,PCMSK2);
 330:	60 91 6d 00 	lds	r22, 0x006D
 334:	80 e1       	ldi	r24, 0x10	; 16
 336:	90 e0       	ldi	r25, 0x00	; 0
 338:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 33c:	ff 91       	pop	r31
 33e:	ef 91       	pop	r30
 340:	bf 91       	pop	r27
 342:	af 91       	pop	r26
 344:	9f 91       	pop	r25
 346:	8f 91       	pop	r24
 348:	7f 91       	pop	r23
 34a:	6f 91       	pop	r22
 34c:	5f 91       	pop	r21
 34e:	4f 91       	pop	r20
 350:	3f 91       	pop	r19
 352:	2f 91       	pop	r18
 354:	0f 90       	pop	r0
 356:	0f be       	out	0x3f, r0	; 63
 358:	0f 90       	pop	r0
 35a:	1f 90       	pop	r1
 35c:	18 95       	reti

pwm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000300  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000334  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000334  2**0
                  ALLOC
  3 .debug_info   00000e28  00000000  00000000  00000334  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000301  00000000  00000000  0000115c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000009d7  00000000  00000000  0000145d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001e34  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00001e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000167  00000000  00000000  00001e6c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000744  00000000  00000000  00001fd3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00002717  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000012c  00000000  00000000  00002744  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pwmSetDutyCycle>:
#include "pwm.h"
#include "timer.h"
//#include "core.h"

// Set the duty cycle
void pwmSetDutyCycle(const IOPin* pin, DUTY_CYCLE duty){
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	f6 2e       	mov	r15, r22
	const TimerCompare* channel = compareFromIOPin(pin);
   c:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  10:	ec 01       	movw	r28, r24
	if(channel){
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <pwmSetDutyCycle+0x16>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  16:	fc 01       	movw	r30, r24
  18:	32 96       	adiw	r30, 0x02	; 2
  1a:	84 91       	lpm	r24, Z
		const Timer* timer = compareGetTimer(channel);
  1c:	2c e2       	ldi	r18, 0x2C	; 44
  1e:	82 9f       	mul	r24, r18
  20:	c0 01       	movw	r24, r0
  22:	11 24       	eor	r1, r1
		uint32_t top = timerGetTOP(timer);
  24:	80 50       	subi	r24, 0x00	; 0
  26:	90 40       	sbci	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  2c:	8c 01       	movw	r16, r24
		// duty => x
		// x = (top * duty) / 100
//		top *= duty;
//		top /= 100;
//		uint16_t delay =  top;
		uint16_t delay = interpolateU(duty, 0,100, 0,top);
  2e:	8f 2d       	mov	r24, r15
  30:	85 36       	cpi	r24, 0x65	; 101
  32:	00 f0       	brcs	.+0      	; 0x34 <pwmSetDutyCycle+0x34>
  34:	84 e6       	ldi	r24, 0x64	; 100
  36:	20 e0       	ldi	r18, 0x00	; 0
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	44 e6       	ldi	r20, 0x64	; 100
  3c:	50 e0       	ldi	r21, 0x00	; 0
  3e:	60 e0       	ldi	r22, 0x00	; 0
  40:	70 e0       	ldi	r23, 0x00	; 0
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

		// Change the duty cycle
		compareSetThreshold(channel,delay);
  48:	bc 01       	movw	r22, r24
  4a:	ce 01       	movw	r24, r28
	}
}
  4c:	df 91       	pop	r29
  4e:	cf 91       	pop	r28
  50:	1f 91       	pop	r17
  52:	0f 91       	pop	r16
  54:	ff 90       	pop	r15
//		top /= 100;
//		uint16_t delay =  top;
		uint16_t delay = interpolateU(duty, 0,100, 0,top);

		// Change the duty cycle
		compareSetThreshold(channel,delay);
  56:	0c 94 00 00 	jmp	0	; 0x0 <pwmSetDutyCycle>
	}
}
  5a:	df 91       	pop	r29
  5c:	cf 91       	pop	r28
  5e:	1f 91       	pop	r17
  60:	0f 91       	pop	r16
  62:	ff 90       	pop	r15
  64:	08 95       	ret

00000066 <pwmGetDutyCycle>:

DUTY_CYCLE pwmGetDutyCycle(const IOPin* pin){
  66:	0f 93       	push	r16
  68:	1f 93       	push	r17
  6a:	cf 93       	push	r28
  6c:	df 93       	push	r29
	DUTY_CYCLE rtn = 0;

	const TimerCompare* channel = compareFromIOPin(pin);
  6e:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  72:	ec 01       	movw	r28, r24
	if(channel){
  74:	00 97       	sbiw	r24, 0x00	; 0
  76:	01 f0       	breq	.+0      	; 0x78 <pwmGetDutyCycle+0x12>
  78:	fc 01       	movw	r30, r24
  7a:	32 96       	adiw	r30, 0x02	; 2
  7c:	84 91       	lpm	r24, Z
		const Timer* timer = compareGetTimer(channel);
  7e:	2c e2       	ldi	r18, 0x2C	; 44
  80:	82 9f       	mul	r24, r18
  82:	c0 01       	movw	r24, r0
  84:	11 24       	eor	r1, r1
		uint32_t top = timerGetTOP(timer);
  86:	80 50       	subi	r24, 0x00	; 0
  88:	90 40       	sbci	r25, 0x00	; 0
  8a:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  8e:	8c 01       	movw	r16, r24
		uint32_t duty = compareGetThreshold(channel);
  90:	ce 01       	movw	r24, r28
  92:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
		// top => 100
		// duty => x
		// x = (100 * duty) / top
		duty *= 100;
  96:	9c 01       	movw	r18, r24
  98:	a4 e6       	ldi	r26, 0x64	; 100
  9a:	b0 e0       	ldi	r27, 0x00	; 0
  9c:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	DUTY_CYCLE rtn = 0;

	const TimerCompare* channel = compareFromIOPin(pin);
	if(channel){
		const Timer* timer = compareGetTimer(channel);
		uint32_t top = timerGetTOP(timer);
  a0:	98 01       	movw	r18, r16
  a2:	40 e0       	ldi	r20, 0x00	; 0
  a4:	50 e0       	ldi	r21, 0x00	; 0
		uint32_t duty = compareGetThreshold(channel);
		// top => 100
		// duty => x
		// x = (100 * duty) / top
		duty *= 100;
		duty /= top;
  a6:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
		rtn = duty;
  aa:	82 2f       	mov	r24, r18
  ac:	00 c0       	rjmp	.+0      	; 0xae <pwmGetDutyCycle+0x48>
		compareSetThreshold(channel,delay);
	}
}

DUTY_CYCLE pwmGetDutyCycle(const IOPin* pin){
	DUTY_CYCLE rtn = 0;
  ae:	80 e0       	ldi	r24, 0x00	; 0
		duty /= top;
		rtn = duty;
	}

	return rtn;
}
  b0:	df 91       	pop	r29
  b2:	cf 91       	pop	r28
  b4:	1f 91       	pop	r17
  b6:	0f 91       	pop	r16
  b8:	08 95       	ret

000000ba <pwmOff>:

// Turn PWM off for the given pin
void pwmOff(const IOPin* pin){
  ba:	cf 93       	push	r28
  bc:	df 93       	push	r29
	const TimerCompare* channel = compareFromIOPin(pin);
  be:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  c2:	ec 01       	movw	r28, r24
	if(channel){
  c4:	00 97       	sbiw	r24, 0x00	; 0
  c6:	01 f0       	breq	.+0      	; 0xc8 <pwmOff+0xe>
		compareDetach(channel);
  c8:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
  cc:	60 e0       	ldi	r22, 0x00	; 0
  ce:	ce 01       	movw	r24, r28
	}
}
  d0:	df 91       	pop	r29
  d2:	cf 91       	pop	r28
// Turn PWM off for the given pin
void pwmOff(const IOPin* pin){
	const TimerCompare* channel = compareFromIOPin(pin);
	if(channel){
		compareDetach(channel);
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
  d4:	0c 94 00 00 	jmp	0	; 0x0 <pwmSetDutyCycle>
	}
}
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	08 95       	ret

000000de <pwmInitDeciHertz>:
	}
	return valid;
}

// Set up PWM on the given pin
boolean pwmInitDeciHertz(const IOPin* pin, uint32_t deciHertz, DUTY_CYCLE duty, uint32_t* actualDeciHertz){
  de:	3f 92       	push	r3
  e0:	4f 92       	push	r4
  e2:	5f 92       	push	r5
  e4:	6f 92       	push	r6
  e6:	7f 92       	push	r7
  e8:	8f 92       	push	r8
  ea:	9f 92       	push	r9
  ec:	af 92       	push	r10
  ee:	bf 92       	push	r11
  f0:	cf 92       	push	r12
  f2:	df 92       	push	r13
  f4:	ef 92       	push	r14
  f6:	ff 92       	push	r15
  f8:	0f 93       	push	r16
  fa:	1f 93       	push	r17
  fc:	cf 93       	push	r28
  fe:	df 93       	push	r29
 100:	cd b7       	in	r28, 0x3d	; 61
 102:	de b7       	in	r29, 0x3e	; 62
 104:	29 97       	sbiw	r28, 0x09	; 9
 106:	0f b6       	in	r0, 0x3f	; 63
 108:	f8 94       	cli
 10a:	de bf       	out	0x3e, r29	; 62
 10c:	0f be       	out	0x3f, r0	; 63
 10e:	cd bf       	out	0x3d, r28	; 61
 110:	3c 01       	movw	r6, r24
 112:	32 2e       	mov	r3, r18
 114:	28 01       	movw	r4, r16
	boolean rtn = FALSE;
	const TimerCompare* channel = compareFromIOPin(pin);
 116:	4e 83       	std	Y+6, r20	; 0x06
 118:	5f 83       	std	Y+7, r21	; 0x07
 11a:	68 87       	std	Y+8, r22	; 0x08
 11c:	79 87       	std	Y+9, r23	; 0x09
 11e:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 122:	4c 01       	movw	r8, r24

	if(channel==null){
 124:	4e 81       	ldd	r20, Y+6	; 0x06
 126:	5f 81       	ldd	r21, Y+7	; 0x07
 128:	68 85       	ldd	r22, Y+8	; 0x08
 12a:	79 85       	ldd	r23, Y+9	; 0x09
 12c:	00 97       	sbiw	r24, 0x00	; 0
 12e:	01 f4       	brne	.+0      	; 0x130 <pwmInitDeciHertz+0x52>
		setError(PWM_PIN_NOT_AVAILABLE);
 130:	84 ef       	ldi	r24, 0xF4	; 244
 132:	00 c0       	rjmp	.+0      	; 0x134 <pwmInitDeciHertz+0x56>
	}else{
		// The pin is valid
		if(compareIsInUse(channel)){
 134:	4e 83       	std	Y+6, r20	; 0x06
 136:	5f 83       	std	Y+7, r21	; 0x07
 138:	68 87       	std	Y+8, r22	; 0x08
 13a:	79 87       	std	Y+9, r23	; 0x09
 13c:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 140:	4e 81       	ldd	r20, Y+6	; 0x06
 142:	5f 81       	ldd	r21, Y+7	; 0x07
 144:	68 85       	ldd	r22, Y+8	; 0x08
 146:	79 85       	ldd	r23, Y+9	; 0x09
 148:	88 23       	and	r24, r24
 14a:	01 f0       	breq	.+0      	; 0x14c <pwmInitDeciHertz+0x6e>
			setError(PWM_PIN_IN_USE);
 14c:	83 ef       	ldi	r24, 0xF3	; 243
 14e:	00 c0       	rjmp	.+0      	; 0x150 <pwmInitDeciHertz+0x72>
 150:	f4 01       	movw	r30, r8
 152:	32 96       	adiw	r30, 0x02	; 2
 154:	a4 90       	lpm	r10, Z
			// The pin is valid and available
			TIMER_MODE mode;
			uint16_t icr;
			uint16_t prescaler;

			const Timer* timer = compareGetTimer(channel);
 156:	8c e2       	ldi	r24, 0x2C	; 44
 158:	a8 9e       	mul	r10, r24
 15a:	50 01       	movw	r10, r0
 15c:	11 24       	eor	r1, r1
 15e:	e0 e0       	ldi	r30, 0x00	; 0
 160:	f0 e0       	ldi	r31, 0x00	; 0
 162:	ae 0e       	add	r10, r30
 164:	bf 1e       	adc	r11, r31

			// Find the best PWM setting
			boolean valid = timerCalcPwm(timer, deciHertz, 100, &mode, &icr, &prescaler);
 166:	cc 24       	eor	r12, r12
 168:	c3 94       	inc	r12
 16a:	d1 2c       	mov	r13, r1
 16c:	cc 0e       	add	r12, r28
 16e:	dd 1e       	adc	r13, r29
 170:	93 e0       	ldi	r25, 0x03	; 3
 172:	e9 2e       	mov	r14, r25
 174:	f1 2c       	mov	r15, r1
 176:	ec 0e       	add	r14, r28
 178:	fd 1e       	adc	r15, r29
 17a:	8e 01       	movw	r16, r28
 17c:	0b 5f       	subi	r16, 0xFB	; 251
 17e:	1f 4f       	sbci	r17, 0xFF	; 255
 180:	24 e6       	ldi	r18, 0x64	; 100
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	c5 01       	movw	r24, r10
 186:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 18a:	f5 01       	movw	r30, r10
 18c:	34 96       	adiw	r30, 0x04	; 4

			if(!valid){
 18e:	81 11       	cpse	r24, r1
 190:	00 c0       	rjmp	.+0      	; 0x192 <pwmInitDeciHertz+0xb4>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 192:	85 91       	lpm	r24, Z+
 194:	94 91       	lpm	r25, Z
 196:	fc 01       	movw	r30, r24
 198:	80 81       	ld	r24, Z
 19a:	87 70       	andi	r24, 0x07	; 7
 19c:	01 f4       	brne	.+0      	; 0x19e <pwmInitDeciHertz+0xc0>
				// There is no PWM setting that is valid
				setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 19e:	83 ee       	ldi	r24, 0xE3	; 227
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <pwmInitDeciHertz+0xc4>
 1a2:	82 ef       	ldi	r24, 0xF2	; 242
 1a4:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	return valid;
}

// Set up PWM on the given pin
boolean pwmInitDeciHertz(const IOPin* pin, uint32_t deciHertz, DUTY_CYCLE duty, uint32_t* actualDeciHertz){
	boolean rtn = FALSE;
 1a8:	80 e0       	ldi	r24, 0x00	; 0
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <pwmInitDeciHertz+0xce>
 1ac:	85 91       	lpm	r24, Z+
 1ae:	94 91       	lpm	r25, Z
 1b0:	fc 01       	movw	r30, r24
 1b2:	80 81       	ld	r24, Z
 1b4:	87 70       	andi	r24, 0x07	; 7
 1b6:	01 f0       	breq	.+0      	; 0x1b8 <pwmInitDeciHertz+0xda>
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <pwmInitDeciHertz+0xdc>
				// Lets set up the PWM
				if(!timerIsInUse(timer)){
					timerSetMode(timer,mode);
					if(modeIsICR(mode)){
						// Set the ICR
						PORT icrPort = pgm_read_word(&timer->pgm_icr);
 1ba:	f5 01       	movw	r30, r10
 1bc:	7f 96       	adiw	r30, 0x1f	; 31
 1be:	85 91       	lpm	r24, Z+
 1c0:	94 91       	lpm	r25, Z
						_SFR_MEM16(icrPort)=icr;
 1c2:	fc 01       	movw	r30, r24
 1c4:	8b 81       	ldd	r24, Y+3	; 0x03
 1c6:	9c 81       	ldd	r25, Y+4	; 0x04
 1c8:	91 83       	std	Z+1, r25	; 0x01
 1ca:	80 83       	st	Z, r24
					// Can't change the prescaler so just use the existing
					prescaler = timerGetPrescaler(timer);
				}

				// Mark the channel as in use
				compareAttach(channel,&nullTimerCompareCallback,0,null);
 1cc:	20 e0       	ldi	r18, 0x00	; 0
 1ce:	30 e0       	ldi	r19, 0x00	; 0
 1d0:	40 e0       	ldi	r20, 0x00	; 0
 1d2:	50 e0       	ldi	r21, 0x00	; 0
 1d4:	60 e0       	ldi	r22, 0x00	; 0
 1d6:	70 e0       	ldi	r23, 0x00	; 0
 1d8:	c4 01       	movw	r24, r8
 1da:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn the pin into an output, low
				pin_make_output(pin, FALSE);
 1de:	60 e0       	ldi	r22, 0x00	; 0
 1e0:	c3 01       	movw	r24, r6
 1e2:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn on the PWM pin output
				compareSetOutputMode(channel, CHANNEL_MODE_NON_INVERTING);
 1e6:	62 e0       	ldi	r22, 0x02	; 2
 1e8:	c4 01       	movw	r24, r8
 1ea:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn on the timer
				timerSetPrescaler(timer,prescaler);
 1ee:	69 81       	ldd	r22, Y+1	; 0x01
 1f0:	7a 81       	ldd	r23, Y+2	; 0x02
 1f2:	c5 01       	movw	r24, r10
 1f4:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Set the initial duty cycle
				pwmSetDutyCycle(pin,duty);
 1f8:	63 2d       	mov	r22, r3
 1fa:	c3 01       	movw	r24, r6
 1fc:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Set the return value
				if(actualDeciHertz){
 200:	41 14       	cp	r4, r1
 202:	51 04       	cpc	r5, r1
 204:	01 f0       	breq	.+0      	; 0x206 <pwmInitDeciHertz+0x128>
					*actualDeciHertz = TimerGetPwmDeciHertz(timer);
 206:	c5 01       	movw	r24, r10
 208:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 20c:	f2 01       	movw	r30, r4
 20e:	60 83       	st	Z, r22
 210:	71 83       	std	Z+1, r23	; 0x01
 212:	82 83       	std	Z+2, r24	; 0x02
 214:	93 83       	std	Z+3, r25	; 0x03
				}

				rtn = TRUE;
 216:	8f ef       	ldi	r24, 0xFF	; 255
 218:	00 c0       	rjmp	.+0      	; 0x21a <pwmInitDeciHertz+0x13c>
				// There is no PWM setting that is valid
				setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
			}else{
				// Lets set up the PWM
				if(!timerIsInUse(timer)){
					timerSetMode(timer,mode);
 21a:	6d 81       	ldd	r22, Y+5	; 0x05
 21c:	c5 01       	movw	r24, r10
 21e:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
					if(modeIsICR(mode)){
 222:	41 e0       	ldi	r20, 0x01	; 1
 224:	50 e0       	ldi	r21, 0x00	; 0
 226:	0d 80       	ldd	r0, Y+5	; 0x05
 228:	00 c0       	rjmp	.+0      	; 0x22a <pwmInitDeciHertz+0x14c>
 22a:	44 0f       	add	r20, r20
 22c:	55 1f       	adc	r21, r21
 22e:	0a 94       	dec	r0
 230:	02 f4       	brpl	.+0      	; 0x232 <pwmInitDeciHertz+0x154>
 232:	44 27       	eor	r20, r20
 234:	55 75       	andi	r21, 0x55	; 85
 236:	45 2b       	or	r20, r21
 238:	01 f0       	breq	.+0      	; 0x23a <pwmInitDeciHertz+0x15c>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <pwmInitDeciHertz+0x15e>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <pwmInitDeciHertz+0x160>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 23e:	f5 01       	movw	r30, r10
 240:	a5 91       	lpm	r26, Z+
 242:	b4 91       	lpm	r27, Z
						PORT icrPort = pgm_read_word(&timer->pgm_icr);
						_SFR_MEM16(icrPort)=icr;
					}
				}else{
					// Can't change the prescaler so just use the existing
					prescaler = timerGetPrescaler(timer);
 244:	8d 91       	ld	r24, X+
 246:	9c 91       	ld	r25, X
 248:	9a 83       	std	Y+2, r25	; 0x02
 24a:	89 83       	std	Y+1, r24	; 0x01
 24c:	00 c0       	rjmp	.+0      	; 0x24e <pwmInitDeciHertz+0x170>
			}

		}
	}
	return rtn;
}
 24e:	29 96       	adiw	r28, 0x09	; 9
 250:	0f b6       	in	r0, 0x3f	; 63
 252:	f8 94       	cli
 254:	de bf       	out	0x3e, r29	; 62
 256:	0f be       	out	0x3f, r0	; 63
 258:	cd bf       	out	0x3d, r28	; 61
 25a:	df 91       	pop	r29
 25c:	cf 91       	pop	r28
 25e:	1f 91       	pop	r17
 260:	0f 91       	pop	r16
 262:	ff 90       	pop	r15
 264:	ef 90       	pop	r14
 266:	df 90       	pop	r13
 268:	cf 90       	pop	r12
 26a:	bf 90       	pop	r11
 26c:	af 90       	pop	r10
 26e:	9f 90       	pop	r9
 270:	8f 90       	pop	r8
 272:	7f 90       	pop	r7
 274:	6f 90       	pop	r6
 276:	5f 90       	pop	r5
 278:	4f 90       	pop	r4
 27a:	3f 90       	pop	r3
 27c:	08 95       	ret

0000027e <pwmInitHertz>:
		compareDetach(channel);
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
	}
}

boolean pwmInitHertz(const IOPin* pin, uint32_t hertz, DUTY_CYCLE duty, uint32_t* actualHertz){
 27e:	bf 92       	push	r11
 280:	cf 92       	push	r12
 282:	df 92       	push	r13
 284:	ef 92       	push	r14
 286:	ff 92       	push	r15
 288:	0f 93       	push	r16
 28a:	1f 93       	push	r17
 28c:	cf 93       	push	r28
 28e:	df 93       	push	r29
 290:	fc 01       	movw	r30, r24
 292:	6a 01       	movw	r12, r20
 294:	7b 01       	movw	r14, r22
 296:	b2 2e       	mov	r11, r18
 298:	e8 01       	movw	r28, r16
	uint32_t deciHertz;
	deciHertz = hertz * 10;
 29a:	aa e0       	ldi	r26, 0x0A	; 10
 29c:	b0 e0       	ldi	r27, 0x00	; 0
 29e:	9a 01       	movw	r18, r20
 2a0:	ab 01       	movw	r20, r22
 2a2:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2a6:	ab 01       	movw	r20, r22
 2a8:	bc 01       	movw	r22, r24
	// Check for overflow
	if(deciHertz < hertz){
 2aa:	4c 15       	cp	r20, r12
 2ac:	5d 05       	cpc	r21, r13
 2ae:	6e 05       	cpc	r22, r14
 2b0:	7f 05       	cpc	r23, r15
 2b2:	00 f4       	brcc	.+0      	; 0x2b4 <pwmInitHertz+0x36>
		deciHertz = PWM_FASTEST;
 2b4:	4f ef       	ldi	r20, 0xFF	; 255
 2b6:	5f ef       	ldi	r21, 0xFF	; 255
 2b8:	ba 01       	movw	r22, r20
	}

	// Now do it
	boolean valid = pwmInitDeciHertz(pin, deciHertz, duty, actualHertz);
 2ba:	8e 01       	movw	r16, r28
 2bc:	2b 2d       	mov	r18, r11
 2be:	cf 01       	movw	r24, r30
 2c0:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2c4:	18 2f       	mov	r17, r24

	if(valid==TRUE && actualHertz!=null){
 2c6:	8f 3f       	cpi	r24, 0xFF	; 255
 2c8:	01 f4       	brne	.+0      	; 0x2ca <pwmInitHertz+0x4c>
 2ca:	20 97       	sbiw	r28, 0x00	; 0
 2cc:	01 f0       	breq	.+0      	; 0x2ce <pwmInitHertz+0x50>
		*actualHertz = *actualHertz /10;
 2ce:	68 81       	ld	r22, Y
 2d0:	79 81       	ldd	r23, Y+1	; 0x01
 2d2:	8a 81       	ldd	r24, Y+2	; 0x02
 2d4:	9b 81       	ldd	r25, Y+3	; 0x03
 2d6:	2a e0       	ldi	r18, 0x0A	; 10
 2d8:	30 e0       	ldi	r19, 0x00	; 0
 2da:	40 e0       	ldi	r20, 0x00	; 0
 2dc:	50 e0       	ldi	r21, 0x00	; 0
 2de:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2e2:	28 83       	st	Y, r18
 2e4:	39 83       	std	Y+1, r19	; 0x01
 2e6:	4a 83       	std	Y+2, r20	; 0x02
 2e8:	5b 83       	std	Y+3, r21	; 0x03
	}
	return valid;
}
 2ea:	81 2f       	mov	r24, r17
 2ec:	df 91       	pop	r29
 2ee:	cf 91       	pop	r28
 2f0:	1f 91       	pop	r17
 2f2:	0f 91       	pop	r16
 2f4:	ff 90       	pop	r15
 2f6:	ef 90       	pop	r14
 2f8:	df 90       	pop	r13
 2fa:	cf 90       	pop	r12
 2fc:	bf 90       	pop	r11
 2fe:	08 95       	ret

rprintf.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000002  00000000  00000000  000000e4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  000000e6  2**0
                  ALLOC
  3 .progmem.data 00000011  00000000  00000000  000000e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000003ae  00000000  00000000  000000f7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000206  00000000  00000000  000004a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000027e  00000000  00000000  000006ab  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000929  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000103  00000000  00000000  00000949  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000001bc  00000000  00000000  00000a4c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00000c08  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000c4  00000000  00000000  00000c34  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfIgnore>:
const char PROGMEM HexChars[] = "0123456789ABCDEF";


MAKE_WRITER(rprintfIgnore){
	return byte;
}
   0:	08 95       	ret

00000002 <rprintfInit>:

// you must call this function once and supply the character output
// routine before using other functions in this library
Writer rprintfInit(Writer putchar_func){
	Writer rtn;
	CRITICAL_SECTION{
   2:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
   4:	f8 94       	cli
		rtn = rputchar;
   6:	20 91 00 00 	lds	r18, 0x0000
   a:	30 91 00 00 	lds	r19, 0x0000
		rputchar = putchar_func;
   e:	90 93 00 00 	sts	0x0000, r25
  12:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  16:	4f bf       	out	0x3f, r20	; 63
	}
	return rtn;
}
  18:	c9 01       	movw	r24, r18
  1a:	08 95       	ret

0000001c <rprintfChar>:


// send a character/byte to the current output device
void rprintfChar(uint8_t c)
{
  1c:	cf 93       	push	r28
  1e:	c8 2f       	mov	r28, r24
	// do LF -> CR/LF translation
	if(c == '\n')
  20:	8a 30       	cpi	r24, 0x0A	; 10
  22:	01 f4       	brne	.+0      	; 0x24 <rprintfChar+0x8>
		rputchar('\r');
  24:	e0 91 00 00 	lds	r30, 0x0000
  28:	f0 91 00 00 	lds	r31, 0x0000
  2c:	8d e0       	ldi	r24, 0x0D	; 13
  2e:	09 95       	icall
	// send character
	rputchar(c);
  30:	e0 91 00 00 	lds	r30, 0x0000
  34:	f0 91 00 00 	lds	r31, 0x0000
  38:	8c 2f       	mov	r24, r28
}
  3a:	cf 91       	pop	r28
{
	// do LF -> CR/LF translation
	if(c == '\n')
		rputchar('\r');
	// send character
	rputchar(c);
  3c:	09 94       	ijmp

0000003e <rprintfCharN>:
}

void rprintfCharN(uint8_t c, size_t repeat){
  3e:	1f 93       	push	r17
  40:	cf 93       	push	r28
  42:	df 93       	push	r29
  44:	18 2f       	mov	r17, r24
  46:	eb 01       	movw	r28, r22
	while(repeat-- > 0){
  48:	00 c0       	rjmp	.+0      	; 0x4a <rprintfCharN+0xc>
		rprintfChar(c);
  4a:	81 2f       	mov	r24, r17
  4c:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
  50:	21 97       	sbiw	r28, 0x01	; 1
	// send character
	rputchar(c);
}

void rprintfCharN(uint8_t c, size_t repeat){
	while(repeat-- > 0){
  52:	20 97       	sbiw	r28, 0x00	; 0
  54:	01 f4       	brne	.+0      	; 0x56 <rprintfCharN+0x18>
		rprintfChar(c);
	}
}
  56:	df 91       	pop	r29
  58:	cf 91       	pop	r28
  5a:	1f 91       	pop	r17
  5c:	08 95       	ret

0000005e <rprintfStr>:


// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
  5e:	cf 93       	push	r28
  60:	df 93       	push	r29
	// send a string stored in RAM
	if(str){
  62:	00 97       	sbiw	r24, 0x00	; 0
  64:	01 f0       	breq	.+0      	; 0x66 <rprintfStr+0x8>
  66:	ec 01       	movw	r28, r24
  68:	00 c0       	rjmp	.+0      	; 0x6a <rprintfStr+0xc>
		// print the string until a null-terminator
		while (*str)
			rprintfChar(*str++);
  6a:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
void rprintfStr(char str[])
{
	// send a string stored in RAM
	if(str){
		// print the string until a null-terminator
		while (*str)
  6e:	89 91       	ld	r24, Y+
  70:	81 11       	cpse	r24, r1
  72:	00 c0       	rjmp	.+0      	; 0x74 <rprintfStr+0x16>
			rprintfChar(*str++);
	}
}
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	08 95       	ret

0000007a <rprintfProgStr>:


// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
  7a:	cf 93       	push	r28
  7c:	df 93       	push	r29
	if(str){
  7e:	00 97       	sbiw	r24, 0x00	; 0
  80:	01 f0       	breq	.+0      	; 0x82 <rprintfProgStr+0x8>
  82:	ec 01       	movw	r28, r24
  84:	00 c0       	rjmp	.+0      	; 0x86 <rprintfProgStr+0xc>
		// print a string stored in program memory
		register char c;

		// print the string until the null-terminator
		while((c = pgm_read_byte(str++)))
			rprintfChar(c);
  86:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
	if(str){
		// print a string stored in program memory
		register char c;

		// print the string until the null-terminator
		while((c = pgm_read_byte(str++)))
  8a:	fe 01       	movw	r30, r28
  8c:	84 91       	lpm	r24, Z
  8e:	22 96       	adiw	r28, 0x02	; 2
  90:	81 11       	cpse	r24, r1
  92:	00 c0       	rjmp	.+0      	; 0x94 <rprintfProgStr+0x1a>
			rprintfChar(c);
	}
}
  94:	df 91       	pop	r29
  96:	cf 91       	pop	r28
  98:	08 95       	ret

0000009a <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
  9a:	8a e0       	ldi	r24, 0x0A	; 10
  9c:	0c 94 00 00 	jmp	0	; 0x0 <rprintfIgnore>

000000a0 <rprintfu04>:

// prints an unsigned 4-bit number in hex (1 digit)
void rprintfu04(uint8_t data)
{
	// print 4-bit hex value
	rprintfChar(hexchar(data));
  a0:	8f 70       	andi	r24, 0x0F	; 15
  a2:	e8 2f       	mov	r30, r24
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	e0 50       	subi	r30, 0x00	; 0
  a8:	f0 40       	sbci	r31, 0x00	; 0
  aa:	84 91       	lpm	r24, Z
  ac:	0c 94 00 00 	jmp	0	; 0x0 <rprintfIgnore>

rprintfHexDump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000016c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001a0  2**0
                  ALLOC
  3 .progmem.data 00000042  00000000  00000000  000001a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000002af  00000000  00000000  000001e2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000122  00000000  00000000  00000491  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000002f3  00000000  00000000  000005b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000008a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  000008c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000010b  00000000  00000000  000008de  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000015a  00000000  00000000  000009e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00000b43  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000088  00000000  00000000  00000b70  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfMemoryDump>:

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
   0:	5f 92       	push	r5
   2:	6f 92       	push	r6
   4:	7f 92       	push	r7
   6:	8f 92       	push	r8
   8:	9f 92       	push	r9
   a:	af 92       	push	r10
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	ec 01       	movw	r28, r24
  20:	8b 01       	movw	r16, r22
  22:	6a 01       	movw	r12, r20
    int x;
    int c;
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	9f 93       	push	r25
  2a:	8f 93       	push	r24
  2c:	81 e0       	ldi	r24, 0x01	; 1
  2e:	8f 93       	push	r24
  30:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    rprintfCharN('-',72); rprintfCRLF();
  34:	68 e4       	ldi	r22, 0x48	; 72
  36:	70 e0       	ldi	r23, 0x00	; 0
  38:	8d e2       	ldi	r24, 0x2D	; 45
  3a:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  3e:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  42:	c6 01       	movw	r24, r12
  44:	24 e0       	ldi	r18, 0x04	; 4
  46:	96 95       	lsr	r25
  48:	87 95       	ror	r24
  4a:	2a 95       	dec	r18
  4c:	01 f4       	brne	.+0      	; 0x4e <rprintfMemoryDump+0x4e>
  4e:	9c 01       	movw	r18, r24
  50:	2f 5f       	subi	r18, 0xFF	; 255
  52:	3f 4f       	sbci	r19, 0xFF	; 255

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  54:	c0 0f       	add	r28, r16
  56:	d1 1f       	adc	r29, r17
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	0f 90       	pop	r0
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  5e:	a6 01       	movw	r20, r12
  60:	4f 70       	andi	r20, 0x0F	; 15
  62:	55 27       	eor	r21, r21

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  64:	45 2b       	or	r20, r21
  66:	01 f0       	breq	.+0      	; 0x68 <rprintfMemoryDump+0x68>
  68:	83 2f       	mov	r24, r19
  6a:	00 c0       	rjmp	.+0      	; 0x6c <rprintfMemoryDump+0x6c>
  6c:	28 2f       	mov	r18, r24
  6e:	89 2f       	mov	r24, r25
  70:	a2 2e       	mov	r10, r18
  72:	b8 2e       	mov	r11, r24
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  74:	00 e0       	ldi	r16, 0x00	; 0
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	81 2c       	mov	r8, r1
  7a:	91 2c       	mov	r9, r1
    	int line16 = line * 16;
    	rprintfu16(line16);
        rprintf("| ");
  7c:	80 e0       	ldi	r24, 0x00	; 0
  7e:	68 2e       	mov	r6, r24
  80:	80 e0       	ldi	r24, 0x00	; 0
  82:	78 2e       	mov	r7, r24
  84:	55 24       	eor	r5, r5
  86:	53 94       	inc	r5
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  88:	00 c0       	rjmp	.+0      	; 0x8a <rprintfMemoryDump+0x8a>
    	int line16 = line * 16;
    	rprintfu16(line16);
  8a:	c8 01       	movw	r24, r16
  8c:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
        rprintf("| ");
  90:	7f 92       	push	r7
  92:	6f 92       	push	r6
  94:	5f 92       	push	r5
  96:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  9a:	0f 90       	pop	r0
  9c:	0f 90       	pop	r0
  9e:	0f 90       	pop	r0

        // put hex values
        for(x = 0; x < 16; x++){
  a0:	e1 2c       	mov	r14, r1
  a2:	f1 2c       	mov	r15, r1
            if(x + line16 < len){
  a4:	c7 01       	movw	r24, r14
  a6:	80 0f       	add	r24, r16
  a8:	91 1f       	adc	r25, r17
  aa:	8c 15       	cp	r24, r12
  ac:	9d 05       	cpc	r25, r13
  ae:	00 f4       	brcc	.+0      	; 0xb0 <rprintfMemoryDump+0xb0>

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  b0:	fe 01       	movw	r30, r28
  b2:	ee 0d       	add	r30, r14
  b4:	ff 1d       	adc	r31, r15

        // put hex values
        for(x = 0; x < 16; x++){
            if(x + line16 < len){
                c = b[off + x + line16];
                rprintfu08(c);
  b6:	80 81       	ld	r24, Z
  b8:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
                rprintfChar(' ');
  bc:	80 e2       	ldi	r24, 0x20	; 32
  be:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <rprintfMemoryDump+0xc4>
            }else{
                rprintfCharN(' ',3);
  c4:	63 e0       	ldi	r22, 0x03	; 3
  c6:	70 e0       	ldi	r23, 0x00	; 0
  c8:	80 e2       	ldi	r24, 0x20	; 32
  ca:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    	int line16 = line * 16;
    	rprintfu16(line16);
        rprintf("| ");

        // put hex values
        for(x = 0; x < 16; x++){
  ce:	8f ef       	ldi	r24, 0xFF	; 255
  d0:	e8 1a       	sub	r14, r24
  d2:	f8 0a       	sbc	r15, r24
  d4:	80 e1       	ldi	r24, 0x10	; 16
  d6:	e8 16       	cp	r14, r24
  d8:	f1 04       	cpc	r15, r1
  da:	01 f4       	brne	.+0      	; 0xdc <rprintfMemoryDump+0xdc>
                rprintfChar(' ');
            }else{
                rprintfCharN(' ',3);
            }
        }
        rprintfChar('|');rprintfChar(' ');
  dc:	8c e7       	ldi	r24, 0x7C	; 124
  de:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  e2:	80 e2       	ldi	r24, 0x20	; 32
  e4:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>

        // put ascii values
        for(x = 0; x < 16; x++){
  e8:	e1 2c       	mov	r14, r1
  ea:	f1 2c       	mov	r15, r1
            if(x + line16 < len){
  ec:	c7 01       	movw	r24, r14
  ee:	80 0f       	add	r24, r16
  f0:	91 1f       	adc	r25, r17
  f2:	8c 15       	cp	r24, r12
  f4:	9d 05       	cpc	r25, r13
  f6:	00 f4       	brcc	.+0      	; 0xf8 <rprintfMemoryDump+0xf8>

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  f8:	fe 01       	movw	r30, r28
  fa:	ee 0d       	add	r30, r14
  fc:	ff 1d       	adc	r31, r15
        rprintfChar('|');rprintfChar(' ');

        // put ascii values
        for(x = 0; x < 16; x++){
            if(x + line16 < len){
                c = b[off + x + line16];
  fe:	80 81       	ld	r24, Z
                if((c > 0x1f) && (c < 0x7f)){
 100:	28 2f       	mov	r18, r24
 102:	30 e0       	ldi	r19, 0x00	; 0
 104:	20 52       	subi	r18, 0x20	; 32
 106:	31 09       	sbc	r19, r1
 108:	2f 35       	cpi	r18, 0x5F	; 95
 10a:	31 05       	cpc	r19, r1
 10c:	00 f4       	brcc	.+0      	; 0x10e <rprintfMemoryDump+0x10e>
 10e:	00 c0       	rjmp	.+0      	; 0x110 <rprintfMemoryDump+0x110>
                	// ascii
                    rprintfChar((unsigned char)c);
                }else{
                	// non ascii
                	rprintfChar('.');
 110:	8e e2       	ldi	r24, 0x2E	; 46
 112:	00 c0       	rjmp	.+0      	; 0x114 <rprintfMemoryDump+0x114>
                }
             }else{
             	rprintfChar(' ');
 114:	80 e2       	ldi	r24, 0x20	; 32
 116:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
            }
        }
        rprintfChar('|');rprintfChar(' ');

        // put ascii values
        for(x = 0; x < 16; x++){
 11a:	8f ef       	ldi	r24, 0xFF	; 255
 11c:	e8 1a       	sub	r14, r24
 11e:	f8 0a       	sbc	r15, r24
 120:	80 e1       	ldi	r24, 0x10	; 16
 122:	e8 16       	cp	r14, r24
 124:	f1 04       	cpc	r15, r1
 126:	01 f4       	brne	.+0      	; 0x128 <rprintfMemoryDump+0x128>
                }
             }else{
             	rprintfChar(' ');
             }
        }
        rprintfCRLF();
 128:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
 12c:	8f ef       	ldi	r24, 0xFF	; 255
 12e:	88 1a       	sub	r8, r24
 130:	98 0a       	sbc	r9, r24
 132:	60 96       	adiw	r28, 0x10	; 16
 134:	00 5f       	subi	r16, 0xF0	; 240
 136:	1f 4f       	sbci	r17, 0xFF	; 255
 138:	8a 14       	cp	r8, r10
 13a:	9b 04       	cpc	r9, r11
 13c:	01 f0       	breq	.+0      	; 0x13e <rprintfMemoryDump+0x13e>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <rprintfMemoryDump+0x140>
             	rprintfChar(' ');
             }
        }
        rprintfCRLF();
    }
    rprintfCharN('-',72); rprintfCRLF();
 140:	68 e4       	ldi	r22, 0x48	; 72
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	8d e2       	ldi	r24, 0x2D	; 45
 146:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
}
 14a:	df 91       	pop	r29
 14c:	cf 91       	pop	r28
 14e:	1f 91       	pop	r17
 150:	0f 91       	pop	r16
 152:	ff 90       	pop	r15
 154:	ef 90       	pop	r14
 156:	df 90       	pop	r13
 158:	cf 90       	pop	r12
 15a:	bf 90       	pop	r11
 15c:	af 90       	pop	r10
 15e:	9f 90       	pop	r9
 160:	8f 90       	pop	r8
 162:	7f 90       	pop	r7
 164:	6f 90       	pop	r6
 166:	5f 90       	pop	r5
             	rprintfChar(' ');
             }
        }
        rprintfCRLF();
    }
    rprintfCharN('-',72); rprintfCRLF();
 168:	0c 94 00 00 	jmp	0	; 0x0 <rprintfMemoryDump>

rprintfStrLen.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000048  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000007c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000007c  2**0
                  ALLOC
  3 .debug_info   000000fc  00000000  00000000  0000007c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000b1  00000000  00000000  00000178  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000bf  00000000  00000000  00000229  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000002e8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000ee  00000000  00000000  00000308  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000103  00000000  00000000  000003f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000004f9  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000038  00000000  00000000  00000524  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfStrLen>:

// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], size_t start, size_t len)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	8a 01       	movw	r16, r20
	if(str){
   a:	00 97       	sbiw	r24, 0x00	; 0
   c:	01 f0       	breq	.+0      	; 0xe <rprintfStrLen+0xe>


// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], size_t start, size_t len)
   e:	68 0f       	add	r22, r24
  10:	79 1f       	adc	r23, r25
  12:	ec 01       	movw	r28, r24
	if(str){
		register size_t i=0;

		// spin through characters up to requested start
		// keep going as long as there's no null
		while( (i++<start) && (*str) ){
  14:	86 17       	cp	r24, r22
  16:	97 07       	cpc	r25, r23
  18:	01 f0       	breq	.+0      	; 0x1a <rprintfStrLen+0x1a>
  1a:	01 96       	adiw	r24, 0x01	; 1
  1c:	28 81       	ld	r18, Y
  1e:	21 11       	cpse	r18, r1
  20:	00 c0       	rjmp	.+0      	; 0x22 <rprintfStrLen+0x22>
  22:	00 c0       	rjmp	.+0      	; 0x24 <rprintfStrLen+0x24>
		// then print exactly len characters
		while(len--)
		{
			// print data out of the string as long as we haven't reached a null yet
			// at the null, start printing spaces
			rprintfChar( (*str) ? *str++ : ' ');
  24:	88 81       	ld	r24, Y
  26:	88 23       	and	r24, r24
  28:	01 f0       	breq	.+0      	; 0x2a <rprintfStrLen+0x2a>
  2a:	21 96       	adiw	r28, 0x01	; 1
  2c:	00 c0       	rjmp	.+0      	; 0x2e <rprintfStrLen+0x2e>
  2e:	80 e2       	ldi	r24, 0x20	; 32
  30:	0e 94 00 00 	call	0	; 0x0 <rprintfStrLen>
  34:	01 50       	subi	r16, 0x01	; 1
  36:	11 09       	sbc	r17, r1
		while( (i++<start) && (*str) ){
			str++;
		}

		// then print exactly len characters
		while(len--)
  38:	01 15       	cp	r16, r1
  3a:	11 05       	cpc	r17, r1
  3c:	01 f4       	brne	.+0      	; 0x3e <rprintfStrLen+0x3e>
			// print data out of the string as long as we haven't reached a null yet
			// at the null, start printing spaces
			rprintfChar( (*str) ? *str++ : ' ');
		}
	}
}
  3e:	df 91       	pop	r29
  40:	cf 91       	pop	r28
  42:	1f 91       	pop	r17
  44:	0f 91       	pop	r16
  46:	08 95       	ret

rprintfc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ee  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000622  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000029  00000000  00000000  00000622  2**0
                  ALLOC
  3 .rodata.str1.1 00000006  00000000  00000000  00000622  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000658  00000000  00000000  00000628  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001a8  00000000  00000000  00000c80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000c53  00000000  00000000  00000e28  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001a7b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   000002e0  00000000  00000000  00001a9b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000193  00000000  00000000  00001d7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001f0e  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000a4  00000000  00000000  00001f38  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <Isdigit>:
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
   0:	80 53       	subi	r24, 0x30	; 48
   2:	8a 30       	cpi	r24, 0x0A	; 10
   4:	00 f4       	brcc	.+0      	; 0x6 <Isdigit+0x6>
   6:	8f ef       	ldi	r24, 0xFF	; 255
   8:	08 95       	ret
   a:	80 e0       	ldi	r24, 0x00	; 0
}
   c:	08 95       	ret

0000000e <atoiRamRom>:

int atoiRamRom(boolean stringInRom, char *str)
{
   e:	fb 01       	movw	r30, r22
	int num = 0;
  10:	20 e0       	ldi	r18, 0x00	; 0
  12:	30 e0       	ldi	r19, 0x00	; 0

	while(Isdigit(READMEMBYTE(stringInRom,str)))
	{
		num *= 10;
  14:	6a e0       	ldi	r22, 0x0A	; 10

int atoiRamRom(boolean stringInRom, char *str)
{
	int num = 0;

	while(Isdigit(READMEMBYTE(stringInRom,str)))
  16:	00 c0       	rjmp	.+0      	; 0x18 <atoiRamRom+0xa>
	{
		num *= 10;
		num += ((READMEMBYTE(stringInRom,str++)) - '0');
  18:	24 91       	lpm	r18, Z
  1a:	00 c0       	rjmp	.+0      	; 0x1c <atoiRamRom+0xe>
  1c:	20 81       	ld	r18, Z
  1e:	30 e0       	ldi	r19, 0x00	; 0
  20:	20 53       	subi	r18, 0x30	; 48
  22:	31 09       	sbc	r19, r1
  24:	24 0f       	add	r18, r20
  26:	35 1f       	adc	r19, r21
  28:	31 96       	adiw	r30, 0x01	; 1

int atoiRamRom(boolean stringInRom, char *str)
{
	int num = 0;

	while(Isdigit(READMEMBYTE(stringInRom,str)))
  2a:	88 23       	and	r24, r24
  2c:	01 f0       	breq	.+0      	; 0x2e <atoiRamRom+0x20>
  2e:	94 91       	lpm	r25, Z
  30:	00 c0       	rjmp	.+0      	; 0x32 <atoiRamRom+0x24>
  32:	90 81       	ld	r25, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
  34:	90 53       	subi	r25, 0x30	; 48
  36:	9a 30       	cpi	r25, 0x0A	; 10
  38:	00 f4       	brcc	.+0      	; 0x3a <atoiRamRom+0x2c>
{
	int num = 0;

	while(Isdigit(READMEMBYTE(stringInRom,str)))
	{
		num *= 10;
  3a:	62 9f       	mul	r22, r18
  3c:	a0 01       	movw	r20, r0
  3e:	63 9f       	mul	r22, r19
  40:	50 0d       	add	r21, r0
  42:	11 24       	eor	r1, r1
		num += ((READMEMBYTE(stringInRom,str++)) - '0');
  44:	81 11       	cpse	r24, r1
  46:	00 c0       	rjmp	.+0      	; 0x48 <atoiRamRom+0x3a>
  48:	00 c0       	rjmp	.+0      	; 0x4a <atoiRamRom+0x3c>
	}
	return num;
}
  4a:	c9 01       	movw	r24, r18
  4c:	08 95       	ret

0000004e <rprintf2RamRom>:
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
{
  4e:	2f 92       	push	r2
  50:	3f 92       	push	r3
  52:	4f 92       	push	r4
  54:	5f 92       	push	r5
  56:	6f 92       	push	r6
  58:	7f 92       	push	r7
  5a:	8f 92       	push	r8
  5c:	9f 92       	push	r9
  5e:	af 92       	push	r10
  60:	bf 92       	push	r11
  62:	cf 92       	push	r12
  64:	df 92       	push	r13
  66:	ef 92       	push	r14
  68:	ff 92       	push	r15
  6a:	0f 93       	push	r16
  6c:	1f 93       	push	r17
  6e:	cf 93       	push	r28
  70:	df 93       	push	r29
  72:	00 d0       	rcall	.+0      	; 0x74 <rprintf2RamRom+0x26>
  74:	00 d0       	rcall	.+0      	; 0x76 <rprintf2RamRom+0x28>
  76:	1f 92       	push	r1
  78:	cd b7       	in	r28, 0x3d	; 61
  7a:	de b7       	in	r29, 0x3e	; 62
  7c:	fa 8c       	ldd	r15, Y+26	; 0x1a
  7e:	3b 8d       	ldd	r19, Y+27	; 0x1b
  80:	2c 8d       	ldd	r18, Y+28	; 0x1c
	register unsigned char pad = ' ';
	int flush_left = 0, f_width = 0, prec = INF, hash = 0, do_long = 0;
	int sign = 0;

	va_list ap;
	va_start(ap, sfmt);
  82:	ce 01       	movw	r24, r28
  84:	4d 96       	adiw	r24, 0x1d	; 29
  86:	9a 83       	std	Y+2, r25	; 0x02
  88:	89 83       	std	Y+1, r24	; 0x01

	f = (unsigned char *) sfmt;
  8a:	a3 2e       	mov	r10, r19
  8c:	b2 2e       	mov	r11, r18
						{
							*bp++ = 'x';
							*bp++ = '0';
						}
					}
					i = f_width - (bp - buf);
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	c8 2e       	mov	r12, r24
  92:	80 e0       	ldi	r24, 0x00	; 0
  94:	d8 2e       	mov	r13, r24
								*bp++ = i - 10 + 'a';
						} while ((u /= 16) > 0);
						if (hash)
						{
							*bp++ = 'x';
							*bp++ = '0';
  96:	90 e3       	ldi	r25, 0x30	; 48
  98:	e9 2e       	mov	r14, r25
	va_list ap;
	va_start(ap, sfmt);

	f = (unsigned char *) sfmt;

	for (; READMEMBYTE(stringInRom,f); f++)
  9a:	00 c0       	rjmp	.+0      	; 0x9c <rprintf2RamRom+0x4e>
	{
		if (READMEMBYTE(stringInRom,f) != '%')
  9c:	85 32       	cpi	r24, 0x25	; 37
  9e:	01 f0       	breq	.+0      	; 0xa0 <rprintf2RamRom+0x52>
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <rprintf2RamRom+0x54>
			// then just output the char
			rprintfChar(READMEMBYTE(stringInRom,f));
		}
		else
		{
			f++;						// if we have a "%" then skip it
  a2:	f5 01       	movw	r30, r10
  a4:	31 96       	adiw	r30, 0x01	; 1
			if (READMEMBYTE(stringInRom,f) == '-')
  a6:	ff 20       	and	r15, r15
  a8:	01 f0       	breq	.+0      	; 0xaa <rprintf2RamRom+0x5c>
  aa:	84 91       	lpm	r24, Z
  ac:	00 c0       	rjmp	.+0      	; 0xae <rprintf2RamRom+0x60>
  ae:	d5 01       	movw	r26, r10
  b0:	11 96       	adiw	r26, 0x01	; 1
  b2:	8c 91       	ld	r24, X
  b4:	8d 32       	cpi	r24, 0x2D	; 45
  b6:	01 f4       	brne	.+0      	; 0xb8 <rprintf2RamRom+0x6a>
			{
				flush_left = 1;	// minus: flush left
				f++;
  b8:	f5 01       	movw	r30, r10
  ba:	32 96       	adiw	r30, 0x02	; 2
		else
		{
			f++;						// if we have a "%" then skip it
			if (READMEMBYTE(stringInRom,f) == '-')
			{
				flush_left = 1;	// minus: flush left
  bc:	66 24       	eor	r6, r6
  be:	63 94       	inc	r6
  c0:	71 2c       	mov	r7, r1
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <rprintf2RamRom+0x76>
			rprintfChar(READMEMBYTE(stringInRom,f));
		}
		else
		{
			f++;						// if we have a "%" then skip it
			if (READMEMBYTE(stringInRom,f) == '-')
  c4:	61 2c       	mov	r6, r1
  c6:	71 2c       	mov	r7, r1
			{
				flush_left = 1;	// minus: flush left
				f++;
			}
            if (READMEMBYTE(stringInRom,f) == '0'
  c8:	ff 20       	and	r15, r15
  ca:	01 f0       	breq	.+0      	; 0xcc <rprintf2RamRom+0x7e>
  cc:	84 91       	lpm	r24, Z
  ce:	80 33       	cpi	r24, 0x30	; 48
  d0:	01 f4       	brne	.+0      	; 0xd2 <rprintf2RamRom+0x84>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <rprintf2RamRom+0x86>
  d4:	80 81       	ld	r24, Z
  d6:	80 33       	cpi	r24, 0x30	; 48
  d8:	01 f4       	brne	.+0      	; 0xda <rprintf2RamRom+0x8c>
  da:	00 c0       	rjmp	.+0      	; 0xdc <rprintf2RamRom+0x8e>
				 || READMEMBYTE(stringInRom,f) == '.')
  dc:	8e 32       	cpi	r24, 0x2E	; 46
  de:	01 f0       	breq	.+0      	; 0xe0 <rprintf2RamRom+0x92>
  e0:	b0 e2       	ldi	r27, 0x20	; 32
  e2:	bb 83       	std	Y+3, r27	; 0x03
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <rprintf2RamRom+0x98>
  e6:	8e 32       	cpi	r24, 0x2E	; 46
  e8:	01 f4       	brne	.+0      	; 0xea <rprintf2RamRom+0x9c>
				{
					// padding with 0 rather than blank
					pad = '0';
					f++;
  ea:	31 96       	adiw	r30, 0x01	; 1
            }
            if (READMEMBYTE(stringInRom,f) == '*')
  ec:	ff 20       	and	r15, r15
  ee:	01 f0       	breq	.+0      	; 0xf0 <rprintf2RamRom+0xa2>
			}
            if (READMEMBYTE(stringInRom,f) == '0'
				 || READMEMBYTE(stringInRom,f) == '.')
				{
					// padding with 0 rather than blank
					pad = '0';
  f0:	20 e3       	ldi	r18, 0x30	; 48
  f2:	2b 83       	std	Y+3, r18	; 0x03
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == '*')
  f4:	94 91       	lpm	r25, Z
  f6:	81 e0       	ldi	r24, 0x01	; 1
  f8:	00 c0       	rjmp	.+0      	; 0xfa <rprintf2RamRom+0xac>
			{
				flush_left = 1;	// minus: flush left
				f++;
			}
            if (READMEMBYTE(stringInRom,f) == '0'
				 || READMEMBYTE(stringInRom,f) == '.')
  fa:	30 e2       	ldi	r19, 0x20	; 32
  fc:	3b 83       	std	Y+3, r19	; 0x03
  fe:	00 c0       	rjmp	.+0      	; 0x100 <rprintf2RamRom+0xb2>
				{
					// padding with 0 rather than blank
					pad = '0';
 100:	80 e3       	ldi	r24, 0x30	; 48
 102:	8b 83       	std	Y+3, r24	; 0x03
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == '*')
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	90 81       	ld	r25, Z
 108:	9a 32       	cpi	r25, 0x2A	; 42
 10a:	01 f0       	breq	.+0      	; 0x10c <rprintf2RamRom+0xbe>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	5f 01       	movw	r10, r30
 110:	88 23       	and	r24, r24
 112:	01 f0       	breq	.+0      	; 0x114 <rprintf2RamRom+0xc6>
				{	// field width
					f_width = va_arg(ap, int);
 114:	a9 81       	ldd	r26, Y+1	; 0x01
 116:	ba 81       	ldd	r27, Y+2	; 0x02
 118:	cd 01       	movw	r24, r26
 11a:	02 96       	adiw	r24, 0x02	; 2
 11c:	9a 83       	std	Y+2, r25	; 0x02
 11e:	89 83       	std	Y+1, r24	; 0x01
 120:	4d 90       	ld	r4, X+
 122:	5c 90       	ld	r5, X
					f++;
 124:	5f 01       	movw	r10, r30
 126:	9f ef       	ldi	r25, 0xFF	; 255
 128:	a9 1a       	sub	r10, r25
 12a:	b9 0a       	sbc	r11, r25
 12c:	00 c0       	rjmp	.+0      	; 0x12e <rprintf2RamRom+0xe0>
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
 12e:	ff 20       	and	r15, r15
 130:	01 f0       	breq	.+0      	; 0x132 <rprintf2RamRom+0xe4>
 132:	84 91       	lpm	r24, Z
 134:	00 c0       	rjmp	.+0      	; 0x136 <rprintf2RamRom+0xe8>
 136:	80 81       	ld	r24, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 138:	80 53       	subi	r24, 0x30	; 48
 13a:	8a 30       	cpi	r24, 0x0A	; 10
 13c:	00 f4       	brcc	.+0      	; 0x13e <rprintf2RamRom+0xf0>
 13e:	00 c0       	rjmp	.+0      	; 0x140 <rprintf2RamRom+0xf2>
 140:	41 2c       	mov	r4, r1
 142:	51 2c       	mov	r5, r1
 144:	00 c0       	rjmp	.+0      	; 0x146 <rprintf2RamRom+0xf8>
					f++;
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
					while (Isdigit(READMEMBYTE(stringInRom,f)))
 146:	ff 20       	and	r15, r15
 148:	01 f0       	breq	.+0      	; 0x14a <rprintf2RamRom+0xfc>
 14a:	f5 01       	movw	r30, r10
 14c:	84 91       	lpm	r24, Z
 14e:	00 c0       	rjmp	.+0      	; 0x150 <rprintf2RamRom+0x102>
 150:	d5 01       	movw	r26, r10
 152:	8c 91       	ld	r24, X
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 154:	80 53       	subi	r24, 0x30	; 48
 156:	8a 30       	cpi	r24, 0x0A	; 10
 158:	00 f4       	brcc	.+0      	; 0x15a <rprintf2RamRom+0x10c>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <rprintf2RamRom+0x10e>
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
 15c:	ff 20       	and	r15, r15
 15e:	01 f0       	breq	.+0      	; 0x160 <rprintf2RamRom+0x112>
 160:	f5 01       	movw	r30, r10
 162:	84 91       	lpm	r24, Z
 164:	00 c0       	rjmp	.+0      	; 0x166 <rprintf2RamRom+0x118>
 166:	d5 01       	movw	r26, r10
 168:	8c 91       	ld	r24, X
 16a:	8e 32       	cpi	r24, 0x2E	; 46
 16c:	01 f4       	brne	.+0      	; 0x16e <rprintf2RamRom+0x120>
				{	// precision
					f++;
 16e:	85 01       	movw	r16, r10
 170:	0f 5f       	subi	r16, 0xFF	; 255
 172:	1f 4f       	sbci	r17, 0xFF	; 255
					if (READMEMBYTE(stringInRom,f) == '*')
 174:	ff 20       	and	r15, r15
 176:	01 f0       	breq	.+0      	; 0x178 <rprintf2RamRom+0x12a>
 178:	f8 01       	movw	r30, r16
 17a:	84 91       	lpm	r24, Z
 17c:	00 c0       	rjmp	.+0      	; 0x17e <rprintf2RamRom+0x130>
 17e:	d5 01       	movw	r26, r10
 180:	11 96       	adiw	r26, 0x01	; 1
 182:	8c 91       	ld	r24, X
 184:	8a 32       	cpi	r24, 0x2A	; 42
 186:	01 f4       	brne	.+0      	; 0x188 <rprintf2RamRom+0x13a>
					{
						prec = va_arg(ap, int);
 188:	e9 81       	ldd	r30, Y+1	; 0x01
 18a:	fa 81       	ldd	r31, Y+2	; 0x02
 18c:	cf 01       	movw	r24, r30
 18e:	02 96       	adiw	r24, 0x02	; 2
 190:	9a 83       	std	Y+2, r25	; 0x02
 192:	89 83       	std	Y+1, r24	; 0x01
 194:	80 80       	ld	r8, Z
 196:	91 80       	ldd	r9, Z+1	; 0x01
						f++;
 198:	b2 e0       	ldi	r27, 0x02	; 2
 19a:	ab 0e       	add	r10, r27
 19c:	b1 1c       	adc	r11, r1
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <rprintf2RamRom+0x152>
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 1a0:	80 53       	subi	r24, 0x30	; 48
 1a2:	8a 30       	cpi	r24, 0x0A	; 10
 1a4:	00 f4       	brcc	.+0      	; 0x1a6 <rprintf2RamRom+0x158>
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <rprintf2RamRom+0x15a>
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
				{	// precision
					f++;
 1a8:	58 01       	movw	r10, r16
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <rprintf2RamRom+0x15e>
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
 1ac:	ff 20       	and	r15, r15
 1ae:	01 f0       	breq	.+0      	; 0x1b0 <rprintf2RamRom+0x162>
 1b0:	f5 01       	movw	r30, r10
 1b2:	84 91       	lpm	r24, Z
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <rprintf2RamRom+0x168>
 1b6:	d5 01       	movw	r26, r10
 1b8:	8c 91       	ld	r24, X
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 1ba:	80 53       	subi	r24, 0x30	; 48
 1bc:	8a 30       	cpi	r24, 0x0A	; 10
 1be:	00 f4       	brcc	.+0      	; 0x1c0 <rprintf2RamRom+0x172>
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <rprintf2RamRom+0x174>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <rprintf2RamRom+0x176>
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
 1c4:	18 e2       	ldi	r17, 0x28	; 40
 1c6:	81 2e       	mov	r8, r17
 1c8:	91 2c       	mov	r9, r1
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
 1ca:	ff 20       	and	r15, r15
 1cc:	01 f0       	breq	.+0      	; 0x1ce <rprintf2RamRom+0x180>
 1ce:	f5 01       	movw	r30, r10
 1d0:	84 91       	lpm	r24, Z
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <rprintf2RamRom+0x186>
 1d4:	d5 01       	movw	r26, r10
 1d6:	8c 91       	ld	r24, X
 1d8:	83 32       	cpi	r24, 0x23	; 35
 1da:	01 f4       	brne	.+0      	; 0x1dc <rprintf2RamRom+0x18e>
				{	// alternate form
					hash = 1;
					f++;
 1dc:	bf ef       	ldi	r27, 0xFF	; 255
 1de:	ab 1a       	sub	r10, r27
 1e0:	bb 0a       	sbc	r11, r27
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
				{	// alternate form
					hash = 1;
 1e2:	22 24       	eor	r2, r2
 1e4:	23 94       	inc	r2
 1e6:	31 2c       	mov	r3, r1
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <rprintf2RamRom+0x19c>
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
 1ea:	21 2c       	mov	r2, r1
 1ec:	31 2c       	mov	r3, r1
				{	// alternate form
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
 1ee:	ff 20       	and	r15, r15
 1f0:	01 f0       	breq	.+0      	; 0x1f2 <rprintf2RamRom+0x1a4>
 1f2:	f5 01       	movw	r30, r10
 1f4:	84 91       	lpm	r24, Z
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <rprintf2RamRom+0x1aa>
 1f8:	d5 01       	movw	r26, r10
 1fa:	8c 91       	ld	r24, X
 1fc:	8c 36       	cpi	r24, 0x6C	; 108
 1fe:	01 f4       	brne	.+0      	; 0x200 <rprintf2RamRom+0x1b2>
				{	// long format
					do_long = 1;
					f++;
 200:	bf ef       	ldi	r27, 0xFF	; 255
 202:	ab 1a       	sub	r10, r27
 204:	bb 0a       	sbc	r11, r27
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
				{	// long format
					do_long = 1;
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	00 c0       	rjmp	.+0      	; 0x20c <rprintf2RamRom+0x1be>
            if (READMEMBYTE(stringInRom,f) == '#')
				{	// alternate form
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
 20c:	80 e0       	ldi	r24, 0x00	; 0
 20e:	90 e0       	ldi	r25, 0x00	; 0
				{	// long format
					do_long = 1;
					f++;
            }

				fmt = READMEMBYTE(stringInRom,f);
 210:	ff 20       	and	r15, r15
 212:	01 f0       	breq	.+0      	; 0x214 <rprintf2RamRom+0x1c6>
 214:	f5 01       	movw	r30, r10
 216:	24 91       	lpm	r18, Z
 218:	00 c0       	rjmp	.+0      	; 0x21a <rprintf2RamRom+0x1cc>
 21a:	d5 01       	movw	r26, r10
 21c:	2c 91       	ld	r18, X
 21e:	30 e0       	ldi	r19, 0x00	; 0
				bp = buf;
				switch (fmt) {		// do the formatting
 220:	2f 36       	cpi	r18, 0x6F	; 111
 222:	31 05       	cpc	r19, r1
 224:	01 f4       	brne	.+0      	; 0x226 <rprintf2RamRom+0x1d8>
 226:	00 c0       	rjmp	.+0      	; 0x228 <rprintf2RamRom+0x1da>
 228:	04 f4       	brge	.+0      	; 0x22a <rprintf2RamRom+0x1dc>
 22a:	23 36       	cpi	r18, 0x63	; 99
 22c:	31 05       	cpc	r19, r1
 22e:	01 f4       	brne	.+0      	; 0x230 <rprintf2RamRom+0x1e2>
 230:	00 c0       	rjmp	.+0      	; 0x232 <rprintf2RamRom+0x1e4>
 232:	24 36       	cpi	r18, 0x64	; 100
 234:	31 05       	cpc	r19, r1
 236:	01 f0       	breq	.+0      	; 0x238 <rprintf2RamRom+0x1ea>
 238:	25 32       	cpi	r18, 0x25	; 37
 23a:	31 05       	cpc	r19, r1
 23c:	01 f0       	breq	.+0      	; 0x23e <rprintf2RamRom+0x1f0>
 23e:	00 c0       	rjmp	.+0      	; 0x240 <rprintf2RamRom+0x1f2>
 240:	00 c0       	rjmp	.+0      	; 0x242 <rprintf2RamRom+0x1f4>
 242:	25 37       	cpi	r18, 0x75	; 117
 244:	31 05       	cpc	r19, r1
 246:	01 f4       	brne	.+0      	; 0x248 <rprintf2RamRom+0x1fa>
 248:	00 c0       	rjmp	.+0      	; 0x24a <rprintf2RamRom+0x1fc>
 24a:	28 37       	cpi	r18, 0x78	; 120
 24c:	31 05       	cpc	r19, r1
 24e:	01 f4       	brne	.+0      	; 0x250 <rprintf2RamRom+0x202>
 250:	00 c0       	rjmp	.+0      	; 0x252 <rprintf2RamRom+0x204>
 252:	23 37       	cpi	r18, 0x73	; 115
 254:	31 05       	cpc	r19, r1
 256:	01 f0       	breq	.+0      	; 0x258 <rprintf2RamRom+0x20a>
 258:	00 c0       	rjmp	.+0      	; 0x25a <rprintf2RamRom+0x20c>
 25a:	00 c0       	rjmp	.+0      	; 0x25c <rprintf2RamRom+0x20e>
 25c:	e9 81       	ldd	r30, Y+1	; 0x01
 25e:	fa 81       	ldd	r31, Y+2	; 0x02
				case 'd':			// 'd' signed decimal
					if (do_long)
 260:	89 2b       	or	r24, r25
 262:	01 f0       	breq	.+0      	; 0x264 <rprintf2RamRom+0x216>
						l = va_arg(ap, long);
 264:	cf 01       	movw	r24, r30
 266:	04 96       	adiw	r24, 0x04	; 4
 268:	9a 83       	std	Y+2, r25	; 0x02
 26a:	89 83       	std	Y+1, r24	; 0x01
 26c:	60 81       	ld	r22, Z
 26e:	71 81       	ldd	r23, Z+1	; 0x01
 270:	82 81       	ldd	r24, Z+2	; 0x02
 272:	93 81       	ldd	r25, Z+3	; 0x03
 274:	00 c0       	rjmp	.+0      	; 0x276 <rprintf2RamRom+0x228>
					else
						l = (long) (va_arg(ap, int));
 276:	cf 01       	movw	r24, r30
 278:	02 96       	adiw	r24, 0x02	; 2
 27a:	9a 83       	std	Y+2, r25	; 0x02
 27c:	89 83       	std	Y+1, r24	; 0x01
 27e:	60 81       	ld	r22, Z
 280:	71 81       	ldd	r23, Z+1	; 0x01
 282:	88 27       	eor	r24, r24
 284:	77 fd       	sbrc	r23, 7
 286:	80 95       	com	r24
 288:	98 2f       	mov	r25, r24
					if (l < 0)
 28a:	97 ff       	sbrs	r25, 7
 28c:	00 c0       	rjmp	.+0      	; 0x28e <rprintf2RamRom+0x240>
					{
						sign = 1;
						l = -l;
 28e:	90 95       	com	r25
 290:	80 95       	com	r24
 292:	70 95       	com	r23
 294:	61 95       	neg	r22
 296:	7f 4f       	sbci	r23, 0xFF	; 255
 298:	8f 4f       	sbci	r24, 0xFF	; 255
 29a:	9f 4f       	sbci	r25, 0xFF	; 255
						l = va_arg(ap, long);
					else
						l = (long) (va_arg(ap, int));
					if (l < 0)
					{
						sign = 1;
 29c:	e1 e0       	ldi	r30, 0x01	; 1
 29e:	f0 e0       	ldi	r31, 0x00	; 0
 2a0:	fd 83       	std	Y+5, r31	; 0x05
 2a2:	ec 83       	std	Y+4, r30	; 0x04
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <rprintf2RamRom+0x258>
				case 'd':			// 'd' signed decimal
					if (do_long)
						l = va_arg(ap, long);
					else
						l = (long) (va_arg(ap, int));
					if (l < 0)
 2a6:	1d 82       	std	Y+5, r1	; 0x05
 2a8:	1c 82       	std	Y+4, r1	; 0x04
 2aa:	00 e0       	ldi	r16, 0x00	; 0
 2ac:	10 e0       	ldi	r17, 0x00	; 0
 2ae:	18 01       	movw	r2, r16
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 2b0:	0f 5f       	subi	r16, 0xFF	; 255
 2b2:	1f 4f       	sbci	r17, 0xFF	; 255
 2b4:	48 01       	movw	r8, r16
					{
						sign = 1;
						l = -l;
					}
					do	{
						*bp++ = l % 10 + '0';
 2b6:	2a e0       	ldi	r18, 0x0A	; 10
 2b8:	30 e0       	ldi	r19, 0x00	; 0
 2ba:	40 e0       	ldi	r20, 0x00	; 0
 2bc:	50 e0       	ldi	r21, 0x00	; 0
 2be:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 2c2:	60 5d       	subi	r22, 0xD0	; 208
 2c4:	d1 01       	movw	r26, r2
 2c6:	6c 93       	st	X, r22
					} while ((l /= 10) > 0);
 2c8:	b9 01       	movw	r22, r18
 2ca:	ca 01       	movw	r24, r20
 2cc:	16 16       	cp	r1, r22
 2ce:	17 06       	cpc	r1, r23
 2d0:	18 06       	cpc	r1, r24
 2d2:	19 06       	cpc	r1, r25
 2d4:	04 f0       	brlt	.+0      	; 0x2d6 <rprintf2RamRom+0x288>
					if (sign)
 2d6:	ec 81       	ldd	r30, Y+4	; 0x04
 2d8:	fd 81       	ldd	r31, Y+5	; 0x05
 2da:	ef 2b       	or	r30, r31
 2dc:	01 f0       	breq	.+0      	; 0x2de <rprintf2RamRom+0x290>
						*bp++ = '-';
 2de:	41 01       	movw	r8, r2
 2e0:	f2 e0       	ldi	r31, 0x02	; 2
 2e2:	8f 0e       	add	r8, r31
 2e4:	91 1c       	adc	r9, r1
 2e6:	2d e2       	ldi	r18, 0x2D	; 45
 2e8:	11 96       	adiw	r26, 0x01	; 1
 2ea:	2c 93       	st	X, r18
					f_width = f_width - (bp - buf);
 2ec:	86 01       	movw	r16, r12
 2ee:	08 19       	sub	r16, r8
 2f0:	19 09       	sbc	r17, r9
 2f2:	04 0d       	add	r16, r4
 2f4:	15 1d       	adc	r17, r5
					if (!flush_left)
 2f6:	61 14       	cp	r6, r1
 2f8:	71 04       	cpc	r7, r1
 2fa:	01 f4       	brne	.+0      	; 0x2fc <rprintf2RamRom+0x2ae>
 2fc:	28 01       	movw	r4, r16
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <rprintf2RamRom+0x2b2>
						while (f_width-- > 0)
							rprintfChar(pad);
 300:	8b 81       	ldd	r24, Y+3	; 0x03
 302:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 306:	31 e0       	ldi	r19, 0x01	; 1
 308:	43 1a       	sub	r4, r19
 30a:	51 08       	sbc	r5, r1
					} while ((l /= 10) > 0);
					if (sign)
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
 30c:	14 14       	cp	r1, r4
 30e:	15 04       	cpc	r1, r5
 310:	04 f0       	brlt	.+0      	; 0x312 <rprintf2RamRom+0x2c4>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 312:	c8 01       	movw	r24, r16
 314:	01 97       	sbiw	r24, 0x01	; 1
 316:	17 ff       	sbrs	r17, 7
 318:	00 c0       	rjmp	.+0      	; 0x31a <rprintf2RamRom+0x2cc>
 31a:	00 e0       	ldi	r16, 0x00	; 0
 31c:	10 e0       	ldi	r17, 0x00	; 0
 31e:	dc 01       	movw	r26, r24
 320:	a0 1b       	sub	r26, r16
 322:	b1 0b       	sbc	r27, r17
 324:	8d 01       	movw	r16, r26
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 326:	00 c0       	rjmp	.+0      	; 0x328 <rprintf2RamRom+0x2da>
						rprintfChar(*bp);
 328:	f4 01       	movw	r30, r8
 32a:	80 81       	ld	r24, Z
 32c:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 330:	f1 e0       	ldi	r31, 0x01	; 1
 332:	8f 1a       	sub	r8, r31
 334:	91 08       	sbc	r9, r1
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 336:	20 e0       	ldi	r18, 0x00	; 0
 338:	82 16       	cp	r8, r18
 33a:	20 e0       	ldi	r18, 0x00	; 0
 33c:	92 06       	cpc	r9, r18
 33e:	00 f4       	brcc	.+0      	; 0x340 <rprintf2RamRom+0x2f2>
						rprintfChar(*bp);
					if (flush_left)
 340:	67 28       	or	r6, r7
 342:	01 f4       	brne	.+0      	; 0x344 <rprintf2RamRom+0x2f6>
 344:	00 c0       	rjmp	.+0      	; 0x346 <rprintf2RamRom+0x2f8>
 346:	00 c0       	rjmp	.+0      	; 0x348 <rprintf2RamRom+0x2fa>
						while (f_width-- > 0)
							rprintfChar(' ');
 348:	80 e2       	ldi	r24, 0x20	; 32
 34a:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 34e:	01 50       	subi	r16, 0x01	; 1
 350:	11 09       	sbc	r17, r1
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
						rprintfChar(*bp);
					if (flush_left)
						while (f_width-- > 0)
 352:	10 16       	cp	r1, r16
 354:	11 06       	cpc	r1, r17
 356:	04 f0       	brlt	.+0      	; 0x358 <rprintf2RamRom+0x30a>
 358:	00 c0       	rjmp	.+0      	; 0x35a <rprintf2RamRom+0x30c>
 35a:	e9 81       	ldd	r30, Y+1	; 0x01
 35c:	fa 81       	ldd	r31, Y+2	; 0x02
							rprintfChar(' ');
					break;
            case 'o':			// 'o' octal number
            case 'x':			// 'x' hex number
            case 'u':			// 'u' unsigned decimal
					if (do_long)
 35e:	89 2b       	or	r24, r25
 360:	01 f0       	breq	.+0      	; 0x362 <rprintf2RamRom+0x314>
						u = va_arg(ap, unsigned long);
 362:	cf 01       	movw	r24, r30
 364:	04 96       	adiw	r24, 0x04	; 4
 366:	9a 83       	std	Y+2, r25	; 0x02
 368:	89 83       	std	Y+1, r24	; 0x01
 36a:	60 81       	ld	r22, Z
 36c:	71 81       	ldd	r23, Z+1	; 0x01
 36e:	82 81       	ldd	r24, Z+2	; 0x02
 370:	93 81       	ldd	r25, Z+3	; 0x03
 372:	00 c0       	rjmp	.+0      	; 0x374 <rprintf2RamRom+0x326>
					else
						u = (unsigned long) (va_arg(ap, unsigned));
 374:	cf 01       	movw	r24, r30
 376:	02 96       	adiw	r24, 0x02	; 2
 378:	9a 83       	std	Y+2, r25	; 0x02
 37a:	89 83       	std	Y+1, r24	; 0x01
 37c:	60 81       	ld	r22, Z
 37e:	71 81       	ldd	r23, Z+1	; 0x01
 380:	80 e0       	ldi	r24, 0x00	; 0
 382:	90 e0       	ldi	r25, 0x00	; 0
					if (fmt == 'u')
 384:	25 37       	cpi	r18, 0x75	; 117
 386:	31 05       	cpc	r19, r1
 388:	01 f4       	brne	.+0      	; 0x38a <rprintf2RamRom+0x33c>
 38a:	00 e0       	ldi	r16, 0x00	; 0
 38c:	10 e0       	ldi	r17, 0x00	; 0
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 38e:	48 01       	movw	r8, r16
 390:	3f ef       	ldi	r19, 0xFF	; 255
 392:	83 1a       	sub	r8, r19
 394:	93 0a       	sbc	r9, r19
					else
						u = (unsigned long) (va_arg(ap, unsigned));
					if (fmt == 'u')
					{	// unsigned decimal
						do {
							*bp++ = u % 10 + '0';
 396:	2a e0       	ldi	r18, 0x0A	; 10
 398:	30 e0       	ldi	r19, 0x00	; 0
 39a:	40 e0       	ldi	r20, 0x00	; 0
 39c:	50 e0       	ldi	r21, 0x00	; 0
 39e:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 3a2:	60 5d       	subi	r22, 0xD0	; 208
 3a4:	d8 01       	movw	r26, r16
 3a6:	6c 93       	st	X, r22
						} while ((u /= 10) > 0);
 3a8:	b9 01       	movw	r22, r18
 3aa:	ca 01       	movw	r24, r20
 3ac:	84 01       	movw	r16, r8
 3ae:	61 15       	cp	r22, r1
 3b0:	71 05       	cpc	r23, r1
 3b2:	81 05       	cpc	r24, r1
 3b4:	91 05       	cpc	r25, r1
 3b6:	01 f4       	brne	.+0      	; 0x3b8 <rprintf2RamRom+0x36a>
 3b8:	00 c0       	rjmp	.+0      	; 0x3ba <rprintf2RamRom+0x36c>
					}
					else if (fmt == 'o')
 3ba:	2f 36       	cpi	r18, 0x6F	; 111
 3bc:	31 05       	cpc	r19, r1
 3be:	01 f4       	brne	.+0      	; 0x3c0 <rprintf2RamRom+0x372>
 3c0:	40 e0       	ldi	r20, 0x00	; 0
 3c2:	50 e0       	ldi	r21, 0x00	; 0
 3c4:	fa 01       	movw	r30, r20
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 3c6:	4f 5f       	subi	r20, 0xFF	; 255
 3c8:	5f 4f       	sbci	r21, 0xFF	; 255
 3ca:	4a 01       	movw	r8, r20
						} while ((u /= 10) > 0);
					}
					else if (fmt == 'o')
					{  // octal
						do {
							*bp++ = u % 8 + '0';
 3cc:	8b 01       	movw	r16, r22
 3ce:	9c 01       	movw	r18, r24
 3d0:	07 70       	andi	r16, 0x07	; 7
 3d2:	11 27       	eor	r17, r17
 3d4:	22 27       	eor	r18, r18
 3d6:	33 27       	eor	r19, r19
 3d8:	00 5d       	subi	r16, 0xD0	; 208
 3da:	00 83       	st	Z, r16
						} while ((u /= 8) > 0);
 3dc:	a3 e0       	ldi	r26, 0x03	; 3
 3de:	96 95       	lsr	r25
 3e0:	87 95       	ror	r24
 3e2:	77 95       	ror	r23
 3e4:	67 95       	ror	r22
 3e6:	aa 95       	dec	r26
 3e8:	01 f4       	brne	.+0      	; 0x3ea <rprintf2RamRom+0x39c>
 3ea:	61 15       	cp	r22, r1
 3ec:	71 05       	cpc	r23, r1
 3ee:	81 05       	cpc	r24, r1
 3f0:	91 05       	cpc	r25, r1
 3f2:	01 f4       	brne	.+0      	; 0x3f4 <rprintf2RamRom+0x3a6>
						if (hash)
 3f4:	23 28       	or	r2, r3
 3f6:	01 f0       	breq	.+0      	; 0x3f8 <rprintf2RamRom+0x3aa>
							*bp++ = '0';
 3f8:	4f 01       	movw	r8, r30
 3fa:	b2 e0       	ldi	r27, 0x02	; 2
 3fc:	8b 0e       	add	r8, r27
 3fe:	91 1c       	adc	r9, r1
 400:	00 c0       	rjmp	.+0      	; 0x402 <rprintf2RamRom+0x3b4>
					}
					else if (fmt == 'x')
 402:	40 e0       	ldi	r20, 0x00	; 0
 404:	84 2e       	mov	r8, r20
 406:	40 e0       	ldi	r20, 0x00	; 0
 408:	94 2e       	mov	r9, r20
 40a:	28 37       	cpi	r18, 0x78	; 120
 40c:	31 05       	cpc	r19, r1
 40e:	01 f4       	brne	.+0      	; 0x410 <rprintf2RamRom+0x3c2>
					{	// hex
						do {
							i = u % 16;
 410:	8b 01       	movw	r16, r22
 412:	9c 01       	movw	r18, r24
 414:	0f 70       	andi	r16, 0x0F	; 15
 416:	11 27       	eor	r17, r17
 418:	22 27       	eor	r18, r18
 41a:	33 27       	eor	r19, r19
 41c:	f4 01       	movw	r30, r8
 41e:	31 96       	adiw	r30, 0x01	; 1
							if (i < 10)
 420:	0a 30       	cpi	r16, 0x0A	; 10
 422:	11 05       	cpc	r17, r1
 424:	04 f4       	brge	.+0      	; 0x426 <rprintf2RamRom+0x3d8>
								*bp++ = i + '0';
 426:	00 5d       	subi	r16, 0xD0	; 208
 428:	00 c0       	rjmp	.+0      	; 0x42a <rprintf2RamRom+0x3dc>
							else
								*bp++ = i - 10 + 'a';
 42a:	09 5a       	subi	r16, 0xA9	; 169
 42c:	d4 01       	movw	r26, r8
 42e:	0c 93       	st	X, r16
 430:	4f 01       	movw	r8, r30
						} while ((u /= 16) > 0);
 432:	24 e0       	ldi	r18, 0x04	; 4
 434:	96 95       	lsr	r25
 436:	87 95       	ror	r24
 438:	77 95       	ror	r23
 43a:	67 95       	ror	r22
 43c:	2a 95       	dec	r18
 43e:	01 f4       	brne	.+0      	; 0x440 <rprintf2RamRom+0x3f2>
 440:	61 15       	cp	r22, r1
 442:	71 05       	cpc	r23, r1
 444:	81 05       	cpc	r24, r1
 446:	91 05       	cpc	r25, r1
 448:	01 f4       	brne	.+0      	; 0x44a <rprintf2RamRom+0x3fc>
						if (hash)
 44a:	23 28       	or	r2, r3
 44c:	01 f0       	breq	.+0      	; 0x44e <rprintf2RamRom+0x400>
						{
							*bp++ = 'x';
 44e:	b8 e7       	ldi	r27, 0x78	; 120
 450:	b0 83       	st	Z, r27
							*bp++ = '0';
 452:	4f 01       	movw	r8, r30
 454:	22 e0       	ldi	r18, 0x02	; 2
 456:	82 0e       	add	r8, r18
 458:	91 1c       	adc	r9, r1
 45a:	e1 82       	std	Z+1, r14	; 0x01
						}
					}
					i = f_width - (bp - buf);
 45c:	86 01       	movw	r16, r12
 45e:	08 19       	sub	r16, r8
 460:	19 09       	sbc	r17, r9
 462:	04 0d       	add	r16, r4
 464:	15 1d       	adc	r17, r5
					if (!flush_left)
 466:	61 14       	cp	r6, r1
 468:	71 04       	cpc	r7, r1
 46a:	01 f4       	brne	.+0      	; 0x46c <rprintf2RamRom+0x41e>
 46c:	28 01       	movw	r4, r16
 46e:	00 c0       	rjmp	.+0      	; 0x470 <rprintf2RamRom+0x422>
						while (i-- > 0)
							rprintfChar(pad);
 470:	8b 81       	ldd	r24, Y+3	; 0x03
 472:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 476:	31 e0       	ldi	r19, 0x01	; 1
 478:	43 1a       	sub	r4, r19
 47a:	51 08       	sbc	r5, r1
							*bp++ = '0';
						}
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
 47c:	14 14       	cp	r1, r4
 47e:	15 04       	cpc	r1, r5
 480:	04 f0       	brlt	.+0      	; 0x482 <rprintf2RamRom+0x434>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 482:	c8 01       	movw	r24, r16
 484:	01 97       	sbiw	r24, 0x01	; 1
 486:	17 ff       	sbrs	r17, 7
 488:	00 c0       	rjmp	.+0      	; 0x48a <rprintf2RamRom+0x43c>
 48a:	00 e0       	ldi	r16, 0x00	; 0
 48c:	10 e0       	ldi	r17, 0x00	; 0
 48e:	dc 01       	movw	r26, r24
 490:	a0 1b       	sub	r26, r16
 492:	b1 0b       	sbc	r27, r17
 494:	8d 01       	movw	r16, r26
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 496:	00 c0       	rjmp	.+0      	; 0x498 <rprintf2RamRom+0x44a>
						rprintfChar((int) (*bp));
 498:	f4 01       	movw	r30, r8
 49a:	80 81       	ld	r24, Z
 49c:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 4a0:	f1 e0       	ldi	r31, 0x01	; 1
 4a2:	8f 1a       	sub	r8, r31
 4a4:	91 08       	sbc	r9, r1
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 4a6:	20 e0       	ldi	r18, 0x00	; 0
 4a8:	82 16       	cp	r8, r18
 4aa:	20 e0       	ldi	r18, 0x00	; 0
 4ac:	92 06       	cpc	r9, r18
 4ae:	00 f4       	brcc	.+0      	; 0x4b0 <rprintf2RamRom+0x462>
						rprintfChar((int) (*bp));
					if (flush_left)
 4b0:	67 28       	or	r6, r7
 4b2:	01 f4       	brne	.+0      	; 0x4b4 <rprintf2RamRom+0x466>
 4b4:	00 c0       	rjmp	.+0      	; 0x4b6 <rprintf2RamRom+0x468>
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <rprintf2RamRom+0x46a>
						while (i-- > 0)
							rprintfChar(' ');
 4b8:	80 e2       	ldi	r24, 0x20	; 32
 4ba:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 4be:	01 50       	subi	r16, 0x01	; 1
 4c0:	11 09       	sbc	r17, r1
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
						rprintfChar((int) (*bp));
					if (flush_left)
						while (i-- > 0)
 4c2:	10 16       	cp	r1, r16
 4c4:	11 06       	cpc	r1, r17
 4c6:	04 f0       	brlt	.+0      	; 0x4c8 <rprintf2RamRom+0x47a>
 4c8:	00 c0       	rjmp	.+0      	; 0x4ca <rprintf2RamRom+0x47c>
							rprintfChar(' ');
					break;
            case 'c':			// 'c' character
					i = va_arg(ap, int);
 4ca:	e9 81       	ldd	r30, Y+1	; 0x01
 4cc:	fa 81       	ldd	r31, Y+2	; 0x02
 4ce:	cf 01       	movw	r24, r30
 4d0:	02 96       	adiw	r24, 0x02	; 2
 4d2:	9a 83       	std	Y+2, r25	; 0x02
 4d4:	89 83       	std	Y+1, r24	; 0x01
					rprintfChar((int) (i));
 4d6:	80 81       	ld	r24, Z
 4d8:	00 c0       	rjmp	.+0      	; 0x4da <rprintf2RamRom+0x48c>
					break;
            case 's':			// 's' string
					bp = va_arg(ap, unsigned char *);
 4da:	e9 81       	ldd	r30, Y+1	; 0x01
 4dc:	fa 81       	ldd	r31, Y+2	; 0x02
 4de:	cf 01       	movw	r24, r30
 4e0:	02 96       	adiw	r24, 0x02	; 2
 4e2:	9a 83       	std	Y+2, r25	; 0x02
 4e4:	89 83       	std	Y+1, r24	; 0x01
 4e6:	00 81       	ld	r16, Z
 4e8:	11 81       	ldd	r17, Z+1	; 0x01
					if (!bp)
 4ea:	01 15       	cp	r16, r1
 4ec:	11 05       	cpc	r17, r1
 4ee:	01 f4       	brne	.+0      	; 0x4f0 <rprintf2RamRom+0x4a2>
						bp = (unsigned char *) "(nil)";
 4f0:	00 e0       	ldi	r16, 0x00	; 0
 4f2:	10 e0       	ldi	r17, 0x00	; 0
					f_width = f_width - strlen((char *) bp);
 4f4:	f8 01       	movw	r30, r16
 4f6:	01 90       	ld	r0, Z+
 4f8:	00 20       	and	r0, r0
 4fa:	01 f4       	brne	.+0      	; 0x4fc <rprintf2RamRom+0x4ae>
 4fc:	31 97       	sbiw	r30, 0x01	; 1
 4fe:	e0 1b       	sub	r30, r16
 500:	f1 0b       	sbc	r31, r17
 502:	4e 1a       	sub	r4, r30
 504:	5f 0a       	sbc	r5, r31
 506:	12 01       	movw	r2, r4
					if (!flush_left)
 508:	61 14       	cp	r6, r1
 50a:	71 04       	cpc	r7, r1
 50c:	01 f0       	breq	.+0      	; 0x50e <rprintf2RamRom+0x4c0>
 50e:	00 c0       	rjmp	.+0      	; 0x510 <rprintf2RamRom+0x4c2>
						while (f_width-- > 0)
							rprintfChar(pad);
 510:	8b 81       	ldd	r24, Y+3	; 0x03
 512:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 516:	31 e0       	ldi	r19, 0x01	; 1
 518:	43 1a       	sub	r4, r19
 51a:	51 08       	sbc	r5, r1
					bp = va_arg(ap, unsigned char *);
					if (!bp)
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
 51c:	14 14       	cp	r1, r4
 51e:	15 04       	cpc	r1, r5
 520:	04 f0       	brlt	.+0      	; 0x522 <rprintf2RamRom+0x4d4>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 522:	c1 01       	movw	r24, r2
 524:	01 97       	sbiw	r24, 0x01	; 1
 526:	37 fe       	sbrs	r3, 7
 528:	00 c0       	rjmp	.+0      	; 0x52a <rprintf2RamRom+0x4dc>
 52a:	21 2c       	mov	r2, r1
 52c:	31 2c       	mov	r3, r1
 52e:	dc 01       	movw	r26, r24
 530:	a2 19       	sub	r26, r2
 532:	b3 09       	sbc	r27, r3
 534:	1d 01       	movw	r2, r26
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (i = 0; *bp && i < prec; i++)
 536:	41 2c       	mov	r4, r1
 538:	51 2c       	mov	r5, r1
 53a:	00 c0       	rjmp	.+0      	; 0x53c <rprintf2RamRom+0x4ee>
					{
						rprintfChar(*bp);
 53c:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (i = 0; *bp && i < prec; i++)
 540:	bf ef       	ldi	r27, 0xFF	; 255
 542:	4b 1a       	sub	r4, r27
 544:	5b 0a       	sbc	r5, r27
 546:	f8 01       	movw	r30, r16
 548:	81 91       	ld	r24, Z+
 54a:	8f 01       	movw	r16, r30
 54c:	88 23       	and	r24, r24
 54e:	01 f0       	breq	.+0      	; 0x550 <rprintf2RamRom+0x502>
 550:	48 14       	cp	r4, r8
 552:	59 04       	cpc	r5, r9
 554:	04 f0       	brlt	.+0      	; 0x556 <rprintf2RamRom+0x508>
					{
						rprintfChar(*bp);
						bp++;
					}
					if (flush_left)
 556:	67 28       	or	r6, r7
 558:	01 f0       	breq	.+0      	; 0x55a <rprintf2RamRom+0x50c>
 55a:	00 c0       	rjmp	.+0      	; 0x55c <rprintf2RamRom+0x50e>
						while (f_width-- > 0)
							rprintfChar(' ');
 55c:	80 e2       	ldi	r24, 0x20	; 32
 55e:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 562:	f1 e0       	ldi	r31, 0x01	; 1
 564:	2f 1a       	sub	r2, r31
 566:	31 08       	sbc	r3, r1
					{
						rprintfChar(*bp);
						bp++;
					}
					if (flush_left)
						while (f_width-- > 0)
 568:	12 14       	cp	r1, r2
 56a:	13 04       	cpc	r1, r3
 56c:	04 f0       	brlt	.+0      	; 0x56e <rprintf2RamRom+0x520>
 56e:	00 c0       	rjmp	.+0      	; 0x570 <rprintf2RamRom+0x522>
							rprintfChar(' ');
					break;
            case '%':			// '%' character
					rprintfChar('%');
 570:	85 e2       	ldi	r24, 0x25	; 37
 572:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
	va_list ap;
	va_start(ap, sfmt);

	f = (unsigned char *) sfmt;

	for (; READMEMBYTE(stringInRom,f); f++)
 576:	2f ef       	ldi	r18, 0xFF	; 255
 578:	a2 1a       	sub	r10, r18
 57a:	b2 0a       	sbc	r11, r18
 57c:	ff 20       	and	r15, r15
 57e:	01 f0       	breq	.+0      	; 0x580 <rprintf2RamRom+0x532>
 580:	f5 01       	movw	r30, r10
 582:	84 91       	lpm	r24, Z
 584:	00 c0       	rjmp	.+0      	; 0x586 <rprintf2RamRom+0x538>
 586:	d5 01       	movw	r26, r10
 588:	8c 91       	ld	r24, X
 58a:	81 11       	cpse	r24, r1
 58c:	00 c0       	rjmp	.+0      	; 0x58e <rprintf2RamRom+0x540>
 58e:	00 c0       	rjmp	.+0      	; 0x590 <rprintf2RamRom+0x542>
					f_width = va_arg(ap, int);
					f++;
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
 590:	bf 01       	movw	r22, r30
 592:	8f 2d       	mov	r24, r15
 594:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 598:	2c 01       	movw	r4, r24
					while (Isdigit(READMEMBYTE(stringInRom,f)))
 59a:	00 c0       	rjmp	.+0      	; 0x59c <rprintf2RamRom+0x54e>
						f++;        // skip the digits
 59c:	bf ef       	ldi	r27, 0xFF	; 255
 59e:	ab 1a       	sub	r10, r27
 5a0:	bb 0a       	sbc	r11, r27
 5a2:	00 c0       	rjmp	.+0      	; 0x5a4 <rprintf2RamRom+0x556>
						prec = va_arg(ap, int);
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
 5a4:	b8 01       	movw	r22, r16
 5a6:	8f 2d       	mov	r24, r15
 5a8:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 5ac:	4c 01       	movw	r8, r24
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
				{	// precision
					f++;
 5ae:	58 01       	movw	r10, r16
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
 5b0:	00 c0       	rjmp	.+0      	; 0x5b2 <rprintf2RamRom+0x564>
							f++;    // skip the digits
 5b2:	ef ef       	ldi	r30, 0xFF	; 255
 5b4:	ae 1a       	sub	r10, r30
 5b6:	be 0a       	sbc	r11, r30
 5b8:	00 c0       	rjmp	.+0      	; 0x5ba <rprintf2RamRom+0x56c>
		}
	}

	va_end(ap);
	return 0;
}
 5ba:	80 e0       	ldi	r24, 0x00	; 0
 5bc:	90 e0       	ldi	r25, 0x00	; 0
 5be:	0f 90       	pop	r0
 5c0:	0f 90       	pop	r0
 5c2:	0f 90       	pop	r0
 5c4:	0f 90       	pop	r0
 5c6:	0f 90       	pop	r0
 5c8:	df 91       	pop	r29
 5ca:	cf 91       	pop	r28
 5cc:	1f 91       	pop	r17
 5ce:	0f 91       	pop	r16
 5d0:	ff 90       	pop	r15
 5d2:	ef 90       	pop	r14
 5d4:	df 90       	pop	r13
 5d6:	cf 90       	pop	r12
 5d8:	bf 90       	pop	r11
 5da:	af 90       	pop	r10
 5dc:	9f 90       	pop	r9
 5de:	8f 90       	pop	r8
 5e0:	7f 90       	pop	r7
 5e2:	6f 90       	pop	r6
 5e4:	5f 90       	pop	r5
 5e6:	4f 90       	pop	r4
 5e8:	3f 90       	pop	r3
 5ea:	2f 90       	pop	r2
 5ec:	08 95       	ret

rprintff.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000018a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001be  2**0
                  ALLOC
  3 .debug_info   0000014b  00000000  00000000  000001be  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000e1  00000000  00000000  00000309  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000024d  00000000  00000000  000003ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000637  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000cc  00000000  00000000  00000657  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000121  00000000  00000000  00000723  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000844  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000074  00000000  00000000  00000870  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfFloat>:
#include "libdefs.h"
#include <stdarg.h>

// floating-point print
void rprintfFloat(char numDigits, double x)
{
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	c8 2f       	mov	r28, r24
  22:	2a 01       	movw	r4, r20
  24:	3b 01       	movw	r6, r22
	double place = 1.0;

	// save sign
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);
  26:	20 e0       	ldi	r18, 0x00	; 0
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	a9 01       	movw	r20, r18
  2c:	c3 01       	movw	r24, r6
  2e:	b2 01       	movw	r22, r4
  30:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  34:	73 01       	movw	r14, r6
  36:	62 01       	movw	r12, r4
  38:	18 16       	cp	r1, r24
  3a:	04 f0       	brlt	.+0      	; 0x3c <rprintfFloat+0x3c>
  3c:	f7 fa       	bst	r15, 7
  3e:	f0 94       	com	r15
  40:	f7 f8       	bld	r15, 7
  42:	f0 94       	com	r15
  44:	df e0       	ldi	r29, 0x0F	; 15
void rprintfFloat(char numDigits, double x)
{
	unsigned char firstplace = FALSE;
	unsigned char negative;
	unsigned char i, digit;
	double place = 1.0;
  46:	a1 2c       	mov	r10, r1
  48:	91 2c       	mov	r9, r1
  4a:	10 e8       	ldi	r17, 0x80	; 128
  4c:	0f e3       	ldi	r16, 0x3F	; 63
	x = (x>0)?(x):(-x);

	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
  4e:	c8 01       	movw	r24, r16
  50:	2a 2d       	mov	r18, r10
  52:	39 2d       	mov	r19, r9
  54:	49 2f       	mov	r20, r25
  56:	50 2f       	mov	r21, r16
  58:	c7 01       	movw	r24, r14
  5a:	b6 01       	movw	r22, r12
  5c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	30 e0       	ldi	r19, 0x00	; 0
  64:	40 e2       	ldi	r20, 0x20	; 32
  66:	51 e4       	ldi	r21, 0x41	; 65
  68:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  6c:	87 fd       	sbrc	r24, 7
  6e:	00 c0       	rjmp	.+0      	; 0x70 <rprintfFloat+0x70>
			break;
		else
			place *= 10.0;
  70:	20 e0       	ldi	r18, 0x00	; 0
  72:	30 e0       	ldi	r19, 0x00	; 0
  74:	40 e2       	ldi	r20, 0x20	; 32
  76:	51 e4       	ldi	r21, 0x41	; 65
  78:	f8 01       	movw	r30, r16
  7a:	6a 2d       	mov	r22, r10
  7c:	79 2d       	mov	r23, r9
  7e:	8f 2f       	mov	r24, r31
  80:	90 2f       	mov	r25, r16
  82:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  86:	a6 2e       	mov	r10, r22
  88:	97 2e       	mov	r9, r23
  8a:	18 2f       	mov	r17, r24
  8c:	09 2f       	mov	r16, r25
  8e:	d1 50       	subi	r29, 0x01	; 1
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);

	// find starting digit place
	for(i=0; i<15; i++)
  90:	01 f4       	brne	.+0      	; 0x92 <rprintfFloat+0x92>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
  92:	20 e0       	ldi	r18, 0x00	; 0
  94:	30 e0       	ldi	r19, 0x00	; 0
  96:	a9 01       	movw	r20, r18
  98:	c3 01       	movw	r24, r6
  9a:	b2 01       	movw	r22, r4
  9c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  a0:	87 ff       	sbrs	r24, 7
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <rprintfFloat+0xa4>
		rprintfChar('-');
  a4:	8d e2       	ldi	r24, 0x2D	; 45
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <rprintfFloat+0xa8>
	else
		rprintfChar('+');
  a8:	8b e2       	ldi	r24, 0x2B	; 43
  aa:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
		}
		else
			rprintfChar(' ');
  ae:	b1 2c       	mov	r11, r1
  b0:	d0 e0       	ldi	r29, 0x00	; 0
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <rprintfFloat+0xb4>
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
  b4:	c8 01       	movw	r24, r16
  b6:	2a 2d       	mov	r18, r10
  b8:	39 2d       	mov	r19, r9
  ba:	49 2f       	mov	r20, r25
  bc:	50 2f       	mov	r21, r16
  be:	c7 01       	movw	r24, r14
  c0:	b6 01       	movw	r22, r12
  c2:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  c6:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  ca:	86 2e       	mov	r8, r22

		if(digit | firstplace | (place == 1.0))
  cc:	77 24       	eor	r7, r7
  ce:	73 94       	inc	r7
  d0:	20 e0       	ldi	r18, 0x00	; 0
  d2:	30 e0       	ldi	r19, 0x00	; 0
  d4:	40 e8       	ldi	r20, 0x80	; 128
  d6:	5f e3       	ldi	r21, 0x3F	; 63
  d8:	f8 01       	movw	r30, r16
  da:	6a 2d       	mov	r22, r10
  dc:	79 2d       	mov	r23, r9
  de:	8f 2f       	mov	r24, r31
  e0:	90 2f       	mov	r25, r16
  e2:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  e6:	81 11       	cpse	r24, r1
  e8:	71 2c       	mov	r7, r1
  ea:	d8 29       	or	r29, r8
  ec:	87 2d       	mov	r24, r7
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	8d 2b       	or	r24, r29
  f2:	89 2b       	or	r24, r25
  f4:	01 f0       	breq	.+0      	; 0xf6 <rprintfFloat+0xf6>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
  f6:	88 2d       	mov	r24, r8
  f8:	80 5d       	subi	r24, 0xD0	; 208
  fa:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
		}
		else
			rprintfChar(' ');

		if(place == 1.0)
  fe:	71 10       	cpse	r7, r1
 100:	00 c0       	rjmp	.+0      	; 0x102 <rprintfFloat+0x102>
 102:	00 c0       	rjmp	.+0      	; 0x104 <rprintfFloat+0x104>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
		}
		else
			rprintfChar(' ');
 104:	80 e2       	ldi	r24, 0x20	; 32
 106:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 10a:	d0 e0       	ldi	r29, 0x00	; 0
 10c:	00 c0       	rjmp	.+0      	; 0x10e <rprintfFloat+0x10e>

		if(place == 1.0)
		{
			rprintfChar('.');
 10e:	8e e2       	ldi	r24, 0x2E	; 46
 110:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
	{
		digit = (x/place);

		if(digit | firstplace | (place == 1.0))
		{
			firstplace = TRUE;
 114:	df ef       	ldi	r29, 0xFF	; 255
		if(place == 1.0)
		{
			rprintfChar('.');
		}

		x -= (digit*place);
 116:	68 2d       	mov	r22, r8
 118:	70 e0       	ldi	r23, 0x00	; 0
 11a:	80 e0       	ldi	r24, 0x00	; 0
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 122:	f8 01       	movw	r30, r16
 124:	2a 2d       	mov	r18, r10
 126:	39 2d       	mov	r19, r9
 128:	4f 2f       	mov	r20, r31
 12a:	50 2f       	mov	r21, r16
 12c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 130:	9b 01       	movw	r18, r22
 132:	ac 01       	movw	r20, r24
 134:	c7 01       	movw	r24, r14
 136:	b6 01       	movw	r22, r12
 138:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 13c:	c6 2e       	mov	r12, r22
 13e:	d7 2e       	mov	r13, r23
 140:	e8 2e       	mov	r14, r24
 142:	f9 2e       	mov	r15, r25
		place /= 10.0;
 144:	20 e0       	ldi	r18, 0x00	; 0
 146:	30 e0       	ldi	r19, 0x00	; 0
 148:	40 e2       	ldi	r20, 0x20	; 32
 14a:	51 e4       	ldi	r21, 0x41	; 65
 14c:	f8 01       	movw	r30, r16
 14e:	6a 2d       	mov	r22, r10
 150:	79 2d       	mov	r23, r9
 152:	8f 2f       	mov	r24, r31
 154:	90 2f       	mov	r25, r16
 156:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 15a:	a6 2e       	mov	r10, r22
 15c:	97 2e       	mov	r9, r23
 15e:	18 2f       	mov	r17, r24
 160:	09 2f       	mov	r16, r25
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
 162:	b3 94       	inc	r11
 164:	bc 12       	cpse	r11, r28
 166:	00 c0       	rjmp	.+0      	; 0x168 <rprintfFloat+0x168>
		}

		x -= (digit*place);
		place /= 10.0;
	}
}
 168:	df 91       	pop	r29
 16a:	cf 91       	pop	r28
 16c:	1f 91       	pop	r17
 16e:	0f 91       	pop	r16
 170:	ff 90       	pop	r15
 172:	ef 90       	pop	r14
 174:	df 90       	pop	r13
 176:	cf 90       	pop	r12
 178:	bf 90       	pop	r11
 17a:	af 90       	pop	r10
 17c:	9f 90       	pop	r9
 17e:	8f 90       	pop	r8
 180:	7f 90       	pop	r7
 182:	6f 90       	pop	r6
 184:	5f 90       	pop	r5
 186:	4f 90       	pop	r4
 188:	08 95       	ret

rprintfh.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000046  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000007a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000007a  2**0
                  ALLOC
  3 .debug_info   00000184  00000000  00000000  0000007a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000b8  00000000  00000000  000001fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000012c  00000000  00000000  000002b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000003e2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000009c  00000000  00000000  00000402  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000115  00000000  00000000  0000049e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000005b3  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000068  00000000  00000000  000005e0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfu08>:
#include "rprintf.h"


// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(uint8_t data)
{
   0:	cf 93       	push	r28
   2:	c8 2f       	mov	r28, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
   4:	82 95       	swap	r24
   6:	8f 70       	andi	r24, 0x0F	; 15
   8:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu04(data);
   c:	8c 2f       	mov	r24, r28
}
   e:	cf 91       	pop	r28
// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(uint8_t data)
{
	// print 8-bit hex value
	rprintfu04(data>>4);
	rprintfu04(data);
  10:	0c 94 00 00 	jmp	0	; 0x0 <rprintfu08>

00000014 <rprintfu16>:
}

// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(uint16_t data)
{
  14:	cf 93       	push	r28
  16:	c8 2f       	mov	r28, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
  18:	89 2f       	mov	r24, r25
  1a:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu08(data);
  1e:	8c 2f       	mov	r24, r28
}
  20:	cf 91       	pop	r28
// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(uint16_t data)
{
	// print 16-bit hex value
	rprintfu08(data>>8);
	rprintfu08(data);
  22:	0c 94 00 00 	jmp	0	; 0x0 <rprintfu08>

00000026 <rprintfu32>:
}

// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(uint32_t data)
{
  26:	cf 92       	push	r12
  28:	df 92       	push	r13
  2a:	ef 92       	push	r14
  2c:	ff 92       	push	r15
  2e:	6b 01       	movw	r12, r22
  30:	7c 01       	movw	r14, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
  32:	c7 01       	movw	r24, r14
  34:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu16(data);
  38:	c6 01       	movw	r24, r12
}
  3a:	ff 90       	pop	r15
  3c:	ef 90       	pop	r14
  3e:	df 90       	pop	r13
  40:	cf 90       	pop	r12
// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(uint32_t data)
{
	// print 32-bit hex value
	rprintfu16(data>>16);
	rprintfu16(data);
  42:	0c 94 00 00 	jmp	0	; 0x0 <rprintfu08>

rprintfn.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000144  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000178  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000178  2**0
                  ALLOC
  3 .debug_info   000001dc  00000000  00000000  00000178  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000102  00000000  00000000  00000354  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000032d  00000000  00000000  00000456  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000783  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000d0  00000000  00000000  000007a3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000138  00000000  00000000  00000873  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000009ab  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000080  00000000  00000000  000009d8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	5f 92       	push	r5
   6:	6f 92       	push	r6
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
  1e:	cf 93       	push	r28
  20:	df 93       	push	r29
  22:	cd b7       	in	r28, 0x3d	; 61
  24:	de b7       	in	r29, 0x3e	; 62
  26:	a0 97       	sbiw	r28, 0x20	; 32
  28:	0f b6       	in	r0, 0x3f	; 63
  2a:	f8 94       	cli
  2c:	de bf       	out	0x3e, r29	; 62
  2e:	0f be       	out	0x3f, r0	; 63
  30:	cd bf       	out	0x3d, r28	; 61
  32:	88 2e       	mov	r8, r24
  34:	d6 2e       	mov	r13, r22
  36:	c2 2e       	mov	r12, r18
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) ){
  38:	44 23       	and	r20, r20
  3a:	01 f0       	breq	.+0      	; 0x3c <rprintfNum+0x3c>
  3c:	17 ff       	sbrs	r17, 7
  3e:	00 c0       	rjmp	.+0      	; 0x40 <rprintfNum+0x40>
		x = -n;
  40:	66 27       	eor	r22, r22
  42:	77 27       	eor	r23, r23
  44:	cb 01       	movw	r24, r22
  46:	6e 19       	sub	r22, r14
  48:	7f 09       	sbc	r23, r15
  4a:	80 0b       	sbc	r24, r16
  4c:	91 0b       	sbc	r25, r17
  4e:	00 c0       	rjmp	.+0      	; 0x50 <rprintfNum+0x50>
	}else{
	 	x = n;
  50:	c8 01       	movw	r24, r16
  52:	b7 01       	movw	r22, r14
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
  54:	66 24       	eor	r6, r6
  56:	63 94       	inc	r6
  58:	41 11       	cpse	r20, r1
  5a:	00 c0       	rjmp	.+0      	; 0x5c <rprintfNum+0x5c>
  5c:	61 2c       	mov	r6, r1
  5e:	7d 2c       	mov	r7, r13
  60:	7a 94       	dec	r7
  62:	76 18       	sub	r7, r6
  	p = buf + sizeof (buf);
  	*--p = '\0';
  64:	18 a2       	std	Y+32, r1	; 0x20

	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
  66:	91 2c       	mov	r9, r1
  68:	a1 2c       	mov	r10, r1
  6a:	b1 2c       	mov	r11, r1
  6c:	a5 01       	movw	r20, r10
  6e:	94 01       	movw	r18, r8
  70:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
  74:	dc 01       	movw	r26, r24
  76:	cb 01       	movw	r24, r22
  78:	8f 70       	andi	r24, 0x0F	; 15
  7a:	99 27       	eor	r25, r25
  7c:	aa 27       	eor	r26, r26
  7e:	bb 27       	eor	r27, r27
  80:	fc 01       	movw	r30, r24
  82:	e0 50       	subi	r30, 0x00	; 0
  84:	f0 40       	sbci	r31, 0x00	; 0
  86:	84 91       	lpm	r24, Z
  88:	8f 8f       	std	Y+31, r24	; 0x1f
	x /= base;
  8a:	b9 01       	movw	r22, r18
  8c:	ca 01       	movw	r24, r20
  8e:	1e 01       	movw	r2, r28
  90:	2e e1       	ldi	r18, 0x1E	; 30
  92:	22 0e       	add	r2, r18
  94:	31 1c       	adc	r3, r1
	}else{
	 	x = n;
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
  96:	57 2c       	mov	r5, r7
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
	x /= base;

	// calculate remaining digits
	while(count--){
  98:	00 c0       	rjmp	.+0      	; 0x9a <rprintfNum+0x9a>
		if(x != 0){
  9a:	61 15       	cp	r22, r1
  9c:	71 05       	cpc	r23, r1
  9e:	81 05       	cpc	r24, r1
  a0:	91 05       	cpc	r25, r1
  a2:	01 f0       	breq	.+0      	; 0xa4 <rprintfNum+0xa4>
			// calculate next digit
			*--p = hexchar(x % base);
  a4:	a5 01       	movw	r20, r10
  a6:	94 01       	movw	r18, r8
  a8:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
  ac:	dc 01       	movw	r26, r24
  ae:	cb 01       	movw	r24, r22
  b0:	8f 70       	andi	r24, 0x0F	; 15
  b2:	99 27       	eor	r25, r25
  b4:	aa 27       	eor	r26, r26
  b6:	bb 27       	eor	r27, r27
  b8:	fc 01       	movw	r30, r24
  ba:	e0 50       	subi	r30, 0x00	; 0
  bc:	f0 40       	sbci	r31, 0x00	; 0
  be:	84 91       	lpm	r24, Z
  c0:	f1 01       	movw	r30, r2
  c2:	80 83       	st	Z, r24
			x /= base;
  c4:	b9 01       	movw	r22, r18
  c6:	ca 01       	movw	r24, r20
  c8:	00 c0       	rjmp	.+0      	; 0xca <rprintfNum+0xca>
		}else{
			// no more digits left, pad out to desired length
			*--p = padchar;
  ca:	f1 01       	movw	r30, r2
  cc:	c0 82       	st	Z, r12
  ce:	f1 e0       	ldi	r31, 0x01	; 1
  d0:	2f 1a       	sub	r2, r31
  d2:	31 08       	sbc	r3, r1
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
	x /= base;

	// calculate remaining digits
	while(count--){
  d4:	5a 94       	dec	r5
  d6:	2f ef       	ldi	r18, 0xFF	; 255
  d8:	52 12       	cpse	r5, r18
  da:	00 c0       	rjmp	.+0      	; 0xdc <rprintfNum+0xdc>
  	p = buf + sizeof (buf);
  	*--p = '\0';

	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
  dc:	fe 01       	movw	r30, r28
  de:	7f 96       	adiw	r30, 0x1f	; 31
  e0:	e7 19       	sub	r30, r7
  e2:	f1 09       	sbc	r31, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )	{
  e4:	66 20       	and	r6, r6
  e6:	01 f0       	breq	.+0      	; 0xe8 <rprintfNum+0xe8>
		char s = ' ';
		if(n < 0){
  e8:	17 fd       	sbrc	r17, 7
  ea:	00 c0       	rjmp	.+0      	; 0xec <rprintfNum+0xec>
   			s = '-';
		}else if(n > 0){
  ec:	ef 28       	or	r14, r15
  ee:	e0 2a       	or	r14, r16
  f0:	e1 2a       	or	r14, r17
  f2:	01 f4       	brne	.+0      	; 0xf4 <rprintfNum+0xf4>
		}
	}

	// apply signed notation if requested
	if( isSigned )	{
		char s = ' ';
  f4:	80 e2       	ldi	r24, 0x20	; 32
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <rprintfNum+0xf8>
		if(n < 0){
   			s = '-';
  f8:	8d e2       	ldi	r24, 0x2D	; 45
  fa:	00 c0       	rjmp	.+0      	; 0xfc <rprintfNum+0xfc>
		}else if(n > 0){
	   		s = '+';
  fc:	8b e2       	ldi	r24, 0x2B	; 43
		}
		*--p = s;
  fe:	82 93       	st	-Z, r24
 100:	8f 01       	movw	r16, r30
//
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
 102:	de 0e       	add	r13, r30
 104:	00 c0       	rjmp	.+0      	; 0x106 <rprintfNum+0x106>
	}

	// print the string right-justified
	count = numDigits;
	while(count--){
		rprintfChar(*p++);
 106:	f8 01       	movw	r30, r16
 108:	81 91       	ld	r24, Z+
 10a:	8f 01       	movw	r16, r30
 10c:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
		*--p = s;
	}

	// print the string right-justified
	count = numDigits;
	while(count--){
 110:	d0 12       	cpse	r13, r16
 112:	00 c0       	rjmp	.+0      	; 0x114 <rprintfNum+0x114>
		rprintfChar(*p++);
	}
}
 114:	a0 96       	adiw	r28, 0x20	; 32
 116:	0f b6       	in	r0, 0x3f	; 63
 118:	f8 94       	cli
 11a:	de bf       	out	0x3e, r29	; 62
 11c:	0f be       	out	0x3f, r0	; 63
 11e:	cd bf       	out	0x3d, r28	; 61
 120:	df 91       	pop	r29
 122:	cf 91       	pop	r28
 124:	1f 91       	pop	r17
 126:	0f 91       	pop	r16
 128:	ff 90       	pop	r15
 12a:	ef 90       	pop	r14
 12c:	df 90       	pop	r13
 12e:	cf 90       	pop	r12
 130:	bf 90       	pop	r11
 132:	af 90       	pop	r10
 134:	9f 90       	pop	r9
 136:	8f 90       	pop	r8
 138:	7f 90       	pop	r7
 13a:	6f 90       	pop	r6
 13c:	5f 90       	pop	r5
 13e:	3f 90       	pop	r3
 140:	2f 90       	pop	r2
 142:	08 95       	ret

rprintfs.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000017e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001b2  2**0
                  ALLOC
  3 .debug_info   0000022b  00000000  00000000  000001b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000123  00000000  00000000  000003dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002cd  00000000  00000000  00000500  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000007cd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000012a  00000000  00000000  000007ed  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000018e  00000000  00000000  00000917  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00000aa5  2**0
                  CONTENTS, READONLY
 10 .debug_frame  0000006c  00000000  00000000  00000ad0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
   0:	7f 92       	push	r7
   2:	8f 92       	push	r8
   4:	9f 92       	push	r9
   6:	af 92       	push	r10
   8:	bf 92       	push	r11
   a:	cf 92       	push	r12
   c:	df 92       	push	r13
   e:	ef 92       	push	r14
  10:	ff 92       	push	r15
  12:	0f 93       	push	r16
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	00 d0       	rcall	.+0      	; 0x1c <rprintf1RamRom+0x1c>
  1c:	1f 92       	push	r1
  1e:	cd b7       	in	r28, 0x3d	; 61
  20:	de b7       	in	r29, 0x3e	; 62
  22:	ec 89       	ldd	r30, Y+20	; 0x14
  24:	fd 89       	ldd	r31, Y+21	; 0x15
	char format_flag;
	char* str;
	unsigned int u_val, div_val, base;
	va_list ap;

	va_start(ap, format);
  26:	ce 01       	movw	r24, r28
  28:	46 96       	adiw	r24, 0x16	; 22
  2a:	9a 83       	std	Y+2, r25	; 0x02
  2c:	89 83       	std	Y+1, r24	; 0x01
					rprintfChar('-');
				}
			}
			if(format_flag == 'u' || format_flag == 'd'){
				// Strip leading zeroes
				while (div_val > 1 && div_val > u_val) div_val /= 10;
  2e:	3a e0       	ldi	r19, 0x0A	; 10
  30:	83 2e       	mov	r8, r19
  32:	91 2c       	mov	r9, r1
  34:	00 c0       	rjmp	.+0      	; 0x36 <rprintf1RamRom+0x36>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
  36:	88 23       	and	r24, r24
  38:	01 f4       	brne	.+0      	; 0x3a <rprintf1RamRom+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <rprintf1RamRom+0x3c>
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
  3c:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
  40:	68 01       	movw	r12, r16
  42:	f6 01       	movw	r30, r12
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
  44:	8b 89       	ldd	r24, Y+19	; 0x13
  46:	88 23       	and	r24, r24
  48:	01 f0       	breq	.+0      	; 0x4a <rprintf1RamRom+0x4a>
  4a:	8f 01       	movw	r16, r30
  4c:	0f 5f       	subi	r16, 0xFF	; 255
  4e:	1f 4f       	sbci	r17, 0xFF	; 255
  50:	84 91       	lpm	r24, Z
  52:	85 32       	cpi	r24, 0x25	; 37
  54:	01 f4       	brne	.+0      	; 0x56 <rprintf1RamRom+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <rprintf1RamRom+0x58>
  58:	80 81       	ld	r24, Z
  5a:	85 32       	cpi	r24, 0x25	; 37
  5c:	01 f0       	breq	.+0      	; 0x5e <rprintf1RamRom+0x5e>
  5e:	8f 01       	movw	r16, r30
  60:	0f 5f       	subi	r16, 0xFF	; 255
  62:	1f 4f       	sbci	r17, 0xFF	; 255
  64:	00 c0       	rjmp	.+0      	; 0x66 <rprintf1RamRom+0x66>
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
  66:	6f 01       	movw	r12, r30
  68:	82 e0       	ldi	r24, 0x02	; 2
  6a:	c8 0e       	add	r12, r24
  6c:	d1 1c       	adc	r13, r1
  6e:	f8 01       	movw	r30, r16
  70:	94 91       	lpm	r25, Z
  72:	00 c0       	rjmp	.+0      	; 0x74 <rprintf1RamRom+0x74>
  74:	6f 01       	movw	r12, r30
  76:	82 e0       	ldi	r24, 0x02	; 2
  78:	c8 0e       	add	r12, r24
  7a:	d1 1c       	adc	r13, r1
  7c:	91 81       	ldd	r25, Z+1	; 0x01
  7e:	93 37       	cpi	r25, 0x73	; 115
  80:	01 f0       	breq	.+0      	; 0x82 <rprintf1RamRom+0x82>
  82:	00 f4       	brcc	.+0      	; 0x84 <rprintf1RamRom+0x84>
  84:	93 36       	cpi	r25, 0x63	; 99
  86:	01 f0       	breq	.+0      	; 0x88 <rprintf1RamRom+0x88>
  88:	94 36       	cpi	r25, 0x64	; 100
  8a:	01 f0       	breq	.+0      	; 0x8c <rprintf1RamRom+0x8c>
  8c:	95 32       	cpi	r25, 0x25	; 37
  8e:	01 f4       	brne	.+0      	; 0x90 <rprintf1RamRom+0x90>
  90:	00 c0       	rjmp	.+0      	; 0x92 <rprintf1RamRom+0x92>
  92:	95 37       	cpi	r25, 0x75	; 117
  94:	01 f0       	breq	.+0      	; 0x96 <rprintf1RamRom+0x96>
  96:	98 37       	cpi	r25, 0x78	; 120
  98:	01 f4       	brne	.+0      	; 0x9a <rprintf1RamRom+0x9a>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <rprintf1RamRom+0x9c>
					  continue;
			default:  rprintfChar('%');
			case '%':
					  rprintfChar(format_flag);
					  continue;
			case 'u': case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
  9c:	2a e0       	ldi	r18, 0x0A	; 10
  9e:	a2 2e       	mov	r10, r18
  a0:	b1 2c       	mov	r11, r1
  a2:	00 e1       	ldi	r16, 0x10	; 16
  a4:	17 e2       	ldi	r17, 0x27	; 39
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <rprintf1RamRom+0xa8>
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
		{
			case 's': str = va_arg(ap,char*); rprintfStr(str);continue;
  a8:	e9 81       	ldd	r30, Y+1	; 0x01
  aa:	fa 81       	ldd	r31, Y+2	; 0x02
  ac:	cf 01       	movw	r24, r30
  ae:	02 96       	adiw	r24, 0x02	; 2
  b0:	9a 83       	std	Y+2, r25	; 0x02
  b2:	89 83       	std	Y+1, r24	; 0x01
  b4:	80 81       	ld	r24, Z
  b6:	91 81       	ldd	r25, Z+1	; 0x01
  b8:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
  bc:	00 c0       	rjmp	.+0      	; 0xbe <rprintf1RamRom+0xbe>
			case 'c': format_flag = va_arg(ap,int);
  be:	e9 81       	ldd	r30, Y+1	; 0x01
  c0:	fa 81       	ldd	r31, Y+2	; 0x02
  c2:	cf 01       	movw	r24, r30
  c4:	02 96       	adiw	r24, 0x02	; 2
  c6:	9a 83       	std	Y+2, r25	; 0x02
  c8:	89 83       	std	Y+1, r24	; 0x01
					  rprintfChar(format_flag);
  ca:	80 81       	ld	r24, Z
  cc:	00 c0       	rjmp	.+0      	; 0xce <rprintf1RamRom+0xce>
					  continue;
			default:  rprintfChar('%');
  ce:	85 e2       	ldi	r24, 0x25	; 37
  d0:	9b 83       	std	Y+3, r25	; 0x03
  d2:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
  d6:	9b 81       	ldd	r25, Y+3	; 0x03
			case '%':
					  rprintfChar(format_flag);
  d8:	89 2f       	mov	r24, r25
  da:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
					  continue;
  de:	00 c0       	rjmp	.+0      	; 0xe0 <rprintf1RamRom+0xe0>
			case 'u': case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
			case 'x': base = 16; div_val = 0x1000;
  e0:	80 e1       	ldi	r24, 0x10	; 16
  e2:	a8 2e       	mov	r10, r24
  e4:	b1 2c       	mov	r11, r1
  e6:	00 e0       	ldi	r16, 0x00	; 0
  e8:	10 e1       	ldi	r17, 0x10	; 16

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
  ea:	e9 81       	ldd	r30, Y+1	; 0x01
  ec:	fa 81       	ldd	r31, Y+2	; 0x02
  ee:	9f 01       	movw	r18, r30
  f0:	2e 5f       	subi	r18, 0xFE	; 254
  f2:	3f 4f       	sbci	r19, 0xFF	; 255
  f4:	3a 83       	std	Y+2, r19	; 0x02
  f6:	29 83       	std	Y+1, r18	; 0x01
  f8:	e0 80       	ld	r14, Z
  fa:	f1 80       	ldd	r15, Z+1	; 0x01
			if (format_flag == 'd')
  fc:	94 36       	cpi	r25, 0x64	; 100
  fe:	01 f4       	brne	.+0      	; 0x100 <rprintf1RamRom+0x100>
			{
				if (((int)u_val) < 0)
 100:	f7 fe       	sbrs	r15, 7
 102:	00 c0       	rjmp	.+0      	; 0x104 <rprintf1RamRom+0x104>
				{
					u_val = - u_val;
 104:	f1 94       	neg	r15
 106:	e1 94       	neg	r14
 108:	f1 08       	sbc	r15, r1
					rprintfChar('-');
 10a:	8d e2       	ldi	r24, 0x2D	; 45
 10c:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 110:	00 c0       	rjmp	.+0      	; 0x112 <rprintf1RamRom+0x112>
				}
			}
			if(format_flag == 'u' || format_flag == 'd'){
 112:	95 37       	cpi	r25, 0x75	; 117
 114:	01 f4       	brne	.+0      	; 0x116 <rprintf1RamRom+0x116>
 116:	00 c0       	rjmp	.+0      	; 0x118 <rprintf1RamRom+0x118>
				// Strip leading zeroes
				while (div_val > 1 && div_val > u_val) div_val /= 10;
 118:	c8 01       	movw	r24, r16
 11a:	b4 01       	movw	r22, r8
 11c:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 120:	8b 01       	movw	r16, r22
 122:	62 30       	cpi	r22, 0x02	; 2
 124:	71 05       	cpc	r23, r1
 126:	00 f0       	brcs	.+0      	; 0x128 <rprintf1RamRom+0x128>
 128:	e0 16       	cp	r14, r16
 12a:	f1 06       	cpc	r15, r17
 12c:	00 f0       	brcs	.+0      	; 0x12e <rprintf1RamRom+0x12e>
			}
			do
			{
				rprintfu04(u_val/div_val);
 12e:	c7 01       	movw	r24, r14
 130:	b8 01       	movw	r22, r16
 132:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 136:	78 2e       	mov	r7, r24
 138:	86 2f       	mov	r24, r22
 13a:	9b 83       	std	Y+3, r25	; 0x03
 13c:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
				u_val %= div_val;
 140:	e7 2c       	mov	r14, r7
 142:	9b 81       	ldd	r25, Y+3	; 0x03
 144:	f9 2e       	mov	r15, r25
				div_val /= base;
 146:	c8 01       	movw	r24, r16
 148:	b5 01       	movw	r22, r10
 14a:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 14e:	8b 01       	movw	r16, r22
			} while (div_val);
 150:	61 15       	cp	r22, r1
 152:	71 05       	cpc	r23, r1
 154:	01 f4       	brne	.+0      	; 0x156 <rprintf1RamRom+0x156>
 156:	00 c0       	rjmp	.+0      	; 0x158 <rprintf1RamRom+0x158>
		}
	}
	va_end(ap);
}
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	0f 90       	pop	r0
 15e:	0f 90       	pop	r0
 160:	0f 90       	pop	r0
 162:	df 91       	pop	r29
 164:	cf 91       	pop	r28
 166:	1f 91       	pop	r17
 168:	0f 91       	pop	r16
 16a:	ff 90       	pop	r15
 16c:	ef 90       	pop	r14
 16e:	df 90       	pop	r13
 170:	cf 90       	pop	r12
 172:	bf 90       	pop	r11
 174:	af 90       	pop	r10
 176:	9f 90       	pop	r9
 178:	8f 90       	pop	r8
 17a:	7f 90       	pop	r7
 17c:	08 95       	ret

scheduler.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000035c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000390  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000390  2**0
                  ALLOC
  3 .debug_info   00000c03  00000000  00000000  00000390  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000002ed  00000000  00000000  00000f93  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000709  00000000  00000000  00001280  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001989  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  000019a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000155  00000000  00000000  000019c1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000691  00000000  00000000  00001b16  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000021a7  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000ec  00000000  00000000  000021d4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__scheduleUpdate>:
		}
	}
}

// called under compare interrupts when there is something in the queu
void __scheduleUpdate(const TimerCompare *channel, void* data){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	61 97       	sbiw	r28, 0x11	; 17
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	98 87       	std	Y+8, r25	; 0x08
  36:	8f 83       	std	Y+7, r24	; 0x07
	// Dont call me again
	compareDetach(channel);
  38:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>

	// Turn interrupts back on
	INTERRUPTABLE_SECTION_START;
  3c:	2f b7       	in	r18, 0x3f	; 63
  3e:	29 87       	std	Y+9, r18	; 0x09
  40:	78 94       	sei
	__running = TRUE;
  42:	8f ef       	ldi	r24, 0xFF	; 255
  44:	80 93 00 00 	sts	0x0000, r24
	TICK_COUNT lowest;
	do{
		int slot;
		__recheck = FALSE;
  48:	10 92 00 00 	sts	0x0000, r1
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
  4c:	80 91 00 00 	lds	r24, 0x0000
  50:	90 e0       	ldi	r25, 0x00	; 0
  52:	01 97       	sbiw	r24, 0x01	; 1
  54:	3d e0       	ldi	r19, 0x0D	; 13
  56:	38 9f       	mul	r19, r24
  58:	10 01       	movw	r2, r0
  5a:	39 9f       	mul	r19, r25
  5c:	30 0c       	add	r3, r0
  5e:	11 24       	eor	r1, r1
  60:	a0 e0       	ldi	r26, 0x00	; 0
  62:	b0 e0       	ldi	r27, 0x00	; 0
  64:	2a 0e       	add	r2, r26
  66:	3b 1e       	adc	r3, r27
  68:	1e 82       	std	Y+6, r1	; 0x06
  6a:	1d 82       	std	Y+5, r1	; 0x05
	TICK_COUNT lowest;
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
  6c:	c1 2c       	mov	r12, r1
  6e:	d1 2c       	mov	r13, r1
  70:	76 01       	movw	r14, r12
		}
	}
}

// called under compare interrupts when there is something in the queu
void __scheduleUpdate(const TimerCompare *channel, void* data){
  72:	9b 87       	std	Y+11, r25	; 0x0b
  74:	8a 87       	std	Y+10, r24	; 0x0a
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
  76:	00 c0       	rjmp	.+0      	; 0x78 <__scheduleUpdate+0x78>
			if(job->used){
  78:	f1 01       	movw	r30, r2
  7a:	80 81       	ld	r24, Z
  7c:	88 23       	and	r24, r24
  7e:	01 f4       	brne	.+0      	; 0x80 <__scheduleUpdate+0x80>
  80:	00 c0       	rjmp	.+0      	; 0x82 <__scheduleUpdate+0x82>
				// check if time has elapsed
				TICK_COUNT overflow;	// how many us the timer has overshot when it should have happened
				TICK_COUNT start=job->start;
  82:	81 84       	ldd	r8, Z+9	; 0x09
  84:	92 84       	ldd	r9, Z+10	; 0x0a
  86:	a3 84       	ldd	r10, Z+11	; 0x0b
  88:	b4 84       	ldd	r11, Z+12	; 0x0c
				TICK_COUNT delay=job->delay;
  8a:	45 80       	ldd	r4, Z+5	; 0x05
  8c:	56 80       	ldd	r5, Z+6	; 0x06
  8e:	67 80       	ldd	r6, Z+7	; 0x07
  90:	70 84       	ldd	r7, Z+8	; 0x08
				if(clockHasElapsedGetOverflow(start, delay, &overflow)){
  92:	8e 01       	movw	r16, r28
  94:	0f 5f       	subi	r16, 0xFF	; 255
  96:	1f 4f       	sbci	r17, 0xFF	; 255
  98:	a3 01       	movw	r20, r6
  9a:	92 01       	movw	r18, r4
  9c:	c5 01       	movw	r24, r10
  9e:	b4 01       	movw	r22, r8
  a0:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
  a4:	09 81       	ldd	r16, Y+1	; 0x01
  a6:	1a 81       	ldd	r17, Y+2	; 0x02
  a8:	2b 81       	ldd	r18, Y+3	; 0x03
  aa:	3c 81       	ldd	r19, Y+4	; 0x04
  ac:	88 23       	and	r24, r24
  ae:	01 f0       	breq	.+0      	; 0xb0 <__scheduleUpdate+0xb0>
					SchedulerCallback callback = job->callback;
  b0:	d1 01       	movw	r26, r2
  b2:	11 96       	adiw	r26, 0x01	; 1
  b4:	0d 90       	ld	r0, X+
  b6:	bc 91       	ld	r27, X
  b8:	a0 2d       	mov	r26, r0
  ba:	b9 8b       	std	Y+17, r27	; 0x11
  bc:	a8 8b       	std	Y+16, r26	; 0x10
					SchedulerData data = job->data;
  be:	f1 01       	movw	r30, r2
  c0:	a3 81       	ldd	r26, Z+3	; 0x03
  c2:	b4 81       	ldd	r27, Z+4	; 0x04

					// Mark this job as unused. No more references shoud be made to job->xxxx
					job->used = FALSE;
  c4:	10 82       	st	Z, r1
					--__numJobs;
  c6:	80 91 00 00 	lds	r24, 0x0000
  ca:	90 91 00 00 	lds	r25, 0x0000
  ce:	01 97       	sbiw	r24, 0x01	; 1
  d0:	90 93 00 00 	sts	0x0000, r25
  d4:	80 93 00 00 	sts	0x0000, r24

					// Run the job with interrupts enabled
					callback(data,start+delay,overflow);
  d8:	b3 01       	movw	r22, r6
  da:	a2 01       	movw	r20, r4
  dc:	48 0d       	add	r20, r8
  de:	59 1d       	adc	r21, r9
  e0:	6a 1d       	adc	r22, r10
  e2:	7b 1d       	adc	r23, r11
  e4:	cd 01       	movw	r24, r26
  e6:	e8 89       	ldd	r30, Y+16	; 0x10
  e8:	f9 89       	ldd	r31, Y+17	; 0x11
  ea:	09 95       	icall


					// Force another loop as the time taken may mean
					// something else can now run
					__recheck = TRUE;
  ec:	ff ef       	ldi	r31, 0xFF	; 255
  ee:	f0 93 00 00 	sts	0x0000, r31
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <__scheduleUpdate+0xf4>
				}else{
				   // overflow has the remaining number of microseconds to wait
				   if(lowest==0 || overflow < lowest){
  f4:	c1 14       	cp	r12, r1
  f6:	d1 04       	cpc	r13, r1
  f8:	e1 04       	cpc	r14, r1
  fa:	f1 04       	cpc	r15, r1
  fc:	01 f0       	breq	.+0      	; 0xfe <__scheduleUpdate+0xfe>
  fe:	0c 15       	cp	r16, r12
 100:	1d 05       	cpc	r17, r13
 102:	2e 05       	cpc	r18, r14
 104:	3f 05       	cpc	r19, r15
 106:	00 f4       	brcc	.+0      	; 0x108 <__scheduleUpdate+0x108>
					   lowest = overflow;
 108:	68 01       	movw	r12, r16
 10a:	79 01       	movw	r14, r18
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
 10c:	2d e0       	ldi	r18, 0x0D	; 13
 10e:	22 1a       	sub	r2, r18
 110:	31 08       	sbc	r3, r1
 112:	8d 81       	ldd	r24, Y+5	; 0x05
 114:	9e 81       	ldd	r25, Y+6	; 0x06
 116:	01 96       	adiw	r24, 0x01	; 1
 118:	9e 83       	std	Y+6, r25	; 0x06
 11a:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
}

// called under compare interrupts when there is something in the queu
void __scheduleUpdate(const TimerCompare *channel, void* data){
 11c:	8a 85       	ldd	r24, Y+10	; 0x0a
 11e:	9b 85       	ldd	r25, Y+11	; 0x0b
 120:	ad 81       	ldd	r26, Y+5	; 0x05
 122:	be 81       	ldd	r27, Y+6	; 0x06
 124:	8a 1b       	sub	r24, r26
 126:	9b 0b       	sbc	r25, r27
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
 128:	01 96       	adiw	r24, 0x01	; 1
 12a:	01 f0       	breq	.+0      	; 0x12c <__scheduleUpdate+0x12c>
 12c:	00 c0       	rjmp	.+0      	; 0x12e <__scheduleUpdate+0x12e>
					   lowest = overflow;
				   }
				}
			}
		}
	}while( __recheck);
 12e:	80 91 00 00 	lds	r24, 0x0000
 132:	81 11       	cpse	r24, r1
 134:	00 c0       	rjmp	.+0      	; 0x136 <__scheduleUpdate+0x136>
	__running=FALSE;
 136:	10 92 00 00 	sts	0x0000, r1

	if(__numJobs > 0){
 13a:	80 91 00 00 	lds	r24, 0x0000
 13e:	90 91 00 00 	lds	r25, 0x0000
 142:	18 16       	cp	r1, r24
 144:	19 06       	cpc	r1, r25
 146:	04 f0       	brlt	.+0      	; 0x148 <__scheduleUpdate+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <__scheduleUpdate+0x14a>
#define CHANNEL_NUM 1


// Calculate the required compare threshold to cause an interrupt at the required time
static uint16_t calcTicks(TICK_COUNT us){
	TICK_COUNT ticks = (us * cpu_speed_div_1000000) / timerGetPrescaler(g_heartbeat);
 14a:	00 91 00 00 	lds	r16, 0x0000
 14e:	10 91 00 00 	lds	r17, 0x0000
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 152:	f8 01       	movw	r30, r16
 154:	a5 90       	lpm	r10, Z+
 156:	b4 90       	lpm	r11, Z
 158:	a0 91 00 00 	lds	r26, 0x0000
 15c:	b0 91 00 00 	lds	r27, 0x0000
 160:	a7 01       	movw	r20, r14
 162:	96 01       	movw	r18, r12
 164:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 168:	f5 01       	movw	r30, r10
 16a:	20 81       	ld	r18, Z
 16c:	31 81       	ldd	r19, Z+1	; 0x01
 16e:	40 e0       	ldi	r20, 0x00	; 0
 170:	50 e0       	ldi	r21, 0x00	; 0
 172:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	uint16_t top = timerGetTOP(g_heartbeat);
 176:	c8 01       	movw	r24, r16
 178:	2c 87       	std	Y+12, r18	; 0x0c
 17a:	3d 87       	std	Y+13, r19	; 0x0d
 17c:	4e 87       	std	Y+14, r20	; 0x0e
 17e:	5f 87       	std	Y+15, r21	; 0x0f
 180:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	uint16_t rtn = MIN(ticks,top);
 184:	a0 e0       	ldi	r26, 0x00	; 0
 186:	b0 e0       	ldi	r27, 0x00	; 0
 188:	2c 85       	ldd	r18, Y+12	; 0x0c
 18a:	3d 85       	ldd	r19, Y+13	; 0x0d
 18c:	4e 85       	ldd	r20, Y+14	; 0x0e
 18e:	5f 85       	ldd	r21, Y+15	; 0x0f
 190:	28 17       	cp	r18, r24
 192:	39 07       	cpc	r19, r25
 194:	4a 07       	cpc	r20, r26
 196:	5b 07       	cpc	r21, r27
 198:	00 f4       	brcc	.+0      	; 0x19a <__scheduleUpdate+0x19a>
 19a:	da 01       	movw	r26, r20
 19c:	c9 01       	movw	r24, r18
 19e:	7c 01       	movw	r14, r24
	}while( __recheck);
	__running=FALSE;

	if(__numJobs > 0){
		uint16_t compare = calcTicks(lowest);
		uint16_t top = timerGetTOP(g_heartbeat);
 1a0:	80 91 00 00 	lds	r24, 0x0000
 1a4:	90 91 00 00 	lds	r25, 0x0000
 1a8:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 1ac:	8c 01       	movw	r16, r24
		compare += timerGetCounter(g_heartbeat);
 1ae:	80 91 00 00 	lds	r24, 0x0000
 1b2:	90 91 00 00 	lds	r25, 0x0000
 1b6:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 1ba:	8e 0d       	add	r24, r14
 1bc:	9f 1d       	adc	r25, r15
		compare %= top;
 1be:	b8 01       	movw	r22, r16
 1c0:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
        compareAttach(channel,&__scheduleUpdate,compare,null);
 1c4:	20 e0       	ldi	r18, 0x00	; 0
 1c6:	30 e0       	ldi	r19, 0x00	; 0
 1c8:	ac 01       	movw	r20, r24
 1ca:	60 e0       	ldi	r22, 0x00	; 0
 1cc:	70 e0       	ldi	r23, 0x00	; 0
 1ce:	8f 81       	ldd	r24, Y+7	; 0x07
 1d0:	98 85       	ldd	r25, Y+8	; 0x08
 1d2:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	}

	// Restore previous interrupt enable
	INTERRUPTABLE_SECTION_END;
 1d6:	f9 85       	ldd	r31, Y+9	; 0x09
 1d8:	ff bf       	out	0x3f, r31	; 63
}
 1da:	61 96       	adiw	r28, 0x11	; 17
 1dc:	0f b6       	in	r0, 0x3f	; 63
 1de:	f8 94       	cli
 1e0:	de bf       	out	0x3e, r29	; 62
 1e2:	0f be       	out	0x3f, r0	; 63
 1e4:	cd bf       	out	0x3d, r28	; 61
 1e6:	df 91       	pop	r29
 1e8:	cf 91       	pop	r28
 1ea:	1f 91       	pop	r17
 1ec:	0f 91       	pop	r16
 1ee:	ff 90       	pop	r15
 1f0:	ef 90       	pop	r14
 1f2:	df 90       	pop	r13
 1f4:	cf 90       	pop	r12
 1f6:	bf 90       	pop	r11
 1f8:	af 90       	pop	r10
 1fa:	9f 90       	pop	r9
 1fc:	8f 90       	pop	r8
 1fe:	7f 90       	pop	r7
 200:	6f 90       	pop	r6
 202:	5f 90       	pop	r5
 204:	4f 90       	pop	r4
 206:	3f 90       	pop	r3
 208:	2f 90       	pop	r2
 20a:	08 95       	ret

0000020c <scheduleJob>:
// schedule a new job
// callback Is the function to be run at a later date
// data is a block of data to be passed into the callback
// start (in us) Is the start time of the delay
// delay (in us) Is the amount to delay by
void scheduleJob(SchedulerCallback callback, SchedulerData data, TICK_COUNT start, TICK_COUNT delay){
 20c:	4f 92       	push	r4
 20e:	5f 92       	push	r5
 210:	6f 92       	push	r6
 212:	7f 92       	push	r7
 214:	8f 92       	push	r8
 216:	9f 92       	push	r9
 218:	af 92       	push	r10
 21a:	bf 92       	push	r11
 21c:	cf 92       	push	r12
 21e:	df 92       	push	r13
 220:	ef 92       	push	r14
 222:	ff 92       	push	r15
 224:	0f 93       	push	r16
 226:	1f 93       	push	r17
 228:	cf 93       	push	r28
 22a:	df 93       	push	r29
 22c:	00 d0       	rcall	.+0      	; 0x22e <scheduleJob+0x22>
 22e:	00 d0       	rcall	.+0      	; 0x230 <scheduleJob+0x24>
 230:	cd b7       	in	r28, 0x3d	; 61
 232:	de b7       	in	r29, 0x3e	; 62
 234:	3c 01       	movw	r6, r24
 236:	2b 01       	movw	r4, r22
 238:	49 01       	movw	r8, r18
 23a:	5a 01       	movw	r10, r20
 23c:	67 01       	movw	r12, r14
 23e:	78 01       	movw	r14, r16
	boolean doItNow = FALSE;

 	if(delay < 1000U){
 240:	88 ee       	ldi	r24, 0xE8	; 232
 242:	c8 16       	cp	r12, r24
 244:	83 e0       	ldi	r24, 0x03	; 3
 246:	d8 06       	cpc	r13, r24
 248:	e1 04       	cpc	r14, r1
 24a:	f1 04       	cpc	r15, r1
 24c:	00 f0       	brcs	.+0      	; 0x24e <scheduleJob+0x42>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <scheduleJob+0x44>
		// it needs to happen now as the delay is < the heartbeat timer interrupt of 1ms
		if(__running){
 250:	80 91 00 00 	lds	r24, 0x0000
 254:	88 23       	and	r24, r24
 256:	01 f0       	breq	.+0      	; 0x258 <scheduleJob+0x4c>
			// make sure we do another loop of __scheduleUpdate to find it
			__recheck=TRUE;
 258:	8f ef       	ldi	r24, 0xFF	; 255
 25a:	80 93 00 00 	sts	0x0000, r24
 25e:	00 c0       	rjmp	.+0      	; 0x260 <scheduleJob+0x54>
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
			for(slot=0; slot<maxJobs; slot++){
				JOB* job = &__queue[slot];
 260:	d9 01       	movw	r26, r18
 262:	23 5f       	subi	r18, 0xF3	; 243
 264:	3f 4f       	sbci	r19, 0xFF	; 255
// schedule a new job
// callback Is the function to be run at a later date
// data is a block of data to be passed into the callback
// start (in us) Is the start time of the delay
// delay (in us) Is the amount to delay by
void scheduleJob(SchedulerCallback callback, SchedulerData data, TICK_COUNT start, TICK_COUNT delay){
 266:	f9 01       	movw	r30, r18
 268:	3d 97       	sbiw	r30, 0x0d	; 13
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
			for(slot=0; slot<maxJobs; slot++){
				JOB* job = &__queue[slot];
				if(!job->used){
 26a:	70 81       	ld	r23, Z
 26c:	71 11       	cpse	r23, r1
 26e:	00 c0       	rjmp	.+0      	; 0x270 <scheduleJob+0x64>
					job->used = TRUE;
 270:	8f ef       	ldi	r24, 0xFF	; 255
 272:	8c 93       	st	X, r24
					job->callback = callback;
 274:	12 96       	adiw	r26, 0x02	; 2
 276:	7c 92       	st	X, r7
 278:	6e 92       	st	-X, r6
 27a:	11 97       	sbiw	r26, 0x01	; 1
					job->data = data;
 27c:	14 96       	adiw	r26, 0x04	; 4
 27e:	5c 92       	st	X, r5
 280:	4e 92       	st	-X, r4
 282:	13 97       	sbiw	r26, 0x03	; 3
					job->start=start;
 284:	19 96       	adiw	r26, 0x09	; 9
 286:	8d 92       	st	X+, r8
 288:	9d 92       	st	X+, r9
 28a:	ad 92       	st	X+, r10
 28c:	bc 92       	st	X, r11
 28e:	1c 97       	sbiw	r26, 0x0c	; 12
					job->delay=delay;
 290:	15 96       	adiw	r26, 0x05	; 5
 292:	cd 92       	st	X+, r12
 294:	dd 92       	st	X+, r13
 296:	ed 92       	st	X+, r14
 298:	fc 92       	st	X, r15
 29a:	18 97       	sbiw	r26, 0x08	; 8
					found=TRUE;
					__numJobs++;
 29c:	20 91 00 00 	lds	r18, 0x0000
 2a0:	30 91 00 00 	lds	r19, 0x0000
 2a4:	2f 5f       	subi	r18, 0xFF	; 255
 2a6:	3f 4f       	sbci	r19, 0xFF	; 255
 2a8:	30 93 00 00 	sts	0x0000, r19
 2ac:	20 93 00 00 	sts	0x0000, r18
					break;
 2b0:	00 c0       	rjmp	.+0      	; 0x2b2 <scheduleJob+0xa6>
	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
			for(slot=0; slot<maxJobs; slot++){
 2b2:	4f 5f       	subi	r20, 0xFF	; 255
 2b4:	5f 4f       	sbci	r21, 0xFF	; 255
 2b6:	48 17       	cp	r20, r24
 2b8:	59 07       	cpc	r21, r25
 2ba:	04 f0       	brlt	.+0      	; 0x2bc <scheduleJob+0xb0>
	}

	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
 2bc:	80 e0       	ldi	r24, 0x00	; 0
					found=TRUE;
					__numJobs++;
					break;
				}
			}
		CRITICAL_SECTION_END; // end atomic
 2be:	6f bf       	out	0x3f, r22	; 63

		if(!found){
 2c0:	81 11       	cpse	r24, r1
 2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <scheduleJob+0xb8>
			// the queue is exhausted
			setError(SCHEDULER_EXHAUSTED);
 2c4:	8f ef       	ldi	r24, 0xFF	; 255
 2c6:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	if(doItNow){
		// we need to do it now
		TICK_COUNT overflow;

		// wait for expiry
		while(!clockHasElapsedGetOverflow(start, delay, &overflow)){
 2ca:	8e 01       	movw	r16, r28
 2cc:	0f 5f       	subi	r16, 0xFF	; 255
 2ce:	1f 4f       	sbci	r17, 0xFF	; 255
 2d0:	a7 01       	movw	r20, r14
 2d2:	96 01       	movw	r18, r12
 2d4:	c5 01       	movw	r24, r10
 2d6:	b4 01       	movw	r22, r8
 2d8:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 2dc:	88 23       	and	r24, r24
 2de:	01 f0       	breq	.+0      	; 0x2e0 <scheduleJob+0xd4>
		}

		// callback
		callback(data,start+delay,overflow);
 2e0:	09 81       	ldd	r16, Y+1	; 0x01
 2e2:	1a 81       	ldd	r17, Y+2	; 0x02
 2e4:	2b 81       	ldd	r18, Y+3	; 0x03
 2e6:	3c 81       	ldd	r19, Y+4	; 0x04
 2e8:	b7 01       	movw	r22, r14
 2ea:	a6 01       	movw	r20, r12
 2ec:	48 0d       	add	r20, r8
 2ee:	59 1d       	adc	r21, r9
 2f0:	6a 1d       	adc	r22, r10
 2f2:	7b 1d       	adc	r23, r11
 2f4:	c2 01       	movw	r24, r4
 2f6:	f3 01       	movw	r30, r6
 2f8:	09 95       	icall
 2fa:	00 c0       	rjmp	.+0      	; 0x2fc <scheduleJob+0xf0>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 2fc:	e0 91 00 00 	lds	r30, 0x0000
 300:	f0 91 00 00 	lds	r31, 0x0000
 304:	77 96       	adiw	r30, 0x17	; 23
 306:	85 91       	lpm	r24, Z+
 308:	94 91       	lpm	r25, Z
	}else{
		if(!__running){
			const TimerCompare* channel = timerGetCompare(g_heartbeat,CHANNEL_NUM);
			__scheduleUpdate(channel, null);
 30a:	60 e0       	ldi	r22, 0x00	; 0
 30c:	70 e0       	ldi	r23, 0x00	; 0
 30e:	40 96       	adiw	r24, 0x10	; 16
 310:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 314:	00 c0       	rjmp	.+0      	; 0x316 <scheduleJob+0x10a>

	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
 316:	6f b7       	in	r22, 0x3f	; 63
 318:	f8 94       	cli
			for(slot=0; slot<maxJobs; slot++){
 31a:	80 91 00 00 	lds	r24, 0x0000
 31e:	90 e0       	ldi	r25, 0x00	; 0
 320:	20 e0       	ldi	r18, 0x00	; 0
 322:	30 e0       	ldi	r19, 0x00	; 0
 324:	40 e0       	ldi	r20, 0x00	; 0
 326:	50 e0       	ldi	r21, 0x00	; 0
 328:	00 c0       	rjmp	.+0      	; 0x32a <scheduleJob+0x11e>
		}

		// callback
		callback(data,start+delay,overflow);
	}else{
		if(!__running){
 32a:	80 91 00 00 	lds	r24, 0x0000
 32e:	88 23       	and	r24, r24
 330:	01 f0       	breq	.+0      	; 0x332 <scheduleJob+0x126>
			const TimerCompare* channel = timerGetCompare(g_heartbeat,CHANNEL_NUM);
			__scheduleUpdate(channel, null);
		}
	}
}
 332:	0f 90       	pop	r0
 334:	0f 90       	pop	r0
 336:	0f 90       	pop	r0
 338:	0f 90       	pop	r0
 33a:	df 91       	pop	r29
 33c:	cf 91       	pop	r28
 33e:	1f 91       	pop	r17
 340:	0f 91       	pop	r16
 342:	ff 90       	pop	r15
 344:	ef 90       	pop	r14
 346:	df 90       	pop	r13
 348:	cf 90       	pop	r12
 34a:	bf 90       	pop	r11
 34c:	af 90       	pop	r10
 34e:	9f 90       	pop	r9
 350:	8f 90       	pop	r8
 352:	7f 90       	pop	r7
 354:	6f 90       	pop	r6
 356:	5f 90       	pop	r5
 358:	4f 90       	pop	r4
 35a:	08 95       	ret

segled.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000196  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001ca  2**0
                  ALLOC
  3 .progmem.data 00000024  00000000  00000000  000001ca  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000519  00000000  00000000  000001ee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000258  00000000  00000000  00000707  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000003fc  00000000  00000000  0000095f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000d5b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   000000f7  00000000  00000000  00000d7b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000021e  00000000  00000000  00000e72  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001090  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000090  00000000  00000000  000010bc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <segled_set>:
		led->initialised=TRUE;

	}
}

void segled_set(SEGLED* led, SEGLED_SEGMENT segment, boolean value){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	1f 92       	push	r1
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	6c 01       	movw	r12, r24
  18:	e6 2e       	mov	r14, r22
		0b11011010  // Z
};


static void init(SEGLED* led){
	if(!led->initialised){
  1a:	fc 01       	movw	r30, r24
  1c:	80 89       	ldd	r24, Z+16	; 0x10
  1e:	81 fd       	sbrc	r24, 1
  20:	00 c0       	rjmp	.+0      	; 0x22 <segled_set+0x22>
  22:	86 01       	movw	r16, r12
  24:	88 e0       	ldi	r24, 0x08	; 8
  26:	f8 2e       	mov	r15, r24
		for(uint8_t i=0; i<8;i++){
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
  28:	60 e0       	ldi	r22, 0x00	; 0
  2a:	f8 01       	movw	r30, r16
  2c:	81 91       	ld	r24, Z+
  2e:	91 91       	ld	r25, Z+
  30:	8f 01       	movw	r16, r30
  32:	49 83       	std	Y+1, r20	; 0x01
  34:	0e 94 00 00 	call	0	; 0x0 <segled_set>
  38:	fa 94       	dec	r15
};


static void init(SEGLED* led){
	if(!led->initialised){
		for(uint8_t i=0; i<8;i++){
  3a:	49 81       	ldd	r20, Y+1	; 0x01
  3c:	f1 10       	cpse	r15, r1
  3e:	00 c0       	rjmp	.+0      	; 0x40 <segled_set+0x40>
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
		}
		led->initialised=TRUE;
  40:	f6 01       	movw	r30, r12
  42:	80 89       	ldd	r24, Z+16	; 0x10
  44:	ff ef       	ldi	r31, 0xFF	; 255
  46:	f0 fb       	bst	r31, 0
  48:	81 f9       	bld	r24, 1
  4a:	f6 01       	movw	r30, r12
  4c:	80 8b       	std	Z+16, r24	; 0x10
	}
}

void segled_set(SEGLED* led, SEGLED_SEGMENT segment, boolean value){
	init(led);
	if(!led->activeHigh){
  4e:	f6 01       	movw	r30, r12
  50:	80 89       	ldd	r24, Z+16	; 0x10
  52:	80 fd       	sbrc	r24, 0
  54:	00 c0       	rjmp	.+0      	; 0x56 <segled_set+0x56>
	 	value = (value) ? FALSE : TRUE;
  56:	44 23       	and	r20, r20
  58:	01 f0       	breq	.+0      	; 0x5a <segled_set+0x5a>
  5a:	40 e0       	ldi	r20, 0x00	; 0
  5c:	00 c0       	rjmp	.+0      	; 0x5e <segled_set+0x5e>
  5e:	4f ef       	ldi	r20, 0xFF	; 255
	}
	const IOPin* pin = led->segment[segment];
  60:	f6 01       	movw	r30, r12
  62:	ee 0d       	add	r30, r14
  64:	f1 1d       	adc	r31, r1
  66:	ee 0d       	add	r30, r14
  68:	f1 1d       	adc	r31, r1
	pin_set(pin,value);
  6a:	64 2f       	mov	r22, r20
  6c:	80 81       	ld	r24, Z
  6e:	91 81       	ldd	r25, Z+1	; 0x01
}
  70:	0f 90       	pop	r0
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	cf 90       	pop	r12
	init(led);
	if(!led->activeHigh){
	 	value = (value) ? FALSE : TRUE;
	}
	const IOPin* pin = led->segment[segment];
	pin_set(pin,value);
  82:	0c 94 00 00 	jmp	0	; 0x0 <segled_set>

00000086 <segled_put_char>:
}

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
  86:	cf 92       	push	r12
  88:	df 92       	push	r13
  8a:	ff 92       	push	r15
  8c:	0f 93       	push	r16
  8e:	1f 93       	push	r17
  90:	cf 93       	push	r28
  92:	df 93       	push	r29
  94:	1f 92       	push	r1
  96:	cd b7       	in	r28, 0x3d	; 61
  98:	de b7       	in	r29, 0x3e	; 62
  9a:	6c 01       	movw	r12, r24
  9c:	46 2f       	mov	r20, r22
		0b11011010  // Z
};


static void init(SEGLED* led){
	if(!led->initialised){
  9e:	fc 01       	movw	r30, r24
  a0:	80 89       	ldd	r24, Z+16	; 0x10
  a2:	81 fd       	sbrc	r24, 1
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <segled_put_char+0x20>
  a6:	86 01       	movw	r16, r12
  a8:	98 e0       	ldi	r25, 0x08	; 8
  aa:	f9 2e       	mov	r15, r25
		for(uint8_t i=0; i<8;i++){
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
  ac:	60 e0       	ldi	r22, 0x00	; 0
  ae:	f8 01       	movw	r30, r16
  b0:	81 91       	ld	r24, Z+
  b2:	91 91       	ld	r25, Z+
  b4:	8f 01       	movw	r16, r30
  b6:	49 83       	std	Y+1, r20	; 0x01
  b8:	0e 94 00 00 	call	0	; 0x0 <segled_set>
  bc:	fa 94       	dec	r15
};


static void init(SEGLED* led){
	if(!led->initialised){
		for(uint8_t i=0; i<8;i++){
  be:	49 81       	ldd	r20, Y+1	; 0x01
  c0:	f1 10       	cpse	r15, r1
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <segled_put_char+0x3e>
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
		}
		led->initialised=TRUE;
  c4:	f6 01       	movw	r30, r12
  c6:	80 89       	ldd	r24, Z+16	; 0x10
  c8:	ff ef       	ldi	r31, 0xFF	; 255
  ca:	f0 fb       	bst	r31, 0
  cc:	81 f9       	bld	r24, 1
  ce:	f6 01       	movw	r30, r12
  d0:	80 8b       	std	Z+16, r24	; 0x10
}

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
	init(led);
	uint8_t mask=0;	// default is a space
	if(ch>='A' && ch<='Z'){
  d2:	84 2f       	mov	r24, r20
  d4:	81 54       	subi	r24, 0x41	; 65
  d6:	8a 31       	cpi	r24, 0x1A	; 26
  d8:	00 f4       	brcc	.+0      	; 0xda <segled_put_char+0x54>
		mask=pgm_read_byte(&atoz[ch-'A']);
  da:	e4 2f       	mov	r30, r20
  dc:	f0 e0       	ldi	r31, 0x00	; 0
  de:	e0 50       	subi	r30, 0x00	; 0
  e0:	f0 40       	sbci	r31, 0x00	; 0
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <segled_put_char+0x5e>
	}else if(ch>='a' && ch<='z'){
  e4:	84 2f       	mov	r24, r20
  e6:	81 56       	subi	r24, 0x61	; 97
  e8:	8a 31       	cpi	r24, 0x1A	; 26
  ea:	00 f4       	brcc	.+0      	; 0xec <segled_put_char+0x66>
		mask=pgm_read_byte(&atoz[ch-'a']);
  ec:	e4 2f       	mov	r30, r20
  ee:	f0 e0       	ldi	r31, 0x00	; 0
  f0:	e0 50       	subi	r30, 0x00	; 0
  f2:	f0 40       	sbci	r31, 0x00	; 0
  f4:	14 91       	lpm	r17, Z
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <segled_put_char+0x72>
	}else if(ch>='0' && ch<='9'){
  f8:	84 2f       	mov	r24, r20
  fa:	80 53       	subi	r24, 0x30	; 48
  fc:	8a 30       	cpi	r24, 0x0A	; 10
  fe:	00 f4       	brcc	.+0      	; 0x100 <segled_put_char+0x7a>
		mask=pgm_read_byte(&digits[ch-'0']);
 100:	e4 2f       	mov	r30, r20
 102:	f0 e0       	ldi	r31, 0x00	; 0
 104:	e0 50       	subi	r30, 0x00	; 0
 106:	f0 40       	sbci	r31, 0x00	; 0
 108:	00 c0       	rjmp	.+0      	; 0x10a <segled_put_char+0x84>
	}else if(ch>=0 && ch<=9){
 10a:	4a 30       	cpi	r20, 0x0A	; 10
 10c:	00 f4       	brcc	.+0      	; 0x10e <segled_put_char+0x88>
		mask=pgm_read_byte(&digits[ch]);
 10e:	e4 2f       	mov	r30, r20
 110:	f0 e0       	ldi	r31, 0x00	; 0
 112:	e0 50       	subi	r30, 0x00	; 0
 114:	f0 40       	sbci	r31, 0x00	; 0
 116:	00 c0       	rjmp	.+0      	; 0x118 <segled_put_char+0x92>
	}else if(ch=='-'){
 118:	4d 32       	cpi	r20, 0x2D	; 45
 11a:	01 f0       	breq	.+0      	; 0x11c <segled_put_char+0x96>
		mask = 0b00000010;
	}else if(ch=='[' || ch=='{' || ch=='('){
 11c:	4b 35       	cpi	r20, 0x5B	; 91
 11e:	01 f0       	breq	.+0      	; 0x120 <segled_put_char+0x9a>
 120:	4b 37       	cpi	r20, 0x7B	; 123
 122:	01 f0       	breq	.+0      	; 0x124 <segled_put_char+0x9e>
 124:	48 32       	cpi	r20, 0x28	; 40
 126:	01 f0       	breq	.+0      	; 0x128 <segled_put_char+0xa2>
		mask = 0b10011100;
	}else if(ch==']' || ch=='}' || ch==')'){
 128:	4d 35       	cpi	r20, 0x5D	; 93
 12a:	01 f0       	breq	.+0      	; 0x12c <segled_put_char+0xa6>
 12c:	4d 37       	cpi	r20, 0x7D	; 125
 12e:	01 f0       	breq	.+0      	; 0x130 <segled_put_char+0xaa>
 130:	49 32       	cpi	r20, 0x29	; 41
 132:	01 f0       	breq	.+0      	; 0x134 <segled_put_char+0xae>
		mask = 0b11110000;
	}else if(ch=='.'){
 134:	4e 32       	cpi	r20, 0x2E	; 46
 136:	01 f4       	brne	.+0      	; 0x138 <segled_put_char+0xb2>
		if(led->segment[7]){
 138:	f6 01       	movw	r30, r12
 13a:	26 85       	ldd	r18, Z+14	; 0x0e
 13c:	37 85       	ldd	r19, Z+15	; 0x0f
 13e:	23 2b       	or	r18, r19
 140:	01 f0       	breq	.+0      	; 0x142 <segled_put_char+0xbc>
			// it has a full stop
			mask = 0b00000001;
 142:	11 e0       	ldi	r17, 0x01	; 1
 144:	00 c0       	rjmp	.+0      	; 0x146 <segled_put_char+0xc0>
	}else if(ch>='0' && ch<='9'){
		mask=pgm_read_byte(&digits[ch-'0']);
	}else if(ch>=0 && ch<=9){
		mask=pgm_read_byte(&digits[ch]);
	}else if(ch=='-'){
		mask = 0b00000010;
 146:	12 e0       	ldi	r17, 0x02	; 2
 148:	00 c0       	rjmp	.+0      	; 0x14a <segled_put_char+0xc4>
	}else if(ch=='[' || ch=='{' || ch=='('){
		mask = 0b10011100;
 14a:	1c e9       	ldi	r17, 0x9C	; 156
 14c:	00 c0       	rjmp	.+0      	; 0x14e <segled_put_char+0xc8>
	}else if(ch==']' || ch=='}' || ch==')'){
		mask = 0b11110000;
 14e:	10 ef       	ldi	r17, 0xF0	; 240
 150:	00 c0       	rjmp	.+0      	; 0x152 <segled_put_char+0xcc>
	pin_set(pin,value);
}

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
	init(led);
	uint8_t mask=0;	// default is a space
 152:	10 e0       	ldi	r17, 0x00	; 0
 154:	00 c0       	rjmp	.+0      	; 0x156 <segled_put_char+0xd0>
		if(led->segment[7]){
			// it has a full stop
			mask = 0b00000001;
		}else{
			// no full stop - so just light segment D
			mask = 0b00010000;
 156:	10 e1       	ldi	r17, 0x10	; 16
		}
	}
	if(!led->activeHigh){
 158:	f6 01       	movw	r30, r12
 15a:	80 89       	ldd	r24, Z+16	; 0x10
 15c:	80 ff       	sbrs	r24, 0
	 	mask ^= 0b11111111;
 15e:	10 95       	com	r17
	}else if(ch=='-'){
		mask = 0b00000010;
	}else if(ch=='[' || ch=='{' || ch=='('){
		mask = 0b10011100;
	}else if(ch==']' || ch=='}' || ch==')'){
		mask = 0b11110000;
 160:	08 e0       	ldi	r16, 0x08	; 8
	if(!led->activeHigh){
	 	mask ^= 0b11111111;
	}

	for(uint8_t i=0; i<8;i++){
		const IOPin* pin = led->segment[i];
 162:	f6 01       	movw	r30, r12
 164:	81 91       	ld	r24, Z+
 166:	91 91       	ld	r25, Z+
 168:	6f 01       	movw	r12, r30
		if(mask & 0b10000000){
			pin_high(pin);
 16a:	49 83       	std	Y+1, r20	; 0x01
	 	mask ^= 0b11111111;
	}

	for(uint8_t i=0; i<8;i++){
		const IOPin* pin = led->segment[i];
		if(mask & 0b10000000){
 16c:	17 ff       	sbrs	r17, 7
 16e:	00 c0       	rjmp	.+0      	; 0x170 <segled_put_char+0xea>
			pin_high(pin);
 170:	0e 94 00 00 	call	0	; 0x0 <segled_set>
 174:	00 c0       	rjmp	.+0      	; 0x176 <segled_put_char+0xf0>
		}else{
			pin_low(pin);
 176:	0e 94 00 00 	call	0	; 0x0 <segled_set>
 17a:	49 81       	ldd	r20, Y+1	; 0x01
		}
		mask <<= 1;
 17c:	11 0f       	add	r17, r17
 17e:	01 50       	subi	r16, 0x01	; 1
	}
	if(!led->activeHigh){
	 	mask ^= 0b11111111;
	}

	for(uint8_t i=0; i<8;i++){
 180:	01 f4       	brne	.+0      	; 0x182 <segled_put_char+0xfc>
			pin_low(pin);
		}
		mask <<= 1;
	}
	return ch;
}
 182:	84 2f       	mov	r24, r20
 184:	0f 90       	pop	r0
 186:	df 91       	pop	r29
 188:	cf 91       	pop	r28
 18a:	1f 91       	pop	r17
 18c:	0f 91       	pop	r16
 18e:	ff 90       	pop	r15
 190:	df 90       	pop	r13
 192:	cf 90       	pop	r12
 194:	08 95       	ret

segledMarquee.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000372  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003a6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003a6  2**0
                  ALLOC
  3 .debug_info   00000a31  00000000  00000000  000003a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000002da  00000000  00000000  00000dd7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000005de  00000000  00000000  000010b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000168f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000048  00000000  00000000  000016af  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001c8  00000000  00000000  000016f7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000046a  00000000  00000000  000018bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001d29  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000f4  00000000  00000000  00001d54  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <marqueeUpdate>:
			}
		}
	}
}

static void marqueeUpdate(SchedulerData data, TICK_COUNT lastTime, TICK_COUNT overflow){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	00 d0       	rcall	.+0      	; 0x22 <marqueeUpdate+0x22>
  22:	00 d0       	rcall	.+0      	; 0x24 <marqueeUpdate+0x24>
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	2c 01       	movw	r4, r24
  2a:	9a 01       	movw	r18, r20
  2c:	ab 01       	movw	r20, r22
	MARQUEE* m = (MARQUEE*)data;

	char* readPos = m->txt + m->readPos;
  2e:	dc 01       	movw	r26, r24
  30:	14 96       	adiw	r26, 0x04	; 4
  32:	cd 90       	ld	r12, X+
  34:	dc 90       	ld	r13, X
  36:	15 97       	sbiw	r26, 0x05	; 5
  38:	16 96       	adiw	r26, 0x06	; 6
  3a:	8d 91       	ld	r24, X+
  3c:	9c 91       	ld	r25, X
  3e:	17 97       	sbiw	r26, 0x07	; 7
  40:	c8 0e       	add	r12, r24
  42:	d9 1e       	adc	r13, r25
	char  first=*readPos;
  44:	f6 01       	movw	r30, r12
  46:	70 80       	ld	r7, Z
	boolean blink = m->blink;
  48:	54 96       	adiw	r26, 0x14	; 20
  4a:	8c 91       	ld	r24, X
  4c:	54 97       	sbiw	r26, 0x14	; 20
  4e:	82 95       	swap	r24
  50:	88 0f       	add	r24, r24
  52:	88 0f       	add	r24, r24
  54:	80 7c       	andi	r24, 0xC0	; 192
  56:	88 0f       	add	r24, r24
  58:	88 0b       	sbc	r24, r24

	TICK_COUNT delay = (first=='\0') ? m->delayEnd : m->delayChar;
  5a:	71 10       	cpse	r7, r1
  5c:	00 c0       	rjmp	.+0      	; 0x5e <marqueeUpdate+0x5e>
  5e:	50 96       	adiw	r26, 0x10	; 16
  60:	ed 90       	ld	r14, X+
  62:	fd 90       	ld	r15, X+
  64:	0d 91       	ld	r16, X+
  66:	1c 91       	ld	r17, X
  68:	53 97       	sbiw	r26, 0x13	; 19
  6a:	00 c0       	rjmp	.+0      	; 0x6c <marqueeUpdate+0x6c>
  6c:	d2 01       	movw	r26, r4
  6e:	1c 96       	adiw	r26, 0x0c	; 12
  70:	ed 90       	ld	r14, X+
  72:	fd 90       	ld	r15, X+
  74:	0d 91       	ld	r16, X+
  76:	1c 91       	ld	r17, X
  78:	1f 97       	sbiw	r26, 0x0f	; 15
	TICK_COUNT delayDiv4 = delay >> 2;

	if(blink==FALSE){
  7a:	81 11       	cpse	r24, r1
  7c:	00 c0       	rjmp	.+0      	; 0x7e <marqueeUpdate+0x7e>
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
  7e:	f6 01       	movw	r30, r12
  80:	31 97       	sbiw	r30, 0x01	; 1
  82:	70 81       	ld	r23, Z
  84:	f6 01       	movw	r30, r12
			}
		}
	}
}

static void marqueeUpdate(SchedulerData data, TICK_COUNT lastTime, TICK_COUNT overflow){
  86:	12 96       	adiw	r26, 0x02	; 2
  88:	8d 91       	ld	r24, X+
  8a:	9c 91       	ld	r25, X
  8c:	13 97       	sbiw	r26, 0x03	; 3
  8e:	8c 0d       	add	r24, r12
  90:	9d 1d       	adc	r25, r13
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
			blink = TRUE;
			for(size_t led = 0; led < m->num_leds; led++){
  92:	00 c0       	rjmp	.+0      	; 0x94 <marqueeUpdate+0x94>
				char ch = *pos++;
  94:	61 91       	ld	r22, Z+
				// If we've hit end of line or a different char then no blink
				if(ch=='\0' || ch!=prev){
  96:	66 23       	and	r22, r22
  98:	01 f0       	breq	.+0      	; 0x9a <marqueeUpdate+0x9a>
  9a:	67 13       	cpse	r22, r23
  9c:	00 c0       	rjmp	.+0      	; 0x9e <marqueeUpdate+0x9e>
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
			blink = TRUE;
			for(size_t led = 0; led < m->num_leds; led++){
  9e:	e8 17       	cp	r30, r24
  a0:	f9 07       	cpc	r31, r25
  a2:	01 f4       	brne	.+0      	; 0xa4 <marqueeUpdate+0xa4>
	if(blink==FALSE){
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
			blink = TRUE;
  a4:	66 24       	eor	r6, r6
  a6:	6a 94       	dec	r6
  a8:	00 c0       	rjmp	.+0      	; 0xaa <marqueeUpdate+0xaa>
				prev = ch;
			}
		}
	}else{
		// We are already blinking, so turn it off
		blink=FALSE;
  aa:	61 2c       	mov	r6, r1
	}

	// Set it for next time
	if(blink != m->blink){
  ac:	f2 01       	movw	r30, r4
  ae:	84 89       	ldd	r24, Z+20	; 0x14
  b0:	82 95       	swap	r24
  b2:	88 0f       	add	r24, r24
  b4:	88 0f       	add	r24, r24
  b6:	80 7c       	andi	r24, 0xC0	; 192
  b8:	88 0f       	add	r24, r24
  ba:	88 0b       	sbc	r24, r24
  bc:	68 16       	cp	r6, r24
  be:	01 f0       	breq	.+0      	; 0xc0 <marqueeUpdate+0xc0>
	char* readPos = m->txt + m->readPos;
	char  first=*readPos;
	boolean blink = m->blink;

	TICK_COUNT delay = (first=='\0') ? m->delayEnd : m->delayChar;
	TICK_COUNT delayDiv4 = delay >> 2;
  c0:	47 01       	movw	r8, r14
  c2:	58 01       	movw	r10, r16
  c4:	72 e0       	ldi	r23, 0x02	; 2
  c6:	b6 94       	lsr	r11
  c8:	a7 94       	ror	r10
  ca:	97 94       	ror	r9
  cc:	87 94       	ror	r8
  ce:	7a 95       	dec	r23
  d0:	01 f4       	brne	.+0      	; 0xd2 <marqueeUpdate+0xd2>
		blink=FALSE;
	}

	// Set it for next time
	if(blink != m->blink){
		m->blink = blink;
  d2:	86 2d       	mov	r24, r6
  d4:	87 95       	ror	r24
  d6:	88 27       	eor	r24, r24
  d8:	87 95       	ror	r24
  da:	88 0f       	add	r24, r24
  dc:	88 0b       	sbc	r24, r24
  de:	94 89       	ldd	r25, Z+20	; 0x14
  e0:	80 fb       	bst	r24, 0
  e2:	91 f9       	bld	r25, 1
  e4:	94 8b       	std	Z+20, r25	; 0x14
		delay = (blink) ? delayDiv4 : delay - delayDiv4;
  e6:	61 10       	cpse	r6, r1
  e8:	00 c0       	rjmp	.+0      	; 0xea <marqueeUpdate+0xea>
  ea:	e8 18       	sub	r14, r8
  ec:	f9 08       	sbc	r15, r9
  ee:	0a 09       	sbc	r16, r10
  f0:	1b 09       	sbc	r17, r11
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <marqueeUpdate+0xf4>
  f4:	85 01       	movw	r16, r10
  f6:	74 01       	movw	r14, r8
	}

	// Write chars to leds
	for(size_t l = 0; l < m->num_leds; l++){
  f8:	a1 2c       	mov	r10, r1
  fa:	b1 2c       	mov	r11, r1
  fc:	00 c0       	rjmp	.+0      	; 0xfe <marqueeUpdate+0xfe>
			}
		}
	}
}

static void marqueeUpdate(SchedulerData data, TICK_COUNT lastTime, TICK_COUNT overflow){
  fe:	c5 01       	movw	r24, r10
 100:	88 0f       	add	r24, r24
 102:	99 1f       	adc	r25, r25
		delay = (blink) ? delayDiv4 : delay - delayDiv4;
	}

	// Write chars to leds
	for(size_t l = 0; l < m->num_leds; l++){
		SEGLED* led = (SEGLED*)pgm_read_word(&m->leds[l]);
 104:	d2 01       	movw	r26, r4
 106:	ed 91       	ld	r30, X+
 108:	fc 91       	ld	r31, X
 10a:	e8 0f       	add	r30, r24
 10c:	f9 1f       	adc	r31, r25
 10e:	65 91       	lpm	r22, Z+
 110:	74 91       	lpm	r23, Z
 112:	cb 01       	movw	r24, r22
		char ch = (blink) ? '\0' : *readPos;
 114:	61 10       	cpse	r6, r1
 116:	00 c0       	rjmp	.+0      	; 0x118 <marqueeUpdate+0x118>
 118:	f6 01       	movw	r30, r12
 11a:	60 81       	ld	r22, Z
		if(ch!='\0'){
 11c:	66 23       	and	r22, r22
 11e:	01 f0       	breq	.+0      	; 0x120 <marqueeUpdate+0x120>
			readPos++;
 120:	ff ef       	ldi	r31, 0xFF	; 255
 122:	cf 1a       	sub	r12, r31
 124:	df 0a       	sbc	r13, r31
 126:	00 c0       	rjmp	.+0      	; 0x128 <marqueeUpdate+0x128>
		}else{
			ch = ' ';
 128:	60 e2       	ldi	r22, 0x20	; 32
		}
		segled_put_char(led,ch);
 12a:	29 83       	std	Y+1, r18	; 0x01
 12c:	3a 83       	std	Y+2, r19	; 0x02
 12e:	4b 83       	std	Y+3, r20	; 0x03
 130:	5c 83       	std	Y+4, r21	; 0x04
 132:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
		m->blink = blink;
		delay = (blink) ? delayDiv4 : delay - delayDiv4;
	}

	// Write chars to leds
	for(size_t l = 0; l < m->num_leds; l++){
 136:	7f ef       	ldi	r23, 0xFF	; 255
 138:	a7 1a       	sub	r10, r23
 13a:	b7 0a       	sbc	r11, r23
 13c:	5c 81       	ldd	r21, Y+4	; 0x04
 13e:	4b 81       	ldd	r20, Y+3	; 0x03
 140:	3a 81       	ldd	r19, Y+2	; 0x02
 142:	29 81       	ldd	r18, Y+1	; 0x01
 144:	d2 01       	movw	r26, r4
 146:	12 96       	adiw	r26, 0x02	; 2
 148:	8d 91       	ld	r24, X+
 14a:	9c 91       	ld	r25, X
 14c:	13 97       	sbiw	r26, 0x03	; 3
 14e:	a8 16       	cp	r10, r24
 150:	b9 06       	cpc	r11, r25
 152:	00 f0       	brcs	.+0      	; 0x154 <marqueeUpdate+0x154>
			ch = ' ';
		}
		segled_put_char(led,ch);
	}

	if(first=='\0'){
 154:	71 10       	cpse	r7, r1
 156:	00 c0       	rjmp	.+0      	; 0x158 <marqueeUpdate+0x158>
		// line is finished
		m->readPos = 0;
 158:	17 96       	adiw	r26, 0x07	; 7
 15a:	1c 92       	st	X, r1
 15c:	1e 92       	st	-X, r1
 15e:	16 97       	sbiw	r26, 0x06	; 6
		if(m->delayEnd==0 || m->txt[0]=='\0'){
 160:	50 96       	adiw	r26, 0x10	; 16
 162:	8d 90       	ld	r8, X+
 164:	9d 90       	ld	r9, X+
 166:	ad 90       	ld	r10, X+
 168:	bc 90       	ld	r11, X
 16a:	53 97       	sbiw	r26, 0x13	; 19
 16c:	89 28       	or	r8, r9
 16e:	8a 28       	or	r8, r10
 170:	8b 28       	or	r8, r11
 172:	01 f0       	breq	.+0      	; 0x174 <marqueeUpdate+0x174>
 174:	14 96       	adiw	r26, 0x04	; 4
 176:	ed 91       	ld	r30, X+
 178:	fc 91       	ld	r31, X
 17a:	15 97       	sbiw	r26, 0x05	; 5
 17c:	80 81       	ld	r24, Z
 17e:	81 11       	cpse	r24, r1
 180:	00 c0       	rjmp	.+0      	; 0x182 <marqueeUpdate+0x182>
			m->active=FALSE;
 182:	f2 01       	movw	r30, r4
 184:	84 89       	ldd	r24, Z+20	; 0x14
 186:	8e 7f       	andi	r24, 0xFE	; 254
 188:	84 8b       	std	Z+20, r24	; 0x14
 18a:	00 c0       	rjmp	.+0      	; 0x18c <marqueeUpdate+0x18c>
		}else{
			m->blink = FALSE;
 18c:	d2 01       	movw	r26, r4
 18e:	54 96       	adiw	r26, 0x14	; 20
 190:	8c 91       	ld	r24, X
 192:	54 97       	sbiw	r26, 0x14	; 20
 194:	8d 7f       	andi	r24, 0xFD	; 253
 196:	54 96       	adiw	r26, 0x14	; 20
 198:	8c 93       	st	X, r24
 19a:	00 c0       	rjmp	.+0      	; 0x19c <marqueeUpdate+0x19c>
		}
	}else{
		// middle of line
		if(!blink){
 19c:	61 10       	cpse	r6, r1
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <marqueeUpdate+0x1a0>
			// Show character next time
			m->readPos += 1;
 1a0:	f2 01       	movw	r30, r4
 1a2:	86 81       	ldd	r24, Z+6	; 0x06
 1a4:	97 81       	ldd	r25, Z+7	; 0x07
 1a6:	01 96       	adiw	r24, 0x01	; 1
 1a8:	97 83       	std	Z+7, r25	; 0x07
 1aa:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	if(m->active){
 1ac:	d2 01       	movw	r26, r4
 1ae:	54 96       	adiw	r26, 0x14	; 20
 1b0:	8c 91       	ld	r24, X
 1b2:	80 ff       	sbrs	r24, 0
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <marqueeUpdate+0x1b6>
		scheduleJob(&marqueeUpdate,data,lastTime,delay);
 1b6:	b2 01       	movw	r22, r4
 1b8:	80 e0       	ldi	r24, 0x00	; 0
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
	}
}
 1c0:	0f 90       	pop	r0
 1c2:	0f 90       	pop	r0
 1c4:	0f 90       	pop	r0
 1c6:	0f 90       	pop	r0
 1c8:	df 91       	pop	r29
 1ca:	cf 91       	pop	r28
 1cc:	1f 91       	pop	r17
 1ce:	0f 91       	pop	r16
 1d0:	ff 90       	pop	r15
 1d2:	ef 90       	pop	r14
 1d4:	df 90       	pop	r13
 1d6:	cf 90       	pop	r12
 1d8:	bf 90       	pop	r11
 1da:	af 90       	pop	r10
 1dc:	9f 90       	pop	r9
 1de:	8f 90       	pop	r8
 1e0:	7f 90       	pop	r7
 1e2:	6f 90       	pop	r6
 1e4:	5f 90       	pop	r5
 1e6:	4f 90       	pop	r4
 1e8:	08 95       	ret

000001ea <marqueeSendByte>:

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
 1ea:	cf 92       	push	r12
 1ec:	df 92       	push	r13
 1ee:	ef 92       	push	r14
 1f0:	ff 92       	push	r15
 1f2:	0f 93       	push	r16
 1f4:	1f 93       	push	r17
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	ec 01       	movw	r28, r24
 1fc:	d6 2e       	mov	r13, r22
// For malloc
#include <stdlib.h>

// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
 1fe:	8c 81       	ldd	r24, Y+4	; 0x04
 200:	9d 81       	ldd	r25, Y+5	; 0x05
 202:	89 2b       	or	r24, r25
 204:	01 f0       	breq	.+0      	; 0x206 <marqueeSendByte+0x1c>
	}
}

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
	marquee_init(marquee);
	if(marquee->txt){
 206:	2c 81       	ldd	r18, Y+4	; 0x04
 208:	3d 81       	ldd	r19, Y+5	; 0x05
 20a:	21 15       	cp	r18, r1
 20c:	31 05       	cpc	r19, r1
 20e:	01 f4       	brne	.+0      	; 0x210 <marqueeSendByte+0x26>
 210:	00 c0       	rjmp	.+0      	; 0x212 <marqueeSendByte+0x28>
#include <stdlib.h>

// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
		marquee->txt = malloc(1 + marquee->txtSize);
 212:	8a 85       	ldd	r24, Y+10	; 0x0a
 214:	9b 85       	ldd	r25, Y+11	; 0x0b
 216:	01 96       	adiw	r24, 0x01	; 1
 218:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
 21c:	9d 83       	std	Y+5, r25	; 0x05
 21e:	8c 83       	std	Y+4, r24	; 0x04
		if(marquee->txt){
 220:	00 97       	sbiw	r24, 0x00	; 0
 222:	01 f4       	brne	.+0      	; 0x224 <marqueeSendByte+0x3a>
 224:	00 c0       	rjmp	.+0      	; 0x226 <marqueeSendByte+0x3c>
			for(int i=0; i<=marquee->txtSize;i++){
				marquee->txt[i] = '\0';
 226:	ec 81       	ldd	r30, Y+4	; 0x04
 228:	fd 81       	ldd	r31, Y+5	; 0x05
 22a:	e2 0f       	add	r30, r18
 22c:	f3 1f       	adc	r31, r19
 22e:	10 82       	st	Z, r1
// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
		marquee->txt = malloc(1 + marquee->txtSize);
		if(marquee->txt){
			for(int i=0; i<=marquee->txtSize;i++){
 230:	2f 5f       	subi	r18, 0xFF	; 255
 232:	3f 4f       	sbci	r19, 0xFF	; 255
 234:	00 c0       	rjmp	.+0      	; 0x236 <marqueeSendByte+0x4c>

// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
		marquee->txt = malloc(1 + marquee->txtSize);
		if(marquee->txt){
 236:	20 e0       	ldi	r18, 0x00	; 0
 238:	30 e0       	ldi	r19, 0x00	; 0
			for(int i=0; i<=marquee->txtSize;i++){
 23a:	8a 85       	ldd	r24, Y+10	; 0x0a
 23c:	9b 85       	ldd	r25, Y+11	; 0x0b
 23e:	82 17       	cp	r24, r18
 240:	93 07       	cpc	r25, r19
 242:	00 f4       	brcc	.+0      	; 0x244 <marqueeSendByte+0x5a>
				marquee->txt[i] = '\0';
			}
			marquee->readPos = marquee->writePos = 0;
 244:	19 86       	std	Y+9, r1	; 0x09
 246:	18 86       	std	Y+8, r1	; 0x08
 248:	1f 82       	std	Y+7, r1	; 0x07
 24a:	1e 82       	std	Y+6, r1	; 0x06
			marquee->active = FALSE;
 24c:	8c 89       	ldd	r24, Y+20	; 0x14
 24e:	8e 7f       	andi	r24, 0xFE	; 254
 250:	8c 8b       	std	Y+20, r24	; 0x14
			for(size_t i = 0; i < marquee->num_leds; i++){
 252:	00 e0       	ldi	r16, 0x00	; 0
 254:	10 e0       	ldi	r17, 0x00	; 0
 256:	00 c0       	rjmp	.+0      	; 0x258 <marqueeSendByte+0x6e>
	if(m->active){
		scheduleJob(&marqueeUpdate,data,lastTime,delay);
	}
}

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
 258:	c8 01       	movw	r24, r16
 25a:	88 0f       	add	r24, r24
 25c:	99 1f       	adc	r25, r25
				marquee->txt[i] = '\0';
			}
			marquee->readPos = marquee->writePos = 0;
			marquee->active = FALSE;
			for(size_t i = 0; i < marquee->num_leds; i++){
				SEGLED* led = (SEGLED*)pgm_read_word(&marquee->leds[i]);
 25e:	e8 81       	ld	r30, Y
 260:	f9 81       	ldd	r31, Y+1	; 0x01
 262:	e8 0f       	add	r30, r24
 264:	f9 1f       	adc	r31, r25
 266:	25 91       	lpm	r18, Z+
 268:	34 91       	lpm	r19, Z
				segled_put_char(led,' ');
 26a:	60 e2       	ldi	r22, 0x20	; 32
 26c:	c9 01       	movw	r24, r18
 26e:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
			for(int i=0; i<=marquee->txtSize;i++){
				marquee->txt[i] = '\0';
			}
			marquee->readPos = marquee->writePos = 0;
			marquee->active = FALSE;
			for(size_t i = 0; i < marquee->num_leds; i++){
 272:	0f 5f       	subi	r16, 0xFF	; 255
 274:	1f 4f       	sbci	r17, 0xFF	; 255
 276:	8a 81       	ldd	r24, Y+2	; 0x02
 278:	9b 81       	ldd	r25, Y+3	; 0x03
 27a:	08 17       	cp	r16, r24
 27c:	19 07       	cpc	r17, r25
 27e:	00 f0       	brcs	.+0      	; 0x280 <marqueeSendByte+0x96>
 280:	00 c0       	rjmp	.+0      	; 0x282 <marqueeSendByte+0x98>

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
	marquee_init(marquee);
	if(marquee->txt){

		if(byte=='\n'){
 282:	8a e0       	ldi	r24, 0x0A	; 10
 284:	d8 12       	cpse	r13, r24
 286:	00 c0       	rjmp	.+0      	; 0x288 <marqueeSendByte+0x9e>
			// Start writing at the beginning of the line
			marquee->txt[marquee->writePos] = '\0';
 288:	e8 85       	ldd	r30, Y+8	; 0x08
 28a:	f9 85       	ldd	r31, Y+9	; 0x09
 28c:	e2 0f       	add	r30, r18
 28e:	f3 1f       	adc	r31, r19
 290:	10 82       	st	Z, r1
			marquee->writePos = 0;
 292:	19 86       	std	Y+9, r1	; 0x09
 294:	18 86       	std	Y+8, r1	; 0x08
			CRITICAL_SECTION_START;
 296:	cf b6       	in	r12, 0x3f	; 63
 298:	f8 94       	cli
			if(!marquee->active){
 29a:	8c 89       	ldd	r24, Y+20	; 0x14
 29c:	80 fd       	sbrc	r24, 0
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <marqueeSendByte+0xb6>
				marquee->active = TRUE;
 2a0:	8c 89       	ldd	r24, Y+20	; 0x14
 2a2:	9f ef       	ldi	r25, 0xFF	; 255
 2a4:	90 fb       	bst	r25, 0
 2a6:	80 f9       	bld	r24, 0
 2a8:	8c 8b       	std	Y+20, r24	; 0x14
				marquee->blink = FALSE;
 2aa:	8c 89       	ldd	r24, Y+20	; 0x14
 2ac:	8d 7f       	andi	r24, 0xFD	; 253
 2ae:	8c 8b       	std	Y+20, r24	; 0x14
				marquee->readPos=0;
 2b0:	1f 82       	std	Y+7, r1	; 0x07
 2b2:	1e 82       	std	Y+6, r1	; 0x06
				scheduleJob(&marqueeUpdate,(SchedulerData)marquee,clockGetus(),marquee->delayChar);
 2b4:	ec 84       	ldd	r14, Y+12	; 0x0c
 2b6:	fd 84       	ldd	r15, Y+13	; 0x0d
 2b8:	0e 85       	ldd	r16, Y+14	; 0x0e
 2ba:	1f 85       	ldd	r17, Y+15	; 0x0f
 2bc:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
 2c0:	9b 01       	movw	r18, r22
 2c2:	ac 01       	movw	r20, r24
 2c4:	be 01       	movw	r22, r28
 2c6:	80 e0       	ldi	r24, 0x00	; 0
 2c8:	90 e0       	ldi	r25, 0x00	; 0
 2ca:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
			}
			CRITICAL_SECTION_END;
 2ce:	cf be       	out	0x3f, r12	; 63
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <marqueeSendByte+0xe8>
		}else if(byte!='\r'){
 2d2:	8d e0       	ldi	r24, 0x0D	; 13
 2d4:	d8 16       	cp	r13, r24
 2d6:	01 f0       	breq	.+0      	; 0x2d8 <marqueeSendByte+0xee>
			// Now put the character to the buffer
			if(marquee->writePos < marquee->txtSize){
 2d8:	e8 85       	ldd	r30, Y+8	; 0x08
 2da:	f9 85       	ldd	r31, Y+9	; 0x09
 2dc:	8a 85       	ldd	r24, Y+10	; 0x0a
 2de:	9b 85       	ldd	r25, Y+11	; 0x0b
 2e0:	e8 17       	cp	r30, r24
 2e2:	f9 07       	cpc	r31, r25
 2e4:	00 f4       	brcc	.+0      	; 0x2e6 <marqueeSendByte+0xfc>
				char* put = marquee->txt + marquee->writePos;
 2e6:	e2 0f       	add	r30, r18
 2e8:	f3 1f       	adc	r31, r19
				CRITICAL_SECTION_START;
 2ea:	8f b7       	in	r24, 0x3f	; 63
 2ec:	f8 94       	cli
				*put++ = byte;
 2ee:	d0 82       	st	Z, r13
				*put = '\0';
 2f0:	11 82       	std	Z+1, r1	; 0x01
				marquee->writePos += 1;
 2f2:	28 85       	ldd	r18, Y+8	; 0x08
 2f4:	39 85       	ldd	r19, Y+9	; 0x09
 2f6:	2f 5f       	subi	r18, 0xFF	; 255
 2f8:	3f 4f       	sbci	r19, 0xFF	; 255
 2fa:	39 87       	std	Y+9, r19	; 0x09
 2fc:	28 87       	std	Y+8, r18	; 0x08
				marquee->readPos = 0;
 2fe:	1f 82       	std	Y+7, r1	; 0x07
 300:	1e 82       	std	Y+6, r1	; 0x06
				CRITICAL_SECTION_END;
 302:	8f bf       	out	0x3f, r24	; 63
			}
		}
	}
	return byte;
}
 304:	8d 2d       	mov	r24, r13
 306:	df 91       	pop	r29
 308:	cf 91       	pop	r28
 30a:	1f 91       	pop	r17
 30c:	0f 91       	pop	r16
 30e:	ff 90       	pop	r15
 310:	ef 90       	pop	r14
 312:	df 90       	pop	r13
 314:	cf 90       	pop	r12
 316:	08 95       	ret

00000318 <marqueeStop>:


// Stop an existing marquee
void marqueeStop(MARQUEE* marquee){
 318:	fc 01       	movw	r30, r24
	if(marquee && marquee->txt){
 31a:	00 97       	sbiw	r24, 0x00	; 0
 31c:	01 f0       	breq	.+0      	; 0x31e <marqueeStop+0x6>
 31e:	84 81       	ldd	r24, Z+4	; 0x04
 320:	95 81       	ldd	r25, Z+5	; 0x05
 322:	89 2b       	or	r24, r25
 324:	01 f0       	breq	.+0      	; 0x326 <marqueeStop+0xe>
		CRITICAL_SECTION_START;
 326:	8f b7       	in	r24, 0x3f	; 63
 328:	f8 94       	cli
		marquee->readPos = marquee->writePos = 0;
 32a:	11 86       	std	Z+9, r1	; 0x09
 32c:	10 86       	std	Z+8, r1	; 0x08
 32e:	17 82       	std	Z+7, r1	; 0x07
 330:	16 82       	std	Z+6, r1	; 0x06
		marquee->txt[0]='\0';
 332:	04 80       	ldd	r0, Z+4	; 0x04
 334:	f5 81       	ldd	r31, Z+5	; 0x05
 336:	e0 2d       	mov	r30, r0
 338:	10 82       	st	Z, r1
		CRITICAL_SECTION_END;
 33a:	8f bf       	out	0x3f, r24	; 63
 33c:	08 95       	ret

0000033e <marqueeIsActive>:
	}
}

// Is there an existing message being scrolled
boolean marqueeIsActive(const MARQUEE * marquee){
	return (marquee->active) ? TRUE : FALSE;
 33e:	fc 01       	movw	r30, r24
 340:	84 89       	ldd	r24, Z+20	; 0x14
 342:	80 ff       	sbrs	r24, 0
 344:	00 c0       	rjmp	.+0      	; 0x346 <marqueeIsActive+0x8>
 346:	8f ef       	ldi	r24, 0xFF	; 255
 348:	08 95       	ret
 34a:	80 e0       	ldi	r24, 0x00	; 0
}
 34c:	08 95       	ret

0000034e <marqueeSetCharDelay>:

void marqueeSetCharDelay(MARQUEE* marquee,TICK_COUNT delay){
	CRITICAL_SECTION_START;
 34e:	2f b7       	in	r18, 0x3f	; 63
 350:	f8 94       	cli
	marquee->delayChar = delay;
 352:	fc 01       	movw	r30, r24
 354:	44 87       	std	Z+12, r20	; 0x0c
 356:	55 87       	std	Z+13, r21	; 0x0d
 358:	66 87       	std	Z+14, r22	; 0x0e
 35a:	77 87       	std	Z+15, r23	; 0x0f
	CRITICAL_SECTION_END;
 35c:	2f bf       	out	0x3f, r18	; 63
 35e:	08 95       	ret

00000360 <marqueeSetEndDelay>:
}

void marqueeSetEndDelay(MARQUEE* marquee,TICK_COUNT delay){
	CRITICAL_SECTION_START;
 360:	2f b7       	in	r18, 0x3f	; 63
 362:	f8 94       	cli
	marquee->delayEnd = delay;
 364:	fc 01       	movw	r30, r24
 366:	40 8b       	std	Z+16, r20	; 0x10
 368:	51 8b       	std	Z+17, r21	; 0x11
 36a:	62 8b       	std	Z+18, r22	; 0x12
 36c:	73 8b       	std	Z+19, r23	; 0x13
	CRITICAL_SECTION_END;
 36e:	2f bf       	out	0x3f, r18	; 63
 370:	08 95       	ret

servoMux.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003b6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  000003ea  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003ea  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000016df  00000000  00000000  000003ee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000003aa  00000000  00000000  00001acd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000a04  00000000  00000000  00001e77  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000287b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000048  00000000  00000000  0000289b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000023a  00000000  00000000  000028e3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000b2f  00000000  00000000  00002b1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  0000364c  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000e0  00000000  00000000  00003678  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <mux_setSpeed>:
	//compareSetThreshold(channel,newPos);
	PORT port = driver->specific.softwareMUX.pwmPort;
	_SFR_MEM16(port) = newPos; 					// set 16 bit word
}

static void mux_setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	86 2f       	mov	r24, r22
	SERVO* servo = (SERVO*)actuator;

	// Interpolate the values
	uint16_t ticks=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
   c:	0e 85       	ldd	r16, Y+14	; 0x0e
   e:	1f 85       	ldd	r17, Y+15	; 0x0f
  10:	2c 85       	ldd	r18, Y+12	; 0x0c
  12:	3d 85       	ldd	r19, Y+13	; 0x0d
  14:	4f e7       	ldi	r20, 0x7F	; 127
  16:	50 e0       	ldi	r21, 0x00	; 0
  18:	61 e8       	ldi	r22, 0x81	; 129
  1a:	7f ef       	ldi	r23, 0xFF	; 255
  1c:	99 27       	eor	r25, r25
  1e:	87 fd       	sbrc	r24, 7
  20:	90 95       	com	r25
  22:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

	// The min/max ticks are based on a 20ms frequency, but we actually using 2.5ms
	// so multiply by 20/2.5 = 8
	ticks *= 8;		//
  26:	23 e0       	ldi	r18, 0x03	; 3
  28:	88 0f       	add	r24, r24
  2a:	99 1f       	adc	r25, r25
  2c:	2a 95       	dec	r18
  2e:	01 f4       	brne	.+0      	; 0x30 <mux_setSpeed+0x30>

	if(ticks!=servo->delay){
  30:	28 89       	ldd	r18, Y+16	; 0x10
  32:	39 89       	ldd	r19, Y+17	; 0x11
  34:	82 17       	cp	r24, r18
  36:	93 07       	cpc	r25, r19
  38:	01 f0       	breq	.+0      	; 0x3a <mux_setSpeed+0x3a>
		CRITICAL_SECTION{
  3a:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  3c:	f8 94       	cli
			servo->delay = ticks;
  3e:	99 8b       	std	Y+17, r25	; 0x11
  40:	88 8b       	std	Y+16, r24	; 0x10
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  42:	2f bf       	out	0x3f, r18	; 63
		};
	}
}
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	1f 91       	pop	r17
  4a:	0f 91       	pop	r16
  4c:	08 95       	ret

0000004e <service>:

/**
 * We have just hit top and are starting to count down again.
 * The new PWM duty cycle has been clocked in for the next servo
 */
static void service(const Timer *timer, void* data){
  4e:	cf 92       	push	r12
  50:	df 92       	push	r13
  52:	ef 92       	push	r14
  54:	ff 92       	push	r15
  56:	0f 93       	push	r16
  58:	1f 93       	push	r17
  5a:	cf 93       	push	r28
  5c:	df 93       	push	r29
  5e:	7c 01       	movw	r14, r24
  60:	eb 01       	movw	r28, r22
	SERVO_DRIVER* driver = data;
	uint8_t i;

	// Move to the next servo
	uint8_t index = (driver->specific.softwareMUX.currentServo + 1)& 7;
  62:	df 80       	ldd	r13, Y+7	; 0x07
  64:	d3 94       	inc	r13
  66:	87 e0       	ldi	r24, 0x07	; 7
  68:	d8 22       	and	r13, r24
	driver->specific.softwareMUX.currentServo = index;
  6a:	df 82       	std	Y+7, r13	; 0x07

	// Set the multiplex pins so the pulse goes to the correct servo
	// This needs to be done quickly to stop the start of the pulse
	// going to the wrong sevo
	uint8_t bits = index;
  6c:	cd 2c       	mov	r12, r13
	SERVO_DRIVER* driver = data;
	uint8_t i;

	// Move to the next servo
	uint8_t index = (driver->specific.softwareMUX.currentServo + 1)& 7;
	driver->specific.softwareMUX.currentServo = index;
  6e:	00 e0       	ldi	r16, 0x00	; 0
  70:	10 e0       	ldi	r17, 0x00	; 0

/**
 * We have just hit top and are starting to count down again.
 * The new PWM duty cycle has been clocked in for the next servo
 */
static void service(const Timer *timer, void* data){
  72:	fe 01       	movw	r30, r28
  74:	e0 0f       	add	r30, r16
  76:	f1 1f       	adc	r31, r17
	// Set the multiplex pins so the pulse goes to the correct servo
	// This needs to be done quickly to stop the start of the pulse
	// going to the wrong sevo
	uint8_t bits = index;
	for (i = 0; i < NUM_MUX_PINS; i++){
		const IOPin* pin = driver->specific.softwareMUX.muxPins[i];
  78:	82 85       	ldd	r24, Z+10	; 0x0a
  7a:	93 85       	ldd	r25, Z+11	; 0x0b
		if(bits & 1){
  7c:	c0 fe       	sbrs	r12, 0
  7e:	00 c0       	rjmp	.+0      	; 0x80 <service+0x32>
			pin_high(pin);
  80:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
  84:	00 c0       	rjmp	.+0      	; 0x86 <service+0x38>
		}else{
			pin_low(pin);
  86:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		}
		bits >>= 1;
  8a:	c6 94       	lsr	r12
  8c:	0e 5f       	subi	r16, 0xFE	; 254
  8e:	1f 4f       	sbci	r17, 0xFF	; 255

	// Set the multiplex pins so the pulse goes to the correct servo
	// This needs to be done quickly to stop the start of the pulse
	// going to the wrong sevo
	uint8_t bits = index;
	for (i = 0; i < NUM_MUX_PINS; i++){
  90:	06 30       	cpi	r16, 0x06	; 6
  92:	11 05       	cpc	r17, r1
  94:	01 f4       	brne	.+0      	; 0x96 <service+0x48>
		bits >>= 1;
	}

	// Keep track of the lowest value of the timer counter
	// Setting a delay between this value and TOP will mean the mux bits dont get changed in time
	uint16_t thisDelay = timerGetCounter(timer);
  96:	c7 01       	movw	r24, r14
  98:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
	if(thisDelay < maxDelay){
  9c:	20 91 00 00 	lds	r18, 0x0000
  a0:	30 91 00 00 	lds	r19, 0x0000
  a4:	82 17       	cp	r24, r18
  a6:	93 07       	cpc	r25, r19
  a8:	00 f4       	brcc	.+0      	; 0xaa <service+0x5c>
		maxDelay = thisDelay;
  aa:	90 93 00 00 	sts	0x0000, r25
  ae:	80 93 00 00 	sts	0x0000, r24
	}

	// Time critical part is over
	// Now calculate the pulse width for next servo
	uint16_t newPos=0;
	index = (index + 1) & 7;
  b2:	8d 2d       	mov	r24, r13
  b4:	8f 5f       	subi	r24, 0xFF	; 255
  b6:	87 70       	andi	r24, 0x07	; 7
	if(index < driver->num_servos){
  b8:	9a 81       	ldd	r25, Y+2	; 0x02
  ba:	89 17       	cp	r24, r25
  bc:	00 f4       	brcc	.+0      	; 0xbe <service+0x70>
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[index]);
  be:	28 81       	ld	r18, Y
  c0:	99 81       	ldd	r25, Y+1	; 0x01
  c2:	e2 2f       	mov	r30, r18
  c4:	f9 2f       	mov	r31, r25
  c6:	e8 0f       	add	r30, r24
  c8:	f1 1d       	adc	r31, r1
  ca:	e8 0f       	add	r30, r24
  cc:	f1 1d       	adc	r31, r1
  ce:	85 91       	lpm	r24, Z+
  d0:	94 91       	lpm	r25, Z
  d2:	fc 01       	movw	r30, r24
		if(servo->actuator.connected){
  d4:	83 81       	ldd	r24, Z+3	; 0x03
  d6:	80 ff       	sbrs	r24, 0
  d8:	00 c0       	rjmp	.+0      	; 0xda <service+0x8c>
			newPos = servo->delay;
  da:	20 89       	ldd	r18, Z+16	; 0x10
  dc:	31 89       	ldd	r19, Z+17	; 0x11

			// Limit to the maximum value
			uint16_t limit = maxDelay;
  de:	80 91 00 00 	lds	r24, 0x0000
  e2:	90 91 00 00 	lds	r25, 0x0000
  e6:	28 17       	cp	r18, r24
  e8:	39 07       	cpc	r19, r25
  ea:	00 f4       	brcc	.+0      	; 0xec <service+0x9e>
  ec:	c9 01       	movw	r24, r18
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <service+0xa2>
		maxDelay = thisDelay;
	}

	// Time critical part is over
	// Now calculate the pulse width for next servo
	uint16_t newPos=0;
  f0:	80 e0       	ldi	r24, 0x00	; 0
  f2:	90 e0       	ldi	r25, 0x00	; 0
	}

	// Set the threshold inline - to save more registers push/pops
	//compareSetThreshold(channel,newPos);
	PORT port = driver->specific.softwareMUX.pwmPort;
	_SFR_MEM16(port) = newPos; 					// set 16 bit word
  f4:	e8 89       	ldd	r30, Y+16	; 0x10
  f6:	f9 89       	ldd	r31, Y+17	; 0x11
  f8:	91 83       	std	Z+1, r25	; 0x01
  fa:	80 83       	st	Z, r24
}
  fc:	df 91       	pop	r29
  fe:	cf 91       	pop	r28
 100:	1f 91       	pop	r17
 102:	0f 91       	pop	r16
 104:	ff 90       	pop	r15
 106:	ef 90       	pop	r14
 108:	df 90       	pop	r13
 10a:	cf 90       	pop	r12
 10c:	08 95       	ret

0000010e <servosMuxInit>:
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 10e:	2f 92       	push	r2
 110:	3f 92       	push	r3
 112:	4f 92       	push	r4
 114:	5f 92       	push	r5
 116:	6f 92       	push	r6
 118:	7f 92       	push	r7
 11a:	8f 92       	push	r8
 11c:	9f 92       	push	r9
 11e:	af 92       	push	r10
 120:	bf 92       	push	r11
 122:	cf 92       	push	r12
 124:	df 92       	push	r13
 126:	ef 92       	push	r14
 128:	ff 92       	push	r15
 12a:	0f 93       	push	r16
 12c:	1f 93       	push	r17
 12e:	cf 93       	push	r28
 130:	df 93       	push	r29
 132:	00 d0       	rcall	.+0      	; 0x134 <servosMuxInit+0x26>
 134:	00 d0       	rcall	.+0      	; 0x136 <servosMuxInit+0x28>
 136:	cd b7       	in	r28, 0x3d	; 61
 138:	de b7       	in	r29, 0x3e	; 62
 13a:	9c 83       	std	Y+4, r25	; 0x04
 13c:	8b 83       	std	Y+3, r24	; 0x03
 13e:	cb 01       	movw	r24, r22
 140:	2a 01       	movw	r4, r20
 142:	19 01       	movw	r2, r18
 144:	1a 83       	std	Y+2, r17	; 0x02
 146:	09 83       	std	Y+1, r16	; 0x01
	const TimerCompare* channel = compareFromIOPin(pwm16);
 148:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 14c:	4c 01       	movw	r8, r24
	const Timer* timer = (channel==null) ? null : compareGetTimer(channel);
 14e:	00 97       	sbiw	r24, 0x00	; 0
 150:	01 f4       	brne	.+0      	; 0x152 <servosMuxInit+0x44>
 152:	00 c0       	rjmp	.+0      	; 0x154 <servosMuxInit+0x46>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 154:	fc 01       	movw	r30, r24
 156:	32 96       	adiw	r30, 0x02	; 2
 158:	04 91       	lpm	r16, Z
 15a:	2c e2       	ldi	r18, 0x2C	; 44
 15c:	02 9f       	mul	r16, r18
 15e:	80 01       	movw	r16, r0
 160:	11 24       	eor	r1, r1
 162:	00 50       	subi	r16, 0x00	; 0
 164:	10 40       	sbci	r17, 0x00	; 0

	if(timer!=null && timerIs16bit(timer)){
 166:	01 f4       	brne	.+0      	; 0x168 <servosMuxInit+0x5a>
 168:	00 c0       	rjmp	.+0      	; 0x16a <servosMuxInit+0x5c>
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 16a:	f8 01       	movw	r30, r16
 16c:	36 96       	adiw	r30, 0x06	; 6
 16e:	e4 91       	lpm	r30, Z
 170:	ee 23       	and	r30, r30
 172:	01 f4       	brne	.+0      	; 0x174 <servosMuxInit+0x66>
 174:	00 c0       	rjmp	.+0      	; 0x176 <servosMuxInit+0x68>

		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
 176:	6b e0       	ldi	r22, 0x0B	; 11
 178:	66 2e       	mov	r6, r22
 17a:	71 2c       	mov	r7, r1
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
 17c:	aa 24       	eor	r10, r10
 17e:	a3 94       	inc	r10
 180:	b1 2c       	mov	r11, r1
			int inx = __timerPrescalerIndex(timer, prescale);
			if(inx!=-1){
				// TOP=F_CPU / (2 * Prescaler * 400Hz)
			    uint32_t top = cpu_speed / (uint16_t)(2U*400U * prescale);
 182:	c0 90 00 00 	lds	r12, 0x0000
 186:	d0 90 00 00 	lds	r13, 0x0000
 18a:	e0 90 00 00 	lds	r14, 0x0000
 18e:	f0 90 00 00 	lds	r15, 0x0000
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
			int inx = __timerPrescalerIndex(timer, prescale);
 192:	b5 01       	movw	r22, r10
 194:	c8 01       	movw	r24, r16
 196:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			if(inx!=-1){
 19a:	01 96       	adiw	r24, 0x01	; 1
 19c:	01 f0       	breq	.+0      	; 0x19e <servosMuxInit+0x90>
				// TOP=F_CPU / (2 * Prescaler * 400Hz)
			    uint32_t top = cpu_speed / (uint16_t)(2U*400U * prescale);
 19e:	e0 e2       	ldi	r30, 0x20	; 32
 1a0:	f3 e0       	ldi	r31, 0x03	; 3
 1a2:	ae 9e       	mul	r10, r30
 1a4:	90 01       	movw	r18, r0
 1a6:	af 9e       	mul	r10, r31
 1a8:	30 0d       	add	r19, r0
 1aa:	be 9e       	mul	r11, r30
 1ac:	30 0d       	add	r19, r0
 1ae:	11 24       	eor	r1, r1
 1b0:	40 e0       	ldi	r20, 0x00	; 0
 1b2:	50 e0       	ldi	r21, 0x00	; 0
 1b4:	c7 01       	movw	r24, r14
 1b6:	b6 01       	movw	r22, r12
 1b8:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			    if(top <= maxTop){
 1bc:	21 15       	cp	r18, r1
 1be:	31 05       	cpc	r19, r1
 1c0:	f1 e0       	ldi	r31, 0x01	; 1
 1c2:	4f 07       	cpc	r20, r31
 1c4:	51 05       	cpc	r21, r1
 1c6:	00 f4       	brcc	.+0      	; 0x1c8 <servosMuxInit+0xba>
			    	bestTop = top;
 1c8:	79 01       	movw	r14, r18
			    	break;
 1ca:	00 c0       	rjmp	.+0      	; 0x1cc <servosMuxInit+0xbe>
		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
 1cc:	aa 0c       	add	r10, r10
 1ce:	bb 1c       	adc	r11, r11
 1d0:	21 e0       	ldi	r18, 0x01	; 1
 1d2:	62 1a       	sub	r6, r18
 1d4:	71 08       	sbc	r7, r1
 1d6:	01 f4       	brne	.+0      	; 0x1d8 <servosMuxInit+0xca>
		int i;

		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
 1d8:	e1 2c       	mov	r14, r1
 1da:	f1 2c       	mov	r15, r1
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 1dc:	f8 01       	movw	r30, r16
 1de:	34 96       	adiw	r30, 0x04	; 4
 1e0:	85 91       	lpm	r24, Z+
 1e2:	94 91       	lpm	r25, Z
 1e4:	fc 01       	movw	r30, r24
 1e6:	80 81       	ld	r24, Z
 1e8:	87 70       	andi	r24, 0x07	; 7
 1ea:	01 f4       	brne	.+0      	; 0x1ec <servosMuxInit+0xde>
 1ec:	00 c0       	rjmp	.+0      	; 0x1ee <servosMuxInit+0xe0>
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <servosMuxInit+0xe2>


		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			if(timerGetMode(timer) != TIMER_MODE_PWM_PHASE_CORRECT_ICR
					|| timerGetPrescaler(timer)!=prescale
 1f0:	8d 91       	ld	r24, X+
 1f2:	9c 91       	ld	r25, X
 1f4:	8a 15       	cp	r24, r10
 1f6:	9b 05       	cpc	r25, r11
 1f8:	01 f0       	breq	.+0      	; 0x1fa <servosMuxInit+0xec>
					|| timerGetTOP(timer)!=bestTop
					){
				setError(PWM_TIMER_IN_USE);
 1fa:	82 ef       	ldi	r24, 0xF2	; 242
 1fc:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 200:	00 c0       	rjmp	.+0      	; 0x202 <servosMuxInit+0xf4>

		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			if(timerGetMode(timer) != TIMER_MODE_PWM_PHASE_CORRECT_ICR
					|| timerGetPrescaler(timer)!=prescale
					|| timerGetTOP(timer)!=bestTop
 202:	c8 01       	movw	r24, r16
 204:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 208:	8e 15       	cp	r24, r14
 20a:	9f 05       	cpc	r25, r15
 20c:	01 f4       	brne	.+0      	; 0x20e <servosMuxInit+0x100>
			// Set the ICR
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
			_SFR_MEM16(icrPort)=bestTop;
		}
		// Use non-inverted PWM
		compareSetOutputMode(channel,CHANNEL_MODE_NON_INVERTING);
 20e:	62 e0       	ldi	r22, 0x02	; 2
 210:	c4 01       	movw	r24, r8
 212:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>


		driver->specific.softwareMUX.currentServo = driver->num_servos;
 216:	ab 81       	ldd	r26, Y+3	; 0x03
 218:	bc 81       	ldd	r27, Y+4	; 0x04
 21a:	12 96       	adiw	r26, 0x02	; 2
 21c:	8c 91       	ld	r24, X
 21e:	12 97       	sbiw	r26, 0x02	; 2
 220:	17 96       	adiw	r26, 0x07	; 7
 222:	8c 93       	st	X, r24
 224:	17 97       	sbiw	r26, 0x07	; 7
		driver->specific.softwareMUX.servo_cycle = bestTop;
 226:	19 96       	adiw	r26, 0x09	; 9
 228:	fc 92       	st	X, r15
 22a:	ee 92       	st	-X, r14
 22c:	18 97       	sbiw	r26, 0x08	; 8

		// Set all the multiplex pins as output low
		driver->specific.softwareMUX.muxPins[0] = mux1;
 22e:	1b 96       	adiw	r26, 0x0b	; 11
 230:	5c 92       	st	X, r5
 232:	4e 92       	st	-X, r4
 234:	1a 97       	sbiw	r26, 0x0a	; 10
		driver->specific.softwareMUX.muxPins[1] = mux2;
 236:	1d 96       	adiw	r26, 0x0d	; 13
 238:	3c 92       	st	X, r3
 23a:	2e 92       	st	-X, r2
 23c:	1c 97       	sbiw	r26, 0x0c	; 12
		driver->specific.softwareMUX.muxPins[2] = mux3;
 23e:	e9 81       	ldd	r30, Y+1	; 0x01
 240:	fa 81       	ldd	r31, Y+2	; 0x02
 242:	1f 96       	adiw	r26, 0x0f	; 15
 244:	fc 93       	st	X, r31
 246:	ee 93       	st	-X, r30
 248:	1e 97       	sbiw	r26, 0x0e	; 14
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
 24a:	f4 01       	movw	r30, r8
 24c:	36 96       	adiw	r30, 0x06	; 6
 24e:	85 91       	lpm	r24, Z+
 250:	94 91       	lpm	r25, Z
		driver->specific.softwareMUX.pwmPort = port;
 252:	50 96       	adiw	r26, 0x10	; 16
 254:	8c 93       	st	X, r24
 256:	50 97       	sbiw	r26, 0x10	; 16
 258:	51 96       	adiw	r26, 0x11	; 17
 25a:	9c 93       	st	X, r25
		pin_make_output(mux1,FALSE);
 25c:	60 e0       	ldi	r22, 0x00	; 0
 25e:	c2 01       	movw	r24, r4
 260:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		pin_make_output(mux2,FALSE);
 264:	60 e0       	ldi	r22, 0x00	; 0
 266:	c1 01       	movw	r24, r2
 268:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		pin_make_output(mux3,FALSE);
 26c:	60 e0       	ldi	r22, 0x00	; 0
 26e:	89 81       	ldd	r24, Y+1	; 0x01
 270:	9a 81       	ldd	r25, Y+2	; 0x02
 272:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

		maxDelay = bestTop;
 276:	f0 92 00 00 	sts	0x0000, r15
 27a:	e0 92 00 00 	sts	0x0000, r14

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 27e:	ab 81       	ldd	r26, Y+3	; 0x03
 280:	bc 81       	ldd	r27, Y+4	; 0x04
 282:	12 96       	adiw	r26, 0x02	; 2
 284:	4c 90       	ld	r4, X
 286:	61 2c       	mov	r6, r1
 288:	71 2c       	mov	r7, r1
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 28a:	51 2c       	mov	r5, r1
		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);

			// Connect the servo to this driver
			servo->actuator.class = &c_mux_Servos;
 28c:	40 e0       	ldi	r20, 0x00	; 0
 28e:	24 2e       	mov	r2, r20
 290:	40 e0       	ldi	r20, 0x00	; 0
 292:	34 2e       	mov	r3, r20
		pin_make_output(mux3,FALSE);

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 294:	00 c0       	rjmp	.+0      	; 0x296 <servosMuxInit+0x188>
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 296:	88 0f       	add	r24, r24
 298:	99 1f       	adc	r25, r25

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 29a:	ab 81       	ldd	r26, Y+3	; 0x03
 29c:	bc 81       	ldd	r27, Y+4	; 0x04
 29e:	ed 91       	ld	r30, X+
 2a0:	fc 91       	ld	r31, X
 2a2:	11 97       	sbiw	r26, 0x01	; 1
 2a4:	e8 0f       	add	r30, r24
 2a6:	f9 1f       	adc	r31, r25
 2a8:	c5 90       	lpm	r12, Z+
 2aa:	d4 90       	lpm	r13, Z

			// Connect the servo to this driver
			servo->actuator.class = &c_mux_Servos;
 2ac:	f6 01       	movw	r30, r12
 2ae:	31 82       	std	Z+1, r3	; 0x01
 2b0:	20 82       	st	Z, r2
			servo->driver = driver;
 2b2:	b5 83       	std	Z+5, r27	; 0x05
 2b4:	a4 83       	std	Z+4, r26	; 0x04
			servo->top = driver->specific.softwareMUX.servo_cycle;
 2b6:	18 96       	adiw	r26, 0x08	; 8
 2b8:	8d 91       	ld	r24, X+
 2ba:	9c 91       	ld	r25, X
 2bc:	19 97       	sbiw	r26, 0x09	; 9
 2be:	93 8b       	std	Z+19, r25	; 0x13
 2c0:	82 8b       	std	Z+18, r24	; 0x12

			servoSetConfig(servo,servo->center_us,servo->range_us);
 2c2:	42 85       	ldd	r20, Z+10	; 0x0a
 2c4:	53 85       	ldd	r21, Z+11	; 0x0b
 2c6:	60 85       	ldd	r22, Z+8	; 0x08
 2c8:	71 85       	ldd	r23, Z+9	; 0x09
 2ca:	c6 01       	movw	r24, r12
 2cc:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

			// The servo is connected
			act_setConnected(servo,TRUE);
 2d0:	6f ef       	ldi	r22, 0xFF	; 255
 2d2:	8c 2d       	mov	r24, r12
 2d4:	9d 2d       	mov	r25, r13
 2d6:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 2da:	60 e0       	ldi	r22, 0x00	; 0
 2dc:	8c 2d       	mov	r24, r12
 2de:	9d 2d       	mov	r25, r13
 2e0:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 2e4:	ff ef       	ldi	r31, 0xFF	; 255
 2e6:	6f 1a       	sub	r6, r31
 2e8:	7f 0a       	sbc	r7, r31
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 2ea:	c2 01       	movw	r24, r4
 2ec:	86 19       	sub	r24, r6
 2ee:	97 09       	sbc	r25, r7
		pin_make_output(mux3,FALSE);

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 2f0:	8f 3f       	cpi	r24, 0xFF	; 255
 2f2:	2f ef       	ldi	r18, 0xFF	; 255
 2f4:	92 07       	cpc	r25, r18
 2f6:	01 f4       	brne	.+0      	; 0x2f8 <servosMuxInit+0x1ea>
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}


		// Set up the timer to start processing interrupts
		if(getError()==0){
 2f8:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 2fc:	81 11       	cpse	r24, r1
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <servosMuxInit+0x1f2>
			CRITICAL_SECTION{
 300:	ff b6       	in	r15, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 302:	f8 94       	cli
				timerCaptureAttach(timer,&service,driver,false);
 304:	20 e0       	ldi	r18, 0x00	; 0
 306:	4b 81       	ldd	r20, Y+3	; 0x03
 308:	5c 81       	ldd	r21, Y+4	; 0x04
 30a:	60 e0       	ldi	r22, 0x00	; 0
 30c:	70 e0       	ldi	r23, 0x00	; 0
 30e:	c8 01       	movw	r24, r16
 310:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
				// Set 0% duty cycle to start with
				compareSetThreshold(channel,0);
 314:	60 e0       	ldi	r22, 0x00	; 0
 316:	70 e0       	ldi	r23, 0x00	; 0
 318:	c4 01       	movw	r24, r8
 31a:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

				// Do this last as it then turns on the timer
				timerSetPrescaler(timer,prescale);
 31e:	b5 01       	movw	r22, r10
 320:	c8 01       	movw	r24, r16
 322:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 326:	ff be       	out	0x3f, r15	; 63
 328:	00 c0       	rjmp	.+0      	; 0x32a <servosMuxInit+0x21c>



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 32a:	89 ef       	ldi	r24, 0xF9	; 249
	}

}
 32c:	0f 90       	pop	r0
 32e:	0f 90       	pop	r0
 330:	0f 90       	pop	r0
 332:	0f 90       	pop	r0
 334:	df 91       	pop	r29
 336:	cf 91       	pop	r28
 338:	1f 91       	pop	r17
 33a:	0f 91       	pop	r16
 33c:	ff 90       	pop	r15
 33e:	ef 90       	pop	r14
 340:	df 90       	pop	r13
 342:	cf 90       	pop	r12
 344:	bf 90       	pop	r11
 346:	af 90       	pop	r10
 348:	9f 90       	pop	r9
 34a:	8f 90       	pop	r8
 34c:	7f 90       	pop	r7
 34e:	6f 90       	pop	r6
 350:	5f 90       	pop	r5
 352:	4f 90       	pop	r4
 354:	3f 90       	pop	r3
 356:	2f 90       	pop	r2



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 358:	0c 94 00 00 	jmp	0	; 0x0 <mux_setSpeed>
					|| timerGetTOP(timer)!=bestTop
					){
				setError(PWM_TIMER_IN_USE);
			}
		}else{
			timerSetMode(timer,TIMER_MODE_PWM_PHASE_CORRECT_ICR);
 35c:	6a e0       	ldi	r22, 0x0A	; 10
 35e:	c8 01       	movw	r24, r16
 360:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			// Set the ICR
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
 364:	f8 01       	movw	r30, r16
 366:	7f 96       	adiw	r30, 0x1f	; 31
 368:	85 91       	lpm	r24, Z+
 36a:	94 91       	lpm	r25, Z
			_SFR_MEM16(icrPort)=bestTop;
 36c:	fc 01       	movw	r30, r24
 36e:	f1 82       	std	Z+1, r15	; 0x01
 370:	e0 82       	st	Z, r14
 372:	00 c0       	rjmp	.+0      	; 0x374 <servosMuxInit+0x266>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 374:	f8 01       	movw	r30, r16
 376:	a5 91       	lpm	r26, Z+
 378:	b4 91       	lpm	r27, Z
		}


		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			if(timerGetMode(timer) != TIMER_MODE_PWM_PHASE_CORRECT_ICR
 37a:	1a 96       	adiw	r26, 0x0a	; 10
 37c:	8c 91       	ld	r24, X
 37e:	1a 97       	sbiw	r26, 0x0a	; 10
 380:	8a 30       	cpi	r24, 0x0A	; 10
 382:	01 f0       	breq	.+0      	; 0x384 <servosMuxInit+0x276>
 384:	00 c0       	rjmp	.+0      	; 0x386 <servosMuxInit+0x278>
 386:	00 c0       	rjmp	.+0      	; 0x388 <servosMuxInit+0x27a>
	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
	}

}
 388:	0f 90       	pop	r0
 38a:	0f 90       	pop	r0
 38c:	0f 90       	pop	r0
 38e:	0f 90       	pop	r0
 390:	df 91       	pop	r29
 392:	cf 91       	pop	r28
 394:	1f 91       	pop	r17
 396:	0f 91       	pop	r16
 398:	ff 90       	pop	r15
 39a:	ef 90       	pop	r14
 39c:	df 90       	pop	r13
 39e:	cf 90       	pop	r12
 3a0:	bf 90       	pop	r11
 3a2:	af 90       	pop	r10
 3a4:	9f 90       	pop	r9
 3a6:	8f 90       	pop	r8
 3a8:	7f 90       	pop	r7
 3aa:	6f 90       	pop	r6
 3ac:	5f 90       	pop	r5
 3ae:	4f 90       	pop	r4
 3b0:	3f 90       	pop	r3
 3b2:	2f 90       	pop	r2
 3b4:	08 95       	ret

servoPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000258  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000028c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000028c  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  0000028c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001413  00000000  00000000  00000290  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000354  00000000  00000000  000016a3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000006b3  00000000  00000000  000019f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000020aa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000040  00000000  00000000  000020ca  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001bb  00000000  00000000  0000210a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000a8d  00000000  00000000  000022c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002d52  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000000d8  00000000  00000000  00002d7c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	1f 92       	push	r1
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	SERVO* servo = (SERVO*)actuator;
	const TimerCompare* channel = compareFromIOPin(servo->pin);
   a:	fc 01       	movw	r30, r24
   c:	86 81       	ldd	r24, Z+6	; 0x06
   e:	97 81       	ldd	r25, Z+7	; 0x07
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
}
  22:	0f 90       	pop	r0
  24:	df 91       	pop	r29
  26:	cf 91       	pop	r28
static void setConnected(__ACTUATOR *actuator, boolean connected){
	SERVO* servo = (SERVO*)actuator;
	const TimerCompare* channel = compareFromIOPin(servo->pin);

	// Turn on/off the pin
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  28:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

0000002c <setSpeed>:
#include "timer.h"
#include "core.h"
#include "servos.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2c:	df 92       	push	r13
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	0f 93       	push	r16
  34:	1f 93       	push	r17
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	ec 01       	movw	r28, r24
  3c:	d6 2e       	mov	r13, r22
	SERVO* servo = (SERVO*)actuator;
	const TimerCompare* channel = compareFromIOPin(servo->pin);
  3e:	8e 81       	ldd	r24, Y+6	; 0x06
  40:	9f 81       	ldd	r25, Y+7	; 0x07
  42:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  46:	7c 01       	movw	r14, r24

	// Interpolate the values
	uint16_t delay = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
  48:	0e 85       	ldd	r16, Y+14	; 0x0e
  4a:	1f 85       	ldd	r17, Y+15	; 0x0f
  4c:	2c 85       	ldd	r18, Y+12	; 0x0c
  4e:	3d 85       	ldd	r19, Y+13	; 0x0d
  50:	4f e7       	ldi	r20, 0x7F	; 127
  52:	50 e0       	ldi	r21, 0x00	; 0
  54:	61 e8       	ldi	r22, 0x81	; 129
  56:	7f ef       	ldi	r23, 0xFF	; 255
  58:	8d 2d       	mov	r24, r13
  5a:	99 27       	eor	r25, r25
  5c:	87 fd       	sbrc	r24, 7
  5e:	90 95       	com	r25
  60:	0e 94 00 00 	call	0	; 0x0 <setConnected>
//	servo->delay = delay;

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  64:	bc 01       	movw	r22, r24
  66:	c7 01       	movw	r24, r14
}
  68:	df 91       	pop	r29
  6a:	cf 91       	pop	r28
  6c:	1f 91       	pop	r17
  6e:	0f 91       	pop	r16
  70:	ff 90       	pop	r15
  72:	ef 90       	pop	r14
  74:	df 90       	pop	r13
	// Interpolate the values
	uint16_t delay = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
//	servo->delay = delay;

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  76:	0c 94 00 00 	jmp	0	; 0x0 <setConnected>

0000007a <servoPWMInit>:


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  7a:	2f 92       	push	r2
  7c:	3f 92       	push	r3
  7e:	4f 92       	push	r4
  80:	5f 92       	push	r5
  82:	6f 92       	push	r6
  84:	7f 92       	push	r7
  86:	8f 92       	push	r8
  88:	9f 92       	push	r9
  8a:	af 92       	push	r10
  8c:	bf 92       	push	r11
  8e:	cf 92       	push	r12
  90:	df 92       	push	r13
  92:	ef 92       	push	r14
  94:	ff 92       	push	r15
  96:	0f 93       	push	r16
  98:	1f 93       	push	r17
  9a:	cf 93       	push	r28
  9c:	df 93       	push	r29
  9e:	00 d0       	rcall	.+0      	; 0xa0 <servoPWMInit+0x26>
  a0:	00 d0       	rcall	.+0      	; 0xa2 <servoPWMInit+0x28>
  a2:	cd b7       	in	r28, 0x3d	; 61
  a4:	de b7       	in	r29, 0x3e	; 62
  a6:	2c 01       	movw	r4, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
  a8:	dc 01       	movw	r26, r24
  aa:	12 96       	adiw	r26, 0x02	; 2
  ac:	8c 91       	ld	r24, X
  ae:	81 2c       	mov	r8, r1
  b0:	91 2c       	mov	r9, r1


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  b2:	90 e0       	ldi	r25, 0x00	; 0
  b4:	1c 01       	movw	r2, r24
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	2b 1a       	sub	r2, r27
  ba:	31 08       	sbc	r3, r1
  bc:	fc 01       	movw	r30, r24
  be:	e1 50       	subi	r30, 0x01	; 1
  c0:	f0 48       	sbci	r31, 0x80	; 128
  c2:	fa 83       	std	Y+2, r31	; 0x02
  c4:	e9 83       	std	Y+1, r30	; 0x01
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <servoPWMInit+0x4e>


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  c8:	89 81       	ldd	r24, Y+1	; 0x01
  ca:	9a 81       	ldd	r25, Y+2	; 0x02
  cc:	88 19       	sub	r24, r8
  ce:	99 09       	sbc	r25, r9
  d0:	88 0f       	add	r24, r24
  d2:	99 1f       	adc	r25, r25
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  d4:	d2 01       	movw	r26, r4
  d6:	ed 91       	ld	r30, X+
  d8:	fc 91       	ld	r31, X
  da:	e8 0f       	add	r30, r24
  dc:	f9 1f       	adc	r31, r25
  de:	85 91       	lpm	r24, Z+
  e0:	94 91       	lpm	r25, Z
  e2:	8b 83       	std	Y+3, r24	; 0x03
  e4:	9c 83       	std	Y+4, r25	; 0x04

		// Connect the servo to this driver
		servo->driver = driver;
  e6:	eb 81       	ldd	r30, Y+3	; 0x03
  e8:	fc 81       	ldd	r31, Y+4	; 0x04
  ea:	55 82       	std	Z+5, r5	; 0x05
  ec:	44 82       	std	Z+4, r4	; 0x04

		const TimerCompare* channel = compareFromIOPin(servo->pin);
  ee:	86 81       	ldd	r24, Z+6	; 0x06
  f0:	97 81       	ldd	r25, Z+7	; 0x07
  f2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  f6:	5c 01       	movw	r10, r24
		if(channel==null){
  f8:	00 97       	sbiw	r24, 0x00	; 0
  fa:	01 f4       	brne	.+0      	; 0xfc <servoPWMInit+0x82>
			setError(PWM_PIN_NOT_AVAILABLE);
  fc:	84 ef       	ldi	r24, 0xF4	; 244
  fe:	00 c0       	rjmp	.+0      	; 0x100 <servoPWMInit+0x86>
			continue;
		}
		if(compareIsInUse(channel)){
 100:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 104:	88 23       	and	r24, r24
 106:	01 f0       	breq	.+0      	; 0x108 <servoPWMInit+0x8e>
			setError(PWM_PIN_IN_USE);
 108:	83 ef       	ldi	r24, 0xF3	; 243
 10a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			continue;
 10e:	00 c0       	rjmp	.+0      	; 0x110 <servoPWMInit+0x96>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 110:	f5 01       	movw	r30, r10
 112:	32 96       	adiw	r30, 0x02	; 2
 114:	04 91       	lpm	r16, Z
		}

		// Find which timer the compare unit is attached to
		const Timer* timer = compareGetTimer(channel);
 116:	fc e2       	ldi	r31, 0x2C	; 44
 118:	f0 9f       	mul	r31, r16
 11a:	80 01       	movw	r16, r0
 11c:	11 24       	eor	r1, r1
 11e:	00 50       	subi	r16, 0x00	; 0
 120:	10 40       	sbci	r17, 0x00	; 0
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 122:	f8 01       	movw	r30, r16
 124:	36 96       	adiw	r30, 0x06	; 6
 126:	e4 91       	lpm	r30, Z

		// We need a 16 bit timer
		if(!timerIs16bit(timer)){
 128:	e1 11       	cpse	r30, r1
 12a:	00 c0       	rjmp	.+0      	; 0x12c <servoPWMInit+0xb2>
			setError(SERVO_TIMER_MUST_BE_16_BIT);
 12c:	89 ef       	ldi	r24, 0xF9	; 249
 12e:	00 c0       	rjmp	.+0      	; 0x130 <servoPWMInit+0xb6>
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
 130:	f8 01       	movw	r30, r16
 132:	39 96       	adiw	r30, 0x09	; 9
 134:	85 91       	lpm	r24, Z+
 136:	94 91       	lpm	r25, Z
 138:	96 ff       	sbrs	r25, 6
 13a:	00 c0       	rjmp	.+0      	; 0x13c <servoPWMInit+0xc2>
 13c:	00 c0       	rjmp	.+0      	; 0x13e <servoPWMInit+0xc4>
			continue;
		}

		// Find the optimum prescale value
		uint16_t prescale=timerGetBestPrescaler(timer, SERVO_CYCLE);
		if(timerIsInUse(timer) && (timerGetPrescaler(timer)!=prescale || timerGetMode(timer)!=TIMER_MODE_PWM_FAST_ICR)){
 13e:	1a 96       	adiw	r26, 0x0a	; 10
 140:	8c 91       	ld	r24, X
 142:	8e 30       	cpi	r24, 0x0E	; 14
 144:	01 f0       	breq	.+0      	; 0x146 <servoPWMInit+0xcc>
			setError(PWM_TIMER_IN_USE);
 146:	82 ef       	ldi	r24, 0xF2	; 242
 148:	00 c0       	rjmp	.+0      	; 0x14a <servoPWMInit+0xd0>
			continue;
		}

		// Connect to driver
		servo->actuator.class = &c_servoPWM;
 14a:	e0 e0       	ldi	r30, 0x00	; 0
 14c:	f0 e0       	ldi	r31, 0x00	; 0
 14e:	ab 81       	ldd	r26, Y+3	; 0x03
 150:	bc 81       	ldd	r27, Y+4	; 0x04
 152:	11 96       	adiw	r26, 0x01	; 1
 154:	fc 93       	st	X, r31
 156:	ee 93       	st	-X, r30

		// Make sure its an output pin, low
		pin_make_output(servo->pin, FALSE);
 158:	60 e0       	ldi	r22, 0x00	; 0
 15a:	16 96       	adiw	r26, 0x06	; 6
 15c:	8d 91       	ld	r24, X+
 15e:	9c 91       	ld	r25, X
 160:	17 97       	sbiw	r26, 0x07	; 7
 162:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// put the timer into the correct mode
		timerSetMode(timer,TIMER_MODE_PWM_FAST_ICR);
 166:	6e e0       	ldi	r22, 0x0E	; 14
 168:	c8 01       	movw	r24, r16
 16a:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Set top for the correct cycle time
		uint16_t top = ticks_per_ms(SERVO_CYCLE,prescale);
 16e:	a3 01       	movw	r20, r6
 170:	64 e1       	ldi	r22, 0x14	; 20
 172:	70 e0       	ldi	r23, 0x00	; 0
 174:	80 e0       	ldi	r24, 0x00	; 0
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 17c:	6b 01       	movw	r12, r22
 17e:	7c 01       	movw	r14, r24
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 180:	20 e0       	ldi	r18, 0x00	; 0
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	40 e0       	ldi	r20, 0x00	; 0
 186:	50 e0       	ldi	r21, 0x00	; 0
 188:	60 e0       	ldi	r22, 0x00	; 0
 18a:	70 e0       	ldi	r23, 0x00	; 0
 18c:	c5 01       	movw	r24, r10
 18e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		PORT icr = pgm_read_word(&timer->pgm_icr);
 192:	f8 01       	movw	r30, r16
 194:	7f 96       	adiw	r30, 0x1f	; 31
 196:	85 91       	lpm	r24, Z+
 198:	94 91       	lpm	r25, Z
		_SFR_MEM16(icr)=top;
 19a:	fc 01       	movw	r30, r24
 19c:	d1 82       	std	Z+1, r13	; 0x01
 19e:	c0 82       	st	Z, r12
		servo->top = top;
 1a0:	ab 81       	ldd	r26, Y+3	; 0x03
 1a2:	bc 81       	ldd	r27, Y+4	; 0x04
 1a4:	53 96       	adiw	r26, 0x13	; 19
 1a6:	dc 92       	st	X, r13
 1a8:	ce 92       	st	-X, r12
 1aa:	52 97       	sbiw	r26, 0x12	; 18
		uint32_t max = servo->center_us + servo->range_us;
		m2 =  m1 * max;
		m3 =  m2 / SERVO_CYCLE;
		servo->max_ticks = m3;
		*/
		servoSetConfig(servo, servo->center_us, servo->range_us);
 1ac:	1a 96       	adiw	r26, 0x0a	; 10
 1ae:	4d 91       	ld	r20, X+
 1b0:	5c 91       	ld	r21, X
 1b2:	1b 97       	sbiw	r26, 0x0b	; 11
 1b4:	18 96       	adiw	r26, 0x08	; 8
 1b6:	6d 91       	ld	r22, X+
 1b8:	7c 91       	ld	r23, X
 1ba:	19 97       	sbiw	r26, 0x09	; 9
 1bc:	cd 01       	movw	r24, r26
 1be:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescale);
 1c2:	b3 01       	movw	r22, r6
 1c4:	c8 01       	movw	r24, r16
 1c6:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 1ca:	60 e0       	ldi	r22, 0x00	; 0
 1cc:	8b 81       	ldd	r24, Y+3	; 0x03
 1ce:	9c 81       	ldd	r25, Y+4	; 0x04
 1d0:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Indicate the servo is connected
		act_setConnected(servo,TRUE);
 1d4:	6f ef       	ldi	r22, 0xFF	; 255
 1d6:	8b 81       	ldd	r24, Y+3	; 0x03
 1d8:	9c 81       	ldd	r25, Y+4	; 0x04
 1da:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1de:	bf ef       	ldi	r27, 0xFF	; 255
 1e0:	8b 1a       	sub	r8, r27
 1e2:	9b 0a       	sbc	r9, r27


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
 1e4:	c1 01       	movw	r24, r2
 1e6:	88 19       	sub	r24, r8
 1e8:	99 09       	sbc	r25, r9
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
 1ea:	01 96       	adiw	r24, 0x01	; 1
 1ec:	01 f0       	breq	.+0      	; 0x1ee <servoPWMInit+0x174>
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <servoPWMInit+0x176>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <servoPWMInit+0x178>
			continue;
		}

		// Make sure it supports fast pwm using ICR
		if(!timerIsModeSupported(timer,TIMER_MODE_PWM_FAST_ICR)){
			setError(PWM_TIMER_MODE_PWM_FAST_ICR_UNSUPPORTED);
 1f2:	81 ef       	ldi	r24, 0xF1	; 241
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <servoPWMInit+0x17c>
			continue;
		}

		// Find the optimum prescale value
		uint16_t prescale=timerGetBestPrescaler(timer, SERVO_CYCLE);
 1f6:	64 e1       	ldi	r22, 0x14	; 20
 1f8:	70 e0       	ldi	r23, 0x00	; 0
 1fa:	c8 01       	movw	r24, r16
 1fc:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 200:	3c 01       	movw	r6, r24
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 202:	f8 01       	movw	r30, r16
 204:	34 96       	adiw	r30, 0x04	; 4
 206:	85 91       	lpm	r24, Z+
 208:	94 91       	lpm	r25, Z
 20a:	fc 01       	movw	r30, r24
 20c:	80 81       	ld	r24, Z
 20e:	87 70       	andi	r24, 0x07	; 7
 210:	01 f4       	brne	.+0      	; 0x212 <servoPWMInit+0x198>
 212:	00 c0       	rjmp	.+0      	; 0x214 <servoPWMInit+0x19a>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 214:	f8 01       	movw	r30, r16
 216:	a5 91       	lpm	r26, Z+
 218:	b4 91       	lpm	r27, Z
		if(timerIsInUse(timer) && (timerGetPrescaler(timer)!=prescale || timerGetMode(timer)!=TIMER_MODE_PWM_FAST_ICR)){
 21a:	8d 91       	ld	r24, X+
 21c:	9c 91       	ld	r25, X
 21e:	11 97       	sbiw	r26, 0x01	; 1
 220:	86 15       	cp	r24, r6
 222:	97 05       	cpc	r25, r7
 224:	01 f0       	breq	.+0      	; 0x226 <servoPWMInit+0x1ac>
 226:	00 c0       	rjmp	.+0      	; 0x228 <servoPWMInit+0x1ae>
 228:	00 c0       	rjmp	.+0      	; 0x22a <servoPWMInit+0x1b0>
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);

		// Indicate the servo is connected
		act_setConnected(servo,TRUE);
	}
}
 22a:	0f 90       	pop	r0
 22c:	0f 90       	pop	r0
 22e:	0f 90       	pop	r0
 230:	0f 90       	pop	r0
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	1f 91       	pop	r17
 238:	0f 91       	pop	r16
 23a:	ff 90       	pop	r15
 23c:	ef 90       	pop	r14
 23e:	df 90       	pop	r13
 240:	cf 90       	pop	r12
 242:	bf 90       	pop	r11
 244:	af 90       	pop	r10
 246:	9f 90       	pop	r9
 248:	8f 90       	pop	r8
 24a:	7f 90       	pop	r7
 24c:	6f 90       	pop	r6
 24e:	5f 90       	pop	r5
 250:	4f 90       	pop	r4
 252:	3f 90       	pop	r3
 254:	2f 90       	pop	r2
 256:	08 95       	ret

servos.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003ba  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003ee  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003ee  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001862  00000000  00000000  000003f2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000003b5  00000000  00000000  00001c54  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000bbc  00000000  00000000  00002009  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00002bc5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000050  00000000  00000000  00002be5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000024d  00000000  00000000  00002c35  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000b1e  00000000  00000000  00002e82  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  000039a0  2**0
                  CONTENTS, READONLY
 12 .debug_frame  0000010c  00000000  00000000  000039cc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#define CHANNEL_ON  0
#define CHANNEL_OFF 1


// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
   a:	86 2f       	mov	r24, r22
	SERVO* servo = (SERVO*)actuator;

	// Interpolate the values
	uint16_t ticks=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
   c:	0e 85       	ldd	r16, Y+14	; 0x0e
   e:	1f 85       	ldd	r17, Y+15	; 0x0f
  10:	2c 85       	ldd	r18, Y+12	; 0x0c
  12:	3d 85       	ldd	r19, Y+13	; 0x0d
  14:	4f e7       	ldi	r20, 0x7F	; 127
  16:	50 e0       	ldi	r21, 0x00	; 0
  18:	61 e8       	ldi	r22, 0x81	; 129
  1a:	7f ef       	ldi	r23, 0xFF	; 255
  1c:	99 27       	eor	r25, r25
  1e:	87 fd       	sbrc	r24, 7
  20:	90 95       	com	r25
  22:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	if(ticks!=servo->delay){
  26:	28 89       	ldd	r18, Y+16	; 0x10
  28:	39 89       	ldd	r19, Y+17	; 0x11
  2a:	82 17       	cp	r24, r18
  2c:	93 07       	cpc	r25, r19
  2e:	01 f0       	breq	.+0      	; 0x30 <setSpeed+0x30>
		CRITICAL_SECTION{
  30:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  32:	f8 94       	cli
			servo->delay = ticks;
  34:	99 8b       	std	Y+17, r25	; 0x11
  36:	88 8b       	std	Y+16, r24	; 0x10
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  38:	2f bf       	out	0x3f, r18	; 63
		};
	}
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	1f 91       	pop	r17
  40:	0f 91       	pop	r16
  42:	08 95       	ret

00000044 <__servoEndService>:
// Define the class
static const __ACTUATOR_DRIVER_CLASS c_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);


// Called to turn off the current pulse
static void __servoEndService(const TimerCompare *timer_compare, void* data){
  44:	cf 93       	push	r28
  46:	df 93       	push	r29
  48:	ec 01       	movw	r28, r24
  4a:	fb 01       	movw	r30, r22
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;

	if(driver->specific.softwarePWM.currentServo < driver->num_servos){
  4c:	87 81       	ldd	r24, Z+7	; 0x07
  4e:	92 81       	ldd	r25, Z+2	; 0x02
  50:	89 17       	cp	r24, r25
  52:	00 f4       	brcc	.+0      	; 0x54 <__servoEndService+0x10>
		// turn off the previous channel
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[driver->specific.softwarePWM.currentServo]);
  54:	20 81       	ld	r18, Z
  56:	91 81       	ldd	r25, Z+1	; 0x01
  58:	e2 2f       	mov	r30, r18
  5a:	f9 2f       	mov	r31, r25
  5c:	e8 0f       	add	r30, r24
  5e:	f1 1d       	adc	r31, r1
  60:	e8 0f       	add	r30, r24
  62:	f1 1d       	adc	r31, r1
  64:	a5 91       	lpm	r26, Z+
  66:	b4 91       	lpm	r27, Z
		pin_low(servo->pin);
  68:	16 96       	adiw	r26, 0x06	; 6
  6a:	8d 91       	ld	r24, X+
  6c:	9c 91       	ld	r25, X
  6e:	17 97       	sbiw	r26, 0x07	; 7
  70:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

	// disable channel that turns pulses off
	__portMaskClear(&timer_compare->pgm_intenable);
  74:	ce 01       	movw	r24, r28
  76:	03 96       	adiw	r24, 0x03	; 3

}
  78:	df 91       	pop	r29
  7a:	cf 91       	pop	r28
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[driver->specific.softwarePWM.currentServo]);
		pin_low(servo->pin);
	}

	// disable channel that turns pulses off
	__portMaskClear(&timer_compare->pgm_intenable);
  7c:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>

00000080 <__servoStartService>:

}

static void __servoStartService(const TimerCompare *timer_compare, void* data){
  80:	8f 92       	push	r8
  82:	9f 92       	push	r9
  84:	af 92       	push	r10
  86:	bf 92       	push	r11
  88:	cf 92       	push	r12
  8a:	df 92       	push	r13
  8c:	ef 92       	push	r14
  8e:	ff 92       	push	r15
  90:	0f 93       	push	r16
  92:	1f 93       	push	r17
  94:	cf 93       	push	r28
  96:	df 93       	push	r29
  98:	7c 01       	movw	r14, r24
  9a:	eb 01       	movw	r28, r22
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  9c:	fc 01       	movw	r30, r24
  9e:	32 96       	adiw	r30, 0x02	; 2
  a0:	c4 90       	lpm	r12, Z
	uint16_t delay;	// The next delay in cycles
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;
	const Timer* timer = compareGetTimer(timer_compare);
  a2:	8c e2       	ldi	r24, 0x2C	; 44
  a4:	c8 9e       	mul	r12, r24
  a6:	60 01       	movw	r12, r0
  a8:	11 24       	eor	r1, r1
  aa:	e0 e0       	ldi	r30, 0x00	; 0
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	ce 0e       	add	r12, r30
  b0:	df 1e       	adc	r13, r31
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  b2:	f6 01       	movw	r30, r12
  b4:	77 96       	adiw	r30, 0x17	; 23
  b6:	a5 90       	lpm	r10, Z+
  b8:	b4 90       	lpm	r11, Z
  ba:	45 01       	movw	r8, r10
  bc:	f0 e1       	ldi	r31, 0x10	; 16
  be:	8f 0e       	add	r8, r31
  c0:	91 1c       	adc	r9, r1
	const TimerCompare* turnOff = timerGetCompare(timer,CHANNEL_OFF);

	// Wait if previous pulse is still going
	while( __portMaskGet(&turnOff->pgm_intenable) ){
  c2:	83 e1       	ldi	r24, 0x13	; 19
  c4:	a8 0e       	add	r10, r24
  c6:	b1 1c       	adc	r11, r1
  c8:	00 c0       	rjmp	.+0      	; 0xca <__servoStartService+0x4a>
		breathe();
  ca:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;
	const Timer* timer = compareGetTimer(timer_compare);
	const TimerCompare* turnOff = timerGetCompare(timer,CHANNEL_OFF);

	// Wait if previous pulse is still going
	while( __portMaskGet(&turnOff->pgm_intenable) ){
  ce:	c5 01       	movw	r24, r10
  d0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  d4:	81 11       	cpse	r24, r1
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <__servoStartService+0x58>
		breathe();
	}

	// Start processing the next one
	if(driver->servos_init){
  d8:	8b 81       	ldd	r24, Y+3	; 0x03
  da:	88 23       	and	r24, r24
  dc:	01 f0       	breq	.+0      	; 0xde <__servoStartService+0x5e>
		driver->specific.softwarePWM.currentServo++;
  de:	8f 81       	ldd	r24, Y+7	; 0x07
  e0:	8f 5f       	subi	r24, 0xFF	; 255
  e2:	8f 83       	std	Y+7, r24	; 0x07
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <__servoStartService+0x66>
	}else{
		driver->servos_init=TRUE;
  e6:	8f ef       	ldi	r24, 0xFF	; 255
  e8:	8b 83       	std	Y+3, r24	; 0x03
		// Set the threshold to when the first compare was fired
		// so that if there are multiple banks then each bank is
		// reset to use its actual start time.
		compareSetThreshold(timer_compare,timerGetCounter(compareGetTimer(timer_compare)));
  ea:	c6 01       	movw	r24, r12
  ec:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  f0:	bc 01       	movw	r22, r24
  f2:	c7 01       	movw	r24, r14
  f4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

	if(driver->specific.softwarePWM.currentServo != driver->num_servos){
  f8:	9f 81       	ldd	r25, Y+7	; 0x07
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	98 17       	cp	r25, r24
  fe:	01 f0       	breq	.+0      	; 0x100 <__servoStartService+0x80>
		// do the next servo
		if(driver->specific.softwarePWM.currentServo > driver->num_servos){
 100:	89 17       	cp	r24, r25
 102:	00 f4       	brcc	.+0      	; 0x104 <__servoStartService+0x84>
			// restart from the beginning
			driver->specific.softwarePWM.currentServo = 0;
 104:	1f 82       	std	Y+7, r1	; 0x07
			driver->specific.softwarePWM.total_delay = 0;
 106:	19 86       	std	Y+9, r1	; 0x09
 108:	18 86       	std	Y+8, r1	; 0x08

		}

		// Locate the servo
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[driver->specific.softwarePWM.currentServo]);
 10a:	8f 81       	ldd	r24, Y+7	; 0x07
 10c:	28 81       	ld	r18, Y
 10e:	99 81       	ldd	r25, Y+1	; 0x01
 110:	e2 2f       	mov	r30, r18
 112:	f9 2f       	mov	r31, r25
 114:	e8 0f       	add	r30, r24
 116:	f1 1d       	adc	r31, r1
 118:	e8 0f       	add	r30, r24
 11a:	f1 1d       	adc	r31, r1
 11c:	85 91       	lpm	r24, Z+
 11e:	94 91       	lpm	r25, Z
 120:	8c 01       	movw	r16, r24
		delay = servo->delay;		// The pulse length to set

		uint16_t now = timerGetCounter(timer);
 122:	c6 01       	movw	r24, r12
 124:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 128:	6c 01       	movw	r12, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
 12a:	f8 01       	movw	r30, r16
 12c:	83 81       	ldd	r24, Z+3	; 0x03
 12e:	80 fd       	sbrc	r24, 0
 130:	00 c0       	rjmp	.+0      	; 0x132 <__servoStartService+0xb2>
			pin_high(servo->pin);
		}


		// Set time to turn pin low
		compareSetThreshold(turnOff,servo->delay + now);
 132:	f8 01       	movw	r30, r16
 134:	60 89       	ldd	r22, Z+16	; 0x10
 136:	71 89       	ldd	r23, Z+17	; 0x11
 138:	6c 0d       	add	r22, r12
 13a:	7d 1d       	adc	r23, r13
 13c:	c4 01       	movw	r24, r8
 13e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 142:	c4 01       	movw	r24, r8
 144:	08 96       	adiw	r24, 0x08	; 8
 146:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// enable channel that turns pulses off
		compareClearInterruptPending(turnOff);
		__portMaskSet(&turnOff->pgm_intenable);
 14a:	c5 01       	movw	r24, r10
 14c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Set the time to check the next servo
		compareSetThreshold(timer_compare,servo->max_ticks + now);
 150:	f8 01       	movw	r30, r16
 152:	66 85       	ldd	r22, Z+14	; 0x0e
 154:	77 85       	ldd	r23, Z+15	; 0x0f
 156:	6c 0d       	add	r22, r12
 158:	7d 1d       	adc	r23, r13
 15a:	c7 01       	movw	r24, r14
 15c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Accumulate total time in this pass of the servos
		driver->specific.softwarePWM.total_delay += servo->max_ticks;
 160:	88 85       	ldd	r24, Y+8	; 0x08
 162:	99 85       	ldd	r25, Y+9	; 0x09
 164:	f8 01       	movw	r30, r16
 166:	26 85       	ldd	r18, Z+14	; 0x0e
 168:	37 85       	ldd	r19, Z+15	; 0x0f
 16a:	82 0f       	add	r24, r18
 16c:	93 1f       	adc	r25, r19
 16e:	99 87       	std	Y+9, r25	; 0x09
 170:	88 87       	std	Y+8, r24	; 0x08
 172:	00 c0       	rjmp	.+0      	; 0x174 <__servoStartService+0xf4>

	}else{
		// disable channel that turns pulses off
		__portMaskClear(&turnOff->pgm_intenable);
 174:	c5 01       	movw	r24, r10
 176:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// pause before going back to the first servo
		delay = (driver->specific.softwarePWM.total_delay > driver->specific.softwarePWM.servo_cycle)
 17a:	88 85       	ldd	r24, Y+8	; 0x08
 17c:	99 85       	ldd	r25, Y+9	; 0x09
 17e:	0a 84       	ldd	r0, Y+10	; 0x0a
 180:	db 85       	ldd	r29, Y+11	; 0x0b
 182:	c0 2d       	mov	r28, r0
				? 100
				:  driver->specific.softwarePWM.servo_cycle - driver->specific.softwarePWM.total_delay;
 184:	c8 17       	cp	r28, r24
 186:	d9 07       	cpc	r29, r25
 188:	00 f0       	brcs	.+0      	; 0x18a <__servoStartService+0x10a>
 18a:	c8 1b       	sub	r28, r24
 18c:	d9 0b       	sbc	r29, r25
 18e:	00 c0       	rjmp	.+0      	; 0x190 <__servoStartService+0x110>
 190:	c4 e6       	ldi	r28, 0x64	; 100
 192:	d0 e0       	ldi	r29, 0x00	; 0

		// Re-fire the event
		compareSetThreshold(timer_compare,delay + compareGetThreshold(timer_compare));
 194:	c7 01       	movw	r24, r14
 196:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 19a:	bc 01       	movw	r22, r24
 19c:	6c 0f       	add	r22, r28
 19e:	7d 1f       	adc	r23, r29
 1a0:	c7 01       	movw	r24, r14
	}


}
 1a2:	df 91       	pop	r29
 1a4:	cf 91       	pop	r28
 1a6:	1f 91       	pop	r17
 1a8:	0f 91       	pop	r16
 1aa:	ff 90       	pop	r15
 1ac:	ef 90       	pop	r14
 1ae:	df 90       	pop	r13
 1b0:	cf 90       	pop	r12
 1b2:	bf 90       	pop	r11
 1b4:	af 90       	pop	r10
 1b6:	9f 90       	pop	r9
 1b8:	8f 90       	pop	r8
		delay = (driver->specific.softwarePWM.total_delay > driver->specific.softwarePWM.servo_cycle)
				? 100
				:  driver->specific.softwarePWM.servo_cycle - driver->specific.softwarePWM.total_delay;

		// Re-fire the event
		compareSetThreshold(timer_compare,delay + compareGetThreshold(timer_compare));
 1ba:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
		uint16_t now = timerGetCounter(timer);

		// ignore the servo if its not connected
		if(act_isConnected(servo)){
			// turn on servo channel bit
			pin_high(servo->pin);
 1be:	f8 01       	movw	r30, r16
 1c0:	86 81       	ldd	r24, Z+6	; 0x06
 1c2:	97 81       	ldd	r25, Z+7	; 0x07
 1c4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <__servoStartService+0x14a>
		// Re-fire the event
		compareSetThreshold(timer_compare,delay + compareGetThreshold(timer_compare));
	}


}
 1ca:	df 91       	pop	r29
 1cc:	cf 91       	pop	r28
 1ce:	1f 91       	pop	r17
 1d0:	0f 91       	pop	r16
 1d2:	ff 90       	pop	r15
 1d4:	ef 90       	pop	r14
 1d6:	df 90       	pop	r13
 1d8:	cf 90       	pop	r12
 1da:	bf 90       	pop	r11
 1dc:	af 90       	pop	r10
 1de:	9f 90       	pop	r9
 1e0:	8f 90       	pop	r8
 1e2:	08 95       	ret

000001e4 <servosInit>:

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 1e4:	2f 92       	push	r2
 1e6:	3f 92       	push	r3
 1e8:	4f 92       	push	r4
 1ea:	5f 92       	push	r5
 1ec:	6f 92       	push	r6
 1ee:	7f 92       	push	r7
 1f0:	8f 92       	push	r8
 1f2:	9f 92       	push	r9
 1f4:	af 92       	push	r10
 1f6:	bf 92       	push	r11
 1f8:	cf 92       	push	r12
 1fa:	df 92       	push	r13
 1fc:	ef 92       	push	r14
 1fe:	ff 92       	push	r15
 200:	0f 93       	push	r16
 202:	1f 93       	push	r17
 204:	cf 93       	push	r28
 206:	df 93       	push	r29
 208:	ec 01       	movw	r28, r24
 20a:	7b 01       	movw	r14, r22
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 20c:	fb 01       	movw	r30, r22
 20e:	77 96       	adiw	r30, 0x17	; 23
 210:	c5 90       	lpm	r12, Z+
 212:	d4 90       	lpm	r13, Z
 214:	5c 2c       	mov	r5, r12
 216:	4d 2c       	mov	r4, r13
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 218:	fb 01       	movw	r30, r22
 21a:	36 96       	adiw	r30, 0x06	; 6
 21c:	e4 91       	lpm	r30, Z
	const TimerCompare* channel1 = timerGetCompare(timer,CHANNEL_ON);
	const TimerCompare* channel2 = timerGetCompare(timer,CHANNEL_OFF);

	if(timerIs16bit(timer) && timerNumberOfCompareUnits(timer) >= 2){
 21e:	ee 23       	and	r30, r30
 220:	01 f4       	brne	.+0      	; 0x222 <servosInit+0x3e>
 222:	00 c0       	rjmp	.+0      	; 0x224 <servosInit+0x40>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
 224:	fb 01       	movw	r30, r22
 226:	38 96       	adiw	r30, 0x08	; 8
 228:	e4 91       	lpm	r30, Z
 22a:	e2 30       	cpi	r30, 0x02	; 2
 22c:	00 f4       	brcc	.+0      	; 0x22e <servosInit+0x4a>
 22e:	00 c0       	rjmp	.+0      	; 0x230 <servosInit+0x4c>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 230:	fb 01       	movw	r30, r22
 232:	34 96       	adiw	r30, 0x04	; 4
 234:	25 91       	lpm	r18, Z+
 236:	34 91       	lpm	r19, Z
 238:	f9 01       	movw	r30, r18
 23a:	80 81       	ld	r24, Z
 23c:	87 70       	andi	r24, 0x07	; 7
 23e:	01 f4       	brne	.+0      	; 0x240 <servosInit+0x5c>
 240:	00 c0       	rjmp	.+0      	; 0x242 <servosInit+0x5e>
 242:	00 c0       	rjmp	.+0      	; 0x244 <servosInit+0x60>

		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			prescale = timerGetPrescaler(timer);
			if(timerGetMode(timer) != TIMER_MODE_NORMAL){
				setError(PWM_TIMER_IN_USE);
 244:	82 ef       	ldi	r24, 0xF2	; 242
 246:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			}
		}else{
			prescale = timerGetBestPrescaler(timer, SERVO_CYCLE + 5 );
		}

		driver->specific.softwarePWM.currentServo = driver->num_servos;
 24a:	8a 81       	ldd	r24, Y+2	; 0x02
 24c:	8f 83       	std	Y+7, r24	; 0x07

		// Find how many timer ticks there will be for SERVO_CYCLE
		uint32_t tmp32 = ticks_per_ms(SERVO_CYCLE,prescale);
 24e:	a4 01       	movw	r20, r8
 250:	64 e1       	ldi	r22, 0x14	; 20
 252:	70 e0       	ldi	r23, 0x00	; 0
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		driver->specific.softwarePWM.servo_cycle = tmp32;
 25c:	7b 87       	std	Y+11, r23	; 0x0b
 25e:	6a 87       	std	Y+10, r22	; 0x0a
		// make sure it fits
		if( (tmp32 & 0xFFFF0000UL)!=0){
 260:	dc 01       	movw	r26, r24
 262:	cb 01       	movw	r24, r22
 264:	88 27       	eor	r24, r24
 266:	99 27       	eor	r25, r25
 268:	89 2b       	or	r24, r25
 26a:	8a 2b       	or	r24, r26
 26c:	8b 2b       	or	r24, r27
 26e:	01 f0       	breq	.+0      	; 0x270 <servosInit+0x8c>
			setError(SERVO_TIMING);
 270:	86 ee       	ldi	r24, 0xE6	; 230
 272:	00 c0       	rjmp	.+0      	; 0x274 <servosInit+0x90>
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 274:	2a 80       	ldd	r2, Y+2	; 0x02
 276:	61 2c       	mov	r6, r1
 278:	71 2c       	mov	r7, r1
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 27a:	31 2c       	mov	r3, r1
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 27c:	00 c0       	rjmp	.+0      	; 0x27e <servosInit+0x9a>
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 27e:	22 0f       	add	r18, r18
 280:	33 1f       	adc	r19, r19
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 282:	e8 81       	ld	r30, Y
 284:	f9 81       	ldd	r31, Y+1	; 0x01
 286:	e2 0f       	add	r30, r18
 288:	f3 1f       	adc	r31, r19
 28a:	a5 90       	lpm	r10, Z+
 28c:	b4 90       	lpm	r11, Z

			// Connect the servo to this driver
			servo->actuator.class = &c_Servos;
 28e:	80 e0       	ldi	r24, 0x00	; 0
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	f5 01       	movw	r30, r10
 294:	91 83       	std	Z+1, r25	; 0x01
 296:	80 83       	st	Z, r24
			servo->driver = driver;
 298:	d5 83       	std	Z+5, r29	; 0x05
 29a:	c4 83       	std	Z+4, r28	; 0x04
			servo->top = driver->specific.softwarePWM.servo_cycle;
 29c:	8a 85       	ldd	r24, Y+10	; 0x0a
 29e:	9b 85       	ldd	r25, Y+11	; 0x0b
 2a0:	93 8b       	std	Z+19, r25	; 0x13
 2a2:	82 8b       	std	Z+18, r24	; 0x12

			pin_make_output(servo->pin, FALSE);
 2a4:	60 e0       	ldi	r22, 0x00	; 0
 2a6:	86 81       	ldd	r24, Z+6	; 0x06
 2a8:	97 81       	ldd	r25, Z+7	; 0x07
 2aa:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			servoSetConfig(servo,servo->center_us,servo->range_us);
 2ae:	f5 01       	movw	r30, r10
 2b0:	42 85       	ldd	r20, Z+10	; 0x0a
 2b2:	53 85       	ldd	r21, Z+11	; 0x0b
 2b4:	60 85       	ldd	r22, Z+8	; 0x08
 2b6:	71 85       	ldd	r23, Z+9	; 0x09
 2b8:	c5 01       	movw	r24, r10
 2ba:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 2be:	6f ef       	ldi	r22, 0xFF	; 255
 2c0:	8a 2d       	mov	r24, r10
 2c2:	9b 2d       	mov	r25, r11
 2c4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 2c8:	60 e0       	ldi	r22, 0x00	; 0
 2ca:	8a 2d       	mov	r24, r10
 2cc:	9b 2d       	mov	r25, r11
 2ce:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2d2:	ff ef       	ldi	r31, 0xFF	; 255
 2d4:	6f 1a       	sub	r6, r31
 2d6:	7f 0a       	sbc	r7, r31
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 2d8:	91 01       	movw	r18, r2
 2da:	26 19       	sub	r18, r6
 2dc:	37 09       	sbc	r19, r7
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 2de:	2f 3f       	cpi	r18, 0xFF	; 255
 2e0:	8f ef       	ldi	r24, 0xFF	; 255
 2e2:	38 07       	cpc	r19, r24
 2e4:	01 f4       	brne	.+0      	; 0x2e6 <servosInit+0x102>
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}


		// Set the threshold to start interrupt chain
		if(getError()==0){
 2e6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2ea:	81 11       	cpse	r24, r1
 2ec:	00 c0       	rjmp	.+0      	; 0x2ee <servosInit+0x10a>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 2ee:	86 01       	movw	r16, r12
 2f0:	00 5f       	subi	r16, 0xF0	; 240
 2f2:	1f 4f       	sbci	r17, 0xFF	; 255
			CRITICAL_SECTION_START;
 2f4:	bf b6       	in	r11, 0x3f	; 63
 2f6:	f8 94       	cli

			compareAttach(channel1, &__servoStartService,  compareGetThreshold(channel1) + driver->specific.softwarePWM.servo_cycle, driver);
 2f8:	85 2d       	mov	r24, r5
 2fa:	94 2d       	mov	r25, r4
 2fc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 300:	4a 85       	ldd	r20, Y+10	; 0x0a
 302:	5b 85       	ldd	r21, Y+11	; 0x0b
 304:	48 0f       	add	r20, r24
 306:	59 1f       	adc	r21, r25
 308:	9e 01       	movw	r18, r28
 30a:	60 e0       	ldi	r22, 0x00	; 0
 30c:	70 e0       	ldi	r23, 0x00	; 0
 30e:	85 2d       	mov	r24, r5
 310:	94 2d       	mov	r25, r4
 312:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			compareAttach(channel2, &__servoEndService  ,  compareGetThreshold(channel2) + driver->specific.softwarePWM.servo_cycle, driver);
 316:	c8 01       	movw	r24, r16
 318:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 31c:	4a 85       	ldd	r20, Y+10	; 0x0a
 31e:	5b 85       	ldd	r21, Y+11	; 0x0b
 320:	48 0f       	add	r20, r24
 322:	59 1f       	adc	r21, r25
 324:	9e 01       	movw	r18, r28
 326:	60 e0       	ldi	r22, 0x00	; 0
 328:	70 e0       	ldi	r23, 0x00	; 0
 32a:	c8 01       	movw	r24, r16
 32c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			__portMaskClear(&channel2->pgm_intenable);		// disable channel2
 330:	c6 01       	movw	r24, r12
 332:	43 96       	adiw	r24, 0x13	; 19
 334:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescale);
 338:	b4 01       	movw	r22, r8
 33a:	c7 01       	movw	r24, r14
 33c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


			CRITICAL_SECTION_END;
 340:	bf be       	out	0x3f, r11	; 63
 342:	00 c0       	rjmp	.+0      	; 0x344 <servosInit+0x160>



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 344:	89 ef       	ldi	r24, 0xF9	; 249
	}

}
 346:	df 91       	pop	r29
 348:	cf 91       	pop	r28
 34a:	1f 91       	pop	r17
 34c:	0f 91       	pop	r16
 34e:	ff 90       	pop	r15
 350:	ef 90       	pop	r14
 352:	df 90       	pop	r13
 354:	cf 90       	pop	r12
 356:	bf 90       	pop	r11
 358:	af 90       	pop	r10
 35a:	9f 90       	pop	r9
 35c:	8f 90       	pop	r8
 35e:	7f 90       	pop	r7
 360:	6f 90       	pop	r6
 362:	5f 90       	pop	r5
 364:	4f 90       	pop	r4
 366:	3f 90       	pop	r3
 368:	2f 90       	pop	r2



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 36a:	0c 94 00 00 	jmp	0	; 0x0 <setSpeed>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 36e:	fb 01       	movw	r30, r22
 370:	a5 91       	lpm	r26, Z+
 372:	b4 91       	lpm	r27, Z
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
 374:	8d 90       	ld	r8, X+
 376:	9c 90       	ld	r9, X
 378:	11 97       	sbiw	r26, 0x01	; 1
		uint16_t prescale;

		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			prescale = timerGetPrescaler(timer);
			if(timerGetMode(timer) != TIMER_MODE_NORMAL){
 37a:	1a 96       	adiw	r26, 0x0a	; 10
 37c:	8c 91       	ld	r24, X
 37e:	88 23       	and	r24, r24
 380:	01 f4       	brne	.+0      	; 0x382 <servosInit+0x19e>
 382:	00 c0       	rjmp	.+0      	; 0x384 <servosInit+0x1a0>
 384:	00 c0       	rjmp	.+0      	; 0x386 <servosInit+0x1a2>
				setError(PWM_TIMER_IN_USE);
			}
		}else{
			prescale = timerGetBestPrescaler(timer, SERVO_CYCLE + 5 );
 386:	69 e1       	ldi	r22, 0x19	; 25
 388:	70 e0       	ldi	r23, 0x00	; 0
 38a:	c7 01       	movw	r24, r14
 38c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 390:	4c 01       	movw	r8, r24
 392:	00 c0       	rjmp	.+0      	; 0x394 <servosInit+0x1b0>
	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
	}

}
 394:	df 91       	pop	r29
 396:	cf 91       	pop	r28
 398:	1f 91       	pop	r17
 39a:	0f 91       	pop	r16
 39c:	ff 90       	pop	r15
 39e:	ef 90       	pop	r14
 3a0:	df 90       	pop	r13
 3a2:	cf 90       	pop	r12
 3a4:	bf 90       	pop	r11
 3a6:	af 90       	pop	r10
 3a8:	9f 90       	pop	r9
 3aa:	8f 90       	pop	r8
 3ac:	7f 90       	pop	r7
 3ae:	6f 90       	pop	r6
 3b0:	5f 90       	pop	r5
 3b2:	4f 90       	pop	r4
 3b4:	3f 90       	pop	r3
 3b6:	2f 90       	pop	r2
 3b8:	08 95       	ret

servosCenter.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000030a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  0000030a  2**0
                  ALLOC
  3 .progmem.data 000000cc  00000000  00000000  0000030a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000d8f  00000000  00000000  000003d6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000036f  00000000  00000000  00001165  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000667  00000000  00000000  000014d4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001b3b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00001b5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001a6  00000000  00000000  00001b73  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000578  00000000  00000000  00001d19  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00002291  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000168  00000000  00000000  000022bc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <list>:
		c = c - 'a' + 'A';
	}
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
   6:	ef 92       	push	r14
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	d8 2f       	mov	r29, r24
  14:	c9 2f       	mov	r28, r25
  16:	c6 2e       	mov	r12, r22
	rprintf("\nServo Center Range\n");
  18:	20 e0       	ldi	r18, 0x00	; 0
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3f 93       	push	r19
  1e:	2f 93       	push	r18
  20:	81 e0       	ldi	r24, 0x01	; 1
  22:	8f 93       	push	r24
  24:	0e 94 00 00 	call	0	; 0x0 <list>
  28:	0d 2f       	mov	r16, r29
  2a:	1c 2f       	mov	r17, r28
	for(int i=0; i<numServos; i++){
  2c:	0f 90       	pop	r0
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	c0 e0       	ldi	r28, 0x00	; 0
  34:	d0 e0       	ldi	r29, 0x00	; 0
  36:	d1 2c       	mov	r13, r1
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
  38:	80 e0       	ldi	r24, 0x00	; 0
  3a:	e8 2e       	mov	r14, r24
  3c:	80 e0       	ldi	r24, 0x00	; 0
  3e:	f8 2e       	mov	r15, r24
  40:	bb 24       	eor	r11, r11
  42:	b3 94       	inc	r11
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
	rprintf("\nServo Center Range\n");
	for(int i=0; i<numServos; i++){
  44:	00 c0       	rjmp	.+0      	; 0x46 <list+0x46>
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
  46:	f8 01       	movw	r30, r16
  48:	85 91       	lpm	r24, Z+
  4a:	94 91       	lpm	r25, Z
  4c:	fc 01       	movw	r30, r24
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
  4e:	83 85       	ldd	r24, Z+11	; 0x0b
  50:	8f 93       	push	r24
  52:	82 85       	ldd	r24, Z+10	; 0x0a
  54:	8f 93       	push	r24
  56:	81 85       	ldd	r24, Z+9	; 0x09
  58:	8f 93       	push	r24
  5a:	80 85       	ldd	r24, Z+8	; 0x08
  5c:	8f 93       	push	r24
  5e:	df 93       	push	r29
  60:	cf 93       	push	r28
  62:	ff 92       	push	r15
  64:	ef 92       	push	r14
  66:	bf 92       	push	r11
  68:	0e 94 00 00 	call	0	; 0x0 <list>
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
	rprintf("\nServo Center Range\n");
	for(int i=0; i<numServos; i++){
  6c:	21 96       	adiw	r28, 0x01	; 1
  6e:	0e 5f       	subi	r16, 0xFE	; 254
  70:	1f 4f       	sbci	r17, 0xFF	; 255
  72:	8d b7       	in	r24, 0x3d	; 61
  74:	9e b7       	in	r25, 0x3e	; 62
  76:	09 96       	adiw	r24, 0x09	; 9
  78:	0f b6       	in	r0, 0x3f	; 63
  7a:	f8 94       	cli
  7c:	9e bf       	out	0x3e, r25	; 62
  7e:	0f be       	out	0x3f, r0	; 63
  80:	8d bf       	out	0x3d, r24	; 61
  82:	cc 15       	cp	r28, r12
  84:	dd 05       	cpc	r29, r13
  86:	04 f0       	brlt	.+0      	; 0x88 <list+0x88>
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
	}
}
  88:	df 91       	pop	r29
  8a:	cf 91       	pop	r28
  8c:	1f 91       	pop	r17
  8e:	0f 91       	pop	r16
  90:	ff 90       	pop	r15
  92:	ef 90       	pop	r14
  94:	df 90       	pop	r13
  96:	cf 90       	pop	r12
  98:	bf 90       	pop	r11
  9a:	08 95       	ret

0000009c <update>:

static void update(SERVO_LIST* const servos, int diff){
	SERVO* servo = (SERVO*)pgm_read_word(&servos[current]);
  9c:	20 91 00 00 	lds	r18, 0x0000
  a0:	82 0f       	add	r24, r18
  a2:	91 1d       	adc	r25, r1
  a4:	82 0f       	add	r24, r18
  a6:	91 1d       	adc	r25, r1
  a8:	fc 01       	movw	r30, r24
  aa:	25 91       	lpm	r18, Z+
  ac:	34 91       	lpm	r19, Z
  ae:	c9 01       	movw	r24, r18
	uint16_t c = servo->center_us;
  b0:	f9 01       	movw	r30, r18
  b2:	20 85       	ldd	r18, Z+8	; 0x08
  b4:	31 85       	ldd	r19, Z+9	; 0x09
	uint16_t r = servo->range_us;
  b6:	42 85       	ldd	r20, Z+10	; 0x0a
  b8:	53 85       	ldd	r21, Z+11	; 0x0b

	if(ranging){
  ba:	e0 91 00 00 	lds	r30, 0x0000
  be:	ee 23       	and	r30, r30
  c0:	01 f0       	breq	.+0      	; 0xc2 <update+0x26>
		r += diff;
  c2:	46 0f       	add	r20, r22
  c4:	57 1f       	adc	r21, r23
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <update+0x2c>
	}else{
		c += diff;
  c8:	26 0f       	add	r18, r22
  ca:	37 1f       	adc	r19, r23
	}

	servoSetConfig(servo,c,r);
  cc:	b9 01       	movw	r22, r18
  ce:	0c 94 00 00 	jmp	0	; 0x0 <list>

000000d2 <setRanging>:
}

static void setRanging( boolean r, SERVO_LIST* const servos, uint8_t numServos){
  d2:	df 92       	push	r13
  d4:	ef 92       	push	r14
  d6:	ff 92       	push	r15
  d8:	0f 93       	push	r16
  da:	1f 93       	push	r17
  dc:	cf 93       	push	r28
  de:	df 93       	push	r29
	if(ranging != r){
  e0:	90 91 00 00 	lds	r25, 0x0000
  e4:	98 17       	cp	r25, r24
  e6:	01 f0       	breq	.+0      	; 0xe8 <setRanging+0x16>
		ranging = r;
  e8:	80 93 00 00 	sts	0x0000, r24
		DRIVE_SPEED speed = (ranging) ? DRIVE_SPEED_MAX : DRIVE_SPEED_BRAKE;
  ec:	88 23       	and	r24, r24
  ee:	01 f0       	breq	.+0      	; 0xf0 <setRanging+0x1e>
  f0:	9f e7       	ldi	r25, 0x7F	; 127
  f2:	d9 2e       	mov	r13, r25
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <setRanging+0x24>
  f6:	d1 2c       	mov	r13, r1
  f8:	eb 01       	movw	r28, r22
		for(int i=0; i<numServos; i++){
  fa:	00 e0       	ldi	r16, 0x00	; 0
  fc:	10 e0       	ldi	r17, 0x00	; 0
  fe:	e4 2e       	mov	r14, r20
 100:	f1 2c       	mov	r15, r1
 102:	00 c0       	rjmp	.+0      	; 0x104 <setRanging+0x32>
			SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
 104:	fe 01       	movw	r30, r28
 106:	25 91       	lpm	r18, Z+
 108:	34 91       	lpm	r19, Z
			act_setSpeed(servo,speed);
 10a:	6d 2d       	mov	r22, r13
 10c:	c9 01       	movw	r24, r18
 10e:	0e 94 00 00 	call	0	; 0x0 <list>

static void setRanging( boolean r, SERVO_LIST* const servos, uint8_t numServos){
	if(ranging != r){
		ranging = r;
		DRIVE_SPEED speed = (ranging) ? DRIVE_SPEED_MAX : DRIVE_SPEED_BRAKE;
		for(int i=0; i<numServos; i++){
 112:	0f 5f       	subi	r16, 0xFF	; 255
 114:	1f 4f       	sbci	r17, 0xFF	; 255
 116:	22 96       	adiw	r28, 0x02	; 2
 118:	0e 15       	cp	r16, r14
 11a:	1f 05       	cpc	r17, r15
 11c:	04 f0       	brlt	.+0      	; 0x11e <setRanging+0x4c>
			SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
			act_setSpeed(servo,speed);
		}
	}
}
 11e:	df 91       	pop	r29
 120:	cf 91       	pop	r28
 122:	1f 91       	pop	r17
 124:	0f 91       	pop	r16
 126:	ff 90       	pop	r15
 128:	ef 90       	pop	r14
 12a:	df 90       	pop	r13
 12c:	08 95       	ret

0000012e <help>:


static uint8_t current;
static boolean ranging;

static void help(void){
 12e:	cf 93       	push	r28
	rprintf("\nL = List");
 130:	80 e0       	ldi	r24, 0x00	; 0
 132:	90 e0       	ldi	r25, 0x00	; 0
 134:	9f 93       	push	r25
 136:	8f 93       	push	r24
 138:	c1 e0       	ldi	r28, 0x01	; 1
 13a:	cf 93       	push	r28
 13c:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n+ = Increment");
 140:	80 e0       	ldi	r24, 0x00	; 0
 142:	90 e0       	ldi	r25, 0x00	; 0
 144:	9f 93       	push	r25
 146:	8f 93       	push	r24
 148:	cf 93       	push	r28
 14a:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n- = Decrement");
 14e:	80 e0       	ldi	r24, 0x00	; 0
 150:	90 e0       	ldi	r25, 0x00	; 0
 152:	9f 93       	push	r25
 154:	8f 93       	push	r24
 156:	cf 93       	push	r28
 158:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n* = Add 10");
 15c:	80 e0       	ldi	r24, 0x00	; 0
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	9f 93       	push	r25
 162:	8f 93       	push	r24
 164:	cf 93       	push	r28
 166:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n/ = Sub 10");
 16a:	80 e0       	ldi	r24, 0x00	; 0
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	9f 93       	push	r25
 170:	8f 93       	push	r24
 172:	cf 93       	push	r28
 174:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nN = Next Servo");
 178:	80 e0       	ldi	r24, 0x00	; 0
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	9f 93       	push	r25
 17e:	8f 93       	push	r24
 180:	cf 93       	push	r28
 182:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nP = Previous Servo");
 186:	80 e0       	ldi	r24, 0x00	; 0
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	9f 93       	push	r25
 18c:	8f 93       	push	r24
 18e:	cf 93       	push	r28
 190:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nC = Center mode");
 194:	80 e0       	ldi	r24, 0x00	; 0
 196:	90 e0       	ldi	r25, 0x00	; 0
 198:	9f 93       	push	r25
 19a:	8f 93       	push	r24
 19c:	cf 93       	push	r28
 19e:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nR = Range mode");
 1a2:	80 e0       	ldi	r24, 0x00	; 0
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	9f 93       	push	r25
 1a8:	8f 93       	push	r24
 1aa:	cf 93       	push	r28
 1ac:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintfCRLF();
 1b0:	8d b7       	in	r24, 0x3d	; 61
 1b2:	9e b7       	in	r25, 0x3e	; 62
 1b4:	4b 96       	adiw	r24, 0x1b	; 27
 1b6:	0f b6       	in	r0, 0x3f	; 63
 1b8:	f8 94       	cli
 1ba:	9e bf       	out	0x3e, r25	; 62
 1bc:	0f be       	out	0x3f, r0	; 63
 1be:	8d bf       	out	0x3d, r24	; 61
}
 1c0:	cf 91       	pop	r28
	rprintf("\n/ = Sub 10");
	rprintf("\nN = Next Servo");
	rprintf("\nP = Previous Servo");
	rprintf("\nC = Center mode");
	rprintf("\nR = Range mode");
	rprintfCRLF();
 1c2:	0c 94 00 00 	jmp	0	; 0x0 <list>

000001c6 <prompt>:
}

static void prompt(void){
	if(ranging){
 1c6:	90 91 00 00 	lds	r25, 0x0000
 1ca:	80 91 00 00 	lds	r24, 0x0000
 1ce:	99 23       	and	r25, r25
 1d0:	01 f0       	breq	.+0      	; 0x1d2 <prompt+0xc>
		rprintf("\nRange Servo %d>",current);
 1d2:	1f 92       	push	r1
 1d4:	8f 93       	push	r24
 1d6:	80 e0       	ldi	r24, 0x00	; 0
 1d8:	90 e0       	ldi	r25, 0x00	; 0
 1da:	00 c0       	rjmp	.+0      	; 0x1dc <prompt+0x16>
	}else{
		rprintf("\nCenter Servo %d>",current);
 1dc:	1f 92       	push	r1
 1de:	8f 93       	push	r24
 1e0:	80 e0       	ldi	r24, 0x00	; 0
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	9f 93       	push	r25
 1e6:	8f 93       	push	r24
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	8f 93       	push	r24
 1ec:	0e 94 00 00 	call	0	; 0x0 <list>
 1f0:	0f 90       	pop	r0
 1f2:	0f 90       	pop	r0
 1f4:	0f 90       	pop	r0
 1f6:	0f 90       	pop	r0
 1f8:	0f 90       	pop	r0
 1fa:	08 95       	ret

000001fc <_servosCenter>:
		}
	}
}


void _servosCenter(SERVO_LIST* const servos, uint8_t numServos, UART* uart){
 1fc:	ec 01       	movw	r28, r24
 1fe:	f6 2e       	mov	r15, r22
 200:	8a 01       	movw	r16, r20
	rprintfInit(uart->writer);
 202:	fa 01       	movw	r30, r20
 204:	83 89       	ldd	r24, Z+19	; 0x13
 206:	94 89       	ldd	r25, Z+20	; 0x14
 208:	0e 94 00 00 	call	0	; 0x0 <list>

	list(servos,numServos);
 20c:	6f 2d       	mov	r22, r15
 20e:	ce 01       	movw	r24, r28
 210:	0e 94 00 00 	call	0	; 0x0 <list>
	help();
 214:	0e 94 00 00 	call	0	; 0x0 <list>
	prompt();
 218:	0e 94 00 00 	call	0	; 0x0 <list>
		case 'N':
			current = (current+1) % numServos;
			prompt();
			break;
		case 'P':
			current = (current==0) ? numServos-1 : current-1;
 21c:	ef 2c       	mov	r14, r15
 21e:	ea 94       	dec	r14
			break;
		case '/':
			update(servos,-10);
			break;
		case 'N':
			current = (current+1) % numServos;
 220:	df 2c       	mov	r13, r15
 222:	c1 2c       	mov	r12, r1
}

static char getCh(UART* uart){
	int val;
	do{
		val = __uartGetByte(uart);
 224:	c8 01       	movw	r24, r16
 226:	0e 94 00 00 	call	0	; 0x0 <list>
	}while(val==-1);
 22a:	8f 3f       	cpi	r24, 0xFF	; 255
 22c:	ff ef       	ldi	r31, 0xFF	; 255
 22e:	9f 07       	cpc	r25, r31
 230:	01 f0       	breq	.+0      	; 0x232 <_servosCenter+0x36>
	char c = val;
	if(c>='a' && c<='z'){
 232:	98 2f       	mov	r25, r24
 234:	91 56       	subi	r25, 0x61	; 97
 236:	9a 31       	cpi	r25, 0x1A	; 26
 238:	00 f4       	brcc	.+0      	; 0x23a <_servosCenter+0x3e>
		c = c - 'a' + 'A';
 23a:	80 52       	subi	r24, 0x20	; 32
	list(servos,numServos);
	help();
	prompt();
	while(1){
		char c = getCh(uart);
		switch(c){
 23c:	8c 34       	cpi	r24, 0x4C	; 76
 23e:	01 f0       	breq	.+0      	; 0x240 <_servosCenter+0x44>
 240:	00 f4       	brcc	.+0      	; 0x242 <_servosCenter+0x46>
 242:	8d 32       	cpi	r24, 0x2D	; 45
 244:	01 f0       	breq	.+0      	; 0x246 <_servosCenter+0x4a>
 246:	00 f4       	brcc	.+0      	; 0x248 <_servosCenter+0x4c>
 248:	8a 32       	cpi	r24, 0x2A	; 42
 24a:	01 f0       	breq	.+0      	; 0x24c <_servosCenter+0x50>
 24c:	8b 32       	cpi	r24, 0x2B	; 43
 24e:	01 f4       	brne	.+0      	; 0x250 <_servosCenter+0x54>
 250:	00 c0       	rjmp	.+0      	; 0x252 <_servosCenter+0x56>
 252:	8f 32       	cpi	r24, 0x2F	; 47
 254:	01 f0       	breq	.+0      	; 0x256 <_servosCenter+0x5a>
 256:	83 34       	cpi	r24, 0x43	; 67
 258:	01 f4       	brne	.+0      	; 0x25a <_servosCenter+0x5e>
 25a:	00 c0       	rjmp	.+0      	; 0x25c <_servosCenter+0x60>
 25c:	80 35       	cpi	r24, 0x50	; 80
 25e:	01 f0       	breq	.+0      	; 0x260 <_servosCenter+0x64>
 260:	82 35       	cpi	r24, 0x52	; 82
 262:	01 f0       	breq	.+0      	; 0x264 <_servosCenter+0x68>
 264:	8e 34       	cpi	r24, 0x4E	; 78
 266:	01 f4       	brne	.+0      	; 0x268 <_servosCenter+0x6c>
 268:	00 c0       	rjmp	.+0      	; 0x26a <_servosCenter+0x6e>
		case 'L':
			list(servos,numServos);
 26a:	6f 2d       	mov	r22, r15
 26c:	ce 01       	movw	r24, r28
 26e:	0e 94 00 00 	call	0	; 0x0 <list>
 272:	00 c0       	rjmp	.+0      	; 0x274 <_servosCenter+0x78>
			prompt();
			break;
		case '+':
			update(servos,1);
 274:	61 e0       	ldi	r22, 0x01	; 1
 276:	70 e0       	ldi	r23, 0x00	; 0
 278:	00 c0       	rjmp	.+0      	; 0x27a <_servosCenter+0x7e>
			break;
		case '*':
			update(servos,10);
 27a:	6a e0       	ldi	r22, 0x0A	; 10
 27c:	70 e0       	ldi	r23, 0x00	; 0
 27e:	00 c0       	rjmp	.+0      	; 0x280 <_servosCenter+0x84>
			break;
		case '-':
			update(servos,-1);
 280:	6f ef       	ldi	r22, 0xFF	; 255
 282:	7f ef       	ldi	r23, 0xFF	; 255
 284:	00 c0       	rjmp	.+0      	; 0x286 <_servosCenter+0x8a>
			break;
		case '/':
			update(servos,-10);
 286:	66 ef       	ldi	r22, 0xF6	; 246
 288:	7f ef       	ldi	r23, 0xFF	; 255
 28a:	ce 01       	movw	r24, r28
 28c:	0e 94 00 00 	call	0	; 0x0 <list>
			break;
 290:	00 c0       	rjmp	.+0      	; 0x292 <_servosCenter+0x96>
		case 'N':
			current = (current+1) % numServos;
 292:	80 91 00 00 	lds	r24, 0x0000
 296:	90 e0       	ldi	r25, 0x00	; 0
 298:	01 96       	adiw	r24, 0x01	; 1
 29a:	6d 2d       	mov	r22, r13
 29c:	7c 2d       	mov	r23, r12
 29e:	0e 94 00 00 	call	0	; 0x0 <list>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <_servosCenter+0xa8>
			prompt();
			break;
		case 'P':
			current = (current==0) ? numServos-1 : current-1;
 2a4:	80 91 00 00 	lds	r24, 0x0000
 2a8:	81 11       	cpse	r24, r1
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <_servosCenter+0xb0>
 2ac:	8e 2d       	mov	r24, r14
 2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <_servosCenter+0xb4>
 2b0:	81 50       	subi	r24, 0x01	; 1
 2b2:	80 93 00 00 	sts	0x0000, r24
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <_servosCenter+0xbc>
			prompt();
			break;
		case 'C':
			setRanging(FALSE, servos,numServos);
 2b8:	4f 2d       	mov	r20, r15
 2ba:	be 01       	movw	r22, r28
 2bc:	80 e0       	ldi	r24, 0x00	; 0
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <_servosCenter+0xc4>
			prompt();
			break;
		case 'R':
			setRanging(TRUE, servos,numServos);
 2c0:	4f 2d       	mov	r20, r15
 2c2:	be 01       	movw	r22, r28
 2c4:	8f ef       	ldi	r24, 0xFF	; 255
 2c6:	0e 94 00 00 	call	0	; 0x0 <list>
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <_servosCenter+0xd0>
			prompt();
			break;
		default:
			help();
 2cc:	0e 94 00 00 	call	0	; 0x0 <list>
			prompt();
 2d0:	0e 94 00 00 	call	0	; 0x0 <list>
			break;
 2d4:	00 c0       	rjmp	.+0      	; 0x2d6 <_servosCenter+0xda>

servosConfig.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ee  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000122  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000122  2**0
                  ALLOC
  3 .debug_info   00000a1e  00000000  00000000  00000122  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000230  00000000  00000000  00000b40  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000003a0  00000000  00000000  00000d70  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001110  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000013b  00000000  00000000  00001130  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004f9  00000000  00000000  0000126b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  00001764  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000068  00000000  00000000  00001790  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servoSetConfig>:
 *      Author: Clive Webster
 *
 * Change the config settings for a given servo
 */
#include "servos.h"
void servoSetConfig(SERVO* servo, uint16_t center, uint16_t range){
   0:	6f 92       	push	r6
   2:	7f 92       	push	r7
   4:	8f 92       	push	r8
   6:	9f 92       	push	r9
   8:	af 92       	push	r10
   a:	bf 92       	push	r11
   c:	cf 92       	push	r12
   e:	df 92       	push	r13
  10:	ef 92       	push	r14
  12:	ff 92       	push	r15
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	ec 01       	movw	r28, r24
  1c:	5b 01       	movw	r10, r22
  1e:	4a 01       	movw	r8, r20
	servo->center_us = center;						// Set the new center value
  20:	79 87       	std	Y+9, r23	; 0x09
  22:	68 87       	std	Y+8, r22	; 0x08
	servo->range_us = range;						// Set the new range value
  24:	5b 87       	std	Y+11, r21	; 0x0b
  26:	4a 87       	std	Y+10, r20	; 0x0a

	SERVO_DRIVER* driver = servo->driver;			// Get the current driver
	if(driver){
  28:	8c 81       	ldd	r24, Y+4	; 0x04
  2a:	9d 81       	ldd	r25, Y+5	; 0x05
  2c:	89 2b       	or	r24, r25
  2e:	01 f4       	brne	.+0      	; 0x30 <servoSetConfig+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <servoSetConfig+0x32>
		// The servo is 'live'
		CRITICAL_SECTION_START;
  32:	1f b7       	in	r17, 0x3f	; 63
  34:	f8 94       	cli

		// Take the useable servo range and calculate the min/max pulses
		// (SERVO_CYCLE*1000) = servo_cycle
		//        min			    x
		// x = (min * g_servo_cycle)/(SERVO_CYCLE*1000)
		uint32_t min = center - range;
  36:	9b 01       	movw	r18, r22
  38:	24 1b       	sub	r18, r20
  3a:	35 0b       	sbc	r19, r21
		uint32_t m1 =  servo->top / 1000;
  3c:	8a 89       	ldd	r24, Y+18	; 0x12
  3e:	9b 89       	ldd	r25, Y+19	; 0x13
  40:	68 ee       	ldi	r22, 0xE8	; 232
  42:	73 e0       	ldi	r23, 0x03	; 3
  44:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
  48:	3b 01       	movw	r6, r22
		uint32_t m2 =  m1 * min;
  4a:	db 01       	movw	r26, r22
  4c:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		uint32_t m3 =  m2 / SERVO_CYCLE;
  50:	24 e1       	ldi	r18, 0x14	; 20
  52:	30 e0       	ldi	r19, 0x00	; 0
  54:	40 e0       	ldi	r20, 0x00	; 0
  56:	50 e0       	ldi	r21, 0x00	; 0
  58:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		if( (m3 & 0xFFFF0000UL)!=0){
  5c:	69 01       	movw	r12, r18
  5e:	7a 01       	movw	r14, r20
  60:	cc 24       	eor	r12, r12
  62:	dd 24       	eor	r13, r13
  64:	cd 28       	or	r12, r13
  66:	ce 28       	or	r12, r14
  68:	cf 28       	or	r12, r15
  6a:	01 f0       	breq	.+0      	; 0x6c <servoSetConfig+0x6c>
			// doesn't fit
			setError(SERVO_TIMING);
  6c:	86 ee       	ldi	r24, 0xE6	; 230
  6e:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
			m3 = 0xFFFFUL;
  72:	2f ef       	ldi	r18, 0xFF	; 255
  74:	3f ef       	ldi	r19, 0xFF	; 255
  76:	40 e0       	ldi	r20, 0x00	; 0
  78:	50 e0       	ldi	r21, 0x00	; 0
		}
		servo->min_ticks = m3;
  7a:	3d 87       	std	Y+13, r19	; 0x0d
  7c:	2c 87       	std	Y+12, r18	; 0x0c

		uint32_t max = center + range;
  7e:	94 01       	movw	r18, r8
  80:	2a 0d       	add	r18, r10
  82:	3b 1d       	adc	r19, r11
		m2 =  m1 * max;
  84:	d3 01       	movw	r26, r6
  86:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		m3 =  m2 / SERVO_CYCLE;
  8a:	24 e1       	ldi	r18, 0x14	; 20
  8c:	30 e0       	ldi	r19, 0x00	; 0
  8e:	40 e0       	ldi	r20, 0x00	; 0
  90:	50 e0       	ldi	r21, 0x00	; 0
  92:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		if( (m3 & 0xFFFF0000UL)!=0){
  96:	69 01       	movw	r12, r18
  98:	7a 01       	movw	r14, r20
  9a:	cc 24       	eor	r12, r12
  9c:	dd 24       	eor	r13, r13
  9e:	cd 28       	or	r12, r13
  a0:	ce 28       	or	r12, r14
  a2:	cf 28       	or	r12, r15
  a4:	01 f0       	breq	.+0      	; 0xa6 <servoSetConfig+0xa6>
			// doesn't fit
			setError(SERVO_TIMING);
  a6:	86 ee       	ldi	r24, 0xE6	; 230
  a8:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
			m3 = 0xFFFFUL;
  ac:	2f ef       	ldi	r18, 0xFF	; 255
  ae:	3f ef       	ldi	r19, 0xFF	; 255
  b0:	40 e0       	ldi	r20, 0x00	; 0
  b2:	50 e0       	ldi	r21, 0x00	; 0
		}
		servo->max_ticks = m3;
  b4:	3f 87       	std	Y+15, r19	; 0x0f
  b6:	2e 87       	std	Y+14, r18	; 0x0e
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  b8:	8b 81       	ldd	r24, Y+3	; 0x03
  ba:	80 fd       	sbrc	r24, 0
  bc:	00 c0       	rjmp	.+0      	; 0xbe <servoSetConfig+0xbe>
		if(act_isConnected(servo)){
			DRIVE_SPEED speed = servo->actuator.required_speed;
			servo->actuator.required_speed-=1;
			act_setSpeed(servo,speed);
		}
		CRITICAL_SECTION_END;
  be:	1f bf       	out	0x3f, r17	; 63
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <servoSetConfig+0xc2>
		}
		servo->max_ticks = m3;

		// Set the speed again
		if(act_isConnected(servo)){
			DRIVE_SPEED speed = servo->actuator.required_speed;
  c2:	6a 81       	ldd	r22, Y+2	; 0x02
			servo->actuator.required_speed-=1;
  c4:	86 2f       	mov	r24, r22
  c6:	81 50       	subi	r24, 0x01	; 1
  c8:	8a 83       	std	Y+2, r24	; 0x02
			act_setSpeed(servo,speed);
  ca:	ce 01       	movw	r24, r28
  cc:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <servoSetConfig+0xd2>
		}
		CRITICAL_SECTION_END;
	}
}
  d2:	df 91       	pop	r29
  d4:	cf 91       	pop	r28
  d6:	1f 91       	pop	r17
  d8:	ff 90       	pop	r15
  da:	ef 90       	pop	r14
  dc:	df 90       	pop	r13
  de:	cf 90       	pop	r12
  e0:	bf 90       	pop	r11
  e2:	af 90       	pop	r10
  e4:	9f 90       	pop	r9
  e6:	8f 90       	pop	r8
  e8:	7f 90       	pop	r7
  ea:	6f 90       	pop	r6
  ec:	08 95       	ret

servosConnect.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000005a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000008e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000008e  2**0
                  ALLOC
  3 .debug_info   00000949  00000000  00000000  0000008e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001ea  00000000  00000000  000009d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000012d  00000000  00000000  00000bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000cee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000d0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000012c  00000000  00000000  00000d26  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004e3  00000000  00000000  00000e52  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001335  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000048  00000000  00000000  00001360  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servosSetConnected>:
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	8c 01       	movw	r16, r24
  10:	d6 2e       	mov	r13, r22
	for(int i=driver->num_servos - 1; i >= 0; i--){
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	ec 90       	ld	r14, X
  18:	c0 e0       	ldi	r28, 0x00	; 0
  1a:	d0 e0       	ldi	r29, 0x00	; 0
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  1c:	f1 2c       	mov	r15, r1
	for(int i=driver->num_servos - 1; i >= 0; i--){
  1e:	00 c0       	rjmp	.+0      	; 0x20 <servosSetConnected+0x20>
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  20:	88 0f       	add	r24, r24
  22:	99 1f       	adc	r25, r25
	for(int i=driver->num_servos - 1; i >= 0; i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  24:	d8 01       	movw	r26, r16
  26:	ed 91       	ld	r30, X+
  28:	fc 91       	ld	r31, X
  2a:	e8 0f       	add	r30, r24
  2c:	f9 1f       	adc	r31, r25
  2e:	25 91       	lpm	r18, Z+
  30:	34 91       	lpm	r19, Z
		act_setConnected(servo, connect);
  32:	6d 2d       	mov	r22, r13
  34:	c9 01       	movw	r24, r18
  36:	0e 94 00 00 	call	0	; 0x0 <servosSetConnected>
  3a:	21 96       	adiw	r28, 0x01	; 1
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  3c:	c7 01       	movw	r24, r14
  3e:	8c 1b       	sub	r24, r28
  40:	9d 0b       	sbc	r25, r29
	for(int i=driver->num_servos - 1; i >= 0; i--){
  42:	8f 3f       	cpi	r24, 0xFF	; 255
  44:	bf ef       	ldi	r27, 0xFF	; 255
  46:	9b 07       	cpc	r25, r27
  48:	01 f4       	brne	.+0      	; 0x4a <servosSetConnected+0x4a>
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		act_setConnected(servo, connect);
	}
}
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	df 90       	pop	r13
  58:	08 95       	ret

servosSpeed.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000005a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000008e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000008e  2**0
                  ALLOC
  3 .debug_info   00000949  00000000  00000000  0000008e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001ea  00000000  00000000  000009d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000012d  00000000  00000000  00000bc1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000cee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000d0e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000012a  00000000  00000000  00000d26  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004d1  00000000  00000000  00000e50  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001321  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000048  00000000  00000000  0000134c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servosSetSpeed>:
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	8c 01       	movw	r16, r24
  10:	d6 2e       	mov	r13, r22
	for(int i=driver->num_servos - 1; i >= 0; i--){
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	ec 90       	ld	r14, X
  18:	c0 e0       	ldi	r28, 0x00	; 0
  1a:	d0 e0       	ldi	r29, 0x00	; 0
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  1c:	f1 2c       	mov	r15, r1
	for(int i=driver->num_servos - 1; i >= 0; i--){
  1e:	00 c0       	rjmp	.+0      	; 0x20 <servosSetSpeed+0x20>
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  20:	88 0f       	add	r24, r24
  22:	99 1f       	adc	r25, r25
	for(int i=driver->num_servos - 1; i >= 0; i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  24:	d8 01       	movw	r26, r16
  26:	ed 91       	ld	r30, X+
  28:	fc 91       	ld	r31, X
  2a:	e8 0f       	add	r30, r24
  2c:	f9 1f       	adc	r31, r25
  2e:	25 91       	lpm	r18, Z+
  30:	34 91       	lpm	r19, Z
		act_setSpeed(servo, speed);
  32:	6d 2d       	mov	r22, r13
  34:	c9 01       	movw	r24, r18
  36:	0e 94 00 00 	call	0	; 0x0 <servosSetSpeed>
  3a:	21 96       	adiw	r28, 0x01	; 1
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  3c:	c7 01       	movw	r24, r14
  3e:	8c 1b       	sub	r24, r28
  40:	9d 0b       	sbc	r25, r29
	for(int i=driver->num_servos - 1; i >= 0; i--){
  42:	8f 3f       	cpi	r24, 0xFF	; 255
  44:	bf ef       	ldi	r27, 0xFF	; 255
  46:	9b 07       	cpc	r25, r27
  48:	01 f4       	brne	.+0      	; 0x4a <servosSetSpeed+0x4a>
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		act_setSpeed(servo, speed);
	}
}
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	df 90       	pop	r13
  58:	08 95       	ret

spi.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000118  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  0000014c  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  0000015e  2**0
                  ALLOC
  3 .debug_info   000006b0  00000000  00000000  0000015e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000026b  00000000  00000000  0000080e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001fd  00000000  00000000  00000a79  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000c76  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000c96  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000010d  00000000  00000000  00000cae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000035e  00000000  00000000  00000dbb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001119  2**0
                  CONTENTS, READONLY
 11 .debug_frame  00000094  00000000  00000000  00001144  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiHWOff>:
    CRITICAL_SECTION_END;
}

// Turn off the SPI hardware
static void __spiHWOff(SPI_ABSTRACT_BUS* spi){
	SPCR &= ~(1<<SPE);
   0:	8c b5       	in	r24, 0x2c	; 44
   2:	8f 7b       	andi	r24, 0xBF	; 191
   4:	8c bd       	out	0x2c, r24	; 44
   6:	08 95       	ret

00000008 <__spiHWSetClock>:
		break;
	}
}

static void __spiHWSetClock(SPI_ABSTRACT_BUS* spi, SPI_CLOCK clock){
	cbi(SPCR,SPR1);
   8:	8c b5       	in	r24, 0x2c	; 44
   a:	8d 7f       	andi	r24, 0xFD	; 253
   c:	8c bd       	out	0x2c, r24	; 44
	cbi(SPCR,SPR0);
   e:	8c b5       	in	r24, 0x2c	; 44
  10:	8e 7f       	andi	r24, 0xFE	; 254
  12:	8c bd       	out	0x2c, r24	; 44
#ifdef SPI2X
	cbi(SPSR,SPI2X);
  14:	8d b5       	in	r24, 0x2d	; 45
  16:	8e 7f       	andi	r24, 0xFE	; 254
  18:	8d bd       	out	0x2d, r24	; 45
#endif
	switch(clock){
  1a:	60 31       	cpi	r22, 0x10	; 16
  1c:	01 f0       	breq	.+0      	; 0x1e <__spiHWSetClock+0x16>
  1e:	00 f4       	brcc	.+0      	; 0x20 <__spiHWSetClock+0x18>
  20:	62 30       	cpi	r22, 0x02	; 2
  22:	01 f0       	breq	.+0      	; 0x24 <__spiHWSetClock+0x1c>
  24:	68 30       	cpi	r22, 0x08	; 8
  26:	01 f4       	brne	.+0      	; 0x28 <__spiHWSetClock+0x20>
  28:	00 c0       	rjmp	.+0      	; 0x2a <__spiHWSetClock+0x22>
  2a:	60 34       	cpi	r22, 0x40	; 64
  2c:	01 f0       	breq	.+0      	; 0x2e <__spiHWSetClock+0x26>
  2e:	60 38       	cpi	r22, 0x80	; 128
  30:	01 f0       	breq	.+0      	; 0x32 <__spiHWSetClock+0x2a>
  32:	60 32       	cpi	r22, 0x20	; 32
  34:	01 f4       	brne	.+0      	; 0x36 <__spiHWSetClock+0x2e>
  36:	00 c0       	rjmp	.+0      	; 0x38 <__spiHWSetClock+0x30>
	case SPI_CLOCK_DIV2:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  38:	8d b5       	in	r24, 0x2d	; 45
  3a:	81 60       	ori	r24, 0x01	; 1
  3c:	8d bd       	out	0x2d, r24	; 45
  3e:	08 95       	ret
	case SPI_CLOCK_DIV4:
		break;

	case SPI_CLOCK_DIV8:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  40:	8d b5       	in	r24, 0x2d	; 45
  42:	81 60       	ori	r24, 0x01	; 1
  44:	8d bd       	out	0x2d, r24	; 45
#endif
	case SPI_CLOCK_DIV16:
		sbi(SPCR,SPR0);
  46:	8c b5       	in	r24, 0x2c	; 44
  48:	81 60       	ori	r24, 0x01	; 1
  4a:	00 c0       	rjmp	.+0      	; 0x4c <__spiHWSetClock+0x44>
		break;

	case SPI_CLOCK_DIV32:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  4c:	8d b5       	in	r24, 0x2d	; 45
  4e:	81 60       	ori	r24, 0x01	; 1
  50:	8d bd       	out	0x2d, r24	; 45
  52:	00 c0       	rjmp	.+0      	; 0x54 <__spiHWSetClock+0x4c>
	case SPI_CLOCK_DIV64:
		sbi(SPCR,SPR1);
		break;

	case SPI_CLOCK_DIV128:
		sbi(SPCR,SPR0);
  54:	8c b5       	in	r24, 0x2c	; 44
  56:	81 60       	ori	r24, 0x01	; 1
  58:	8c bd       	out	0x2c, r24	; 44
		sbi(SPCR,SPR1);
  5a:	8c b5       	in	r24, 0x2c	; 44
  5c:	82 60       	ori	r24, 0x02	; 2
  5e:	8c bd       	out	0x2c, r24	; 44
  60:	08 95       	ret

00000062 <__spiHWSendByte>:
		break;
	}
}

static uint8_t __spiHWSendByte(SPI_ABSTRACT_BUS* spi, uint8_t data){
    SPDR  = data;          			// send Character
  62:	6e bd       	out	0x2e, r22	; 46
    while (!(SPSR & (1<<SPIF)));    // wait until Char is sent
  64:	0d b4       	in	r0, 0x2d	; 45
  66:	07 fe       	sbrs	r0, 7
  68:	00 c0       	rjmp	.+0      	; 0x6a <__spiHWSendByte+0x8>
    return SPDR;					// return the received byte
  6a:	8e b5       	in	r24, 0x2e	; 46
}
  6c:	08 95       	ret

0000006e <__spiHWSetDataOrder>:
	SPCR &= ~(1<<SPE);
}

static void __spiHWSetDataOrder(SPI_ABSTRACT_BUS* spi,SPI_DATA_ORDER order){
	if(order == SPI_DATA_ORDER_MSB){
		cbi(SPCR,DORD);
  6e:	8c b5       	in	r24, 0x2c	; 44
static void __spiHWOff(SPI_ABSTRACT_BUS* spi){
	SPCR &= ~(1<<SPE);
}

static void __spiHWSetDataOrder(SPI_ABSTRACT_BUS* spi,SPI_DATA_ORDER order){
	if(order == SPI_DATA_ORDER_MSB){
  70:	61 11       	cpse	r22, r1
  72:	00 c0       	rjmp	.+0      	; 0x74 <__spiHWSetDataOrder+0x6>
		cbi(SPCR,DORD);
  74:	8f 7d       	andi	r24, 0xDF	; 223
  76:	00 c0       	rjmp	.+0      	; 0x78 <__spiHWSetDataOrder+0xa>
	}else{
		sbi(SPCR,DORD);
  78:	80 62       	ori	r24, 0x20	; 32
  7a:	8c bd       	out	0x2c, r24	; 44
  7c:	08 95       	ret

0000007e <__spiHWSetMode>:
	}
}

static void __spiHWSetMode(SPI_ABSTRACT_BUS* spi,SPI_MODE mode){
	switch(mode){
  7e:	61 30       	cpi	r22, 0x01	; 1
  80:	01 f0       	breq	.+0      	; 0x82 <__spiHWSetMode+0x4>
  82:	00 f0       	brcs	.+0      	; 0x84 <__spiHWSetMode+0x6>
  84:	62 30       	cpi	r22, 0x02	; 2
  86:	01 f0       	breq	.+0      	; 0x88 <__spiHWSetMode+0xa>
  88:	63 30       	cpi	r22, 0x03	; 3
  8a:	01 f4       	brne	.+0      	; 0x8c <__spiHWSetMode+0xe>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <__spiHWSetMode+0x10>
	case SPI_MODE_0:
		cbi(SPCR,CPOL);
  8e:	8c b5       	in	r24, 0x2c	; 44
  90:	87 7f       	andi	r24, 0xF7	; 247
  92:	00 c0       	rjmp	.+0      	; 0x94 <__spiHWSetMode+0x16>
		cbi(SPCR,CPHA);
		break;
	case SPI_MODE_1:
		cbi(SPCR,CPOL);
  94:	8c b5       	in	r24, 0x2c	; 44
  96:	87 7f       	andi	r24, 0xF7	; 247
  98:	00 c0       	rjmp	.+0      	; 0x9a <__spiHWSetMode+0x1c>
		sbi(SPCR,CPHA);
		break;
	case SPI_MODE_2:
		sbi(SPCR,CPOL);
  9a:	8c b5       	in	r24, 0x2c	; 44
  9c:	88 60       	ori	r24, 0x08	; 8
  9e:	8c bd       	out	0x2c, r24	; 44
		cbi(SPCR,CPHA);
  a0:	8c b5       	in	r24, 0x2c	; 44
  a2:	8b 7f       	andi	r24, 0xFB	; 251
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <__spiHWSetMode+0x28>
		break;
	case SPI_MODE_3:
		sbi(SPCR,CPOL);
  a6:	8c b5       	in	r24, 0x2c	; 44
  a8:	88 60       	ori	r24, 0x08	; 8
  aa:	8c bd       	out	0x2c, r24	; 44
		sbi(SPCR,CPHA);
  ac:	8c b5       	in	r24, 0x2c	; 44
  ae:	84 60       	ori	r24, 0x04	; 4
  b0:	8c bd       	out	0x2c, r24	; 44
  b2:	08 95       	ret

000000b4 <__spiHWInit>:




//------------- Private methods - dont call directly -----
static void __spiHWInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  b4:	ff 92       	push	r15
  b6:	0f 93       	push	r16
  b8:	1f 93       	push	r17
  ba:	cf 93       	push	r28
  bc:	df 93       	push	r29
  be:	1f 92       	push	r1
  c0:	cd b7       	in	r28, 0x3d	; 61
  c2:	de b7       	in	r29, 0x3e	; 62
  c4:	8c 01       	movw	r16, r24
	//SPI* spi = (SPI*)_spi;
	CRITICAL_SECTION_START;
  c6:	ff b6       	in	r15, 0x3f	; 63
  c8:	f8 94       	cli
    volatile char IOReg;
    if(master){
  ca:	66 23       	and	r22, r22
  cc:	01 f0       	breq	.+0      	; 0xce <__spiHWInit+0x1a>
    	sbi(SCK_DDR, SCK_PIN);		// set SCK as output
  ce:	21 9a       	sbi	0x04, 1	; 4
    	sbi(MOSI_DDR, MOSI_PIN);	// set MOSI as output
  d0:	22 9a       	sbi	0x04, 2	; 4
    	cbi(MISO_DDR, MISO_PIN);	// set MISO as an input
  d2:	23 98       	cbi	0x04, 3	; 4
    	sbi(MISO_PORT,MISO_PIN);	// enable pullup on MISO
  d4:	2b 9a       	sbi	0x05, 3	; 5
    	sbi(SS_DDR, SS_PIN);		// set SS as output for Master mode to work
  d6:	20 9a       	sbi	0x04, 0	; 4
        // enable SPI in Master Mode, Data order=MSB first, Mode=0, with SCK = CK/4
        SPCR    = (1<<SPE)|(1<<MSTR);
  d8:	80 e5       	ldi	r24, 0x50	; 80
  da:	00 c0       	rjmp	.+0      	; 0xdc <__spiHWInit+0x28>
    }else{
    	sbi(MISO_DDR, MISO_PIN);	// set MISO as output
  dc:	23 9a       	sbi	0x04, 3	; 4
        SPCR    = (1<<SPE);
  de:	80 e4       	ldi	r24, 0x40	; 64
  e0:	8c bd       	out	0x2c, r24	; 44
    }

    __spiHWSetClock(_spi,_spi->clock);
  e2:	f8 01       	movw	r30, r16
  e4:	66 81       	ldd	r22, Z+6	; 0x06
  e6:	c8 01       	movw	r24, r16
  e8:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>
    __spiHWSetDataOrder(_spi,_spi->order);
  ec:	f8 01       	movw	r30, r16
  ee:	60 85       	ldd	r22, Z+8	; 0x08
  f0:	c8 01       	movw	r24, r16
  f2:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>
    __spiHWSetMode(_spi,_spi->mode);
  f6:	f8 01       	movw	r30, r16
  f8:	67 81       	ldd	r22, Z+7	; 0x07
  fa:	c8 01       	movw	r24, r16
  fc:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>

    // clear SPIF bit in SPSR
    IOReg   = SPSR;
 100:	8d b5       	in	r24, 0x2d	; 45
 102:	89 83       	std	Y+1, r24	; 0x01
    IOReg   = SPDR;
 104:	8e b5       	in	r24, 0x2e	; 46
 106:	89 83       	std	Y+1, r24	; 0x01
    CRITICAL_SECTION_END;
 108:	ff be       	out	0x3f, r15	; 63
}
 10a:	0f 90       	pop	r0
 10c:	df 91       	pop	r29
 10e:	cf 91       	pop	r28
 110:	1f 91       	pop	r17
 112:	0f 91       	pop	r16
 114:	ff 90       	pop	r15
 116:	08 95       	ret

spiUart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000178  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  000001be  2**0
                  ALLOC
  3 .debug_info   00000b5f  00000000  00000000  000001be  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000021f  00000000  00000000  00000d1d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000004ee  00000000  00000000  00000f3c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000142a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  0000144a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000194  00000000  00000000  00001462  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000543  00000000  00000000  000015f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  00001b39  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000a0  00000000  00000000  00001b64  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiUARTSetClock>:
	// Turn off the UART
	uartOff(uart);
}
static void __spiUARTSetClock(SPI_ABSTRACT_BUS* _spi, SPI_CLOCK clock){
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
   0:	dc 01       	movw	r26, r24
   2:	1c 96       	adiw	r26, 0x0c	; 12
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
   a:	84 a1       	ldd	r24, Z+36	; 0x24
   c:	95 a1       	ldd	r25, Z+37	; 0x25
   e:	89 2b       	or	r24, r25
  10:	01 f0       	breq	.+0      	; 0x12 <__spiUARTSetClock+0x12>
		uint16_t bauddiv = (clock>>1)-1;
  12:	66 95       	lsr	r22
  14:	70 e0       	ldi	r23, 0x00	; 0
  16:	61 50       	subi	r22, 0x01	; 1
  18:	71 09       	sbc	r23, r1
		if(bauddiv==0){
  1a:	01 f4       	brne	.+0      	; 0x1c <__spiUARTSetClock+0x1c>
			bauddiv=1;
  1c:	61 e0       	ldi	r22, 0x01	; 1
  1e:	70 e0       	ldi	r23, 0x00	; 0
		}
		_SFR_MEM8(((HW_UART*)uart)->baudL) =  bauddiv;
  20:	a6 8d       	ldd	r26, Z+30	; 0x1e
  22:	b7 8d       	ldd	r27, Z+31	; 0x1f
  24:	6c 93       	st	X, r22
		_SFR_MEM8(((HW_UART*)uart)->baudH) = bauddiv>>8;
  26:	00 a0       	ldd	r0, Z+32	; 0x20
  28:	f1 a1       	ldd	r31, Z+33	; 0x21
  2a:	e0 2d       	mov	r30, r0
  2c:	70 83       	st	Z, r23
  2e:	08 95       	ret

00000030 <__spiUARTSetDataOrder>:
	}
}

static void __spiUARTSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  30:	dc 01       	movw	r26, r24
  32:	1c 96       	adiw	r26, 0x0c	; 12
  34:	ed 91       	ld	r30, X+
  36:	fc 91       	ld	r31, X
  38:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  3a:	84 a1       	ldd	r24, Z+36	; 0x24
  3c:	95 a1       	ldd	r25, Z+37	; 0x25
  3e:	89 2b       	or	r24, r25
  40:	01 f0       	breq	.+0      	; 0x42 <__spiUARTSetDataOrder+0x12>
		PORT statusC =uart->statusB+1;
  42:	04 8c       	ldd	r0, Z+28	; 0x1c
  44:	f5 8d       	ldd	r31, Z+29	; 0x1d
  46:	e0 2d       	mov	r30, r0
		if(order==SPI_DATA_ORDER_MSB){
			_SFR_MEM8(statusC) |= BV(2);	// Clear UDORD
  48:	81 81       	ldd	r24, Z+1	; 0x01
static void __spiUARTSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
	if(uart->spiClock!=null){
		PORT statusC =uart->statusB+1;
		if(order==SPI_DATA_ORDER_MSB){
  4a:	61 11       	cpse	r22, r1
  4c:	00 c0       	rjmp	.+0      	; 0x4e <__spiUARTSetDataOrder+0x1e>
			_SFR_MEM8(statusC) |= BV(2);	// Clear UDORD
  4e:	84 60       	ori	r24, 0x04	; 4
  50:	00 c0       	rjmp	.+0      	; 0x52 <__spiUARTSetDataOrder+0x22>
		}else{
			_SFR_MEM8(statusC) &= ~(BV(2));	// Set UDORD
  52:	8b 7f       	andi	r24, 0xFB	; 251
  54:	81 83       	std	Z+1, r24	; 0x01
  56:	08 95       	ret

00000058 <__spiUARTSetMode>:
		}
	}
}
static void __spiUARTSetMode(SPI_ABSTRACT_BUS* _spi,SPI_MODE mode){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  58:	dc 01       	movw	r26, r24
  5a:	1c 96       	adiw	r26, 0x0c	; 12
  5c:	ed 91       	ld	r30, X+
  5e:	fc 91       	ld	r31, X
  60:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  62:	84 a1       	ldd	r24, Z+36	; 0x24
  64:	95 a1       	ldd	r25, Z+37	; 0x25
  66:	89 2b       	or	r24, r25
  68:	01 f0       	breq	.+0      	; 0x6a <__spiUARTSetMode+0x12>
		PORT statusC =uart->statusB+1;
  6a:	04 8c       	ldd	r0, Z+28	; 0x1c
  6c:	f5 8d       	ldd	r31, Z+29	; 0x1d
  6e:	e0 2d       	mov	r30, r0
		_SFR_MEM8(statusC) = (_SFR_MEM8(statusC) & ~(3)) | (mode & 3);
  70:	81 81       	ldd	r24, Z+1	; 0x01
  72:	63 70       	andi	r22, 0x03	; 3
  74:	8c 7f       	andi	r24, 0xFC	; 252
  76:	68 2b       	or	r22, r24
  78:	61 83       	std	Z+1, r22	; 0x01
  7a:	08 95       	ret

0000007c <__spiUARTSendByte>:
	}
}

static uint8_t __spiUARTSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
  7c:	cf 93       	push	r28
  7e:	df 93       	push	r29
#ifdef UDRE0
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  80:	dc 01       	movw	r26, r24
  82:	1c 96       	adiw	r26, 0x0c	; 12
  84:	ed 91       	ld	r30, X+
  86:	fc 91       	ld	r31, X
  88:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  8a:	84 a1       	ldd	r24, Z+36	; 0x24
  8c:	95 a1       	ldd	r25, Z+37	; 0x25
  8e:	89 2b       	or	r24, r25
  90:	01 f0       	breq	.+0      	; 0x92 <__spiUARTSendByte+0x16>
		PORT statusA =uart->statusA;
  92:	22 8d       	ldd	r18, Z+26	; 0x1a
  94:	93 8d       	ldd	r25, Z+27	; 0x1b

		// Wait for empty transmit buffer.
		do {} while( (_SFR_MEM8(statusA) & (1<<UDRE0)) == 0 );
  96:	a2 2f       	mov	r26, r18
  98:	b9 2f       	mov	r27, r25
  9a:	8c 91       	ld	r24, X
  9c:	85 ff       	sbrs	r24, 5
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <__spiUARTSendByte+0x24>

		// Send data.
		_SFR_MEM8(uart->data) = data;
  a0:	c2 a1       	ldd	r28, Z+34	; 0x22
  a2:	d3 a1       	ldd	r29, Z+35	; 0x23
  a4:	68 83       	st	Y, r22

		// Wait for transfer to complete and return received value.
		do {} while( (_SFR_MEM8(statusA) & (1<<RXC0)) == 0 );
  a6:	8c 91       	ld	r24, X
  a8:	87 ff       	sbrs	r24, 7
  aa:	00 c0       	rjmp	.+0      	; 0xac <__spiUARTSendByte+0x30>

		return _SFR_MEM8(uart->data);
  ac:	02 a0       	ldd	r0, Z+34	; 0x22
  ae:	f3 a1       	ldd	r31, Z+35	; 0x23
  b0:	e0 2d       	mov	r30, r0
  b2:	80 81       	ld	r24, Z
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <__spiUARTSendByte+0x3a>
	}
#endif
	return -1;
  b6:	8f ef       	ldi	r24, 0xFF	; 255
}
  b8:	df 91       	pop	r29
  ba:	cf 91       	pop	r28
  bc:	08 95       	ret

000000be <__spiUARTOff>:
		setError(SPI_UART_ERROR);
	}
}
static void	__spiUARTOff(SPI_ABSTRACT_BUS* _spi){
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART* uart=spi->uart;
  be:	dc 01       	movw	r26, r24
  c0:	1c 96       	adiw	r26, 0x0c	; 12
  c2:	8d 91       	ld	r24, X+
  c4:	9c 91       	ld	r25, X
  c6:	1d 97       	sbiw	r26, 0x0d	; 13

	// Turn off SPI master mode
	_SFR_MEM8(uart->statusB+1) &=  ~(0xc0);
  c8:	dc 01       	movw	r26, r24
  ca:	5c 96       	adiw	r26, 0x1c	; 28
  cc:	ed 91       	ld	r30, X+
  ce:	fc 91       	ld	r31, X
  d0:	5d 97       	sbiw	r26, 0x1d	; 29
  d2:	21 81       	ldd	r18, Z+1	; 0x01
  d4:	2f 73       	andi	r18, 0x3F	; 63
  d6:	21 83       	std	Z+1, r18	; 0x01

	// Turn off the UART
	uartOff(uart);
  d8:	0c 94 00 00 	jmp	0	; 0x0 <__spiUARTSetClock>

000000dc <__spiUARTInit>:
	#define RXEN	RXEN0
	#define TXEN	TXEN0
#endif

//------------- Private methods - dont call directly -----
static void __spiUARTInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  dc:	ef 92       	push	r14
  de:	ff 92       	push	r15
  e0:	0f 93       	push	r16
  e2:	1f 93       	push	r17
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	ec 01       	movw	r28, r24
	SPI_UART* spi=(SPI_UART*)_spi;

	const IOPin* clock = spi->uart->spiClock;
  ea:	0c 85       	ldd	r16, Y+12	; 0x0c
  ec:	1d 85       	ldd	r17, Y+13	; 0x0d
  ee:	d8 01       	movw	r26, r16
  f0:	94 96       	adiw	r26, 0x24	; 36
  f2:	ed 90       	ld	r14, X+
  f4:	fc 90       	ld	r15, X
  f6:	95 97       	sbiw	r26, 0x25	; 37
	if(master && clock!=null){
  f8:	66 23       	and	r22, r22
  fa:	01 f0       	breq	.+0      	; 0xfc <__spiUARTInit+0x20>
  fc:	e1 14       	cp	r14, r1
  fe:	f1 04       	cpc	r15, r1
 100:	01 f0       	breq	.+0      	; 0x102 <__spiUARTInit+0x26>
		HW_UART* uart = spi->uart;

		// Turn off the UART whilst setting up
		uartOff(uart);
 102:	c8 01       	movw	r24, r16
 104:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// Baud rate must be set to 0 prior to enabling the USART as SPI
		// master, to ensure proper initialization of the XCK line.
		_SFR_MEM8(uart->baudL) =  0;
 108:	d8 01       	movw	r26, r16
 10a:	5e 96       	adiw	r26, 0x1e	; 30
 10c:	ed 91       	ld	r30, X+
 10e:	fc 91       	ld	r31, X
 110:	5f 97       	sbiw	r26, 0x1f	; 31
 112:	10 82       	st	Z, r1
		_SFR_MEM8(uart->baudH) =  0;
 114:	90 96       	adiw	r26, 0x20	; 32
 116:	ed 91       	ld	r30, X+
 118:	fc 91       	ld	r31, X
 11a:	91 97       	sbiw	r26, 0x21	; 33
 11c:	10 82       	st	Z, r1

		// Set XCK line to output, ie. set USART in master mode.
		pin_make_output(clock, TRUE);
 11e:	6f ef       	ldi	r22, 0xFF	; 255
 120:	c7 01       	movw	r24, r14
 122:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// When creating the device files we have checked that the UMSEL bits use
		// mask 0xc0 in statusC and that statusC=statusB+1

		// Set USART to Master SPI mode.
		_SFR_MEM8(uart->statusB+1) =  0xc0;
 126:	d8 01       	movw	r26, r16
 128:	5c 96       	adiw	r26, 0x1c	; 28
 12a:	ed 91       	ld	r30, X+
 12c:	fc 91       	ld	r31, X
 12e:	5d 97       	sbiw	r26, 0x1d	; 29
 130:	80 ec       	ldi	r24, 0xC0	; 192
 132:	81 83       	std	Z+1, r24	; 0x01

		// Set clock polarity and phase to correct SPI mode.
	    __spiUARTSetDataOrder(_spi,_spi->order);
 134:	68 85       	ldd	r22, Y+8	; 0x08
 136:	ce 01       	movw	r24, r28
 138:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>
	    __spiUARTSetMode(_spi,_spi->mode);
 13c:	6f 81       	ldd	r22, Y+7	; 0x07
 13e:	ce 01       	movw	r24, r28
 140:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// Enable RX and TX.
		_SFR_MEM8(uart->statusB) =  BV(RXEN)|BV(TXEN);
 144:	d8 01       	movw	r26, r16
 146:	5c 96       	adiw	r26, 0x1c	; 28
 148:	ed 91       	ld	r30, X+
 14a:	fc 91       	ld	r31, X
 14c:	5d 97       	sbiw	r26, 0x1d	; 29
 14e:	88 e1       	ldi	r24, 0x18	; 24
 150:	80 83       	st	Z, r24

		// Set baud rate. Must be set _after_ enabling the transmitter.
	    __spiUARTSetClock(_spi,_spi->clock);
 152:	6e 81       	ldd	r22, Y+6	; 0x06
 154:	ce 01       	movw	r24, r28
	}else{
		// Error - UART doesn't support SPI mode, or the clock pin is not available
		setError(SPI_UART_ERROR);
	}
}
 156:	df 91       	pop	r29
 158:	cf 91       	pop	r28
 15a:	1f 91       	pop	r17
 15c:	0f 91       	pop	r16
 15e:	ff 90       	pop	r15
 160:	ef 90       	pop	r14

		// Enable RX and TX.
		_SFR_MEM8(uart->statusB) =  BV(RXEN)|BV(TXEN);

		// Set baud rate. Must be set _after_ enabling the transmitter.
	    __spiUARTSetClock(_spi,_spi->clock);
 162:	0c 94 00 00 	jmp	0	; 0x0 <__spiUARTSetClock>
	}else{
		// Error - UART doesn't support SPI mode, or the clock pin is not available
		setError(SPI_UART_ERROR);
 166:	88 ee       	ldi	r24, 0xE8	; 232
	}
}
 168:	df 91       	pop	r29
 16a:	cf 91       	pop	r28
 16c:	1f 91       	pop	r17
 16e:	0f 91       	pop	r16
 170:	ff 90       	pop	r15
 172:	ef 90       	pop	r14

		// Set baud rate. Must be set _after_ enabling the transmitter.
	    __spiUARTSetClock(_spi,_spi->clock);
	}else{
		// Error - UART doesn't support SPI mode, or the clock pin is not available
		setError(SPI_UART_ERROR);
 174:	0c 94 00 00 	jmp	0	; 0x0 <__spiUARTSetClock>

spisw.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004f6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  0000052a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  0000053c  2**0
                  ALLOC
  3 .debug_info   000012b6  00000000  00000000  0000053c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000003ad  00000000  00000000  000017f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000e88  00000000  00000000  00001b9f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00002a27  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000048  00000000  00000000  00002a47  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000024d  00000000  00000000  00002a8f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000602  00000000  00000000  00002cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000032de  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000001a0  00000000  00000000  00003308  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiSWOff>:
    __spiSWSetDataOrder(_spi,_spi->order);
    __spiSWSetMode(_spi,_spi->mode);

}

static void __spiSWOff(SPI_ABSTRACT_BUS* _spi){
   0:	08 95       	ret

00000002 <__spiSWSetClock>:
//	if(spi->SELECT!=null){
//		pin_change_dettach(spi->SELECT);
//	}
}

static void __spiSWSetClock(SPI_ABSTRACT_BUS* _spi, SPI_CLOCK clock){}
   2:	08 95       	ret

00000004 <__spiSWSetDataOrder>:
static void __spiSWSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){}
   4:	08 95       	ret

00000006 <__spiSWSetMode>:

static void __spiSWSetMode(SPI_ABSTRACT_BUS* _spi,SPI_MODE mode){
   6:	26 2f       	mov	r18, r22
	SPI_SW* spi = (SPI_SW*)_spi;
	// Set the clock to its initial state
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
   8:	22 50       	subi	r18, 0x02	; 2
   a:	61 e0       	ldi	r22, 0x01	; 1
   c:	22 30       	cpi	r18, 0x02	; 2
   e:	00 f0       	brcs	.+0      	; 0x10 <__spiSWSetMode+0xa>
  10:	60 e0       	ldi	r22, 0x00	; 0
  12:	fc 01       	movw	r30, r24
  14:	80 89       	ldd	r24, Z+16	; 0x10
  16:	91 89       	ldd	r25, Z+17	; 0x11
  18:	0c 94 00 00 	jmp	0	; 0x0 <__spiSWOff>

0000001c <__spiSWInit>:
//}



//------------- Private methods - dont call directly -----
static void __spiSWInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	ec 01       	movw	r28, r24
	SPI_SW* spi = (SPI_SW*)_spi;

    if(master){
  22:	66 23       	and	r22, r22
  24:	01 f0       	breq	.+0      	; 0x26 <__spiSWInit+0xa>
    	pin_make_output(spi->MOSI, TRUE); 	// make MOSI an output and set high
  26:	6f ef       	ldi	r22, 0xFF	; 255
  28:	8c 85       	ldd	r24, Y+12	; 0x0c
  2a:	9d 85       	ldd	r25, Y+13	; 0x0d
  2c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_input(spi->MISO,TRUE);  	// make MISO an input with a pullup
  30:	6f ef       	ldi	r22, 0xFF	; 255
  32:	8e 85       	ldd	r24, Y+14	; 0x0e
  34:	9f 85       	ldd	r25, Y+15	; 0x0f
  36:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <__spiSWInit+0x20>

    }else{
    	pin_make_input(spi->SCLK,FALSE);  	// make clock an input with no pullup
  3c:	60 e0       	ldi	r22, 0x00	; 0
  3e:	88 89       	ldd	r24, Y+16	; 0x10
  40:	99 89       	ldd	r25, Y+17	; 0x11
  42:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_input(spi->MOSI,FALSE);  	// make MOSI an input with no pullup
  46:	60 e0       	ldi	r22, 0x00	; 0
  48:	8c 85       	ldd	r24, Y+12	; 0x0c
  4a:	9d 85       	ldd	r25, Y+13	; 0x0d
  4c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_output(spi->MISO,TRUE); 	// make MISO an output
  50:	6f ef       	ldi	r22, 0xFF	; 255
  52:	8e 85       	ldd	r24, Y+14	; 0x0e
  54:	9f 85       	ldd	r25, Y+15	; 0x0f
  56:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    }

    __spiSWSetClock(_spi,_spi->clock);
    __spiSWSetDataOrder(_spi,_spi->order);
    __spiSWSetMode(_spi,_spi->mode);
  5a:	6f 81       	ldd	r22, Y+7	; 0x07
  5c:	ce 01       	movw	r24, r28

}
  5e:	df 91       	pop	r29
  60:	cf 91       	pop	r28
    	pin_make_output(spi->MISO,TRUE); 	// make MISO an output
    }

    __spiSWSetClock(_spi,_spi->clock);
    __spiSWSetDataOrder(_spi,_spi->order);
    __spiSWSetMode(_spi,_spi->mode);
  62:	0c 94 00 00 	jmp	0	; 0x0 <__spiSWOff>

00000066 <__spiWriteMOSI>:
		}
	}
	return data;
}

static uint8_t __spiWriteMOSI(const SPI_SW* spi, uint8_t data){
  66:	cf 93       	push	r28
  68:	fc 01       	movw	r30, r24
  6a:	c6 2f       	mov	r28, r22
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
  6c:	20 85       	ldd	r18, Z+8	; 0x08
  6e:	84 85       	ldd	r24, Z+12	; 0x0c
  70:	95 85       	ldd	r25, Z+13	; 0x0d
  72:	21 11       	cpse	r18, r1
  74:	00 c0       	rjmp	.+0      	; 0x76 <__spiWriteMOSI+0x10>
		// MSB is sent first
		pin_set(spi->MOSI, (data & 0x80));
  76:	60 78       	andi	r22, 0x80	; 128
  78:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
		data<<=1;
  7c:	8c 2f       	mov	r24, r28
  7e:	88 0f       	add	r24, r24
  80:	00 c0       	rjmp	.+0      	; 0x82 <__spiWriteMOSI+0x1c>
	}else{
		// LSB is sent first
		pin_set(spi->MOSI, (data & 1));
  82:	61 70       	andi	r22, 0x01	; 1
  84:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
		data>>=1;
  88:	8c 2f       	mov	r24, r28
  8a:	86 95       	lsr	r24
	}
	return data;
}
  8c:	cf 91       	pop	r28
  8e:	08 95       	ret

00000090 <writeMany>:
			*dst++ = rtn;								/* store byte			*/
		}
	}
}

static void writeMany(const SPI_ABSTRACT_DEVICE* device,const void* dta, size_t size){
  90:	9f 92       	push	r9
  92:	af 92       	push	r10
  94:	bf 92       	push	r11
  96:	cf 92       	push	r12
  98:	df 92       	push	r13
  9a:	ef 92       	push	r14
  9c:	ff 92       	push	r15
  9e:	0f 93       	push	r16
  a0:	1f 93       	push	r17
  a2:	cf 93       	push	r28
  a4:	df 93       	push	r29
	SPI_SW* spi = (SPI_SW*)(device->bus);
  a6:	fc 01       	movw	r30, r24
  a8:	a0 81       	ld	r26, Z
  aa:	b1 81       	ldd	r27, Z+1	; 0x01
	uint8_t delay = spi->_bus_.clock / 3;		// delay loop is approx 3 cycles
  ac:	16 96       	adiw	r26, 0x06	; 6
  ae:	1c 91       	ld	r17, X
  b0:	16 97       	sbiw	r26, 0x06	; 6
  b2:	2b ea       	ldi	r18, 0xAB	; 171
  b4:	12 9f       	mul	r17, r18
  b6:	11 2d       	mov	r17, r1
  b8:	11 24       	eor	r1, r1
  ba:	16 95       	lsr	r17
	uint8_t* src = (uint8_t*)dta;

	// Get MOSI pin data
	const IOPin*  io = spi->MOSI;
  bc:	1c 96       	adiw	r26, 0x0c	; 12
  be:	2d 91       	ld	r18, X+
  c0:	3c 91       	ld	r19, X
  c2:	1d 97       	sbiw	r26, 0x0d	; 13
	const IOPort* mosiPortDef = (const IOPort*)pgm_read_word(&io->port);
  c4:	f9 01       	movw	r30, r18
  c6:	c5 91       	lpm	r28, Z+
  c8:	d4 91       	lpm	r29, Z
	PORT mosiPort  = pgm_read_word(&mosiPortDef->port);
  ca:	ec 2f       	mov	r30, r28
  cc:	fd 2f       	mov	r31, r29
  ce:	c5 91       	lpm	r28, Z+
  d0:	d4 91       	lpm	r29, Z
  d2:	fc 2e       	mov	r15, r28
  d4:	ed 2e       	mov	r14, r29
	PIN  mosiMask = pgm_read_byte(&io->pin);
  d6:	f9 01       	movw	r30, r18
  d8:	32 96       	adiw	r30, 0x02	; 2
  da:	04 91       	lpm	r16, Z

	// Get SCLK data
	io = spi->SCLK;
  dc:	50 96       	adiw	r26, 0x10	; 16
  de:	2d 91       	ld	r18, X+
  e0:	3c 91       	ld	r19, X
  e2:	51 97       	sbiw	r26, 0x11	; 17
	const IOPort* sclkPortDef = (const IOPort*)pgm_read_word(&io->port);
  e4:	f9 01       	movw	r30, r18
  e6:	c5 91       	lpm	r28, Z+
  e8:	d4 91       	lpm	r29, Z
	PORT sclkPort = pgm_read_word(&sclkPortDef->port);
  ea:	ec 2f       	mov	r30, r28
  ec:	fd 2f       	mov	r31, r29
  ee:	c5 91       	lpm	r28, Z+
  f0:	d4 91       	lpm	r29, Z
  f2:	dc 2e       	mov	r13, r28
  f4:	cd 2e       	mov	r12, r29
	PIN sclkMask = pgm_read_byte(&io->pin);
  f6:	f9 01       	movw	r30, r18
  f8:	32 96       	adiw	r30, 0x02	; 2
  fa:	b4 90       	lpm	r11, Z

	uint8_t cpha = spi->_bus_.mode & 1;
  fc:	17 96       	adiw	r26, 0x07	; 7
  fe:	ac 90       	ld	r10, X
 100:	17 97       	sbiw	r26, 0x07	; 7
 102:	21 e0       	ldi	r18, 0x01	; 1
 104:	a2 22       	and	r10, r18


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 106:	18 96       	adiw	r26, 0x08	; 8
 108:	2c 91       	ld	r18, X
 10a:	18 97       	sbiw	r26, 0x08	; 8
 10c:	eb 01       	movw	r28, r22
			*dst++ = rtn;								/* store byte			*/
		}
	}
}

static void writeMany(const SPI_ABSTRACT_DEVICE* device,const void* dta, size_t size){
 10e:	46 0f       	add	r20, r22
 110:	57 1f       	adc	r21, r23
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 0x80){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 112:	90 2e       	mov	r9, r16
 114:	90 94       	com	r9
	PIN sclkMask = pgm_read_byte(&io->pin);

	uint8_t cpha = spi->_bus_.mode & 1;


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 116:	22 23       	and	r18, r18
 118:	01 f0       	breq	.+0      	; 0x11a <writeMany+0x8a>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <writeMany+0x8c>
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
 11c:	79 91       	ld	r23, Y+
 11e:	28 e0       	ldi	r18, 0x08	; 8
 120:	30 e0       	ldi	r19, 0x00	; 0
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 122:	aa 20       	and	r10, r10
 124:	01 f0       	breq	.+0      	; 0x126 <writeMany+0x96>
 126:	ed 2d       	mov	r30, r13
 128:	fc 2d       	mov	r31, r12
 12a:	60 81       	ld	r22, Z
 12c:	6b 25       	eor	r22, r11
 12e:	60 83       	st	Z, r22
				if(rtn & 0x80){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 130:	ef 2d       	mov	r30, r15
 132:	fe 2d       	mov	r31, r14
 134:	60 81       	ld	r22, Z
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 0x80){
 136:	77 ff       	sbrs	r23, 7
 138:	00 c0       	rjmp	.+0      	; 0x13a <writeMany+0xaa>
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 13a:	60 2b       	or	r22, r16
 13c:	00 c0       	rjmp	.+0      	; 0x13e <writeMany+0xae>
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 13e:	69 21       	and	r22, r9
 140:	60 83       	st	Z, r22
				}
				rtn<<=1;
 142:	77 0f       	add	r23, r23
				if(!cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 144:	a1 10       	cpse	r10, r1
 146:	00 c0       	rjmp	.+0      	; 0x148 <writeMany+0xb8>
 148:	ed 2d       	mov	r30, r13
 14a:	fc 2d       	mov	r31, r12
 14c:	60 81       	ld	r22, Z
 14e:	6b 25       	eor	r22, r11
 150:	60 83       	st	Z, r22
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
 152:	11 23       	and	r17, r17
 154:	01 f0       	breq	.+0      	; 0x156 <writeMany+0xc6>

    Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
    can be achieved.
*/
static __inline__ void _delay_loop_1(uint8_t __count){
	__asm__ volatile (
 156:	61 2f       	mov	r22, r17
 158:	6a 95       	dec	r22
 15a:	01 f4       	brne	.+0      	; 0x15c <writeMany+0xcc>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 15c:	ed 2d       	mov	r30, r13
 15e:	fc 2d       	mov	r31, r12
 160:	60 81       	ld	r22, Z
 162:	6b 25       	eor	r22, r11
 164:	60 83       	st	Z, r22
 166:	21 50       	subi	r18, 0x01	; 1
 168:	31 09       	sbc	r19, r1

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
 16a:	01 f4       	brne	.+0      	; 0x16c <writeMany+0xdc>
	uint8_t cpha = spi->_bus_.mode & 1;


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
 16c:	c4 17       	cp	r28, r20
 16e:	d5 07       	cpc	r29, r21
 170:	01 f4       	brne	.+0      	; 0x172 <writeMany+0xe2>
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
			}											/* next bit				*/
		}
	}
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 172:	fc 01       	movw	r30, r24
 174:	67 81       	ldd	r22, Z+7	; 0x07
 176:	cd 01       	movw	r24, r26
													/* using first bit of filler */
}
 178:	df 91       	pop	r29
 17a:	cf 91       	pop	r28
 17c:	1f 91       	pop	r17
 17e:	0f 91       	pop	r16
 180:	ff 90       	pop	r15
 182:	ef 90       	pop	r14
 184:	df 90       	pop	r13
 186:	cf 90       	pop	r12
 188:	bf 90       	pop	r11
 18a:	af 90       	pop	r10
 18c:	9f 90       	pop	r9
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
			}											/* next bit				*/
		}
	}
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 18e:	0c 94 00 00 	jmp	0	; 0x0 <__spiSWOff>
			}											/* next bit				*/
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
 192:	79 91       	ld	r23, Y+
 194:	28 e0       	ldi	r18, 0x08	; 8
 196:	30 e0       	ldi	r19, 0x00	; 0
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 198:	aa 20       	and	r10, r10
 19a:	01 f0       	breq	.+0      	; 0x19c <writeMany+0x10c>
 19c:	ed 2d       	mov	r30, r13
 19e:	fc 2d       	mov	r31, r12
 1a0:	60 81       	ld	r22, Z
 1a2:	6b 25       	eor	r22, r11
 1a4:	60 83       	st	Z, r22
				if(rtn & 1){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 1a6:	ef 2d       	mov	r30, r15
 1a8:	fe 2d       	mov	r31, r14
 1aa:	60 81       	ld	r22, Z
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 1){
 1ac:	70 ff       	sbrs	r23, 0
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <writeMany+0x120>
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 1b0:	60 2b       	or	r22, r16
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <writeMany+0x124>
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 1b4:	69 21       	and	r22, r9
 1b6:	60 83       	st	Z, r22
				}
				rtn>>=1;
 1b8:	76 95       	lsr	r23
				if(!cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 1ba:	a1 10       	cpse	r10, r1
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <writeMany+0x12e>
 1be:	ed 2d       	mov	r30, r13
 1c0:	fc 2d       	mov	r31, r12
 1c2:	60 81       	ld	r22, Z
 1c4:	6b 25       	eor	r22, r11
 1c6:	60 83       	st	Z, r22
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
 1c8:	11 23       	and	r17, r17
 1ca:	01 f0       	breq	.+0      	; 0x1cc <writeMany+0x13c>
 1cc:	61 2f       	mov	r22, r17
 1ce:	6a 95       	dec	r22
 1d0:	01 f4       	brne	.+0      	; 0x1d2 <writeMany+0x142>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 1d2:	ed 2d       	mov	r30, r13
 1d4:	fc 2d       	mov	r31, r12
 1d6:	60 81       	ld	r22, Z
 1d8:	6b 25       	eor	r22, r11
 1da:	60 83       	st	Z, r22
 1dc:	21 50       	subi	r18, 0x01	; 1
 1de:	31 09       	sbc	r19, r1
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
 1e0:	01 f4       	brne	.+0      	; 0x1e2 <writeMany+0x152>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
			}											/* next bit				*/
		}
	}else{
		// LSB is sent first
		while(size--){
 1e2:	c4 17       	cp	r28, r20
 1e4:	d5 07       	cpc	r29, r21
 1e6:	01 f4       	brne	.+0      	; 0x1e8 <writeMany+0x158>
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <readMany>

000001ea <readMany>:
	}											/* next bit				*/
	pin_high(spi->MOSI);						/* make MOSI high		*/
	return rtn;									/* return read byte		*/
}

static void readMany(const SPI_ABSTRACT_DEVICE* device,void* dta, size_t size){
 1ea:	2f 92       	push	r2
 1ec:	3f 92       	push	r3
 1ee:	4f 92       	push	r4
 1f0:	5f 92       	push	r5
 1f2:	6f 92       	push	r6
 1f4:	7f 92       	push	r7
 1f6:	8f 92       	push	r8
 1f8:	9f 92       	push	r9
 1fa:	af 92       	push	r10
 1fc:	bf 92       	push	r11
 1fe:	cf 92       	push	r12
 200:	df 92       	push	r13
 202:	ef 92       	push	r14
 204:	ff 92       	push	r15
 206:	0f 93       	push	r16
 208:	1f 93       	push	r17
 20a:	cf 93       	push	r28
 20c:	df 93       	push	r29
 20e:	00 d0       	rcall	.+0      	; 0x210 <readMany+0x26>
 210:	1f 92       	push	r1
 212:	cd b7       	in	r28, 0x3d	; 61
 214:	de b7       	in	r29, 0x3e	; 62
 216:	d6 2e       	mov	r13, r22
 218:	7a 01       	movw	r14, r20
	SPI_SW* spi = (SPI_SW*)(device->bus);
 21a:	fc 01       	movw	r30, r24
 21c:	01 90       	ld	r0, Z+
 21e:	f0 81       	ld	r31, Z
 220:	e0 2d       	mov	r30, r0
 222:	fb 83       	std	Y+3, r31	; 0x03
 224:	ea 83       	std	Y+2, r30	; 0x02
	uint8_t delay = spi->_bus_.clock / 3;		// delay loop is approx 3 cycles
 226:	56 80       	ldd	r5, Z+6	; 0x06
 228:	2b ea       	ldi	r18, 0xAB	; 171
 22a:	52 9e       	mul	r5, r18
 22c:	51 2c       	mov	r5, r1
 22e:	11 24       	eor	r1, r1
 230:	56 94       	lsr	r5
	uint8_t* dst = (uint8_t*)dta;
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 232:	fc 01       	movw	r30, r24
 234:	67 81       	ldd	r22, Z+7	; 0x07
 236:	8a 81       	ldd	r24, Y+2	; 0x02
 238:	9b 81       	ldd	r25, Y+3	; 0x03
 23a:	79 83       	std	Y+1, r23	; 0x01
 23c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
													/* using first bit of filler */

	// Get MISO pin data
	const IOPin*  io = spi->MISO;
 240:	ea 81       	ldd	r30, Y+2	; 0x02
 242:	fb 81       	ldd	r31, Y+3	; 0x03
 244:	26 85       	ldd	r18, Z+14	; 0x0e
 246:	37 85       	ldd	r19, Z+15	; 0x0f
	const IOPort* misoPortDef = (const IOPort*)pgm_read_word(&io->port);
 248:	f9 01       	movw	r30, r18
 24a:	85 91       	lpm	r24, Z+
 24c:	94 91       	lpm	r25, Z
	PORT misoPin  = pgm_read_word(&misoPortDef->pin);
 24e:	04 96       	adiw	r24, 0x04	; 4
 250:	fc 01       	movw	r30, r24
 252:	85 91       	lpm	r24, Z+
 254:	94 91       	lpm	r25, Z
 256:	98 2e       	mov	r9, r24
 258:	89 2e       	mov	r8, r25
	PIN  misoMask = pgm_read_byte(&io->pin);
 25a:	f9 01       	movw	r30, r18
 25c:	32 96       	adiw	r30, 0x02	; 2
 25e:	b4 90       	lpm	r11, Z

	// Get SCLK data
	io = spi->SCLK;
 260:	ea 81       	ldd	r30, Y+2	; 0x02
 262:	fb 81       	ldd	r31, Y+3	; 0x03
 264:	80 89       	ldd	r24, Z+16	; 0x10
 266:	91 89       	ldd	r25, Z+17	; 0x11
	const IOPort* sclkPortDef = (const IOPort*)pgm_read_word(&io->port);
 268:	fc 01       	movw	r30, r24
 26a:	25 91       	lpm	r18, Z+
 26c:	34 91       	lpm	r19, Z
	PORT sclkPort = pgm_read_word(&sclkPortDef->port);
 26e:	f9 01       	movw	r30, r18
 270:	25 91       	lpm	r18, Z+
 272:	34 91       	lpm	r19, Z
 274:	72 2e       	mov	r7, r18
 276:	63 2e       	mov	r6, r19
	PIN sclkMask = pgm_read_byte(&io->pin);
 278:	fc 01       	movw	r30, r24
 27a:	32 96       	adiw	r30, 0x02	; 2
 27c:	44 90       	lpm	r4, Z

	uint8_t cpha = spi->_bus_.mode & 1;
 27e:	ea 81       	ldd	r30, Y+2	; 0x02
 280:	fb 81       	ldd	r31, Y+3	; 0x03
 282:	a7 80       	ldd	r10, Z+7	; 0x07
 284:	f1 e0       	ldi	r31, 0x01	; 1
 286:	af 22       	and	r10, r31

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 288:	ea 81       	ldd	r30, Y+2	; 0x02
 28a:	fb 81       	ldd	r31, Y+3	; 0x03
 28c:	80 85       	ldd	r24, Z+8	; 0x08
 28e:	79 81       	ldd	r23, Y+1	; 0x01
 290:	0d 2d       	mov	r16, r13
 292:	17 2f       	mov	r17, r23
 294:	88 23       	and	r24, r24
 296:	01 f0       	breq	.+0      	; 0x298 <readMany+0xae>
	}											/* next bit				*/
	pin_high(spi->MOSI);						/* make MOSI high		*/
	return rtn;									/* return read byte		*/
}

static void readMany(const SPI_ABSTRACT_DEVICE* device,void* dta, size_t size){
 298:	17 01       	movw	r2, r14
 29a:	20 0e       	add	r2, r16
 29c:	31 1e       	adc	r3, r17
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <readMany+0xb6>
 2a0:	18 01       	movw	r2, r16
 2a2:	2e 0c       	add	r2, r14
 2a4:	3f 1c       	adc	r3, r15
 2a6:	00 c0       	rjmp	.+0      	; 0x2a8 <readMany+0xbe>

	uint8_t cpha = spi->_bus_.mode & 1;

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
 2a8:	98 e0       	ldi	r25, 0x08	; 8
 2aa:	c9 2e       	mov	r12, r25
 2ac:	d1 2c       	mov	r13, r1
 2ae:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
				rtn<<=1;
 2b0:	22 0f       	add	r18, r18
				if(!cpha){ // Mode 0 and 2
 2b2:	a1 10       	cpse	r10, r1
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <readMany+0xcc>
					pin_high(spi->MOSI);					/* make MOSI high		*/
 2b6:	ea 81       	ldd	r30, Y+2	; 0x02
 2b8:	fb 81       	ldd	r31, Y+3	; 0x03
 2ba:	84 85       	ldd	r24, Z+12	; 0x0c
 2bc:	95 85       	ldd	r25, Z+13	; 0x0d
 2be:	29 83       	std	Y+1, r18	; 0x01
 2c0:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 0 & 2 */
 2c4:	a9 2d       	mov	r26, r9
 2c6:	b8 2d       	mov	r27, r8
 2c8:	8c 91       	ld	r24, X
 2ca:	8b 21       	and	r24, r11
 2cc:	29 81       	ldd	r18, Y+1	; 0x01
 2ce:	81 11       	cpse	r24, r1
						rtn |= 1;
 2d0:	21 60       	ori	r18, 0x01	; 1
					}
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 2d2:	a7 2d       	mov	r26, r7
 2d4:	b6 2d       	mov	r27, r6
 2d6:	8c 91       	ld	r24, X
 2d8:	84 25       	eor	r24, r4
 2da:	8c 93       	st	X, r24
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 2dc:	55 20       	and	r5, r5
 2de:	01 f0       	breq	.+0      	; 0x2e0 <readMany+0xf6>
 2e0:	85 2d       	mov	r24, r5
 2e2:	8a 95       	dec	r24
 2e4:	01 f4       	brne	.+0      	; 0x2e6 <readMany+0xfc>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 2e6:	8c 91       	ld	r24, X
 2e8:	84 25       	eor	r24, r4
 2ea:	8c 93       	st	X, r24
 2ec:	00 c0       	rjmp	.+0      	; 0x2ee <readMany+0x104>

				}else{ // Mode 1 or 3
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 2ee:	e7 2c       	mov	r14, r7
 2f0:	f6 2c       	mov	r15, r6
 2f2:	f7 01       	movw	r30, r14
 2f4:	80 81       	ld	r24, Z
 2f6:	84 25       	eor	r24, r4
 2f8:	80 83       	st	Z, r24
					pin_high(spi->MOSI);					/* make MOSI high		*/
 2fa:	ea 81       	ldd	r30, Y+2	; 0x02
 2fc:	fb 81       	ldd	r31, Y+3	; 0x03
 2fe:	84 85       	ldd	r24, Z+12	; 0x0c
 300:	95 85       	ldd	r25, Z+13	; 0x0d
 302:	29 83       	std	Y+1, r18	; 0x01
 304:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 308:	29 81       	ldd	r18, Y+1	; 0x01
 30a:	55 20       	and	r5, r5
 30c:	01 f0       	breq	.+0      	; 0x30e <readMany+0x124>
 30e:	85 2d       	mov	r24, r5
 310:	8a 95       	dec	r24
 312:	01 f4       	brne	.+0      	; 0x314 <readMany+0x12a>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 314:	f7 01       	movw	r30, r14
 316:	80 81       	ld	r24, Z
 318:	84 25       	eor	r24, r4
 31a:	80 83       	st	Z, r24

					if(_SFR_MEM8(misoPin) & misoMask){	    /* read input for modes 1 & 3 */
 31c:	a9 2d       	mov	r26, r9
 31e:	b8 2d       	mov	r27, r8
 320:	8c 91       	ld	r24, X
 322:	8b 21       	and	r24, r11
 324:	01 f0       	breq	.+0      	; 0x326 <readMany+0x13c>
						rtn |= 1;
 326:	21 60       	ori	r18, 0x01	; 1
 328:	f1 e0       	ldi	r31, 0x01	; 1
 32a:	cf 1a       	sub	r12, r31
 32c:	d1 08       	sbc	r13, r1

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
 32e:	01 f0       	breq	.+0      	; 0x330 <readMany+0x146>
 330:	00 c0       	rjmp	.+0      	; 0x332 <readMany+0x148>
					if(_SFR_MEM8(misoPin) & misoMask){	    /* read input for modes 1 & 3 */
						rtn |= 1;
					}
				}
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
 332:	f8 01       	movw	r30, r16
 334:	21 93       	st	Z+, r18
 336:	8f 01       	movw	r16, r30

	uint8_t cpha = spi->_bus_.mode & 1;

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
 338:	02 15       	cp	r16, r2
 33a:	13 05       	cpc	r17, r3
 33c:	01 f0       	breq	.+0      	; 0x33e <readMany+0x154>
 33e:	00 c0       	rjmp	.+0      	; 0x340 <readMany+0x156>
 340:	00 c0       	rjmp	.+0      	; 0x342 <readMany+0x158>
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}else{
		// LSB is sent first
		while(size--){
 342:	88 e0       	ldi	r24, 0x08	; 8
 344:	c8 2e       	mov	r12, r24
 346:	d1 2c       	mov	r13, r1
 348:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
				rtn>>=1;
 34a:	26 95       	lsr	r18
				if(!cpha){ // Mode 0 or 2
 34c:	a1 10       	cpse	r10, r1
 34e:	00 c0       	rjmp	.+0      	; 0x350 <readMany+0x166>
					pin_high(spi->MOSI);					/* make MOSI high		*/
 350:	ea 81       	ldd	r30, Y+2	; 0x02
 352:	fb 81       	ldd	r31, Y+3	; 0x03
 354:	84 85       	ldd	r24, Z+12	; 0x0c
 356:	95 85       	ldd	r25, Z+13	; 0x0d
 358:	29 83       	std	Y+1, r18	; 0x01
 35a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 0 & 2 */
 35e:	a9 2d       	mov	r26, r9
 360:	b8 2d       	mov	r27, r8
 362:	8c 91       	ld	r24, X
 364:	8b 21       	and	r24, r11
 366:	29 81       	ldd	r18, Y+1	; 0x01
 368:	81 11       	cpse	r24, r1
						rtn |= 0x80;
 36a:	20 68       	ori	r18, 0x80	; 128
					}
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 36c:	a7 2d       	mov	r26, r7
 36e:	b6 2d       	mov	r27, r6
 370:	8c 91       	ld	r24, X
 372:	84 25       	eor	r24, r4
 374:	8c 93       	st	X, r24
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 376:	55 20       	and	r5, r5
 378:	01 f0       	breq	.+0      	; 0x37a <readMany+0x190>
 37a:	85 2d       	mov	r24, r5
 37c:	8a 95       	dec	r24
 37e:	01 f4       	brne	.+0      	; 0x380 <readMany+0x196>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 380:	8c 91       	ld	r24, X
 382:	84 25       	eor	r24, r4
 384:	8c 93       	st	X, r24
 386:	00 c0       	rjmp	.+0      	; 0x388 <readMany+0x19e>
				}else{		// Mode 1 or 3
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 388:	e7 2c       	mov	r14, r7
 38a:	f6 2c       	mov	r15, r6
 38c:	f7 01       	movw	r30, r14
 38e:	80 81       	ld	r24, Z
 390:	84 25       	eor	r24, r4
 392:	80 83       	st	Z, r24
					pin_high(spi->MOSI);					/* make MOSI high		*/
 394:	ea 81       	ldd	r30, Y+2	; 0x02
 396:	fb 81       	ldd	r31, Y+3	; 0x03
 398:	84 85       	ldd	r24, Z+12	; 0x0c
 39a:	95 85       	ldd	r25, Z+13	; 0x0d
 39c:	29 83       	std	Y+1, r18	; 0x01
 39e:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 3a2:	29 81       	ldd	r18, Y+1	; 0x01
 3a4:	55 20       	and	r5, r5
 3a6:	01 f0       	breq	.+0      	; 0x3a8 <readMany+0x1be>
 3a8:	85 2d       	mov	r24, r5
 3aa:	8a 95       	dec	r24
 3ac:	01 f4       	brne	.+0      	; 0x3ae <readMany+0x1c4>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 3ae:	f7 01       	movw	r30, r14
 3b0:	80 81       	ld	r24, Z
 3b2:	84 25       	eor	r24, r4
 3b4:	80 83       	st	Z, r24
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 1 & 3 */
 3b6:	a9 2d       	mov	r26, r9
 3b8:	b8 2d       	mov	r27, r8
 3ba:	8c 91       	ld	r24, X
 3bc:	8b 21       	and	r24, r11
 3be:	01 f0       	breq	.+0      	; 0x3c0 <readMany+0x1d6>
						rtn |= 0x80;
 3c0:	20 68       	ori	r18, 0x80	; 128
 3c2:	f1 e0       	ldi	r31, 0x01	; 1
 3c4:	cf 1a       	sub	r12, r31
 3c6:	d1 08       	sbc	r13, r1
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
 3c8:	01 f0       	breq	.+0      	; 0x3ca <readMany+0x1e0>
 3ca:	00 c0       	rjmp	.+0      	; 0x3cc <readMany+0x1e2>
						rtn |= 0x80;
					}
				}

			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
 3cc:	f8 01       	movw	r30, r16
 3ce:	21 93       	st	Z+, r18
 3d0:	8f 01       	movw	r16, r30
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}else{
		// LSB is sent first
		while(size--){
 3d2:	02 15       	cp	r16, r2
 3d4:	13 05       	cpc	r17, r3
 3d6:	01 f0       	breq	.+0      	; 0x3d8 <readMany+0x1ee>
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <readMany+0x1f0>

			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}
}
 3da:	0f 90       	pop	r0
 3dc:	0f 90       	pop	r0
 3de:	0f 90       	pop	r0
 3e0:	df 91       	pop	r29
 3e2:	cf 91       	pop	r28
 3e4:	1f 91       	pop	r17
 3e6:	0f 91       	pop	r16
 3e8:	ff 90       	pop	r15
 3ea:	ef 90       	pop	r14
 3ec:	df 90       	pop	r13
 3ee:	cf 90       	pop	r12
 3f0:	bf 90       	pop	r11
 3f2:	af 90       	pop	r10
 3f4:	9f 90       	pop	r9
 3f6:	8f 90       	pop	r8
 3f8:	7f 90       	pop	r7
 3fa:	6f 90       	pop	r6
 3fc:	5f 90       	pop	r5
 3fe:	4f 90       	pop	r4
 400:	3f 90       	pop	r3
 402:	2f 90       	pop	r2
 404:	08 95       	ret

00000406 <select>:
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
													/* using first bit of filler */
}

static void	 select(const SPI_ABSTRACT_DEVICE* device,boolean selected){
	if(selected){
 406:	66 23       	and	r22, r22
 408:	01 f0       	breq	.+0      	; 0x40a <select+0x4>
		// Set MOSI to initial value
		SPI_SW* spi = (SPI_SW*)(device->bus);
		__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 40a:	fc 01       	movw	r30, r24
 40c:	67 81       	ldd	r22, Z+7	; 0x07
 40e:	80 81       	ld	r24, Z
 410:	91 81       	ldd	r25, Z+1	; 0x01
 412:	0c 94 00 00 	jmp	0	; 0x0 <__spiSWOff>
 416:	08 95       	ret

00000418 <__spiReadMISO>:
	// Set the clock to its initial state
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
}


static uint8_t __spiReadMISO(const SPI_SW* spi, uint8_t data){
 418:	cf 93       	push	r28
 41a:	fc 01       	movw	r30, r24
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 41c:	20 85       	ldd	r18, Z+8	; 0x08
 41e:	86 85       	ldd	r24, Z+14	; 0x0e
 420:	97 85       	ldd	r25, Z+15	; 0x0f
		// MSB is sent first
		data<<=1;
 422:	c6 2f       	mov	r28, r22
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
}


static uint8_t __spiReadMISO(const SPI_SW* spi, uint8_t data){
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 424:	21 11       	cpse	r18, r1
 426:	00 c0       	rjmp	.+0      	; 0x428 <__spiReadMISO+0x10>
		// MSB is sent first
		data<<=1;
 428:	cc 0f       	add	r28, r28
		if(pin_is_high(spi->MISO)){
 42a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 42e:	88 23       	and	r24, r24
 430:	01 f0       	breq	.+0      	; 0x432 <__spiReadMISO+0x1a>
			data |= 1;
 432:	c1 60       	ori	r28, 0x01	; 1
 434:	00 c0       	rjmp	.+0      	; 0x436 <__spiReadMISO+0x1e>
		}
	}else{
		// LSB is sent first
		data>>=1;
 436:	c6 95       	lsr	r28
		if(pin_is_high(spi->MISO)){
 438:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 43c:	81 11       	cpse	r24, r1
			data |= 0x80;
 43e:	c0 68       	ori	r28, 0x80	; 128
		}
	}
	return data;
}
 440:	8c 2f       	mov	r24, r28
 442:	cf 91       	pop	r28
 444:	08 95       	ret

00000446 <__spiSWSendByte>:
	return data;
}


// only tested with modes 0 and 2 (cpha = 0)
static uint8_t __spiSWSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
 446:	cf 92       	push	r12
 448:	df 92       	push	r13
 44a:	ef 92       	push	r14
 44c:	ff 92       	push	r15
 44e:	0f 93       	push	r16
 450:	1f 93       	push	r17
 452:	cf 93       	push	r28
 454:	df 93       	push	r29
 456:	ec 01       	movw	r28, r24
 458:	d6 2e       	mov	r13, r22
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
 45a:	fe 80       	ldd	r15, Y+6	; 0x06
 45c:	8b ea       	ldi	r24, 0xAB	; 171
 45e:	f8 9e       	mul	r15, r24
 460:	f1 2c       	mov	r15, r1
 462:	11 24       	eor	r1, r1
 464:	f6 94       	lsr	r15
	uint8_t cpha = _spi->mode & 1;
 466:	cf 80       	ldd	r12, Y+7	; 0x07
 468:	81 e0       	ldi	r24, 0x01	; 1
 46a:	c8 22       	and	r12, r24
 46c:	08 e0       	ldi	r16, 0x08	; 8
 46e:	10 e0       	ldi	r17, 0x00	; 0


// only tested with modes 0 and 2 (cpha = 0)
static uint8_t __spiSWSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
 470:	e1 2c       	mov	r14, r1
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
	uint8_t cpha = _spi->mode & 1;

	for(int i=0; i<8; i++){						/* for each bit			*/
		if(!cpha){ // Mode 0 or 2
 472:	c1 10       	cpse	r12, r1
 474:	00 c0       	rjmp	.+0      	; 0x476 <__spiSWSendByte+0x30>
			data = __spiWriteMOSI(spi,data);		/* Set the output pin 	*/
 476:	6d 2d       	mov	r22, r13
 478:	ce 01       	movw	r24, r28
 47a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 47e:	d8 2e       	mov	r13, r24
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 0 and 2	*/
 480:	6e 2d       	mov	r22, r14
 482:	ce 01       	movw	r24, r28
 484:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 488:	e8 2e       	mov	r14, r24
			pin_toggle(spi->SCLK);					/* toggle clock (high) 	*/
 48a:	88 89       	ldd	r24, Y+16	; 0x10
 48c:	99 89       	ldd	r25, Y+17	; 0x11
 48e:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
 492:	ff 20       	and	r15, r15
 494:	01 f0       	breq	.+0      	; 0x496 <__spiSWSendByte+0x50>
 496:	8f 2d       	mov	r24, r15
 498:	8a 95       	dec	r24
 49a:	01 f4       	brne	.+0      	; 0x49c <__spiSWSendByte+0x56>
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
 49c:	88 89       	ldd	r24, Y+16	; 0x10
 49e:	99 89       	ldd	r25, Y+17	; 0x11
 4a0:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4a4:	00 c0       	rjmp	.+0      	; 0x4a6 <__spiSWSendByte+0x60>
		}else{		// Mode 1 or 3
			pin_toggle(spi->SCLK);					/* toggle clock (high) 	*/
 4a6:	88 89       	ldd	r24, Y+16	; 0x10
 4a8:	99 89       	ldd	r25, Y+17	; 0x11
 4aa:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			data = __spiWriteMOSI(spi,data);		/* Set the output pin 	*/
 4ae:	6d 2d       	mov	r22, r13
 4b0:	ce 01       	movw	r24, r28
 4b2:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4b6:	d8 2e       	mov	r13, r24
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
 4b8:	ff 20       	and	r15, r15
 4ba:	01 f0       	breq	.+0      	; 0x4bc <__spiSWSendByte+0x76>
 4bc:	8f 2d       	mov	r24, r15
 4be:	8a 95       	dec	r24
 4c0:	01 f4       	brne	.+0      	; 0x4c2 <__spiSWSendByte+0x7c>
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
 4c2:	88 89       	ldd	r24, Y+16	; 0x10
 4c4:	99 89       	ldd	r25, Y+17	; 0x11
 4c6:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 1 and 3	*/
 4ca:	6e 2d       	mov	r22, r14
 4cc:	ce 01       	movw	r24, r28
 4ce:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4d2:	e8 2e       	mov	r14, r24
 4d4:	01 50       	subi	r16, 0x01	; 1
 4d6:	11 09       	sbc	r17, r1
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
	uint8_t cpha = _spi->mode & 1;

	for(int i=0; i<8; i++){						/* for each bit			*/
 4d8:	01 f4       	brne	.+0      	; 0x4da <__spiSWSendByte+0x94>
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 1 and 3	*/
		}
	}											/* next bit				*/
	pin_high(spi->MOSI);						/* make MOSI high		*/
 4da:	8c 85       	ldd	r24, Y+12	; 0x0c
 4dc:	9d 85       	ldd	r25, Y+13	; 0x0d
 4de:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
	return rtn;									/* return read byte		*/
}
 4e2:	8e 2d       	mov	r24, r14
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	df 90       	pop	r13
 4f2:	cf 90       	pop	r12
 4f4:	08 95       	ret

timer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000010f0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000016  00000000  00000000  00001124  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  0000113a  2**0
                  ALLOC
  3 .progmem.data 0000003f  00000000  00000000  0000113a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00002ff7  00000000  00000000  00001179  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000005fa  00000000  00000000  00004170  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000036e0  00000000  00000000  0000476a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00007e4a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 000001c0  00000000  00000000  00007e6a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000613  00000000  00000000  0000802a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000cc9  00000000  00000000  0000863d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  00009306  2**0
                  CONTENTS, READONLY
 12 .debug_frame  000005d8  00000000  00000000  00009330  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerOff>:

/* -----------------------------------------------
 *  Disable a timer
 -------------------------------------------------*/
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
       0:	04 96       	adiw	r24, 0x04	; 4
       2:	fc 01       	movw	r30, r24
       4:	85 91       	lpm	r24, Z+
       6:	94 91       	lpm	r25, Z
       8:	fc 01       	movw	r30, r24
       a:	80 81       	ld	r24, Z
       c:	88 7f       	andi	r24, 0xF8	; 248
       e:	80 83       	st	Z, r24
      10:	08 95       	ret

00000012 <nullTimerCompareCallback>:
	}
}

// Magic callback for compare matches that just mark the channel as in use
// but there is nothing to do in the interrupt routine
void nullTimerCompareCallback(const TimerCompare *timer_compare, void* data){}
      12:	08 95       	ret

00000014 <clockCallback>:

// Service interrupts for the system clock
static void clockCallback(const TimerCompare *timer_compare, void* data){
	clockTicks++;
      14:	80 91 00 00 	lds	r24, 0x0000
      18:	90 91 00 00 	lds	r25, 0x0000
      1c:	a0 91 00 00 	lds	r26, 0x0000
      20:	b0 91 00 00 	lds	r27, 0x0000
      24:	01 96       	adiw	r24, 0x01	; 1
      26:	a1 1d       	adc	r26, r1
      28:	b1 1d       	adc	r27, r1
      2a:	80 93 00 00 	sts	0x0000, r24
      2e:	90 93 00 00 	sts	0x0000, r25
      32:	a0 93 00 00 	sts	0x0000, r26
      36:	b0 93 00 00 	sts	0x0000, r27
      3a:	08 95       	ret

0000003c <__error_flash>:

ERROR_CODE getError(void){
	 return __error.errorCode;
}

void __error_flash(void * __error, TICK_COUNT lastTime, TICK_COUNT overflow){
      3c:	cf 92       	push	r12
      3e:	df 92       	push	r13
      40:	ef 92       	push	r14
      42:	ff 92       	push	r15
      44:	0f 93       	push	r16
      46:	1f 93       	push	r17
      48:	cf 93       	push	r28
      4a:	df 93       	push	r29
      4c:	00 d0       	rcall	.+0      	; 0x4e <__error_flash+0x12>
      4e:	00 d0       	rcall	.+0      	; 0x50 <__error_flash+0x14>
      50:	cd b7       	in	r28, 0x3d	; 61
      52:	de b7       	in	r29, 0x3e	; 62
      54:	6c 01       	movw	r12, r24
      56:	9a 01       	movw	r18, r20
      58:	ab 01       	movw	r20, r22
	ERROR* err = (ERROR*) __error;

	if(err->remaining==0){
      5a:	fc 01       	movw	r30, r24
      5c:	81 81       	ldd	r24, Z+1	; 0x01
      5e:	81 11       	cpse	r24, r1
      60:	00 c0       	rjmp	.+0      	; 0x62 <__error_flash+0x26>
		err->remaining = ABS(err->errorCode);
      62:	80 81       	ld	r24, Z
      64:	18 16       	cp	r1, r24
      66:	04 f4       	brge	.+0      	; 0x68 <__error_flash+0x2c>
      68:	80 81       	ld	r24, Z
      6a:	00 c0       	rjmp	.+0      	; 0x6c <__error_flash+0x30>
      6c:	f6 01       	movw	r30, r12
      6e:	80 81       	ld	r24, Z
      70:	81 95       	neg	r24
      72:	f6 01       	movw	r30, r12
      74:	81 83       	std	Z+1, r24	; 0x01
	}

	TICK_COUNT delay = (err->errorCode <0 ) ? (TICK_COUNT)250000UL : (TICK_COUNT)500000UL;
      76:	f6 01       	movw	r30, r12
      78:	80 81       	ld	r24, Z
      7a:	87 ff       	sbrs	r24, 7
      7c:	00 c0       	rjmp	.+0      	; 0x7e <__error_flash+0x42>
      7e:	10 e9       	ldi	r17, 0x90	; 144
      80:	e1 2e       	mov	r14, r17
      82:	10 ed       	ldi	r17, 0xD0	; 208
      84:	f1 2e       	mov	r15, r17
      86:	03 e0       	ldi	r16, 0x03	; 3
      88:	10 e0       	ldi	r17, 0x00	; 0
      8a:	00 c0       	rjmp	.+0      	; 0x8c <__error_flash+0x50>
      8c:	10 e2       	ldi	r17, 0x20	; 32
      8e:	e1 2e       	mov	r14, r17
      90:	11 ea       	ldi	r17, 0xA1	; 161
      92:	f1 2e       	mov	r15, r17
      94:	07 e0       	ldi	r16, 0x07	; 7
      96:	10 e0       	ldi	r17, 0x00	; 0
	if(err->phase){
      98:	f6 01       	movw	r30, r12
      9a:	62 81       	ldd	r22, Z+2	; 0x02
      9c:	80 91 00 00 	lds	r24, 0x0000
      a0:	90 91 00 00 	lds	r25, 0x0000
		LED_on(&statusLED);
	}
}

static __inline__ void statusLED_off(){
	if(pin_is_output(statusLED.pin)){
      a4:	29 83       	std	Y+1, r18	; 0x01
      a6:	3a 83       	std	Y+2, r19	; 0x02
      a8:	4b 83       	std	Y+3, r20	; 0x03
      aa:	5c 83       	std	Y+4, r21	; 0x04
      ac:	60 ff       	sbrs	r22, 0
      ae:	00 c0       	rjmp	.+0      	; 0xb0 <__error_flash+0x74>
      b0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
      b4:	29 81       	ldd	r18, Y+1	; 0x01
      b6:	3a 81       	ldd	r19, Y+2	; 0x02
      b8:	4b 81       	ldd	r20, Y+3	; 0x03
      ba:	5c 81       	ldd	r21, Y+4	; 0x04
      bc:	88 23       	and	r24, r24
      be:	01 f0       	breq	.+0      	; 0xc0 <__error_flash+0x84>
static __inline__ void LED_on(LED* led){
	LED_set(led,TRUE);
}

static __inline__ void LED_off(LED* led){
	LED_set(led,FALSE);
      c0:	60 e0       	ldi	r22, 0x00	; 0
      c2:	80 e0       	ldi	r24, 0x00	; 0
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
      ca:	5c 81       	ldd	r21, Y+4	; 0x04
      cc:	4b 81       	ldd	r20, Y+3	; 0x03
      ce:	3a 81       	ldd	r19, Y+2	; 0x02
      d0:	29 81       	ldd	r18, Y+1	; 0x01
		// turn led off
		statusLED_off();
		err->remaining--;
      d2:	f6 01       	movw	r30, r12
      d4:	81 81       	ldd	r24, Z+1	; 0x01
      d6:	81 50       	subi	r24, 0x01	; 1
      d8:	81 83       	std	Z+1, r24	; 0x01
		if(err->remaining==0){
      da:	81 81       	ldd	r24, Z+1	; 0x01
      dc:	81 11       	cpse	r24, r1
      de:	00 c0       	rjmp	.+0      	; 0xe0 <__error_flash+0xa4>
			delay = (TICK_COUNT)2000000UL;
      e0:	10 e8       	ldi	r17, 0x80	; 128
      e2:	e1 2e       	mov	r14, r17
      e4:	14 e8       	ldi	r17, 0x84	; 132
      e6:	f1 2e       	mov	r15, r17
      e8:	0e e1       	ldi	r16, 0x1E	; 30
      ea:	10 e0       	ldi	r17, 0x00	; 0
		}

		err->phase=FALSE;
      ec:	f6 01       	movw	r30, r12
      ee:	82 81       	ldd	r24, Z+2	; 0x02
      f0:	8e 7f       	andi	r24, 0xFE	; 254
      f2:	00 c0       	rjmp	.+0      	; 0xf4 <__error_flash+0xb8>
	statusLED.initialised=FALSE;
	LED_on(&statusLED);
}

static __inline__ void statusLED_on(){
	if(pin_is_output(statusLED.pin)){
      f4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
      f8:	29 81       	ldd	r18, Y+1	; 0x01
      fa:	3a 81       	ldd	r19, Y+2	; 0x02
      fc:	4b 81       	ldd	r20, Y+3	; 0x03
      fe:	5c 81       	ldd	r21, Y+4	; 0x04
     100:	88 23       	and	r24, r24
     102:	01 f0       	breq	.+0      	; 0x104 <__error_flash+0xc8>


void LED_set(LED* led,	boolean value);

static __inline__ void LED_on(LED* led){
	LED_set(led,TRUE);
     104:	6f ef       	ldi	r22, 0xFF	; 255
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	90 e0       	ldi	r25, 0x00	; 0
     10a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     10e:	5c 81       	ldd	r21, Y+4	; 0x04
     110:	4b 81       	ldd	r20, Y+3	; 0x03
     112:	3a 81       	ldd	r19, Y+2	; 0x02
     114:	29 81       	ldd	r18, Y+1	; 0x01
	}else{
		// turn led on
		statusLED_on();
		err->phase=TRUE;
     116:	f6 01       	movw	r30, r12
     118:	82 81       	ldd	r24, Z+2	; 0x02
     11a:	ff ef       	ldi	r31, 0xFF	; 255
     11c:	f0 fb       	bst	r31, 0
     11e:	80 f9       	bld	r24, 0
     120:	f6 01       	movw	r30, r12
     122:	82 83       	std	Z+2, r24	; 0x02
		delay -= overflow;	// remove any overflow
	}
*/

	// queue the next event
	scheduleJob(&__error_flash, __error, lastTime, delay);
     124:	b6 01       	movw	r22, r12
     126:	80 e0       	ldi	r24, 0x00	; 0
     128:	90 e0       	ldi	r25, 0x00	; 0
     12a:	0e 94 00 00 	call	0	; 0x0 <timerOff>

}
     12e:	0f 90       	pop	r0
     130:	0f 90       	pop	r0
     132:	0f 90       	pop	r0
     134:	0f 90       	pop	r0
     136:	df 91       	pop	r29
     138:	cf 91       	pop	r28
     13a:	1f 91       	pop	r17
     13c:	0f 91       	pop	r16
     13e:	ff 90       	pop	r15
     140:	ef 90       	pop	r14
     142:	df 90       	pop	r13
     144:	cf 90       	pop	r12
     146:	08 95       	ret

00000148 <ticks_per_ms>:
extern const uint8_t NUMBER_OF_TIMERS;

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
     148:	fa 01       	movw	r30, r20
	return (ms * cpu_speed_div_1000)/prescale;
     14a:	a0 91 00 00 	lds	r26, 0x0000
     14e:	b0 91 00 00 	lds	r27, 0x0000
     152:	9b 01       	movw	r18, r22
     154:	ac 01       	movw	r20, r24
     156:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     15a:	9f 01       	movw	r18, r30
     15c:	40 e0       	ldi	r20, 0x00	; 0
     15e:	50 e0       	ldi	r21, 0x00	; 0
     160:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     164:	b9 01       	movw	r22, r18
     166:	ca 01       	movw	r24, r20
     168:	08 95       	ret

0000016a <delay_cycles>:

/*
	Delay for a given number of processor cycles
*/
void delay_cycles(uint32_t __cycles){
	if(__cycles <= (3*256U)){
     16a:	61 30       	cpi	r22, 0x01	; 1
     16c:	23 e0       	ldi	r18, 0x03	; 3
     16e:	72 07       	cpc	r23, r18
     170:	81 05       	cpc	r24, r1
     172:	91 05       	cpc	r25, r1
     174:	00 f4       	brcc	.+0      	; 0x176 <delay_cycles+0xc>
		_delay_loop_1((uint8_t) (__cycles / 3) );
     176:	23 e0       	ldi	r18, 0x03	; 3
     178:	30 e0       	ldi	r19, 0x00	; 0
     17a:	40 e0       	ldi	r20, 0x00	; 0
     17c:	50 e0       	ldi	r21, 0x00	; 0
     17e:	0e 94 00 00 	call	0	; 0x0 <timerOff>

    Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
    can be achieved.
*/
static __inline__ void _delay_loop_1(uint8_t __count){
	__asm__ volatile (
     182:	2a 95       	dec	r18
     184:	01 f4       	brne	.+0      	; 0x186 <delay_cycles+0x1c>
     186:	08 95       	ret
		return;
	}

	uint32_t cyc = __cycles / 4;
     188:	dc 01       	movw	r26, r24
     18a:	cb 01       	movw	r24, r22
     18c:	72 e0       	ldi	r23, 0x02	; 2
     18e:	b6 95       	lsr	r27
     190:	a7 95       	ror	r26
     192:	97 95       	ror	r25
     194:	87 95       	ror	r24
     196:	7a 95       	dec	r23
     198:	01 f4       	brne	.+0      	; 0x19a <delay_cycles+0x30>
	while(cyc != 0 ){
	   uint16_t actual = (cyc <= 65535U) ? cyc : 65535U;
     19a:	ac 01       	movw	r20, r24
     19c:	bd 01       	movw	r22, r26
     19e:	00 97       	sbiw	r24, 0x00	; 0
     1a0:	21 e0       	ldi	r18, 0x01	; 1
     1a2:	a2 07       	cpc	r26, r18
     1a4:	b1 05       	cpc	r27, r1
     1a6:	00 f0       	brcs	.+0      	; 0x1a8 <delay_cycles+0x3e>
     1a8:	4f ef       	ldi	r20, 0xFF	; 255
     1aa:	5f ef       	ldi	r21, 0xFF	; 255
     1ac:	60 e0       	ldi	r22, 0x00	; 0
     1ae:	70 e0       	ldi	r23, 0x00	; 0

    Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
    milliseconds can be achieved.
 */
static __inline__ void _delay_loop_2(uint16_t __count){
	__asm__ volatile (
     1b0:	fa 01       	movw	r30, r20
     1b2:	31 97       	sbiw	r30, 0x01	; 1
     1b4:	01 f4       	brne	.+0      	; 0x1b6 <delay_cycles+0x4c>
	   _delay_loop_2(actual);
	   cyc -= actual;
     1b6:	66 27       	eor	r22, r22
     1b8:	77 27       	eor	r23, r23
     1ba:	84 1b       	sub	r24, r20
     1bc:	95 0b       	sbc	r25, r21
     1be:	a6 0b       	sbc	r26, r22
     1c0:	b7 0b       	sbc	r27, r23
		_delay_loop_1((uint8_t) (__cycles / 3) );
		return;
	}

	uint32_t cyc = __cycles / 4;
	while(cyc != 0 ){
     1c2:	01 f4       	brne	.+0      	; 0x1c4 <delay_cycles+0x5a>
     1c4:	08 95       	ret

000001c6 <__timerPrescalerIndex>:
int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler){
	uint8_t count;
	uint16_t *array;
	int8_t i;

	if(pgm_read_byte(&timer->pgm_rtc)){
     1c6:	07 96       	adiw	r24, 0x07	; 7
     1c8:	fc 01       	movw	r30, r24
     1ca:	84 91       	lpm	r24, Z
     1cc:	88 23       	and	r24, r24
     1ce:	01 f0       	breq	.+0      	; 0x1d0 <__timerPrescalerIndex+0xa>
		array =TimerRTCPrescaleFactor;
     1d0:	20 e0       	ldi	r18, 0x00	; 0
     1d2:	30 e0       	ldi	r19, 0x00	; 0
		count = sizeof(TimerRTCPrescaleFactor) / sizeof(uint16_t);
     1d4:	a8 e0       	ldi	r26, 0x08	; 8
     1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <__timerPrescalerIndex+0x12>
	}else{
		array =TimerPrescaleFactor;
     1d8:	20 e0       	ldi	r18, 0x00	; 0
     1da:	30 e0       	ldi	r19, 0x00	; 0
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);
     1dc:	a6 e0       	ldi	r26, 0x06	; 6

	}

	for(i=count-1; i>=0; i--){
     1de:	a1 50       	subi	r26, 0x01	; 1
/* -------------------------------------------------------
//
//  Does a timer support a given prescale value
//
------------------------------------------------------- */
int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler){
     1e0:	2a 0f       	add	r18, r26
     1e2:	31 1d       	adc	r19, r1
     1e4:	2a 0f       	add	r18, r26
     1e6:	31 1d       	adc	r19, r1
     1e8:	40 e0       	ldi	r20, 0x00	; 0
     1ea:	50 e0       	ldi	r21, 0x00	; 0
     1ec:	fa 01       	movw	r30, r20
     1ee:	e2 0f       	add	r30, r18
     1f0:	f3 1f       	adc	r31, r19
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);

	}

	for(i=count-1; i>=0; i--){
		uint16_t one = pgm_read_word(array + i);
     1f2:	85 91       	lpm	r24, Z+
     1f4:	94 91       	lpm	r25, Z
		if(one == prescaler){
     1f6:	86 17       	cp	r24, r22
     1f8:	97 07       	cpc	r25, r23
     1fa:	01 f4       	brne	.+0      	; 0x1fc <__timerPrescalerIndex+0x36>
			return i;
     1fc:	2a 2f       	mov	r18, r26
     1fe:	33 27       	eor	r19, r19
     200:	27 fd       	sbrc	r18, 7
     202:	30 95       	com	r19
     204:	00 c0       	rjmp	.+0      	; 0x206 <__timerPrescalerIndex+0x40>
		array =TimerPrescaleFactor;
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);

	}

	for(i=count-1; i>=0; i--){
     206:	a1 50       	subi	r26, 0x01	; 1
     208:	42 50       	subi	r20, 0x02	; 2
     20a:	51 09       	sbc	r21, r1
     20c:	a7 ff       	sbrs	r26, 7
     20e:	00 c0       	rjmp	.+0      	; 0x210 <__timerPrescalerIndex+0x4a>
		uint16_t one = pgm_read_word(array + i);
		if(one == prescaler){
			return i;
		}
	}
	return -1;
     210:	2f ef       	ldi	r18, 0xFF	; 255
     212:	3f ef       	ldi	r19, 0xFF	; 255
}
     214:	c9 01       	movw	r24, r18
     216:	08 95       	ret

00000218 <timerGetClosestPrescale>:
	CRITICAL_SECTION_END;

}

// Round up to the nearest prescaler value
uint16_t timerGetClosestPrescale(const Timer* timer, uint16_t prescale){
     218:	0f 93       	push	r16
     21a:	1f 93       	push	r17
     21c:	cf 93       	push	r28
     21e:	df 93       	push	r29
     220:	8c 01       	movw	r16, r24
	prescale = CLAMP(prescale, 1, MAX_PRESCALE);
     222:	eb 01       	movw	r28, r22
     224:	61 30       	cpi	r22, 0x01	; 1
     226:	24 e0       	ldi	r18, 0x04	; 4
     228:	72 07       	cpc	r23, r18
     22a:	00 f0       	brcs	.+0      	; 0x22c <timerGetClosestPrescale+0x14>
     22c:	c0 e0       	ldi	r28, 0x00	; 0
     22e:	d4 e0       	ldi	r29, 0x04	; 4
     230:	20 97       	sbiw	r28, 0x00	; 0
     232:	01 f4       	brne	.+0      	; 0x234 <timerGetClosestPrescale+0x1c>
     234:	c1 e0       	ldi	r28, 0x01	; 1
     236:	d0 e0       	ldi	r29, 0x00	; 0
     238:	00 c0       	rjmp	.+0      	; 0x23a <timerGetClosestPrescale+0x22>

	while(__timerPrescalerIndex(timer,prescale)==-1){
		prescale++;
     23a:	21 96       	adiw	r28, 0x01	; 1

// Round up to the nearest prescaler value
uint16_t timerGetClosestPrescale(const Timer* timer, uint16_t prescale){
	prescale = CLAMP(prescale, 1, MAX_PRESCALE);

	while(__timerPrescalerIndex(timer,prescale)==-1){
     23c:	be 01       	movw	r22, r28
     23e:	c8 01       	movw	r24, r16
     240:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     244:	01 96       	adiw	r24, 0x01	; 1
     246:	01 f0       	breq	.+0      	; 0x248 <timerGetClosestPrescale+0x30>
		prescale++;
	}
	return prescale;
}
     248:	ce 01       	movw	r24, r28
     24a:	df 91       	pop	r29
     24c:	cf 91       	pop	r28
     24e:	1f 91       	pop	r17
     250:	0f 91       	pop	r16
     252:	08 95       	ret

00000254 <timerGetCounter>:
}



uint16_t timerGetCounter(const Timer* timer){
	PORT counter = pgm_read_word(&timer->pgm_counter);
     254:	fc 01       	movw	r30, r24
     256:	32 96       	adiw	r30, 0x02	; 2
     258:	25 91       	lpm	r18, Z+
     25a:	34 91       	lpm	r19, Z
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     25c:	fc 01       	movw	r30, r24
     25e:	36 96       	adiw	r30, 0x06	; 6
     260:	84 91       	lpm	r24, Z
	if(timerIs16bit(timer)){
		return _SFR_MEM16(counter);
     262:	f9 01       	movw	r30, r18



uint16_t timerGetCounter(const Timer* timer){
	PORT counter = pgm_read_word(&timer->pgm_counter);
	if(timerIs16bit(timer)){
     264:	88 23       	and	r24, r24
     266:	01 f0       	breq	.+0      	; 0x268 <timerGetCounter+0x14>
		return _SFR_MEM16(counter);
     268:	20 81       	ld	r18, Z
     26a:	31 81       	ldd	r19, Z+1	; 0x01
     26c:	00 c0       	rjmp	.+0      	; 0x26e <timerGetCounter+0x1a>
	}
	return _SFR_MEM8(counter);
     26e:	20 81       	ld	r18, Z
     270:	30 e0       	ldi	r19, 0x00	; 0
}
     272:	c9 01       	movw	r24, r18
     274:	08 95       	ret

00000276 <__timerRead>:

static void __timerRead(const Timer* timer,TIMER_SNAPSHOT* snapshot){
     276:	bf 92       	push	r11
     278:	cf 92       	push	r12
     27a:	df 92       	push	r13
     27c:	ef 92       	push	r14
     27e:	ff 92       	push	r15
     280:	0f 93       	push	r16
     282:	1f 93       	push	r17
     284:	cf 93       	push	r28
     286:	df 93       	push	r29
     288:	8c 01       	movw	r16, r24
     28a:	eb 01       	movw	r28, r22
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     28c:	fc 01       	movw	r30, r24
     28e:	a5 91       	lpm	r26, Z+
     290:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
     292:	1a 96       	adiw	r26, 0x0a	; 10
     294:	8c 91       	ld	r24, X
	TIMER_MODE mode = timerGetMode(timer);

	snapshot->timer = timer;
     296:	19 83       	std	Y+1, r17	; 0x01
     298:	08 83       	st	Y, r16
	if(!timer){
     29a:	01 15       	cp	r16, r1
     29c:	11 05       	cpc	r17, r1
     29e:	01 f4       	brne	.+0      	; 0x2a0 <__timerRead+0x2a>
		snapshot->part = snapshot->whole = 0;
     2a0:	1a 82       	std	Y+2, r1	; 0x02
     2a2:	1b 82       	std	Y+3, r1	; 0x03
     2a4:	1c 82       	std	Y+4, r1	; 0x04
     2a6:	1d 82       	std	Y+5, r1	; 0x05
     2a8:	1f 82       	std	Y+7, r1	; 0x07
     2aa:	1e 82       	std	Y+6, r1	; 0x06
		return;
     2ac:	00 c0       	rjmp	.+0      	; 0x2ae <__timerRead+0x38>
	}

	if(mode==TIMER_MODE_CTC_OCR
     2ae:	84 30       	cpi	r24, 0x04	; 4
     2b0:	01 f0       	breq	.+0      	; 0x2b2 <__timerRead+0x3c>
			|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
     2b2:	89 30       	cpi	r24, 0x09	; 9
     2b4:	01 f0       	breq	.+0      	; 0x2b6 <__timerRead+0x40>
			|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
     2b6:	8b 30       	cpi	r24, 0x0B	; 11
     2b8:	01 f0       	breq	.+0      	; 0x2ba <__timerRead+0x44>
			|| mode==TIMER_MODE_PWM_FAST_OCR){
     2ba:	8f 30       	cpi	r24, 0x0F	; 15
     2bc:	01 f0       	breq	.+0      	; 0x2be <__timerRead+0x48>
     2be:	00 c0       	rjmp	.+0      	; 0x2c0 <__timerRead+0x4a>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     2c0:	f8 01       	movw	r30, r16
     2c2:	77 96       	adiw	r30, 0x17	; 23
     2c4:	e5 90       	lpm	r14, Z+
     2c6:	f4 90       	lpm	r15, Z
		// These mode all generate compare interrupts on channel A
		const TimerCompare* channel = timerGetCompare(timer,0);
		CRITICAL_SECTION_START;
     2c8:	bf b6       	in	r11, 0x3f	; 63
     2ca:	f8 94       	cli
		{
			uint16_t tcnt  = timerGetCounter(timer);	// get the current ticks
     2cc:	c8 01       	movw	r24, r16
     2ce:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     2d2:	6c 01       	movw	r12, r24
			snapshot->whole  = (timer==g_heartbeat) ? clockTicks : 0;
     2d4:	80 91 00 00 	lds	r24, 0x0000
     2d8:	90 91 00 00 	lds	r25, 0x0000
     2dc:	08 17       	cp	r16, r24
     2de:	19 07       	cpc	r17, r25
     2e0:	01 f4       	brne	.+0      	; 0x2e2 <__timerRead+0x6c>
     2e2:	40 91 00 00 	lds	r20, 0x0000
     2e6:	50 91 00 00 	lds	r21, 0x0000
     2ea:	60 91 00 00 	lds	r22, 0x0000
     2ee:	70 91 00 00 	lds	r23, 0x0000
     2f2:	00 c0       	rjmp	.+0      	; 0x2f4 <__timerRead+0x7e>
     2f4:	40 e0       	ldi	r20, 0x00	; 0
     2f6:	50 e0       	ldi	r21, 0x00	; 0
     2f8:	ba 01       	movw	r22, r20
     2fa:	4a 83       	std	Y+2, r20	; 0x02
     2fc:	5b 83       	std	Y+3, r21	; 0x03
     2fe:	6c 83       	std	Y+4, r22	; 0x04
     300:	7d 83       	std	Y+5, r23	; 0x05
			snapshot->part   = timerGetCounter(timer);				// get the current ticks again
     302:	c8 01       	movw	r24, r16
     304:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     308:	9f 83       	std	Y+7, r25	; 0x07
     30a:	8e 83       	std	Y+6, r24	; 0x06
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || compareIsInterruptPending(channel)){
     30c:	8c 15       	cp	r24, r12
     30e:	9d 05       	cpc	r25, r13
     310:	00 f4       	brcc	.+0      	; 0x312 <__timerRead+0x9c>
				snapshot->whole+=1;
     312:	4a 81       	ldd	r20, Y+2	; 0x02
     314:	5b 81       	ldd	r21, Y+3	; 0x03
     316:	6c 81       	ldd	r22, Y+4	; 0x04
     318:	7d 81       	ldd	r23, Y+5	; 0x05
     31a:	4f 5f       	subi	r20, 0xFF	; 255
     31c:	5f 4f       	sbci	r21, 0xFF	; 255
     31e:	6f 4f       	sbci	r22, 0xFF	; 255
     320:	7f 4f       	sbci	r23, 0xFF	; 255
     322:	4a 83       	std	Y+2, r20	; 0x02
     324:	5b 83       	std	Y+3, r21	; 0x03
     326:	6c 83       	std	Y+4, r22	; 0x04
     328:	7d 83       	std	Y+5, r23	; 0x05
				snapshot->part = timerGetCounter(timer); 		// get the current ticks again
     32a:	c8 01       	movw	r24, r16
     32c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     330:	9f 83       	std	Y+7, r25	; 0x07
     332:	8e 83       	std	Y+6, r24	; 0x06
     334:	00 c0       	rjmp	.+0      	; 0x336 <__timerRead+0xc0>
//
//  Test if there is a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ boolean compareIsInterruptPending(const TimerCompare* channel){
	return __portMaskGet(&channel->pgm_intpending);
     336:	c7 01       	movw	r24, r14
     338:	08 96       	adiw	r24, 0x08	; 8
     33a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
			snapshot->part   = timerGetCounter(timer);				// get the current ticks again
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || compareIsInterruptPending(channel)){
     33e:	81 11       	cpse	r24, r1
     340:	00 c0       	rjmp	.+0      	; 0x342 <__timerRead+0xcc>
				snapshot->whole+=1;
				snapshot->part = timerGetCounter(timer); 		// get the current ticks again
			}
		}
		CRITICAL_SECTION_END;
     342:	bf be       	out	0x3f, r11	; 63
	}

	if(mode==TIMER_MODE_CTC_OCR
			|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
			|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
			|| mode==TIMER_MODE_PWM_FAST_OCR){
     344:	00 c0       	rjmp	.+0      	; 0x346 <__timerRead+0xd0>
			}
		}
		CRITICAL_SECTION_END;
	}else{
		// These modes generate overflow interrupts.
		CRITICAL_SECTION_START;
     346:	df b6       	in	r13, 0x3f	; 63
     348:	f8 94       	cli
		{
			uint16_t tcnt  = timerGetCounter(timer);	// get the current ticks
     34a:	c8 01       	movw	r24, r16
     34c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     350:	7c 01       	movw	r14, r24
			snapshot->whole = (timer==g_heartbeat) ? clockTicks : 0;
     352:	80 91 00 00 	lds	r24, 0x0000
     356:	90 91 00 00 	lds	r25, 0x0000
     35a:	08 17       	cp	r16, r24
     35c:	19 07       	cpc	r17, r25
     35e:	01 f4       	brne	.+0      	; 0x360 <__timerRead+0xea>
     360:	40 91 00 00 	lds	r20, 0x0000
     364:	50 91 00 00 	lds	r21, 0x0000
     368:	60 91 00 00 	lds	r22, 0x0000
     36c:	70 91 00 00 	lds	r23, 0x0000
     370:	00 c0       	rjmp	.+0      	; 0x372 <__timerRead+0xfc>
     372:	40 e0       	ldi	r20, 0x00	; 0
     374:	50 e0       	ldi	r21, 0x00	; 0
     376:	ba 01       	movw	r22, r20
     378:	4a 83       	std	Y+2, r20	; 0x02
     37a:	5b 83       	std	Y+3, r21	; 0x03
     37c:	6c 83       	std	Y+4, r22	; 0x04
     37e:	7d 83       	std	Y+5, r23	; 0x05
			snapshot->part = timerGetCounter(timer);				// get the current ticks again
     380:	c8 01       	movw	r24, r16
     382:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     386:	9f 83       	std	Y+7, r25	; 0x07
     388:	8e 83       	std	Y+6, r24	; 0x06
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || timerOverflowIsInterruptPending(timer)){
     38a:	8e 15       	cp	r24, r14
     38c:	9f 05       	cpc	r25, r15
     38e:	00 f4       	brcc	.+0      	; 0x390 <__timerRead+0x11a>
				snapshot->whole+=1;
     390:	4a 81       	ldd	r20, Y+2	; 0x02
     392:	5b 81       	ldd	r21, Y+3	; 0x03
     394:	6c 81       	ldd	r22, Y+4	; 0x04
     396:	7d 81       	ldd	r23, Y+5	; 0x05
     398:	4f 5f       	subi	r20, 0xFF	; 255
     39a:	5f 4f       	sbci	r21, 0xFF	; 255
     39c:	6f 4f       	sbci	r22, 0xFF	; 255
     39e:	7f 4f       	sbci	r23, 0xFF	; 255
     3a0:	4a 83       	std	Y+2, r20	; 0x02
     3a2:	5b 83       	std	Y+3, r21	; 0x03
     3a4:	6c 83       	std	Y+4, r22	; 0x04
     3a6:	7d 83       	std	Y+5, r23	; 0x05
				snapshot->part = timerGetCounter(timer); 		// get the current ticks again
     3a8:	c8 01       	movw	r24, r16
     3aa:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     3ae:	9f 83       	std	Y+7, r25	; 0x07
     3b0:	8e 83       	std	Y+6, r24	; 0x06
     3b2:	00 c0       	rjmp	.+0      	; 0x3b4 <__timerRead+0x13e>
//
//  Test if there is a pending overflow interrupt on the timer
//
------------------------------------------------------- */
static __inline__ boolean timerOverflowIsInterruptPending(const Timer* timer){
	return __portMaskGet(&timer->pgm_overflowreq);
     3b4:	c8 01       	movw	r24, r16
     3b6:	4c 96       	adiw	r24, 0x1c	; 28
     3b8:	0e 94 00 00 	call	0	; 0x0 <timerOff>
			snapshot->part = timerGetCounter(timer);				// get the current ticks again
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || timerOverflowIsInterruptPending(timer)){
     3bc:	81 11       	cpse	r24, r1
     3be:	00 c0       	rjmp	.+0      	; 0x3c0 <__timerRead+0x14a>
				snapshot->whole+=1;
				snapshot->part = timerGetCounter(timer); 		// get the current ticks again
			}
		}
		CRITICAL_SECTION_END;
     3c0:	df be       	out	0x3f, r13	; 63
	}
}
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	1f 91       	pop	r17
     3c8:	0f 91       	pop	r16
     3ca:	ff 90       	pop	r15
     3cc:	ef 90       	pop	r14
     3ce:	df 90       	pop	r13
     3d0:	cf 90       	pop	r12
     3d2:	bf 90       	pop	r11
     3d4:	08 95       	ret

000003d6 <clockGetSnapshot>:
	return timerSnapshotToTicks(&snapshot);
}


void clockGetSnapshot(TIMER_SNAPSHOT* snapshot){
	__timerRead(g_heartbeat, snapshot);
     3d6:	bc 01       	movw	r22, r24
     3d8:	80 91 00 00 	lds	r24, 0x0000
     3dc:	90 91 00 00 	lds	r25, 0x0000
     3e0:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

000003e4 <compareSetOutputMode>:
		}

	CRITICAL_SECTION_END;
}
void compareSetOutputMode(const TimerCompare* channel, CHANNEL_MODE mode){
	PORT port = pgm_read_word(&channel->pgm_com.port);
     3e4:	fc 01       	movw	r30, r24
     3e6:	3b 96       	adiw	r30, 0x0b	; 11
     3e8:	45 91       	lpm	r20, Z+
     3ea:	54 91       	lpm	r21, Z
	PIN  bit = pgm_read_byte(&channel->pgm_com.mask);
     3ec:	fc 01       	movw	r30, r24
     3ee:	3d 96       	adiw	r30, 0x0d	; 13
     3f0:	84 91       	lpm	r24, Z
	mode <<= bit;
     3f2:	08 2e       	mov	r0, r24
     3f4:	00 c0       	rjmp	.+0      	; 0x3f6 <compareSetOutputMode+0x12>
     3f6:	66 0f       	add	r22, r22
     3f8:	0a 94       	dec	r0
     3fa:	02 f4       	brpl	.+0      	; 0x3fc <compareSetOutputMode+0x18>

	PIN mask = BV(bit);	// occupies the next bit up as well
     3fc:	21 e0       	ldi	r18, 0x01	; 1
     3fe:	30 e0       	ldi	r19, 0x00	; 0
     400:	00 c0       	rjmp	.+0      	; 0x402 <compareSetOutputMode+0x1e>
     402:	22 0f       	add	r18, r18
     404:	8a 95       	dec	r24
     406:	02 f4       	brpl	.+0      	; 0x408 <compareSetOutputMode+0x24>
	mask |= (mask<<1);
     408:	82 2f       	mov	r24, r18
     40a:	88 0f       	add	r24, r24
     40c:	82 2b       	or	r24, r18

	_SFR_MEM8(port) = (_SFR_MEM8(port) & ~mask) | (mode & mask);
     40e:	fa 01       	movw	r30, r20
     410:	90 81       	ld	r25, Z
     412:	68 23       	and	r22, r24
     414:	80 95       	com	r24
     416:	89 23       	and	r24, r25
     418:	68 2b       	or	r22, r24
     41a:	60 83       	st	Z, r22
     41c:	08 95       	ret

0000041e <compareGetOutputMode>:
}

CHANNEL_MODE compareGetOutputMode(const TimerCompare* channel){
	PORT port = pgm_read_word(&channel->pgm_com.port);
     41e:	fc 01       	movw	r30, r24
     420:	3b 96       	adiw	r30, 0x0b	; 11
     422:	45 91       	lpm	r20, Z+
     424:	54 91       	lpm	r21, Z
	PIN  bit = pgm_read_byte(&channel->pgm_com.mask);
     426:	fc 01       	movw	r30, r24
     428:	3d 96       	adiw	r30, 0x0d	; 13
     42a:	64 91       	lpm	r22, Z

	PIN mask = BV(bit);	// occupies the next bit up as well
     42c:	21 e0       	ldi	r18, 0x01	; 1
     42e:	30 e0       	ldi	r19, 0x00	; 0
     430:	06 2e       	mov	r0, r22
     432:	00 c0       	rjmp	.+0      	; 0x434 <compareGetOutputMode+0x16>
     434:	22 0f       	add	r18, r18
     436:	0a 94       	dec	r0
     438:	02 f4       	brpl	.+0      	; 0x43a <compareGetOutputMode+0x1c>
	mask |= (mask<<1);

	uint8_t val = _SFR_MEM8(port) & mask;
     43a:	da 01       	movw	r26, r20
     43c:	8c 91       	ld	r24, X
CHANNEL_MODE compareGetOutputMode(const TimerCompare* channel){
	PORT port = pgm_read_word(&channel->pgm_com.port);
	PIN  bit = pgm_read_byte(&channel->pgm_com.mask);

	PIN mask = BV(bit);	// occupies the next bit up as well
	mask |= (mask<<1);
     43e:	92 2f       	mov	r25, r18
     440:	99 0f       	add	r25, r25
     442:	92 2b       	or	r25, r18

	uint8_t val = _SFR_MEM8(port) & mask;
     444:	98 23       	and	r25, r24
	val >>= bit;
     446:	89 2f       	mov	r24, r25
     448:	90 e0       	ldi	r25, 0x00	; 0
     44a:	00 c0       	rjmp	.+0      	; 0x44c <compareGetOutputMode+0x2e>
     44c:	95 95       	asr	r25
     44e:	87 95       	ror	r24
     450:	6a 95       	dec	r22
     452:	02 f4       	brpl	.+0      	; 0x454 <compareGetOutputMode+0x36>

	return (CHANNEL_MODE)val;
}
     454:	08 95       	ret

00000456 <__timer_overflowService>:
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     456:	fc 01       	movw	r30, r24
     458:	25 91       	lpm	r18, Z+
     45a:	34 91       	lpm	r19, Z
     45c:	d9 01       	movw	r26, r18
------------------------------------------------------- */
void __timer_overflowService(const Timer* timer){
	TimerData* td = timerGetData(timer);

// 	td->overflow++;	// increment the overflow counter
	if(td->overflow_callback){
     45e:	12 96       	adiw	r26, 0x02	; 2
     460:	ed 91       	ld	r30, X+
     462:	fc 91       	ld	r31, X
     464:	13 97       	sbiw	r26, 0x03	; 3
     466:	30 97       	sbiw	r30, 0x00	; 0
     468:	01 f0       	breq	.+0      	; 0x46a <__timer_overflowService+0x14>
		td->overflow_callback(timer,td->overflow_data);
     46a:	14 96       	adiw	r26, 0x04	; 4
     46c:	6d 91       	ld	r22, X+
     46e:	7c 91       	ld	r23, X
     470:	15 97       	sbiw	r26, 0x05	; 5
     472:	09 94       	ijmp
     474:	08 95       	ret

00000476 <__timer_captureService>:
     476:	fc 01       	movw	r30, r24
     478:	25 91       	lpm	r18, Z+
     47a:	34 91       	lpm	r19, Z
     47c:	d9 01       	movw	r26, r18
//
------------------------------------------------------- */
void __timer_captureService(const Timer* timer){
	TimerData* td = timerGetData(timer);

	if(td->capture_callback){
     47e:	16 96       	adiw	r26, 0x06	; 6
     480:	ed 91       	ld	r30, X+
     482:	fc 91       	ld	r31, X
     484:	17 97       	sbiw	r26, 0x07	; 7
     486:	30 97       	sbiw	r30, 0x00	; 0
     488:	01 f0       	breq	.+0      	; 0x48a <__timer_captureService+0x14>
		td->capture_callback(timer,td->capture_data);
     48a:	18 96       	adiw	r26, 0x08	; 8
     48c:	6d 91       	ld	r22, X+
     48e:	7c 91       	ld	r23, X
     490:	19 97       	sbiw	r26, 0x09	; 9
     492:	09 94       	ijmp
     494:	08 95       	ret

00000496 <__timer_compareService>:
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     496:	fc 01       	movw	r30, r24
     498:	25 91       	lpm	r18, Z+
     49a:	34 91       	lpm	r19, Z
     49c:	d9 01       	movw	r26, r18
//
------------------------------------------------------- */
void __timer_compareService(const TimerCompare* channel){
	TimerDataCompare* td = compareGetData(channel);
//	td->overflow++;
	if(td->compare_callback){
     49e:	ed 91       	ld	r30, X+
     4a0:	fc 91       	ld	r31, X
     4a2:	11 97       	sbiw	r26, 0x01	; 1
     4a4:	30 97       	sbiw	r30, 0x00	; 0
     4a6:	01 f0       	breq	.+0      	; 0x4a8 <__timer_compareService+0x12>
		td->compare_callback(channel,td->compare_data);
     4a8:	12 96       	adiw	r26, 0x02	; 2
     4aa:	6d 91       	ld	r22, X+
     4ac:	7c 91       	ld	r23, X
     4ae:	13 97       	sbiw	r26, 0x03	; 3
     4b0:	09 94       	ijmp
     4b2:	08 95       	ret

000004b4 <getError>:
	}

}

ERROR_CODE getError(void){
	 return __error.errorCode;
     4b4:	80 91 00 00 	lds	r24, 0x0000
}
     4b8:	08 95       	ret

000004ba <setError>:
	// queue the next event
	scheduleJob(&__error_flash, __error, lastTime, delay);

}

void setError(ERROR_CODE err){
     4ba:	df 92       	push	r13
     4bc:	ef 92       	push	r14
     4be:	ff 92       	push	r15
     4c0:	0f 93       	push	r16
     4c2:	1f 93       	push	r17
     4c4:	cf 93       	push	r28
     4c6:	df 93       	push	r29
     4c8:	d8 2e       	mov	r13, r24
	if(__error.errorCode==0){
     4ca:	80 91 00 00 	lds	r24, 0x0000
     4ce:	81 11       	cpse	r24, r1
     4d0:	00 c0       	rjmp	.+0      	; 0x4d2 <setError+0x18>
		__error.errorCode = err;
     4d2:	d0 92 00 00 	sts	0x0000, r13
		// Start to flash the error code if we can
		if(statusLED.pin != null && g_heartbeat != null){
     4d6:	20 91 00 00 	lds	r18, 0x0000
     4da:	30 91 00 00 	lds	r19, 0x0000
     4de:	23 2b       	or	r18, r19
     4e0:	01 f0       	breq	.+0      	; 0x4e2 <setError+0x28>
     4e2:	20 91 00 00 	lds	r18, 0x0000
     4e6:	30 91 00 00 	lds	r19, 0x0000
     4ea:	23 2b       	or	r18, r19
     4ec:	01 f0       	breq	.+0      	; 0x4ee <setError+0x34>
			scheduleJob(&__error_flash, &__error, clockGetus(),0);
     4ee:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     4f2:	9b 01       	movw	r18, r22
     4f4:	ac 01       	movw	r20, r24
     4f6:	e1 2c       	mov	r14, r1
     4f8:	f1 2c       	mov	r15, r1
     4fa:	87 01       	movw	r16, r14
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	80 e0       	ldi	r24, 0x00	; 0
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}

		// log to any rprintf writer
		Writer writer = __error.output;
     508:	80 91 00 00 	lds	r24, 0x0000
     50c:	90 91 00 00 	lds	r25, 0x0000
		if(writer){
     510:	00 97       	sbiw	r24, 0x00	; 0
     512:	01 f0       	breq	.+0      	; 0x514 <setError+0x5a>
			Writer old = rprintfInit(writer);
     514:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     518:	ec 01       	movw	r28, r24
     51a:	2d 2d       	mov	r18, r13
     51c:	33 27       	eor	r19, r19
     51e:	27 fd       	sbrc	r18, 7
     520:	30 95       	com	r19
			if(err < 0 ){
     522:	d7 fe       	sbrs	r13, 7
     524:	00 c0       	rjmp	.+0      	; 0x526 <setError+0x6c>
				rprintf("WebbotLib Error:%d\n",(int)-err);
     526:	31 95       	neg	r19
     528:	21 95       	neg	r18
     52a:	31 09       	sbc	r19, r1
     52c:	3f 93       	push	r19
     52e:	2f 93       	push	r18
     530:	20 e0       	ldi	r18, 0x00	; 0
     532:	30 e0       	ldi	r19, 0x00	; 0
     534:	00 c0       	rjmp	.+0      	; 0x536 <setError+0x7c>
			}else{
				rprintf("User Error:%d\n",(int)err);
     536:	3f 93       	push	r19
     538:	df 92       	push	r13
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	3f 93       	push	r19
     540:	2f 93       	push	r18
     542:	81 e0       	ldi	r24, 0x01	; 1
     544:	8f 93       	push	r24
     546:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     54a:	0f 90       	pop	r0
     54c:	0f 90       	pop	r0
     54e:	0f 90       	pop	r0
     550:	0f 90       	pop	r0
     552:	0f 90       	pop	r0
			}
			rprintfInit(old);
     554:	ce 01       	movw	r24, r28
		}

	}
}
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	0f 91       	pop	r16
     55e:	ff 90       	pop	r15
     560:	ef 90       	pop	r14
     562:	df 90       	pop	r13
			if(err < 0 ){
				rprintf("WebbotLib Error:%d\n",(int)-err);
			}else{
				rprintf("User Error:%d\n",(int)err);
			}
			rprintfInit(old);
     564:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
		}

	}
}
     568:	df 91       	pop	r29
     56a:	cf 91       	pop	r28
     56c:	1f 91       	pop	r17
     56e:	0f 91       	pop	r16
     570:	ff 90       	pop	r15
     572:	ef 90       	pop	r14
     574:	df 90       	pop	r13
     576:	08 95       	ret

00000578 <compareDetach>:
//
//  Detach any callback function from a timer
//
------------------------------------------------------- */
void compareDetach(const TimerCompare* channel)
{
     578:	cf 93       	push	r28
     57a:	df 93       	push	r29
     57c:	ec 01       	movw	r28, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     57e:	fc 01       	movw	r30, r24
     580:	32 96       	adiw	r30, 0x02	; 2
     582:	e4 91       	lpm	r30, Z
	const Timer* timer = compareGetTimer(channel);
     584:	8c e2       	ldi	r24, 0x2C	; 44
     586:	e8 9f       	mul	r30, r24
     588:	f0 01       	movw	r30, r0
     58a:	11 24       	eor	r1, r1

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     58c:	e0 50       	subi	r30, 0x00	; 0
     58e:	f0 40       	sbci	r31, 0x00	; 0
     590:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     592:	ee 23       	and	r30, r30
     594:	01 f0       	breq	.+0      	; 0x596 <compareDetach+0x1e>


		// Disallow compare interrupts for this channel
		__portMaskClear(&channel->pgm_intenable);
     596:	ce 01       	movw	r24, r28
     598:	03 96       	adiw	r24, 0x03	; 3
     59a:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Stop it from changing the output pin
		compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
     59e:	60 e0       	ldi	r22, 0x00	; 0
     5a0:	ce 01       	movw	r24, r28
     5a2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     5a6:	fe 01       	movw	r30, r28
     5a8:	a5 91       	lpm	r26, Z+
     5aa:	b4 91       	lpm	r27, Z

		// remove routine
		compareGetData(channel)->compare_callback = null;
     5ac:	1d 92       	st	X+, r1
     5ae:	1c 92       	st	X, r1
     5b0:	00 c0       	rjmp	.+0      	; 0x5b2 <compareDetach+0x3a>
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     5b2:	8d ef       	ldi	r24, 0xFD	; 253
	}
}
     5b4:	df 91       	pop	r29
     5b6:	cf 91       	pop	r28
		compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);

		// remove routine
		compareGetData(channel)->compare_callback = null;
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     5b8:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
	}
}
     5bc:	df 91       	pop	r29
     5be:	cf 91       	pop	r28
     5c0:	08 95       	ret

000005c2 <compareSetThreshold>:
	}
	return rtn;
}


void compareSetThreshold(const TimerCompare* channel, uint16_t threshold){
     5c2:	cf 93       	push	r28
     5c4:	df 93       	push	r29
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     5c6:	fc 01       	movw	r30, r24
     5c8:	32 96       	adiw	r30, 0x02	; 2
     5ca:	44 91       	lpm	r20, Z
	const Timer* timer = compareGetTimer(channel);
     5cc:	2c e2       	ldi	r18, 0x2C	; 44
     5ce:	42 9f       	mul	r20, r18
     5d0:	a0 01       	movw	r20, r0
     5d2:	11 24       	eor	r1, r1
     5d4:	40 50       	subi	r20, 0x00	; 0
     5d6:	50 40       	sbci	r21, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     5d8:	fa 01       	movw	r30, r20
     5da:	38 96       	adiw	r30, 0x08	; 8
     5dc:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     5de:	ee 23       	and	r30, r30
     5e0:	01 f0       	breq	.+0      	; 0x5e2 <compareSetThreshold+0x20>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
     5e2:	fc 01       	movw	r30, r24
     5e4:	36 96       	adiw	r30, 0x06	; 6
     5e6:	25 91       	lpm	r18, Z+
     5e8:	34 91       	lpm	r19, Z
     5ea:	d2 2f       	mov	r29, r18
     5ec:	c3 2f       	mov	r28, r19
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     5ee:	fa 01       	movw	r30, r20
     5f0:	36 96       	adiw	r30, 0x06	; 6
     5f2:	44 91       	lpm	r20, Z
		if(timerIs16bit(timer)){
     5f4:	44 23       	and	r20, r20
     5f6:	01 f0       	breq	.+0      	; 0x5f8 <compareSetThreshold+0x36>
			_SFR_MEM16(port) = threshold; 					// set 16 bit word
     5f8:	f9 01       	movw	r30, r18
     5fa:	71 83       	std	Z+1, r23	; 0x01
     5fc:	60 83       	st	Z, r22
     5fe:	00 c0       	rjmp	.+0      	; 0x600 <compareSetThreshold+0x3e>
		}else{
			if(threshold > 0xffU){
     600:	6f 3f       	cpi	r22, 0xFF	; 255
     602:	71 05       	cpc	r23, r1
     604:	01 f0       	breq	.+0      	; 0x606 <compareSetThreshold+0x44>
     606:	00 f0       	brcs	.+0      	; 0x608 <compareSetThreshold+0x46>
				threshold=0xffU;
				setError(TIMER_COMPARE_NOT_8_BIT);
     608:	8e ef       	ldi	r24, 0xFE	; 254
     60a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
		if(timerIs16bit(timer)){
			_SFR_MEM16(port) = threshold; 					// set 16 bit word
		}else{
			if(threshold > 0xffU){
				threshold=0xffU;
     60e:	6f ef       	ldi	r22, 0xFF	; 255
     610:	70 e0       	ldi	r23, 0x00	; 0
				setError(TIMER_COMPARE_NOT_8_BIT);
			}
			_SFR_MEM8(port) = threshold; 				// set low byte
     612:	ed 2f       	mov	r30, r29
     614:	fc 2f       	mov	r31, r28
     616:	60 83       	st	Z, r22
     618:	00 c0       	rjmp	.+0      	; 0x61a <compareSetThreshold+0x58>
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     61a:	8d ef       	ldi	r24, 0xFD	; 253
	}
}
     61c:	df 91       	pop	r29
     61e:	cf 91       	pop	r28
				setError(TIMER_COMPARE_NOT_8_BIT);
			}
			_SFR_MEM8(port) = threshold; 				// set low byte
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     620:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
	}
}
     624:	df 91       	pop	r29
     626:	cf 91       	pop	r28
     628:	08 95       	ret

0000062a <compareGetThreshold>:
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     62a:	fc 01       	movw	r30, r24
     62c:	32 96       	adiw	r30, 0x02	; 2
     62e:	44 91       	lpm	r20, Z
}

uint16_t compareGetThreshold(const TimerCompare* channel){
	uint16_t rtn;

	const Timer* timer = compareGetTimer(channel);
     630:	2c e2       	ldi	r18, 0x2C	; 44
     632:	42 9f       	mul	r20, r18
     634:	a0 01       	movw	r20, r0
     636:	11 24       	eor	r1, r1
     638:	40 50       	subi	r20, 0x00	; 0
     63a:	50 40       	sbci	r21, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     63c:	fa 01       	movw	r30, r20
     63e:	38 96       	adiw	r30, 0x08	; 8
     640:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     642:	ee 23       	and	r30, r30
     644:	01 f0       	breq	.+0      	; 0x646 <compareGetThreshold+0x1c>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
     646:	fc 01       	movw	r30, r24
     648:	36 96       	adiw	r30, 0x06	; 6
     64a:	25 91       	lpm	r18, Z+
     64c:	34 91       	lpm	r19, Z
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     64e:	fa 01       	movw	r30, r20
     650:	36 96       	adiw	r30, 0x06	; 6
     652:	44 91       	lpm	r20, Z
		if(timerIs16bit(timer)){
			rtn = _SFR_MEM16(port); 					// set 16 bit word
     654:	f9 01       	movw	r30, r18
	uint16_t rtn;

	const Timer* timer = compareGetTimer(channel);
	if(timerSupportsCompare(timer)){
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
		if(timerIs16bit(timer)){
     656:	44 23       	and	r20, r20
     658:	01 f0       	breq	.+0      	; 0x65a <compareGetThreshold+0x30>
			rtn = _SFR_MEM16(port); 					// set 16 bit word
     65a:	20 81       	ld	r18, Z
     65c:	31 81       	ldd	r19, Z+1	; 0x01
     65e:	00 c0       	rjmp	.+0      	; 0x660 <compareGetThreshold+0x36>
		}else{
			rtn = _SFR_MEM8(port); 					// set low byte
     660:	20 81       	ld	r18, Z
     662:	30 e0       	ldi	r19, 0x00	; 0
     664:	00 c0       	rjmp	.+0      	; 0x666 <compareGetThreshold+0x3c>
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     666:	8d ef       	ldi	r24, 0xFD	; 253
     668:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		rtn = 0xff;
     66c:	2f ef       	ldi	r18, 0xFF	; 255
     66e:	30 e0       	ldi	r19, 0x00	; 0
	}
	return rtn;
}
     670:	c9 01       	movw	r24, r18
     672:	08 95       	ret

00000674 <timerGetTOP>:
 *
 *  	Get the value of TOP for a given timer
 *  	will return 0 if the timer is not in use
 *
 -------------------------------------------------------*/
uint16_t timerGetTOP(const Timer* timer){
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	ec 01       	movw	r28, r24
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
     67a:	fc 01       	movw	r30, r24
     67c:	34 96       	adiw	r30, 0x04	; 4
     67e:	85 91       	lpm	r24, Z+
     680:	94 91       	lpm	r25, Z
     682:	fc 01       	movw	r30, r24
     684:	80 81       	ld	r24, Z
     686:	87 70       	andi	r24, 0x07	; 7
     688:	01 f4       	brne	.+0      	; 0x68a <timerGetTOP+0x16>
     68a:	00 c0       	rjmp	.+0      	; 0x68c <timerGetTOP+0x18>
		case TIMER_MODE_NORMAL:
			rtn = 0xffffU;
			break;
		case TIMER_MODE_PWM8_PHASE_CORRECT:
		case TIMER_MODE_PWM8_FAST:
			rtn = 0xffU;
     68c:	2f ef       	ldi	r18, 0xFF	; 255
     68e:	30 e0       	ldi	r19, 0x00	; 0
			break;
     690:	00 c0       	rjmp	.+0      	; 0x692 <timerGetTOP+0x1e>
		case TIMER_MODE_PWM9_PHASE_CORRECT:
		case TIMER_MODE_PWM9_FAST:
			rtn = 0x1ffU;
     692:	2f ef       	ldi	r18, 0xFF	; 255
     694:	31 e0       	ldi	r19, 0x01	; 1
			break;
     696:	00 c0       	rjmp	.+0      	; 0x698 <timerGetTOP+0x24>
		case TIMER_MODE_PWM10_PHASE_CORRECT:
		case TIMER_MODE_PWM10_FAST:
			rtn = 0x3ffU;
     698:	2f ef       	ldi	r18, 0xFF	; 255
     69a:	33 e0       	ldi	r19, 0x03	; 3
			break;
     69c:	00 c0       	rjmp	.+0      	; 0x69e <timerGetTOP+0x2a>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     69e:	fe 01       	movw	r30, r28
     6a0:	77 96       	adiw	r30, 0x17	; 23
     6a2:	25 91       	lpm	r18, Z+
     6a4:	34 91       	lpm	r19, Z
		case TIMER_MODE_PWM_PHASE_FREQ_OCR:
		case TIMER_MODE_PWM_PHASE_CORRECT_OCR:
		case TIMER_MODE_PWM_FAST_OCR:
			{
				const TimerCompare* tc = timerGetCompare(timer,0); // uses channel A
				rtn = compareGetThreshold(tc);
     6a6:	c9 01       	movw	r24, r18
     6a8:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     6ac:	9c 01       	movw	r18, r24
			}
			break;
     6ae:	00 c0       	rjmp	.+0      	; 0x6b0 <timerGetTOP+0x3c>
		case TIMER_MODE_PWM_PHASE_FREQ_ICR:
		case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
		case TIMER_MODE_CTC_ICR:
		case TIMER_MODE_PWM_FAST_ICR:
			{
				PORT icr = pgm_read_word(&timer->pgm_icr);
     6b0:	fe 01       	movw	r30, r28
     6b2:	7f 96       	adiw	r30, 0x1f	; 31
     6b4:	85 91       	lpm	r24, Z+
     6b6:	94 91       	lpm	r25, Z
				rtn = _SFR_MEM16(icr);
     6b8:	fc 01       	movw	r30, r24
     6ba:	20 81       	ld	r18, Z
     6bc:	31 81       	ldd	r19, Z+1	; 0x01
			}
			break;
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <timerGetTOP+0x4c>
uint16_t timerGetTOP(const Timer* timer){
	uint16_t rtn = 0;
	if(timerIsInUse(timer)){
		switch(timerGetMode(timer)){
		case TIMER_MODE_NORMAL:
			rtn = 0xffffU;
     6c0:	2f ef       	ldi	r18, 0xFF	; 255
     6c2:	3f ef       	ldi	r19, 0xFF	; 255
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     6c4:	fe 01       	movw	r30, r28
     6c6:	36 96       	adiw	r30, 0x06	; 6
     6c8:	c4 91       	lpm	r28, Z
			break;
		case TIMER_MODE_13_RESVD:
			break;
		}// end switch
	}
	if(!timerIs16bit(timer)){
     6ca:	c1 11       	cpse	r28, r1
     6cc:	00 c0       	rjmp	.+0      	; 0x6ce <timerGetTOP+0x5a>
		rtn &= 0xffu;
     6ce:	33 27       	eor	r19, r19
     6d0:	00 c0       	rjmp	.+0      	; 0x6d2 <timerGetTOP+0x5e>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     6d2:	fe 01       	movw	r30, r28
     6d4:	a5 91       	lpm	r26, Z+
     6d6:	b4 91       	lpm	r27, Z
 *
 -------------------------------------------------------*/
uint16_t timerGetTOP(const Timer* timer){
	uint16_t rtn = 0;
	if(timerIsInUse(timer)){
		switch(timerGetMode(timer)){
     6d8:	1a 96       	adiw	r26, 0x0a	; 10
     6da:	8c 91       	ld	r24, X
     6dc:	87 30       	cpi	r24, 0x07	; 7
     6de:	01 f0       	breq	.+0      	; 0x6e0 <timerGetTOP+0x6c>
     6e0:	00 f4       	brcc	.+0      	; 0x6e2 <timerGetTOP+0x6e>
     6e2:	83 30       	cpi	r24, 0x03	; 3
     6e4:	01 f0       	breq	.+0      	; 0x6e6 <timerGetTOP+0x72>
     6e6:	00 f4       	brcc	.+0      	; 0x6e8 <timerGetTOP+0x74>
     6e8:	81 30       	cpi	r24, 0x01	; 1
     6ea:	01 f0       	breq	.+0      	; 0x6ec <timerGetTOP+0x78>
     6ec:	00 f4       	brcc	.+0      	; 0x6ee <timerGetTOP+0x7a>
     6ee:	00 c0       	rjmp	.+0      	; 0x6f0 <timerGetTOP+0x7c>
     6f0:	85 30       	cpi	r24, 0x05	; 5
     6f2:	01 f4       	brne	.+0      	; 0x6f4 <timerGetTOP+0x80>
     6f4:	00 c0       	rjmp	.+0      	; 0x6f6 <timerGetTOP+0x82>
     6f6:	00 f0       	brcs	.+0      	; 0x6f8 <timerGetTOP+0x84>
     6f8:	00 c0       	rjmp	.+0      	; 0x6fa <timerGetTOP+0x86>
     6fa:	00 c0       	rjmp	.+0      	; 0x6fc <timerGetTOP+0x88>
     6fc:	8b 30       	cpi	r24, 0x0B	; 11
     6fe:	01 f4       	brne	.+0      	; 0x700 <timerGetTOP+0x8c>
     700:	00 c0       	rjmp	.+0      	; 0x702 <timerGetTOP+0x8e>
     702:	00 f4       	brcc	.+0      	; 0x704 <timerGetTOP+0x90>
     704:	89 30       	cpi	r24, 0x09	; 9
     706:	01 f4       	brne	.+0      	; 0x708 <timerGetTOP+0x94>
     708:	00 c0       	rjmp	.+0      	; 0x70a <timerGetTOP+0x96>
     70a:	8e 30       	cpi	r24, 0x0E	; 14
     70c:	01 f0       	breq	.+0      	; 0x70e <timerGetTOP+0x9a>
     70e:	8f 30       	cpi	r24, 0x0F	; 15
     710:	01 f4       	brne	.+0      	; 0x712 <timerGetTOP+0x9e>
     712:	00 c0       	rjmp	.+0      	; 0x714 <timerGetTOP+0xa0>
     714:	8c 30       	cpi	r24, 0x0C	; 12
     716:	01 f0       	breq	.+0      	; 0x718 <timerGetTOP+0xa4>
 *  	Get the value of TOP for a given timer
 *  	will return 0 if the timer is not in use
 *
 -------------------------------------------------------*/
uint16_t timerGetTOP(const Timer* timer){
	uint16_t rtn = 0;
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	00 c0       	rjmp	.+0      	; 0x71e <timerGetTOP+0xaa>
	}
	if(!timerIs16bit(timer)){
		rtn &= 0xffu;
	}
	return rtn;
}
     71e:	c9 01       	movw	r24, r18
     720:	df 91       	pop	r29
     722:	cf 91       	pop	r28
     724:	08 95       	ret

00000726 <timerSnapshotToTicks>:
		}
		CRITICAL_SECTION_END;
	}
}

TICK_COUNT timerSnapshotToTicks(const TIMER_SNAPSHOT* snapshot){
     726:	4f 92       	push	r4
     728:	5f 92       	push	r5
     72a:	6f 92       	push	r6
     72c:	7f 92       	push	r7
     72e:	8f 92       	push	r8
     730:	9f 92       	push	r9
     732:	af 92       	push	r10
     734:	bf 92       	push	r11
     736:	cf 92       	push	r12
     738:	df 92       	push	r13
     73a:	ef 92       	push	r14
     73c:	ff 92       	push	r15
     73e:	cf 93       	push	r28
     740:	df 93       	push	r29
     742:	ec 01       	movw	r28, r24
	TICK_COUNT rtn;
	TICK_COUNT top = timerGetTOP(snapshot->timer);
     744:	88 81       	ld	r24, Y
     746:	99 81       	ldd	r25, Y+1	; 0x01
     748:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     74c:	6c 01       	movw	r12, r24
     74e:	e1 2c       	mov	r14, r1
     750:	f1 2c       	mov	r15, r1

	if(snapshot->timer == g_heartbeat){
     752:	48 81       	ld	r20, Y
     754:	59 81       	ldd	r21, Y+1	; 0x01
     756:	20 91 00 00 	lds	r18, 0x0000
     75a:	30 91 00 00 	lds	r19, 0x0000
     75e:	6a 81       	ldd	r22, Y+2	; 0x02
     760:	7b 81       	ldd	r23, Y+3	; 0x03
     762:	8c 81       	ldd	r24, Y+4	; 0x04
     764:	9d 81       	ldd	r25, Y+5	; 0x05
     766:	ee 81       	ldd	r30, Y+6	; 0x06
     768:	ff 81       	ldd	r31, Y+7	; 0x07
     76a:	42 17       	cp	r20, r18
     76c:	53 07       	cpc	r21, r19
     76e:	01 f4       	brne	.+0      	; 0x770 <timerSnapshotToTicks+0x4a>
		rtn = snapshot->whole * _CLOCK_US_;
     770:	80 90 00 00 	lds	r8, 0x0000
     774:	90 90 00 00 	lds	r9, 0x0000
     778:	a0 90 00 00 	lds	r10, 0x0000
     77c:	b0 90 00 00 	lds	r11, 0x0000
     780:	a5 01       	movw	r20, r10
     782:	94 01       	movw	r18, r8
     784:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     788:	2b 01       	movw	r4, r22
     78a:	3c 01       	movw	r6, r24

		// top = _CLOCK_US_
		// part     x
		TICK_COUNT frac  = snapshot->part;
		frac *= _CLOCK_US_;
     78c:	df 01       	movw	r26, r30
     78e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		frac /= top;
     792:	a7 01       	movw	r20, r14
     794:	96 01       	movw	r18, r12
     796:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		rtn += frac;
     79a:	24 0d       	add	r18, r4
     79c:	35 1d       	adc	r19, r5
     79e:	46 1d       	adc	r20, r6
     7a0:	57 1d       	adc	r21, r7
     7a2:	00 c0       	rjmp	.+0      	; 0x7a4 <timerSnapshotToTicks+0x7e>

	}else{
		rtn = snapshot->whole;
		rtn*= (top + 1);
     7a4:	a7 01       	movw	r20, r14
     7a6:	96 01       	movw	r18, r12
     7a8:	2f 5f       	subi	r18, 0xFF	; 255
     7aa:	3f 4f       	sbci	r19, 0xFF	; 255
     7ac:	4f 4f       	sbci	r20, 0xFF	; 255
     7ae:	5f 4f       	sbci	r21, 0xFF	; 255
     7b0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     7b4:	9b 01       	movw	r18, r22
     7b6:	ac 01       	movw	r20, r24
		rtn+= snapshot->part;
     7b8:	2e 0f       	add	r18, r30
     7ba:	3f 1f       	adc	r19, r31
     7bc:	41 1d       	adc	r20, r1
     7be:	51 1d       	adc	r21, r1

	}
	return rtn;
}
     7c0:	b9 01       	movw	r22, r18
     7c2:	ca 01       	movw	r24, r20
     7c4:	df 91       	pop	r29
     7c6:	cf 91       	pop	r28
     7c8:	ff 90       	pop	r15
     7ca:	ef 90       	pop	r14
     7cc:	df 90       	pop	r13
     7ce:	cf 90       	pop	r12
     7d0:	bf 90       	pop	r11
     7d2:	af 90       	pop	r10
     7d4:	9f 90       	pop	r9
     7d6:	8f 90       	pop	r8
     7d8:	7f 90       	pop	r7
     7da:	6f 90       	pop	r6
     7dc:	5f 90       	pop	r5
     7de:	4f 90       	pop	r4
     7e0:	08 95       	ret

000007e2 <timerGetTicks>:

TICK_COUNT timerGetTicks(const Timer* timer){
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	cd b7       	in	r28, 0x3d	; 61
     7e8:	de b7       	in	r29, 0x3e	; 62
     7ea:	28 97       	sbiw	r28, 0x08	; 8
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	de bf       	out	0x3e, r29	; 62
     7f2:	0f be       	out	0x3f, r0	; 63
     7f4:	cd bf       	out	0x3d, r28	; 61

	TIMER_SNAPSHOT snapshot;
	__timerRead(timer, &snapshot);
     7f6:	be 01       	movw	r22, r28
     7f8:	6f 5f       	subi	r22, 0xFF	; 255
     7fa:	7f 4f       	sbci	r23, 0xFF	; 255
     7fc:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	return timerSnapshotToTicks(&snapshot);
     800:	ce 01       	movw	r24, r28
     802:	01 96       	adiw	r24, 0x01	; 1
     804:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     808:	28 96       	adiw	r28, 0x08	; 8
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	de bf       	out	0x3e, r29	; 62
     810:	0f be       	out	0x3f, r0	; 63
     812:	cd bf       	out	0x3d, r28	; 61
     814:	df 91       	pop	r29
     816:	cf 91       	pop	r28
     818:	08 95       	ret

0000081a <clockGetus>:
//  is about 70 minutes - this should not be a problem as you
//  will normally be using the heartbeat to measure durations
//  of less than one second.
------------------------------------------------------- */
TICK_COUNT clockGetus(void){
	return timerGetTicks(g_heartbeat);
     81a:	80 91 00 00 	lds	r24, 0x0000
     81e:	90 91 00 00 	lds	r25, 0x0000
     822:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

00000826 <clockHasElapsedGetOverflow>:
   returns true if the specified number of microseconds
   has passed since the start time
   If true then set overflow to the number of microseconds
   that it is exceeded bt
*/
boolean clockHasElapsedGetOverflow(TICK_COUNT usStart, TICK_COUNT usWait, TICK_COUNT* overflow){
     826:	af 92       	push	r10
     828:	bf 92       	push	r11
     82a:	cf 92       	push	r12
     82c:	df 92       	push	r13
     82e:	ef 92       	push	r14
     830:	ff 92       	push	r15
     832:	0f 93       	push	r16
     834:	1f 93       	push	r17
     836:	cf 93       	push	r28
     838:	df 93       	push	r29
     83a:	00 d0       	rcall	.+0      	; 0x83c <clockHasElapsedGetOverflow+0x16>
     83c:	00 d0       	rcall	.+0      	; 0x83e <clockHasElapsedGetOverflow+0x18>
     83e:	cd b7       	in	r28, 0x3d	; 61
     840:	de b7       	in	r29, 0x3e	; 62
     842:	6b 01       	movw	r12, r22
     844:	7c 01       	movw	r14, r24
     846:	58 01       	movw	r10, r16
	boolean rtn = FALSE;
	TICK_COUNT now = clockGetus();
     848:	29 83       	std	Y+1, r18	; 0x01
     84a:	3a 83       	std	Y+2, r19	; 0x02
     84c:	4b 83       	std	Y+3, r20	; 0x03
     84e:	5c 83       	std	Y+4, r21	; 0x04
     850:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	TICK_COUNT test = now;
	test -= usStart;			// The actual delay that has happened
     854:	6c 19       	sub	r22, r12
     856:	7d 09       	sbc	r23, r13
     858:	8e 09       	sbc	r24, r14
     85a:	9f 09       	sbc	r25, r15
	if( test  > usWait){
     85c:	29 81       	ldd	r18, Y+1	; 0x01
     85e:	3a 81       	ldd	r19, Y+2	; 0x02
     860:	4b 81       	ldd	r20, Y+3	; 0x03
     862:	5c 81       	ldd	r21, Y+4	; 0x04
     864:	26 17       	cp	r18, r22
     866:	37 07       	cpc	r19, r23
     868:	48 07       	cpc	r20, r24
     86a:	59 07       	cpc	r21, r25
     86c:	00 f4       	brcc	.+0      	; 0x86e <clockHasElapsedGetOverflow+0x48>
		TICK_COUNT ovr = test - usWait;
     86e:	dc 01       	movw	r26, r24
     870:	cb 01       	movw	r24, r22
     872:	82 1b       	sub	r24, r18
     874:	93 0b       	sbc	r25, r19
     876:	a4 0b       	sbc	r26, r20
     878:	b5 0b       	sbc	r27, r21
		*overflow = ovr;		// Return the number of microseconds we have overshot by
     87a:	f8 01       	movw	r30, r16
     87c:	80 83       	st	Z, r24
     87e:	91 83       	std	Z+1, r25	; 0x01
     880:	a2 83       	std	Z+2, r26	; 0x02
     882:	b3 83       	std	Z+3, r27	; 0x03
		rtn = TRUE;
     884:	8f ef       	ldi	r24, 0xFF	; 255
     886:	00 c0       	rjmp	.+0      	; 0x888 <clockHasElapsedGetOverflow+0x62>
	}else{
		TICK_COUNT ovr = usWait - test;
     888:	79 01       	movw	r14, r18
     88a:	8a 01       	movw	r16, r20
     88c:	e6 1a       	sub	r14, r22
     88e:	f7 0a       	sbc	r15, r23
     890:	08 0b       	sbc	r16, r24
     892:	19 0b       	sbc	r17, r25
		*overflow = ovr;		// Return the number of microseconds remaining
     894:	f5 01       	movw	r30, r10
     896:	e0 82       	st	Z, r14
     898:	f1 82       	std	Z+1, r15	; 0x01
     89a:	02 83       	std	Z+2, r16	; 0x02
     89c:	13 83       	std	Z+3, r17	; 0x03
   has passed since the start time
   If true then set overflow to the number of microseconds
   that it is exceeded bt
*/
boolean clockHasElapsedGetOverflow(TICK_COUNT usStart, TICK_COUNT usWait, TICK_COUNT* overflow){
	boolean rtn = FALSE;
     89e:	80 e0       	ldi	r24, 0x00	; 0
	}else{
		TICK_COUNT ovr = usWait - test;
		*overflow = ovr;		// Return the number of microseconds remaining
	}
	return rtn;
}
     8a0:	0f 90       	pop	r0
     8a2:	0f 90       	pop	r0
     8a4:	0f 90       	pop	r0
     8a6:	0f 90       	pop	r0
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	df 90       	pop	r13
     8b6:	cf 90       	pop	r12
     8b8:	bf 90       	pop	r11
     8ba:	af 90       	pop	r10
     8bc:	08 95       	ret

000008be <clockWaitus>:
void clockWaitms(TICK_COUNT ms){
	clockWaitus(ms*1000UL);
}

/* Pause for the given number of microseconds */
void clockWaitus(TICK_COUNT us){
     8be:	8f 92       	push	r8
     8c0:	9f 92       	push	r9
     8c2:	af 92       	push	r10
     8c4:	bf 92       	push	r11
     8c6:	cf 92       	push	r12
     8c8:	df 92       	push	r13
     8ca:	ef 92       	push	r14
     8cc:	ff 92       	push	r15
     8ce:	6b 01       	movw	r12, r22
     8d0:	7c 01       	movw	r14, r24
	TICK_COUNT start = clockGetus();
     8d2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     8d6:	4b 01       	movw	r8, r22
     8d8:	5c 01       	movw	r10, r24
	while(clockGetus() - start < us){
     8da:	00 c0       	rjmp	.+0      	; 0x8dc <clockWaitus+0x1e>
		nop();
     8dc:	00 00       	nop
}

/* Pause for the given number of microseconds */
void clockWaitus(TICK_COUNT us){
	TICK_COUNT start = clockGetus();
	while(clockGetus() - start < us){
     8de:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     8e2:	68 19       	sub	r22, r8
     8e4:	79 09       	sbc	r23, r9
     8e6:	8a 09       	sbc	r24, r10
     8e8:	9b 09       	sbc	r25, r11
     8ea:	6c 15       	cp	r22, r12
     8ec:	7d 05       	cpc	r23, r13
     8ee:	8e 05       	cpc	r24, r14
     8f0:	9f 05       	cpc	r25, r15
     8f2:	00 f0       	brcs	.+0      	; 0x8f4 <clockWaitus+0x36>
//	uint16_t mhz = cpu_speed_div_1000000;
//	TICK_COUNT pause = (us / prescaler) * mhz;
//	while(pause > (timerGetTicks(g_heartbeat) - start)){
//		nop();
//	}
}
     8f4:	ff 90       	pop	r15
     8f6:	ef 90       	pop	r14
     8f8:	df 90       	pop	r13
     8fa:	cf 90       	pop	r12
     8fc:	bf 90       	pop	r11
     8fe:	af 90       	pop	r10
     900:	9f 90       	pop	r9
     902:	8f 90       	pop	r8
     904:	08 95       	ret

00000906 <clockWaitms>:
	return FALSE;
}


/* waits (pauses) for the specified number of milliseconds */
void clockWaitms(TICK_COUNT ms){
     906:	9b 01       	movw	r18, r22
     908:	ac 01       	movw	r20, r24
	clockWaitus(ms*1000UL);
     90a:	a8 ee       	ldi	r26, 0xE8	; 232
     90c:	b3 e0       	ldi	r27, 0x03	; 3
     90e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     912:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

00000916 <delay_ms>:

/*
    Delay for a given number of milliseconds
*/
void delay_ms(uint32_t __ms){
	if(g_heartbeat){
     916:	20 91 00 00 	lds	r18, 0x0000
     91a:	30 91 00 00 	lds	r19, 0x0000
     91e:	23 2b       	or	r18, r19
     920:	01 f0       	breq	.+0      	; 0x922 <delay_ms+0xc>
		clockWaitms(__ms);
     922:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     926:	a0 91 00 00 	lds	r26, 0x0000
     92a:	b0 91 00 00 	lds	r27, 0x0000
     92e:	9b 01       	movw	r18, r22
     930:	ac 01       	movw	r20, r24
     932:	0e 94 00 00 	call	0	; 0x0 <timerOff>
void delay_ms(uint32_t __ms){
	if(g_heartbeat){
		clockWaitms(__ms);
	}else{
		uint32_t cycles = ticks_per_ms(__ms, 1U);
		delay_cycles(cycles);
     936:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

0000093a <delay_us>:

/*
	Delay for a given number of microseconds
*/
void delay_us(uint32_t __us){
	if(g_heartbeat && __us > 100){
     93a:	20 91 00 00 	lds	r18, 0x0000
     93e:	30 91 00 00 	lds	r19, 0x0000
     942:	23 2b       	or	r18, r19
     944:	01 f0       	breq	.+0      	; 0x946 <delay_us+0xc>
     946:	65 36       	cpi	r22, 0x65	; 101
     948:	71 05       	cpc	r23, r1
     94a:	81 05       	cpc	r24, r1
     94c:	91 05       	cpc	r25, r1
     94e:	00 f0       	brcs	.+0      	; 0x950 <delay_us+0x16>
		clockWaitus(__us);
     950:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     954:	a0 91 00 00 	lds	r26, 0x0000
     958:	b0 91 00 00 	lds	r27, 0x0000
     95c:	9b 01       	movw	r18, r22
     95e:	ac 01       	movw	r20, r24
     960:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     964:	28 ee       	ldi	r18, 0xE8	; 232
     966:	33 e0       	ldi	r19, 0x03	; 3
     968:	40 e0       	ldi	r20, 0x00	; 0
     96a:	50 e0       	ldi	r21, 0x00	; 0
     96c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
void delay_us(uint32_t __us){
	if(g_heartbeat && __us > 100){
		clockWaitus(__us);
	}else{
		uint32_t cycles = ticks_per_ms(__us, 1000U);
		delay_cycles(cycles);
     970:	ca 01       	movw	r24, r20
     972:	b9 01       	movw	r22, r18
     974:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>

00000978 <clockHasElapsed>:

/*
   returns true if the specified number of microseconds
   has passed since the start time
*/
boolean clockHasElapsed(TICK_COUNT usStart, TICK_COUNT usWait){
     978:	cf 92       	push	r12
     97a:	df 92       	push	r13
     97c:	ef 92       	push	r14
     97e:	ff 92       	push	r15
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	00 d0       	rcall	.+0      	; 0x986 <clockHasElapsed+0xe>
     986:	00 d0       	rcall	.+0      	; 0x988 <clockHasElapsed+0x10>
     988:	cd b7       	in	r28, 0x3d	; 61
     98a:	de b7       	in	r29, 0x3e	; 62
     98c:	6b 01       	movw	r12, r22
     98e:	7c 01       	movw	r14, r24
	TICK_COUNT now = clockGetus();
     990:	29 83       	std	Y+1, r18	; 0x01
     992:	3a 83       	std	Y+2, r19	; 0x02
     994:	4b 83       	std	Y+3, r20	; 0x03
     996:	5c 83       	std	Y+4, r21	; 0x04
     998:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	TICK_COUNT test = now;
	test -= usStart;
     99c:	6c 19       	sub	r22, r12
     99e:	7d 09       	sbc	r23, r13
     9a0:	8e 09       	sbc	r24, r14
     9a2:	9f 09       	sbc	r25, r15
	if( test  >= usWait){
     9a4:	29 81       	ldd	r18, Y+1	; 0x01
     9a6:	3a 81       	ldd	r19, Y+2	; 0x02
     9a8:	4b 81       	ldd	r20, Y+3	; 0x03
     9aa:	5c 81       	ldd	r21, Y+4	; 0x04
     9ac:	62 17       	cp	r22, r18
     9ae:	73 07       	cpc	r23, r19
     9b0:	84 07       	cpc	r24, r20
     9b2:	95 07       	cpc	r25, r21
     9b4:	00 f0       	brcs	.+0      	; 0x9b6 <clockHasElapsed+0x3e>
		return TRUE;
     9b6:	8f ef       	ldi	r24, 0xFF	; 255
     9b8:	00 c0       	rjmp	.+0      	; 0x9ba <clockHasElapsed+0x42>
	}
	return FALSE;
     9ba:	80 e0       	ldi	r24, 0x00	; 0
}
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	0f 90       	pop	r0
     9c2:	0f 90       	pop	r0
     9c4:	df 91       	pop	r29
     9c6:	cf 91       	pop	r28
     9c8:	ff 90       	pop	r15
     9ca:	ef 90       	pop	r14
     9cc:	df 90       	pop	r13
     9ce:	cf 90       	pop	r12
     9d0:	08 95       	ret

000009d2 <timerGetBestPrescaler>:
		prescale++;
	}
	return prescale;
}

uint16_t timerGetBestPrescaler(const Timer* timer, uint16_t repeat_ms){
     9d2:	4f 92       	push	r4
     9d4:	5f 92       	push	r5
     9d6:	6f 92       	push	r6
     9d8:	7f 92       	push	r7
     9da:	8f 92       	push	r8
     9dc:	9f 92       	push	r9
     9de:	af 92       	push	r10
     9e0:	bf 92       	push	r11
     9e2:	cf 92       	push	r12
     9e4:	df 92       	push	r13
     9e6:	ef 92       	push	r14
     9e8:	ff 92       	push	r15
     9ea:	0f 93       	push	r16
     9ec:	1f 93       	push	r17
     9ee:	cf 93       	push	r28
     9f0:	df 93       	push	r29
     9f2:	2c 01       	movw	r4, r24
     9f4:	9b 01       	movw	r18, r22
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     9f6:	fc 01       	movw	r30, r24
     9f8:	36 96       	adiw	r30, 0x06	; 6
     9fa:	e4 91       	lpm	r30, Z
	uint32_t maxval;

	// Find maximum value for the timer counter
	if(timerIs16bit(timer)){
     9fc:	ee 23       	and	r30, r30
     9fe:	01 f0       	breq	.+0      	; 0xa00 <timerGetBestPrescaler+0x2e>
		maxval = 0xffffU;
     a00:	cc 24       	eor	r12, r12
     a02:	ca 94       	dec	r12
     a04:	dc 2c       	mov	r13, r12
     a06:	e1 2c       	mov	r14, r1
     a08:	f1 2c       	mov	r15, r1
     a0a:	00 c0       	rjmp	.+0      	; 0xa0c <timerGetBestPrescaler+0x3a>
	}else{
		maxval = 0xffU;
     a0c:	c1 2c       	mov	r12, r1
     a0e:	d1 2c       	mov	r13, r1
     a10:	76 01       	movw	r14, r12
     a12:	ca 94       	dec	r12

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     a14:	a0 91 00 00 	lds	r26, 0x0000
     a18:	b0 91 00 00 	lds	r27, 0x0000
     a1c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     a20:	4b 01       	movw	r8, r22
     a22:	5c 01       	movw	r10, r24
     a24:	0b e0       	ldi	r16, 0x0B	; 11
     a26:	10 e0       	ldi	r17, 0x00	; 0
	}else{
		maxval = 0xffU;
	}

	uint16_t prescale;
	uint16_t available=1;
     a28:	66 24       	eor	r6, r6
     a2a:	63 94       	inc	r6
     a2c:	71 2c       	mov	r7, r1
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
     a2e:	c1 e0       	ldi	r28, 0x01	; 1
     a30:	d0 e0       	ldi	r29, 0x00	; 0
		int inx = __timerPrescalerIndex(timer, prescale);
     a32:	be 01       	movw	r22, r28
     a34:	c2 01       	movw	r24, r4
     a36:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		if(inx!=-1){
     a3a:	01 96       	adiw	r24, 0x01	; 1
     a3c:	01 f0       	breq	.+0      	; 0xa3e <timerGetBestPrescaler+0x6c>

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     a3e:	9e 01       	movw	r18, r28
     a40:	40 e0       	ldi	r20, 0x00	; 0
     a42:	50 e0       	ldi	r21, 0x00	; 0
     a44:	c5 01       	movw	r24, r10
     a46:	b4 01       	movw	r22, r8
     a48:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
		int inx = __timerPrescalerIndex(timer, prescale);
		if(inx!=-1){
			available = prescale;

			if(ticks_per_ms(repeat_ms,prescale)<= maxval){
     a4c:	c2 16       	cp	r12, r18
     a4e:	d3 06       	cpc	r13, r19
     a50:	e4 06       	cpc	r14, r20
     a52:	f5 06       	cpc	r15, r21
     a54:	00 f4       	brcc	.+0      	; 0xa56 <timerGetBestPrescaler+0x84>
     a56:	3e 01       	movw	r6, r28
		maxval = 0xffU;
	}

	uint16_t prescale;
	uint16_t available=1;
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
     a58:	cc 0f       	add	r28, r28
     a5a:	dd 1f       	adc	r29, r29
     a5c:	01 50       	subi	r16, 0x01	; 1
     a5e:	11 09       	sbc	r17, r1
     a60:	01 f4       	brne	.+0      	; 0xa62 <timerGetBestPrescaler+0x90>
			if(ticks_per_ms(repeat_ms,prescale)<= maxval){
				return prescale;
			}
		}
	}
	setError(NO_APPROPRIATE_TIMER_PRESCALE_VALUES);
     a62:	88 ef       	ldi	r24, 0xF8	; 248
     a64:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	return available;
     a68:	e3 01       	movw	r28, r6
}
     a6a:	ce 01       	movw	r24, r28
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	1f 91       	pop	r17
     a72:	0f 91       	pop	r16
     a74:	ff 90       	pop	r15
     a76:	ef 90       	pop	r14
     a78:	df 90       	pop	r13
     a7a:	cf 90       	pop	r12
     a7c:	bf 90       	pop	r11
     a7e:	af 90       	pop	r10
     a80:	9f 90       	pop	r9
     a82:	8f 90       	pop	r8
     a84:	7f 90       	pop	r7
     a86:	6f 90       	pop	r6
     a88:	5f 90       	pop	r5
     a8a:	4f 90       	pop	r4
     a8c:	08 95       	ret

00000a8e <timerSetPrescaler>:
	return -1;
}



void timerSetPrescaler(const Timer* timer, uint16_t prescaler){
     a8e:	df 92       	push	r13
     a90:	ef 92       	push	r14
     a92:	ff 92       	push	r15
     a94:	0f 93       	push	r16
     a96:	1f 93       	push	r17
     a98:	cf 93       	push	r28
     a9a:	df 93       	push	r29
     a9c:	ec 01       	movw	r28, r24
     a9e:	7b 01       	movw	r14, r22
	PORT pre = pgm_read_word(&timer->pgm_prescaler);
     aa0:	fc 01       	movw	r30, r24
     aa2:	34 96       	adiw	r30, 0x04	; 4
     aa4:	05 91       	lpm	r16, Z+
     aa6:	14 91       	lpm	r17, Z

	CRITICAL_SECTION_START;
     aa8:	df b6       	in	r13, 0x3f	; 63
     aaa:	f8 94       	cli
	int inx = __timerPrescalerIndex(timer,prescaler);
     aac:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	if(inx!=-1){
     ab0:	8f 3f       	cpi	r24, 0xFF	; 255
     ab2:	2f ef       	ldi	r18, 0xFF	; 255
     ab4:	92 07       	cpc	r25, r18
     ab6:	01 f0       	breq	.+0      	; 0xab8 <timerSetPrescaler+0x2a>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     ab8:	fe 01       	movw	r30, r28
     aba:	a5 91       	lpm	r26, Z+
     abc:	b4 91       	lpm	r27, Z
		timerGetData(timer)->prescale_value = prescaler;
     abe:	ed 92       	st	X+, r14
     ac0:	fc 92       	st	X, r15
		_SFR_MEM8(pre) &= ~ TIMER_PRESCALE_MASK;
     ac2:	f8 01       	movw	r30, r16
     ac4:	90 81       	ld	r25, Z
     ac6:	98 7f       	andi	r25, 0xF8	; 248
     ac8:	90 83       	st	Z, r25
		_SFR_MEM8(pre) |= inx;
     aca:	90 81       	ld	r25, Z
     acc:	98 2b       	or	r25, r24
     ace:	90 83       	st	Z, r25
     ad0:	00 c0       	rjmp	.+0      	; 0xad2 <timerSetPrescaler+0x44>
	}else{
		setError(TIMER_PRESCALER_UNSUPPORTED);
     ad2:	8a ef       	ldi	r24, 0xFA	; 250
     ad4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}
	CRITICAL_SECTION_END;
     ad8:	df be       	out	0x3f, r13	; 63

}
     ada:	df 91       	pop	r29
     adc:	cf 91       	pop	r28
     ade:	1f 91       	pop	r17
     ae0:	0f 91       	pop	r16
     ae2:	ff 90       	pop	r15
     ae4:	ef 90       	pop	r14
     ae6:	df 90       	pop	r13
     ae8:	08 95       	ret

00000aea <timerInit>:
//  Reset the timer + overflow to 0
//  Reset the prescaler to the current value
//  leave any overflow callback methods in place
//
------------------------------------------------------- */
void timerInit(const Timer* timer){
     aea:	7f 92       	push	r7
     aec:	8f 92       	push	r8
     aee:	9f 92       	push	r9
     af0:	af 92       	push	r10
     af2:	bf 92       	push	r11
     af4:	cf 92       	push	r12
     af6:	df 92       	push	r13
     af8:	ef 92       	push	r14
     afa:	ff 92       	push	r15
     afc:	0f 93       	push	r16
     afe:	1f 93       	push	r17
     b00:	cf 93       	push	r28
     b02:	df 93       	push	r29
     b04:	ec 01       	movw	r28, r24
	uint8_t i;

	// Get data from ROM to RAM
	PORT counter = pgm_read_word(&timer->pgm_counter);
     b06:	fc 01       	movw	r30, r24
     b08:	32 96       	adiw	r30, 0x02	; 2
     b0a:	e5 90       	lpm	r14, Z+
     b0c:	f4 90       	lpm	r15, Z
     b0e:	fc 01       	movw	r30, r24
     b10:	85 91       	lpm	r24, Z+
     b12:	94 91       	lpm	r25, Z
     b14:	8c 01       	movw	r16, r24
	TimerData* data = timerGetData(timer);

	CRITICAL_SECTION_START;
     b16:	8f b6       	in	r8, 0x3f	; 63
     b18:	f8 94       	cli

		// Turn the timer off for now
		timerOff(timer);
     b1a:	ce 01       	movw	r24, r28
     b1c:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Disallow timer overflow interrupt for now
		__portMaskClear(&timer->pgm_overflowint);
     b20:	6e 01       	movw	r12, r28
     b22:	89 e1       	ldi	r24, 0x19	; 25
     b24:	c8 0e       	add	r12, r24
     b26:	d1 1c       	adc	r13, r1
     b28:	c6 01       	movw	r24, r12
     b2a:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Clear the pre-overflow counter register
		_SFR_MEM8(counter) = 0;
     b2e:	f7 01       	movw	r30, r14
     b30:	10 82       	st	Z, r1

		// Clear the overflow counter
//		data->overflow = 0;

		// Set up the prescaler and turn the timer back on
		timerSetPrescaler(timer,data->prescale_value);
     b32:	f8 01       	movw	r30, r16
     b34:	60 81       	ld	r22, Z
     b36:	71 81       	ldd	r23, Z+1	; 0x01
     b38:	ce 01       	movw	r24, r28
     b3a:	0e 94 00 00 	call	0	; 0x0 <timerOff>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     b3e:	fe 01       	movw	r30, r28
     b40:	38 96       	adiw	r30, 0x08	; 8
     b42:	74 90       	lpm	r7, Z

		// Initialise the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(i=0;i<numCompare;i++){
     b44:	e1 2c       	mov	r14, r1
     b46:	f1 2c       	mov	r15, r1
     b48:	91 2c       	mov	r9, r1
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     b4a:	fe 01       	movw	r30, r28
     b4c:	77 96       	adiw	r30, 0x17	; 23
     b4e:	a5 90       	lpm	r10, Z+
     b50:	b4 90       	lpm	r11, Z
     b52:	00 c0       	rjmp	.+0      	; 0xb54 <timerInit+0x6a>
     b54:	c5 01       	movw	r24, r10
     b56:	8e 0d       	add	r24, r14
     b58:	9f 1d       	adc	r25, r15
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
     b5a:	08 96       	adiw	r24, 0x08	; 8
     b5c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     b60:	93 94       	inc	r9
     b62:	f0 e1       	ldi	r31, 0x10	; 16
     b64:	ef 0e       	add	r14, r31
     b66:	f1 1c       	adc	r15, r1
     b68:	97 10       	cpse	r9, r7
     b6a:	00 c0       	rjmp	.+0      	; 0xb6c <timerInit+0x82>
//
//  Remove any pending overflow interrupt
//
------------------------------------------------------- */
static __inline__ void timerOverflowClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_overflowreq);
     b6c:	ce 01       	movw	r24, r28
     b6e:	4c 96       	adiw	r24, 0x1c	; 28
     b70:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Remove any interrupt pending
		timerOverflowClearInterruptPending(timer);

		// If there is an overflow callback then re-enable timer overflow interrupt
		if(data->overflow_callback!=null){
     b74:	f8 01       	movw	r30, r16
     b76:	82 81       	ldd	r24, Z+2	; 0x02
     b78:	93 81       	ldd	r25, Z+3	; 0x03
     b7a:	89 2b       	or	r24, r25
     b7c:	01 f0       	breq	.+0      	; 0xb7e <timerInit+0x94>
			__portMaskSet(&timer->pgm_overflowint);
     b7e:	c6 01       	movw	r24, r12
     b80:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}

	CRITICAL_SECTION_END;
     b84:	8f be       	out	0x3f, r8	; 63
}
     b86:	df 91       	pop	r29
     b88:	cf 91       	pop	r28
     b8a:	1f 91       	pop	r17
     b8c:	0f 91       	pop	r16
     b8e:	ff 90       	pop	r15
     b90:	ef 90       	pop	r14
     b92:	df 90       	pop	r13
     b94:	cf 90       	pop	r12
     b96:	bf 90       	pop	r11
     b98:	af 90       	pop	r10
     b9a:	9f 90       	pop	r9
     b9c:	8f 90       	pop	r8
     b9e:	7f 90       	pop	r7
     ba0:	08 95       	ret

00000ba2 <timerSetMode>:
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     ba2:	bf 92       	push	r11
     ba4:	cf 92       	push	r12
     ba6:	df 92       	push	r13
     ba8:	ef 92       	push	r14
     baa:	ff 92       	push	r15
     bac:	0f 93       	push	r16
     bae:	1f 93       	push	r17
     bb0:	cf 93       	push	r28
     bb2:	df 93       	push	r29
     bb4:	ec 01       	movw	r28, r24
	if(mode == TIMER_MODE_NORMAL || timerGetMode(timer)!=mode){
     bb6:	66 23       	and	r22, r22
     bb8:	01 f0       	breq	.+0      	; 0xbba <timerSetMode+0x18>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     bba:	fc 01       	movw	r30, r24
     bbc:	a5 91       	lpm	r26, Z+
     bbe:	b4 91       	lpm	r27, Z
     bc0:	1a 96       	adiw	r26, 0x0a	; 10
     bc2:	8c 91       	ld	r24, X
     bc4:	86 17       	cp	r24, r22
     bc6:	01 f4       	brne	.+0      	; 0xbc8 <timerSetMode+0x26>
     bc8:	00 c0       	rjmp	.+0      	; 0xbca <timerSetMode+0x28>
		uint16_t abilities = pgm_read_word(&timer->pgm_modes);	// Get the bitmasks of modes availables
     bca:	fe 01       	movw	r30, r28
     bcc:	39 96       	adiw	r30, 0x09	; 9
     bce:	25 91       	lpm	r18, Z+
     bd0:	34 91       	lpm	r19, Z
		uint8_t wgm=255;

		if(BV(mode) & abilities){
     bd2:	46 2f       	mov	r20, r22
     bd4:	50 e0       	ldi	r21, 0x00	; 0
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	06 2e       	mov	r0, r22
     bdc:	00 c0       	rjmp	.+0      	; 0xbde <timerSetMode+0x3c>
     bde:	88 0f       	add	r24, r24
     be0:	99 1f       	adc	r25, r25
     be2:	0a 94       	dec	r0
     be4:	02 f4       	brpl	.+0      	; 0xbe6 <timerSetMode+0x44>
     be6:	82 23       	and	r24, r18
     be8:	93 23       	and	r25, r19
     bea:	89 2b       	or	r24, r25
     bec:	01 f0       	breq	.+0      	; 0xbee <timerSetMode+0x4c>
     bee:	fe 01       	movw	r30, r28
     bf0:	a5 91       	lpm	r26, Z+
     bf2:	b4 91       	lpm	r27, Z
			// It is capable of the mode

			// Save the new mode
			timerGetData(timer)->mode = mode;
     bf4:	1a 96       	adiw	r26, 0x0a	; 10
     bf6:	6c 93       	st	X, r22

			if(abilities == TIMER_ALL_MODES){
     bf8:	2f 3f       	cpi	r18, 0xFF	; 255
     bfa:	8f ed       	ldi	r24, 0xDF	; 223
     bfc:	38 07       	cpc	r19, r24
     bfe:	01 f0       	breq	.+0      	; 0xc00 <timerSetMode+0x5e>
				wgm = mode;
			}else if(abilities == TIMER_3BIT_MODES){
     c00:	23 33       	cpi	r18, 0x33	; 51
     c02:	98 e8       	ldi	r25, 0x88	; 136
     c04:	39 07       	cpc	r19, r25
     c06:	01 f4       	brne	.+0      	; 0xc08 <timerSetMode+0x66>
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__3bit_modes[mode]);
     c08:	fa 01       	movw	r30, r20
     c0a:	e0 50       	subi	r30, 0x00	; 0
     c0c:	f0 40       	sbci	r31, 0x00	; 0
     c0e:	00 c0       	rjmp	.+0      	; 0xc10 <timerSetMode+0x6e>
			}else if(abilities == TIMER_2BIT_MODES){
     c10:	23 33       	cpi	r18, 0x33	; 51
     c12:	31 05       	cpc	r19, r1
     c14:	01 f4       	brne	.+0      	; 0xc16 <timerSetMode+0x74>
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__2bit_modes[mode]);
     c16:	fa 01       	movw	r30, r20
     c18:	e0 50       	subi	r30, 0x00	; 0
     c1a:	f0 40       	sbci	r31, 0x00	; 0
     c1c:	d4 90       	lpm	r13, Z
     c1e:	00 c0       	rjmp	.+0      	; 0xc20 <timerSetMode+0x7e>
			// It is capable of the mode

			// Save the new mode
			timerGetData(timer)->mode = mode;

			if(abilities == TIMER_ALL_MODES){
     c20:	d6 2e       	mov	r13, r22
				wgm = pgm_read_byte(&__3bit_modes[mode]);
			}else if(abilities == TIMER_2BIT_MODES){
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__2bit_modes[mode]);
			}
			if(wgm==255){
     c22:	af ef       	ldi	r26, 0xFF	; 255
     c24:	da 12       	cpse	r13, r26
     c26:	00 c0       	rjmp	.+0      	; 0xc28 <timerSetMode+0x86>
				// Mode is not supported
				setError(TIMER_MODE_NOT_SUPPORTED);
     c28:	86 ef       	ldi	r24, 0xF6	; 246
		}else{
			// Timer is not able to do this mode
			setError(TIMER_MODE_NOT_SUPPORTED);
		}
	}
}
     c2a:	df 91       	pop	r29
     c2c:	cf 91       	pop	r28
     c2e:	1f 91       	pop	r17
     c30:	0f 91       	pop	r16
     c32:	ff 90       	pop	r15
     c34:	ef 90       	pop	r14
     c36:	df 90       	pop	r13
     c38:	cf 90       	pop	r12
     c3a:	bf 90       	pop	r11
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__2bit_modes[mode]);
			}
			if(wgm==255){
				// Mode is not supported
				setError(TIMER_MODE_NOT_SUPPORTED);
     c3c:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode
     c40:	ce 01       	movw	r24, r28
     c42:	0e 94 00 00 	call	0	; 0x0 <timerOff>

				const PORT_MASK* pm = &timer->pgm_wgm[0];
     c46:	8e 01       	movw	r16, r28
     c48:	05 5f       	subi	r16, 0xF5	; 245
     c4a:	1f 4f       	sbci	r17, 0xFF	; 255
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     c4c:	7e 01       	movw	r14, r28
     c4e:	b7 e1       	ldi	r27, 0x17	; 23
     c50:	eb 0e       	add	r14, r27
     c52:	f1 1c       	adc	r15, r1
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode

				const PORT_MASK* pm = &timer->pgm_wgm[0];
				for(int i=0; i<4;i++,pm++){
					PORT port= pgm_read_word(pm->port);
     c54:	d8 01       	movw	r26, r16
     c56:	ed 91       	ld	r30, X+
     c58:	fc 91       	ld	r31, X
     c5a:	85 91       	lpm	r24, Z+
     c5c:	94 91       	lpm	r25, Z

					if(port==0){
     c5e:	89 2b       	or	r24, r25
     c60:	01 f4       	brne	.+0      	; 0xc62 <timerSetMode+0xc0>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     c62:	fe 01       	movw	r30, r28
     c64:	38 96       	adiw	r30, 0x08	; 8
     c66:	b4 90       	lpm	r11, Z
				}

				// For each channel - disconnect the output pins and remove any callback
				uint8_t numCompare = timerNumberOfCompareUnits(timer);
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
     c68:	ba 94       	dec	r11
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     c6a:	bb 2d       	mov	r27, r11
     c6c:	80 e1       	ldi	r24, 0x10	; 16
     c6e:	b8 02       	muls	r27, r24
     c70:	70 01       	movw	r14, r0
     c72:	11 24       	eor	r1, r1
				}

				// For each channel - disconnect the output pins and remove any callback
				uint8_t numCompare = timerNumberOfCompareUnits(timer);
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
     c74:	00 e0       	ldi	r16, 0x00	; 0
     c76:	10 e0       	ldi	r17, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     c78:	fe 01       	movw	r30, r28
     c7a:	77 96       	adiw	r30, 0x17	; 23
     c7c:	c5 90       	lpm	r12, Z+
     c7e:	d4 90       	lpm	r13, Z
     c80:	00 c0       	rjmp	.+0      	; 0xc82 <timerSetMode+0xe0>
					if(port==0){
						break;
					}

					if(wgm & 1){
						__portMaskSet(pm);
     c82:	c8 01       	movw	r24, r16

					if(port==0){
						break;
					}

					if(wgm & 1){
     c84:	d0 fe       	sbrs	r13, 0
     c86:	00 c0       	rjmp	.+0      	; 0xc88 <timerSetMode+0xe6>
						__portMaskSet(pm);
     c88:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     c8c:	00 c0       	rjmp	.+0      	; 0xc8e <timerSetMode+0xec>
					}else{
						__portMaskClear(pm);
     c8e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
					}
					wgm>>=1;
     c92:	d6 94       	lsr	r13
				setError(TIMER_MODE_NOT_SUPPORTED);
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode

				const PORT_MASK* pm = &timer->pgm_wgm[0];
				for(int i=0; i<4;i++,pm++){
     c94:	0d 5f       	subi	r16, 0xFD	; 253
     c96:	1f 4f       	sbci	r17, 0xFF	; 255
     c98:	0e 15       	cp	r16, r14
     c9a:	1f 05       	cpc	r17, r15
     c9c:	01 f4       	brne	.+0      	; 0xc9e <timerSetMode+0xfc>
     c9e:	00 c0       	rjmp	.+0      	; 0xca0 <timerSetMode+0xfe>
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     ca0:	c8 01       	movw	r24, r16
     ca2:	8e 0d       	add	r24, r14
     ca4:	9f 1d       	adc	r25, r15
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
					const TimerCompare* channel = timerGetCompare(timer,i);
// is done in compareDetach
//					compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
					compareDetach(channel);
     ca6:	8c 0d       	add	r24, r12
     ca8:	9d 1d       	adc	r25, r13
     caa:	0e 94 00 00 	call	0	; 0x0 <timerOff>
				}

				// For each channel - disconnect the output pins and remove any callback
				uint8_t numCompare = timerNumberOfCompareUnits(timer);
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
     cae:	ba 94       	dec	r11
     cb0:	00 51       	subi	r16, 0x10	; 16
     cb2:	11 09       	sbc	r17, r1
     cb4:	b7 fe       	sbrs	r11, 7
     cb6:	00 c0       	rjmp	.+0      	; 0xcb8 <timerSetMode+0x116>
//					compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
					compareDetach(channel);
				}

				// re-initialise the timer and its channels
				timerInit(timer);
     cb8:	ce 01       	movw	r24, r28
		}else{
			// Timer is not able to do this mode
			setError(TIMER_MODE_NOT_SUPPORTED);
		}
	}
}
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	1f 91       	pop	r17
     cc0:	0f 91       	pop	r16
     cc2:	ff 90       	pop	r15
     cc4:	ef 90       	pop	r14
     cc6:	df 90       	pop	r13
     cc8:	cf 90       	pop	r12
     cca:	bf 90       	pop	r11
//					compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
					compareDetach(channel);
				}

				// re-initialise the timer and its channels
				timerInit(timer);
     ccc:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
		}else{
			// Timer is not able to do this mode
			setError(TIMER_MODE_NOT_SUPPORTED);
		}
	}
}
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	df 90       	pop	r13
     cde:	cf 90       	pop	r12
     ce0:	bf 90       	pop	r11
     ce2:	08 95       	ret

00000ce4 <initTimers>:
//  Initialise all timers:
//  	Detach any overflow interrupt
//		timerInit
//
------------------------------------------------------- */
void initTimers(void){
     ce4:	ff 92       	push	r15
     ce6:	0f 93       	push	r16
     ce8:	1f 93       	push	r17
     cea:	cf 93       	push	r28
     cec:	df 93       	push	r29
	uint8_t t;
    cli();
     cee:	f8 94       	cli
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     cf0:	10 e0       	ldi	r17, 0x00	; 0
     cf2:	00 91 00 00 	lds	r16, 0x0000
		const Timer * timer = &pgm_Timers[t];
     cf6:	cc e2       	ldi	r28, 0x2C	; 44
     cf8:	fc 2e       	mov	r15, r28
//
------------------------------------------------------- */
void initTimers(void){
	uint8_t t;
    cli();
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     cfa:	00 c0       	rjmp	.+0      	; 0xcfc <initTimers+0x18>
		const Timer * timer = &pgm_Timers[t];
     cfc:	f1 9e       	mul	r15, r17
     cfe:	e0 01       	movw	r28, r0
     d00:	11 24       	eor	r1, r1
     d02:	c0 50       	subi	r28, 0x00	; 0
     d04:	d0 40       	sbci	r29, 0x00	; 0
//  Detach any callback function to a timer
//
------------------------------------------------------- */
static __inline__ void timerOverflowDetach(const Timer* timer)
{
	timerOverflowAttach(timer,null,null);
     d06:	40 e0       	ldi	r20, 0x00	; 0
     d08:	50 e0       	ldi	r21, 0x00	; 0
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	70 e0       	ldi	r23, 0x00	; 0
     d0e:	ce 01       	movw	r24, r28
     d10:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerOverflowDetach(timer);						// Detach any overyflow call back
		timerCaptureDetach(timer);						// Detach any capture call back
     d14:	ce 01       	movw	r24, r28
     d16:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerSetMode(timer,TIMER_MODE_NORMAL);
     d1a:	60 e0       	ldi	r22, 0x00	; 0
     d1c:	ce 01       	movw	r24, r28
     d1e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerOff(timer);						// initialise the timer
     d22:	ce 01       	movw	r24, r28
     d24:	0e 94 00 00 	call	0	; 0x0 <timerOff>
//
------------------------------------------------------- */
void initTimers(void){
	uint8_t t;
    cli();
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     d28:	1f 5f       	subi	r17, 0xFF	; 255
     d2a:	10 17       	cp	r17, r16
     d2c:	00 f0       	brcs	.+0      	; 0xd2e <initTimers+0x4a>
		timerOverflowDetach(timer);						// Detach any overyflow call back
		timerCaptureDetach(timer);						// Detach any capture call back
		timerSetMode(timer,TIMER_MODE_NORMAL);
		timerOff(timer);						// initialise the timer
	}
    sei();
     d2e:	78 94       	sei
}
     d30:	df 91       	pop	r29
     d32:	cf 91       	pop	r28
     d34:	1f 91       	pop	r17
     d36:	0f 91       	pop	r16
     d38:	ff 90       	pop	r15
     d3a:	08 95       	ret

00000d3c <compareAttach>:
/* -------------------------------------------------------
//
//  Attach a callback function to a timer when the compare is met
//
------------------------------------------------------- */
void compareAttach(const TimerCompare* channel, TimerCompareCallback callback, uint16_t threshold, void* data ){
     d3c:	8f 92       	push	r8
     d3e:	9f 92       	push	r9
     d40:	af 92       	push	r10
     d42:	bf 92       	push	r11
     d44:	cf 92       	push	r12
     d46:	df 92       	push	r13
     d48:	ef 92       	push	r14
     d4a:	ff 92       	push	r15
     d4c:	0f 93       	push	r16
     d4e:	1f 93       	push	r17
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	ec 01       	movw	r28, r24
     d56:	6b 01       	movw	r12, r22
     d58:	4a 01       	movw	r8, r20
     d5a:	59 01       	movw	r10, r18
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     d5c:	fc 01       	movw	r30, r24
     d5e:	32 96       	adiw	r30, 0x02	; 2
     d60:	e4 90       	lpm	r14, Z

	const Timer* timer = compareGetTimer(channel);
     d62:	8c e2       	ldi	r24, 0x2C	; 44
     d64:	e8 9e       	mul	r14, r24
     d66:	70 01       	movw	r14, r0
     d68:	11 24       	eor	r1, r1
     d6a:	e0 e0       	ldi	r30, 0x00	; 0
     d6c:	f0 e0       	ldi	r31, 0x00	; 0
     d6e:	ee 0e       	add	r14, r30
     d70:	ff 1e       	adc	r15, r31

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     d72:	f7 01       	movw	r30, r14
     d74:	38 96       	adiw	r30, 0x08	; 8
     d76:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     d78:	ee 23       	and	r30, r30
     d7a:	01 f4       	brne	.+0      	; 0xd7c <compareAttach+0x40>
     d7c:	00 c0       	rjmp	.+0      	; 0xd7e <compareAttach+0x42>
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     d7e:	fe 01       	movw	r30, r28
     d80:	85 91       	lpm	r24, Z+
     d82:	94 91       	lpm	r25, Z
     d84:	8c 01       	movw	r16, r24

		TimerDataCompare* td = compareGetData(channel);

		// Check if compare is already in use
		if(callback!=null && td->compare_callback!=null){
     d86:	61 15       	cp	r22, r1
     d88:	71 05       	cpc	r23, r1
     d8a:	01 f0       	breq	.+0      	; 0xd8c <compareAttach+0x50>
     d8c:	fc 01       	movw	r30, r24
     d8e:	80 81       	ld	r24, Z
     d90:	91 81       	ldd	r25, Z+1	; 0x01
     d92:	89 2b       	or	r24, r25
     d94:	01 f0       	breq	.+0      	; 0xd96 <compareAttach+0x5a>
			setError(TIMER_COMPARE_CALLBACK_EXISTS);
     d96:	8b ef       	ldi	r24, 0xFB	; 251
     d98:	0e 94 00 00 	call	0	; 0x0 <timerOff>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     d9c:	f7 01       	movw	r30, r14
     d9e:	a5 91       	lpm	r26, Z+
     da0:	b4 91       	lpm	r27, Z
		}

		// Make sure the timer is set up and running
		timerSetPrescaler(timer,timerGetPrescaler(timer));
     da2:	6d 91       	ld	r22, X+
     da4:	7c 91       	ld	r23, X
     da6:	c7 01       	movw	r24, r14
     da8:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Disallow compare interrupts whilst changing
		__portMaskClear(&channel->pgm_intenable);
     dac:	7e 01       	movw	r14, r28
     dae:	f3 e0       	ldi	r31, 0x03	; 3
     db0:	ef 0e       	add	r14, r31
     db2:	f1 1c       	adc	r15, r1
     db4:	c7 01       	movw	r24, r14
     db6:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Set the compare threshold
		compareSetThreshold(channel, threshold);
     dba:	b4 01       	movw	r22, r8
     dbc:	ce 01       	movw	r24, r28
     dbe:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Add the callback routine
		td->compare_callback = callback;
     dc2:	f8 01       	movw	r30, r16
     dc4:	d1 82       	std	Z+1, r13	; 0x01
     dc6:	c0 82       	st	Z, r12
		td->compare_data = data;
     dc8:	b3 82       	std	Z+3, r11	; 0x03
     dca:	a2 82       	std	Z+2, r10	; 0x02
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
     dcc:	ce 01       	movw	r24, r28
     dce:	08 96       	adiw	r24, 0x08	; 8
     dd0:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Clear old interrupt pending before re-enabling interrupt
		compareClearInterruptPending(channel);

		// Allow compare interrupts - unless it is the null routine
		if(callback && callback != &nullTimerCompareCallback){
     dd4:	c1 14       	cp	r12, r1
     dd6:	d1 04       	cpc	r13, r1
     dd8:	01 f0       	breq	.+0      	; 0xdda <compareAttach+0x9e>
     dda:	f0 e0       	ldi	r31, 0x00	; 0
     ddc:	cf 16       	cp	r12, r31
     dde:	f0 e0       	ldi	r31, 0x00	; 0
     de0:	df 06       	cpc	r13, r31
     de2:	01 f0       	breq	.+0      	; 0xde4 <compareAttach+0xa8>
			__portMaskSet(&channel->pgm_intenable);
     de4:	c7 01       	movw	r24, r14
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
	}
}
     de6:	df 91       	pop	r29
     de8:	cf 91       	pop	r28
     dea:	1f 91       	pop	r17
     dec:	0f 91       	pop	r16
     dee:	ff 90       	pop	r15
     df0:	ef 90       	pop	r14
     df2:	df 90       	pop	r13
     df4:	cf 90       	pop	r12
     df6:	bf 90       	pop	r11
     df8:	af 90       	pop	r10
     dfa:	9f 90       	pop	r9
     dfc:	8f 90       	pop	r8
		// Clear old interrupt pending before re-enabling interrupt
		compareClearInterruptPending(channel);

		// Allow compare interrupts - unless it is the null routine
		if(callback && callback != &nullTimerCompareCallback){
			__portMaskSet(&channel->pgm_intenable);
     dfe:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     e02:	8d ef       	ldi	r24, 0xFD	; 253
	}
}
     e04:	df 91       	pop	r29
     e06:	cf 91       	pop	r28
     e08:	1f 91       	pop	r17
     e0a:	0f 91       	pop	r16
     e0c:	ff 90       	pop	r15
     e0e:	ef 90       	pop	r14
     e10:	df 90       	pop	r13
     e12:	cf 90       	pop	r12
     e14:	bf 90       	pop	r11
     e16:	af 90       	pop	r10
     e18:	9f 90       	pop	r9
     e1a:	8f 90       	pop	r8
		// Allow compare interrupts - unless it is the null routine
		if(callback && callback != &nullTimerCompareCallback){
			__portMaskSet(&channel->pgm_intenable);
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     e1c:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
	}
}
     e20:	df 91       	pop	r29
     e22:	cf 91       	pop	r28
     e24:	1f 91       	pop	r17
     e26:	0f 91       	pop	r16
     e28:	ff 90       	pop	r15
     e2a:	ef 90       	pop	r14
     e2c:	df 90       	pop	r13
     e2e:	cf 90       	pop	r12
     e30:	bf 90       	pop	r11
     e32:	af 90       	pop	r10
     e34:	9f 90       	pop	r9
     e36:	8f 90       	pop	r8
     e38:	08 95       	ret

00000e3a <__clockInit>:
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     e3a:	2f 92       	push	r2
     e3c:	3f 92       	push	r3
     e3e:	4f 92       	push	r4
     e40:	5f 92       	push	r5
     e42:	6f 92       	push	r6
     e44:	7f 92       	push	r7
     e46:	8f 92       	push	r8
     e48:	9f 92       	push	r9
     e4a:	af 92       	push	r10
     e4c:	bf 92       	push	r11
     e4e:	cf 92       	push	r12
     e50:	df 92       	push	r13
     e52:	ef 92       	push	r14
     e54:	ff 92       	push	r15
     e56:	0f 93       	push	r16
     e58:	1f 93       	push	r17
     e5a:	cf 93       	push	r28
     e5c:	df 93       	push	r29
     e5e:	cd b7       	in	r28, 0x3d	; 61
     e60:	de b7       	in	r29, 0x3e	; 62
     e62:	2a 97       	sbiw	r28, 0x0a	; 10
     e64:	0f b6       	in	r0, 0x3f	; 63
     e66:	f8 94       	cli
     e68:	de bf       	out	0x3e, r29	; 62
     e6a:	0f be       	out	0x3f, r0	; 63
     e6c:	cd bf       	out	0x3d, r28	; 61

	const Timer* bestTimer;
	uint16_t     bestCompare;
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
     e6e:	10 92 00 00 	sts	0x0000, r1
     e72:	10 92 00 00 	sts	0x0000, r1
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     e76:	50 90 00 00 	lds	r5, 0x0000
     e7a:	5a 94       	dec	r5
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     e7c:	25 2d       	mov	r18, r5
     e7e:	3c e2       	ldi	r19, 0x2C	; 44
     e80:	23 02       	muls	r18, r19
     e82:	80 01       	movw	r16, r0
     e84:	11 24       	eor	r1, r1
     e86:	00 50       	subi	r16, 0x00	; 0
     e88:	10 40       	sbci	r17, 0x00	; 0
	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
	bestCompare = 0;
	bestPrescaler = 0;
     e8a:	1c 82       	std	Y+4, r1	; 0x04
     e8c:	1b 82       	std	Y+3, r1	; 0x03

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
	bestCompare = 0;
     e8e:	1a 82       	std	Y+2, r1	; 0x02
     e90:	19 82       	std	Y+1, r1	; 0x01
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
     e92:	21 2c       	mov	r2, r1
     e94:	31 2c       	mov	r3, r1

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     e96:	20 91 00 00 	lds	r18, 0x0000
     e9a:	30 91 00 00 	lds	r19, 0x0000
     e9e:	ac e0       	ldi	r26, 0x0C	; 12
     ea0:	b0 e0       	ldi	r27, 0x00	; 0
     ea2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     ea6:	6b 01       	movw	r12, r22
     ea8:	7c 01       	movw	r14, r24
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     eaa:	00 c0       	rjmp	.+0      	; 0xeac <__clockInit+0x72>
		const Timer * timer = &pgm_Timers[t];
     eac:	70 2e       	mov	r7, r16
     eae:	61 2e       	mov	r6, r17
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     eb0:	f8 01       	movw	r30, r16
     eb2:	34 96       	adiw	r30, 0x04	; 4
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
     eb4:	85 91       	lpm	r24, Z+
     eb6:	94 91       	lpm	r25, Z
     eb8:	fc 01       	movw	r30, r24
     eba:	80 81       	ld	r24, Z
     ebc:	87 70       	andi	r24, 0x07	; 7
     ebe:	01 f4       	brne	.+0      	; 0xec0 <__clockInit+0x86>
     ec0:	00 c0       	rjmp	.+0      	; 0xec2 <__clockInit+0x88>
     ec2:	00 c0       	rjmp	.+0      	; 0xec4 <__clockInit+0x8a>
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
		const Timer * timer = &pgm_Timers[t];
		if(!timerIsInUse(timer) && timerIsModeSupported(timer,TIMER_MODE_CTC_OCR)
				&& timerNumberOfCompareUnits(timer) >= 2 // Need one for timer and one for scheduler
				){
			if(bestCompare>0xFFU && !timerIs16bit(timer)){
     ec4:	69 81       	ldd	r22, Y+1	; 0x01
     ec6:	7a 81       	ldd	r23, Y+2	; 0x02
     ec8:	6f 3f       	cpi	r22, 0xFF	; 255
     eca:	71 05       	cpc	r23, r1
     ecc:	01 f0       	breq	.+0      	; 0xece <__clockInit+0x94>
     ece:	00 f0       	brcs	.+0      	; 0xed0 <__clockInit+0x96>
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     ed0:	f8 01       	movw	r30, r16
     ed2:	36 96       	adiw	r30, 0x06	; 6
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     ed4:	e4 91       	lpm	r30, Z
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
		const Timer * timer = &pgm_Timers[t];
		if(!timerIsInUse(timer) && timerIsModeSupported(timer,TIMER_MODE_CTC_OCR)
				&& timerNumberOfCompareUnits(timer) >= 2 // Need one for timer and one for scheduler
				){
			if(bestCompare>0xFFU && !timerIs16bit(timer)){
     ed6:	ee 23       	and	r30, r30
     ed8:	01 f0       	breq	.+0      	; 0xeda <__clockInit+0xa0>
				continue;
			}
			// It is a candidate
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
     eda:	6c e0       	ldi	r22, 0x0C	; 12
     edc:	70 e0       	ldi	r23, 0x00	; 0
     ede:	87 2d       	mov	r24, r7
     ee0:	96 2d       	mov	r25, r6
     ee2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     ee6:	9e 83       	std	Y+6, r25	; 0x06
     ee8:	8d 83       	std	Y+5, r24	; 0x05

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     eea:	9c 01       	movw	r18, r24
     eec:	40 e0       	ldi	r20, 0x00	; 0
     eee:	50 e0       	ldi	r21, 0x00	; 0
     ef0:	c7 01       	movw	r24, r14
     ef2:	b6 01       	movw	r22, r12
     ef4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
			// It is a candidate
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
			uint32_t compare = ticks_per_ms(clock_ms,thePreScale);		// Get the value for top

			// See if it is the best so far - and if so then remember it
			if(bestTimer==null || compare > bestCompare){
     ef8:	21 14       	cp	r2, r1
     efa:	31 04       	cpc	r3, r1
     efc:	01 f0       	breq	.+0      	; 0xefe <__clockInit+0xc4>
     efe:	89 81       	ldd	r24, Y+1	; 0x01
     f00:	9a 81       	ldd	r25, Y+2	; 0x02
     f02:	4c 01       	movw	r8, r24
     f04:	a1 2c       	mov	r10, r1
     f06:	b1 2c       	mov	r11, r1
     f08:	82 16       	cp	r8, r18
     f0a:	93 06       	cpc	r9, r19
     f0c:	a4 06       	cpc	r10, r20
     f0e:	b5 06       	cpc	r11, r21
     f10:	00 f4       	brcc	.+0      	; 0xf12 <__clockInit+0xd8>
				bestTimer = timer;
				bestCompare = compare;
     f12:	3a 83       	std	Y+2, r19	; 0x02
     f14:	29 83       	std	Y+1, r18	; 0x01
				bestPrescaler = thePreScale;
     f16:	ed 81       	ldd	r30, Y+5	; 0x05
     f18:	fe 81       	ldd	r31, Y+6	; 0x06
     f1a:	fc 83       	std	Y+4, r31	; 0x04
     f1c:	eb 83       	std	Y+3, r30	; 0x03
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
			uint32_t compare = ticks_per_ms(clock_ms,thePreScale);		// Get the value for top

			// See if it is the best so far - and if so then remember it
			if(bestTimer==null || compare > bestCompare){
				bestTimer = timer;
     f1e:	27 2c       	mov	r2, r7
     f20:	36 2c       	mov	r3, r6
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     f22:	5a 94       	dec	r5
     f24:	0c 52       	subi	r16, 0x2C	; 44
     f26:	11 09       	sbc	r17, r1
     f28:	57 fe       	sbrs	r5, 7
     f2a:	00 c0       	rjmp	.+0      	; 0xf2c <__clockInit+0xf2>
				bestPrescaler = thePreScale;
			}
		}
    }

    if(bestTimer!=null){
     f2c:	21 14       	cp	r2, r1
     f2e:	31 04       	cpc	r3, r1
     f30:	01 f4       	brne	.+0      	; 0xf32 <__clockInit+0xf8>
     f32:	00 c0       	rjmp	.+0      	; 0xf34 <__clockInit+0xfa>
     f34:	f1 01       	movw	r30, r2
     f36:	36 96       	adiw	r30, 0x06	; 6
     f38:	e4 91       	lpm	r30, Z
    	// The largest possible value for top
    	TICK_COUNT max = (timerIs16bit(bestTimer)) ? 0xFFFFUL : 0xFFUL;
     f3a:	ee 23       	and	r30, r30
     f3c:	01 f0       	breq	.+0      	; 0xf3e <__clockInit+0x104>
     f3e:	cc 24       	eor	r12, r12
     f40:	ca 94       	dec	r12
     f42:	dc 2c       	mov	r13, r12
     f44:	e1 2c       	mov	r14, r1
     f46:	f1 2c       	mov	r15, r1
     f48:	00 c0       	rjmp	.+0      	; 0xf4a <__clockInit+0x110>
     f4a:	c1 2c       	mov	r12, r1
     f4c:	d1 2c       	mov	r13, r1
     f4e:	76 01       	movw	r14, r12
     f50:	ca 94       	dec	r12
	const Timer* bestTimer;
	uint16_t     bestCompare;
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case
     f52:	2c e0       	ldi	r18, 0x0C	; 12
     f54:	30 e0       	ldi	r19, 0x00	; 0
     f56:	3a 87       	std	Y+10, r19	; 0x0a
     f58:	29 87       	std	Y+9, r18	; 0x09

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     f5a:	60 91 00 00 	lds	r22, 0x0000
     f5e:	70 91 00 00 	lds	r23, 0x0000
     f62:	78 87       	std	Y+8, r23	; 0x08
     f64:	6f 83       	std	Y+7, r22	; 0x07
     f66:	80 e0       	ldi	r24, 0x00	; 0
     f68:	90 e0       	ldi	r25, 0x00	; 0
     f6a:	eb 81       	ldd	r30, Y+3	; 0x03
     f6c:	fc 81       	ldd	r31, Y+4	; 0x04
     f6e:	9f 01       	movw	r18, r30
     f70:	40 e0       	ldi	r20, 0x00	; 0
     f72:	50 e0       	ldi	r21, 0x00	; 0
     f74:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     f78:	49 01       	movw	r8, r18
     f7a:	5a 01       	movw	r10, r20

    if(bestTimer!=null){
    	// The largest possible value for top
    	TICK_COUNT max = (timerIs16bit(bestTimer)) ? 0xFFFFUL : 0xFFUL;
recalc:
    	if(bestCompare + ticks_per_ms(1,bestPrescaler) + 1 < max){
     f7c:	ff ef       	ldi	r31, 0xFF	; 255
     f7e:	8f 1a       	sub	r8, r31
     f80:	9f 0a       	sbc	r9, r31
     f82:	af 0a       	sbc	r10, r31
     f84:	bf 0a       	sbc	r11, r31
     f86:	29 81       	ldd	r18, Y+1	; 0x01
     f88:	3a 81       	ldd	r19, Y+2	; 0x02
     f8a:	29 01       	movw	r4, r18
     f8c:	61 2c       	mov	r6, r1
     f8e:	71 2c       	mov	r7, r1
     f90:	95 01       	movw	r18, r10
     f92:	84 01       	movw	r16, r8
     f94:	04 0d       	add	r16, r4
     f96:	15 1d       	adc	r17, r5
     f98:	26 1d       	adc	r18, r6
     f9a:	37 1d       	adc	r19, r7
     f9c:	0c 15       	cp	r16, r12
     f9e:	1d 05       	cpc	r17, r13
     fa0:	2e 05       	cpc	r18, r14
     fa2:	3f 05       	cpc	r19, r15
     fa4:	00 f4       	brcc	.+0      	; 0xfa6 <__clockInit+0x16c>
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
     fa6:	09 85       	ldd	r16, Y+9	; 0x09
     fa8:	1a 85       	ldd	r17, Y+10	; 0x0a
     faa:	0f 5f       	subi	r16, 0xFF	; 255
     fac:	1f 4f       	sbci	r17, 0xFF	; 255
     fae:	b8 01       	movw	r22, r16
     fb0:	c1 01       	movw	r24, r2
     fb2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     fb6:	9e 83       	std	Y+6, r25	; 0x06
     fb8:	8d 83       	std	Y+5, r24	; 0x05

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     fba:	98 01       	movw	r18, r16
     fbc:	af 81       	ldd	r26, Y+7	; 0x07
     fbe:	b8 85       	ldd	r27, Y+8	; 0x08
     fc0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     fc4:	ed 81       	ldd	r30, Y+5	; 0x05
     fc6:	fe 81       	ldd	r31, Y+6	; 0x06
     fc8:	9f 01       	movw	r18, r30
     fca:	40 e0       	ldi	r20, 0x00	; 0
     fcc:	50 e0       	ldi	r21, 0x00	; 0
     fce:	0e 94 00 00 	call	0	; 0x0 <timerOff>
recalc:
    	if(bestCompare + ticks_per_ms(1,bestPrescaler) + 1 < max){
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    		if(thePreScale==bestPrescaler && compare <= max && compare>bestCompare){
     fd2:	6d 81       	ldd	r22, Y+5	; 0x05
     fd4:	7e 81       	ldd	r23, Y+6	; 0x06
     fd6:	8b 81       	ldd	r24, Y+3	; 0x03
     fd8:	9c 81       	ldd	r25, Y+4	; 0x04
     fda:	68 17       	cp	r22, r24
     fdc:	79 07       	cpc	r23, r25
     fde:	01 f4       	brne	.+0      	; 0xfe0 <__clockInit+0x1a6>
     fe0:	c2 16       	cp	r12, r18
     fe2:	d3 06       	cpc	r13, r19
     fe4:	e4 06       	cpc	r14, r20
     fe6:	f5 06       	cpc	r15, r21
     fe8:	00 f0       	brcs	.+0      	; 0xfea <__clockInit+0x1b0>
     fea:	42 16       	cp	r4, r18
     fec:	53 06       	cpc	r5, r19
     fee:	64 06       	cpc	r6, r20
     ff0:	75 06       	cpc	r7, r21
     ff2:	00 f4       	brcc	.+0      	; 0xff4 <__clockInit+0x1ba>
    			// Same prescaler and increased compare
    			clock_ms++;
    			bestCompare = compare;
     ff4:	3a 83       	std	Y+2, r19	; 0x02
     ff6:	29 83       	std	Y+1, r18	; 0x01
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    		if(thePreScale==bestPrescaler && compare <= max && compare>bestCompare){
    			// Same prescaler and increased compare
    			clock_ms++;
     ff8:	1a 87       	std	Y+10, r17	; 0x0a
     ffa:	09 87       	std	Y+9, r16	; 0x09
    			bestCompare = compare;
    			goto recalc;
     ffc:	00 c0       	rjmp	.+0      	; 0xffe <__clockInit+0x1c4>
    		}
    	}

		// We have got the highest setting
    	g_heartbeat = bestTimer;
     ffe:	30 92 00 00 	sts	0x0000, r3
    1002:	20 92 00 00 	sts	0x0000, r2
    	_CLOCK_US_ = clock_ms * 1000UL;
    1006:	29 85       	ldd	r18, Y+9	; 0x09
    1008:	3a 85       	ldd	r19, Y+10	; 0x0a
    100a:	a8 ee       	ldi	r26, 0xE8	; 232
    100c:	b3 e0       	ldi	r27, 0x03	; 3
    100e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    1012:	60 93 00 00 	sts	0x0000, r22
    1016:	70 93 00 00 	sts	0x0000, r23
    101a:	80 93 00 00 	sts	0x0000, r24
    101e:	90 93 00 00 	sts	0x0000, r25
        timerSetPrescaler(g_heartbeat, bestPrescaler);
    1022:	6b 81       	ldd	r22, Y+3	; 0x03
    1024:	7c 81       	ldd	r23, Y+4	; 0x04
    1026:	c1 01       	movw	r24, r2
    1028:	0e 94 00 00 	call	0	; 0x0 <timerOff>


		// Change the mode of the timer
		timerSetMode(g_heartbeat, TIMER_MODE_CTC_OCR);
    102c:	64 e0       	ldi	r22, 0x04	; 4
    102e:	80 91 00 00 	lds	r24, 0x0000
    1032:	90 91 00 00 	lds	r25, 0x0000
    1036:	0e 94 00 00 	call	0	; 0x0 <timerOff>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
    103a:	e0 91 00 00 	lds	r30, 0x0000
    103e:	f0 91 00 00 	lds	r31, 0x0000
    1042:	77 96       	adiw	r30, 0x17	; 23
    1044:	a5 91       	lpm	r26, Z+
    1046:	b4 91       	lpm	r27, Z
		const TimerCompare* channel = timerGetCompare(g_heartbeat, 0);
		compareAttach(channel, &clockCallback, bestCompare, null);
    1048:	20 e0       	ldi	r18, 0x00	; 0
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	49 81       	ldd	r20, Y+1	; 0x01
    104e:	5a 81       	ldd	r21, Y+2	; 0x02
    1050:	60 e0       	ldi	r22, 0x00	; 0
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	cd 01       	movw	r24, r26
    1056:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		// Enable overflow interrupts - NOT NEEDED - uses compare interrupts
		//__portMaskSet(&g_heartbeat->pgm_overflowint);
	}

	// if an error was previously set then start it flashing on the LED
	ERROR_CODE current = __error.errorCode;
    105a:	80 91 00 00 	lds	r24, 0x0000
	if(current!=0){
    105e:	88 23       	and	r24, r24
    1060:	01 f0       	breq	.+0      	; 0x1062 <__clockInit+0x228>
		__error.errorCode = 0;
    1062:	10 92 00 00 	sts	0x0000, r1
		setError(current);
	}

}
    1066:	2a 96       	adiw	r28, 0x0a	; 10
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	1f 91       	pop	r17
    1078:	0f 91       	pop	r16
    107a:	ff 90       	pop	r15
    107c:	ef 90       	pop	r14
    107e:	df 90       	pop	r13
    1080:	cf 90       	pop	r12
    1082:	bf 90       	pop	r11
    1084:	af 90       	pop	r10
    1086:	9f 90       	pop	r9
    1088:	8f 90       	pop	r8
    108a:	7f 90       	pop	r7
    108c:	6f 90       	pop	r6
    108e:	5f 90       	pop	r5
    1090:	4f 90       	pop	r4
    1092:	3f 90       	pop	r3
    1094:	2f 90       	pop	r2

	// if an error was previously set then start it flashing on the LED
	ERROR_CODE current = __error.errorCode;
	if(current!=0){
		__error.errorCode = 0;
		setError(current);
    1096:	0c 94 00 00 	jmp	0	; 0x0 <timerOff>
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
    109a:	f8 01       	movw	r30, r16
    109c:	39 96       	adiw	r30, 0x09	; 9
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
    109e:	85 91       	lpm	r24, Z+
    10a0:	94 91       	lpm	r25, Z
    10a2:	84 ff       	sbrs	r24, 4
    10a4:	00 c0       	rjmp	.+0      	; 0x10a6 <__clockInit+0x26c>
    10a6:	f8 01       	movw	r30, r16
    10a8:	38 96       	adiw	r30, 0x08	; 8

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
    10aa:	e4 91       	lpm	r30, Z
	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
		const Timer * timer = &pgm_Timers[t];
		if(!timerIsInUse(timer) && timerIsModeSupported(timer,TIMER_MODE_CTC_OCR)
				&& timerNumberOfCompareUnits(timer) >= 2 // Need one for timer and one for scheduler
    10ac:	e2 30       	cpi	r30, 0x02	; 2
    10ae:	00 f0       	brcs	.+0      	; 0x10b0 <__clockInit+0x276>
    10b0:	00 c0       	rjmp	.+0      	; 0x10b2 <__clockInit+0x278>
    10b2:	00 c0       	rjmp	.+0      	; 0x10b4 <__clockInit+0x27a>
	if(current!=0){
		__error.errorCode = 0;
		setError(current);
	}

}
    10b4:	2a 96       	adiw	r28, 0x0a	; 10
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	f8 94       	cli
    10ba:	de bf       	out	0x3e, r29	; 62
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	cd bf       	out	0x3d, r28	; 61
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	bf 90       	pop	r11
    10d2:	af 90       	pop	r10
    10d4:	9f 90       	pop	r9
    10d6:	8f 90       	pop	r8
    10d8:	7f 90       	pop	r7
    10da:	6f 90       	pop	r6
    10dc:	5f 90       	pop	r5
    10de:	4f 90       	pop	r4
    10e0:	3f 90       	pop	r3
    10e2:	2f 90       	pop	r2
    10e4:	08 95       	ret

000010e6 <setErrorLog>:

	}
}

void setErrorLog(Writer log){
	__error.output = log;
    10e6:	90 93 00 00 	sts	0x0000, r25
    10ea:	80 93 00 00 	sts	0x0000, r24
    10ee:	08 95       	ret

timerCapture.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b8  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ec  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ec  2**0
                  ALLOC
  3 .debug_info   0000075c  00000000  00000000  000000ec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000233  00000000  00000000  00000848  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002fe  00000000  00000000  00000a7b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000d79  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f8  00000000  00000000  00000d99  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000058a  00000000  00000000  00000e91  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  0000141b  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000088  00000000  00000000  00001448  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerCaptureAttach>:
 */

#include "timer.h"

void timerCaptureAttach(const Timer* timer, TimerCallback callback, void* user_data, boolean risingEdge )
{
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	bf 92       	push	r11
   6:	cf 92       	push	r12
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	1f 92       	push	r1
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	8c 01       	movw	r16, r24
  1e:	6b 01       	movw	r12, r22
  20:	7a 01       	movw	r14, r20
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  22:	fc 01       	movw	r30, r24
  24:	85 91       	lpm	r24, Z+
  26:	94 91       	lpm	r25, Z
  28:	4c 01       	movw	r8, r24
	TimerData* data = timerGetData(timer);
	if(data->capture_callback != null){
  2a:	fc 01       	movw	r30, r24
  2c:	86 81       	ldd	r24, Z+6	; 0x06
  2e:	97 81       	ldd	r25, Z+7	; 0x07
  30:	89 2b       	or	r24, r25
  32:	01 f0       	breq	.+0      	; 0x34 <timerCaptureAttach+0x34>
		setError(TIMER_CAPTURE_CALLBACK_EXISTS);
  34:	8a ee       	ldi	r24, 0xEA	; 234
  36:	29 83       	std	Y+1, r18	; 0x01
  38:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
  3c:	29 81       	ldd	r18, Y+1	; 0x01
	}

	// Turn off interrupts whilst changing
	// in case an interrupt happens half way through
	CRITICAL_SECTION_START;
  3e:	bf b6       	in	r11, 0x3f	; 63
  40:	f8 94       	cli

	// Set callback
	data->capture_callback = callback;
  42:	f4 01       	movw	r30, r8
  44:	d7 82       	std	Z+7, r13	; 0x07
  46:	c6 82       	std	Z+6, r12	; 0x06
	data->capture_data = user_data;
  48:	f1 86       	std	Z+9, r15	; 0x09
  4a:	e0 86       	std	Z+8, r14	; 0x08
  4c:	c8 01       	movw	r24, r16
  4e:	87 96       	adiw	r24, 0x27	; 39

	// Set the rising falling edge
	if(risingEdge){
  50:	22 23       	and	r18, r18
  52:	01 f0       	breq	.+0      	; 0x54 <timerCaptureAttach+0x54>
		__portMaskSet(&timer->pgm_captureedge);
  54:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
  58:	00 c0       	rjmp	.+0      	; 0x5a <timerCaptureAttach+0x5a>
	}else{
		__portMaskClear(&timer->pgm_captureedge);
  5a:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
  5e:	c8 01       	movw	r24, r16
  60:	84 96       	adiw	r24, 0x24	; 36
  62:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	// Clear any pending capture interrupt flag
	timerCaptureClearInterruptPending(timer);

	// enable interrupt
	__portMaskSet(&timer->pgm_captureint);
  66:	c8 01       	movw	r24, r16
  68:	81 96       	adiw	r24, 0x21	; 33
  6a:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	CRITICAL_SECTION_END;
  6e:	bf be       	out	0x3f, r11	; 63
}
  70:	0f 90       	pop	r0
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	cf 90       	pop	r12
  82:	bf 90       	pop	r11
  84:	9f 90       	pop	r9
  86:	8f 90       	pop	r8
  88:	08 95       	ret

0000008a <timerCaptureDetach>:

void timerCaptureDetach(const Timer* timer){
  8a:	0f 93       	push	r16
  8c:	1f 93       	push	r17
  8e:	cf 93       	push	r28
  90:	df 93       	push	r29
  92:	ec 01       	movw	r28, r24
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  94:	fc 01       	movw	r30, r24
  96:	05 91       	lpm	r16, Z+
  98:	14 91       	lpm	r17, Z
	TimerData* data = timerGetData(timer);

	// stop interrupt
	__portMaskClear(&timer->pgm_captureint);
  9a:	81 96       	adiw	r24, 0x21	; 33
  9c:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
  a0:	ce 01       	movw	r24, r28
  a2:	84 96       	adiw	r24, 0x24	; 36
  a4:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	// Clear any pending capture interrupt flag
	timerCaptureClearInterruptPending(timer);

	// Set callback
	data->capture_callback = null;
  a8:	f8 01       	movw	r30, r16
  aa:	17 82       	std	Z+7, r1	; 0x07
  ac:	16 82       	std	Z+6, r1	; 0x06
}
  ae:	df 91       	pop	r29
  b0:	cf 91       	pop	r28
  b2:	1f 91       	pop	r17
  b4:	0f 91       	pop	r16
  b6:	08 95       	ret

timerCompare.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000da  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000010e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000010e  2**0
                  ALLOC
  3 .debug_info   000009c5  00000000  00000000  0000010e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000261  00000000  00000000  00000ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000003f8  00000000  00000000  00000d34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000112c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  0000114c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000148  00000000  00000000  0000117c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000060a  00000000  00000000  000012c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  000018ce  2**0
                  CONTENTS, READONLY
 11 .debug_frame  0000006c  00000000  00000000  000018f8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <compareIsInUse>:
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
   0:	fc 01       	movw	r30, r24
   2:	a5 91       	lpm	r26, Z+
   4:	b4 91       	lpm	r27, Z

boolean compareIsInUse(const TimerCompare* channel){
	TimerDataCompare* data = compareGetData(channel);

	// if it has a callback then it is in use
	if(data->compare_callback != null)
   6:	2d 91       	ld	r18, X+
   8:	3c 91       	ld	r19, X
   a:	23 2b       	or	r18, r19
   c:	01 f4       	brne	.+0      	; 0xe <compareIsInUse+0xe>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
   e:	fc 01       	movw	r30, r24
  10:	32 96       	adiw	r30, 0x02	; 2
  12:	24 91       	lpm	r18, Z
		return TRUE;

	// if it is channel A and the Timer is is a mode where TOP is set channel A then it is also
	// in use (for defining the Timer TOP value)
	if(timerGetCompare(compareGetTimer(channel),0)==channel){
  14:	4c e2       	ldi	r20, 0x2C	; 44
  16:	24 9f       	mul	r18, r20
  18:	90 01       	movw	r18, r0
  1a:	11 24       	eor	r1, r1
  1c:	20 50       	subi	r18, 0x00	; 0
  1e:	30 40       	sbci	r19, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  20:	f9 01       	movw	r30, r18
  22:	77 96       	adiw	r30, 0x17	; 23
  24:	45 91       	lpm	r20, Z+
  26:	54 91       	lpm	r21, Z
  28:	84 17       	cp	r24, r20
  2a:	95 07       	cpc	r25, r21
  2c:	01 f0       	breq	.+0      	; 0x2e <compareIsInUse+0x2e>
				|| mode==TIMER_MODE_PWM_FAST_OCR){
			return TRUE;
		}
	}

	return FALSE;
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	08 95       	ret
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  32:	f9 01       	movw	r30, r18
  34:	a5 91       	lpm	r26, Z+
  36:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
  38:	1a 96       	adiw	r26, 0x0a	; 10
  3a:	8c 91       	ld	r24, X

	// if it is channel A and the Timer is is a mode where TOP is set channel A then it is also
	// in use (for defining the Timer TOP value)
	if(timerGetCompare(compareGetTimer(channel),0)==channel){
		TIMER_MODE mode = timerGetMode(compareGetTimer(channel));
		if(mode==TIMER_MODE_CTC_OCR
  3c:	84 30       	cpi	r24, 0x04	; 4
  3e:	01 f0       	breq	.+0      	; 0x40 <compareIsInUse+0x40>
				|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
  40:	89 30       	cpi	r24, 0x09	; 9
  42:	01 f0       	breq	.+0      	; 0x44 <compareIsInUse+0x44>
				|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
  44:	8b 30       	cpi	r24, 0x0B	; 11
  46:	01 f0       	breq	.+0      	; 0x48 <compareIsInUse+0x48>
				|| mode==TIMER_MODE_PWM_FAST_OCR){
  48:	8f 30       	cpi	r24, 0x0F	; 15
  4a:	01 f4       	brne	.+0      	; 0x4c <compareIsInUse+0x4c>
boolean compareIsInUse(const TimerCompare* channel){
	TimerDataCompare* data = compareGetData(channel);

	// if it has a callback then it is in use
	if(data->compare_callback != null)
		return TRUE;
  4c:	8f ef       	ldi	r24, 0xFF	; 255
			return TRUE;
		}
	}

	return FALSE;
}
  4e:	08 95       	ret

00000050 <compareFromIOPin>:
//  May return null if this pin is not to do with a timer
//  or it does not exist on this system board
//  An IOPin may actually support more than one compare
// channel - in which case give priority to 16 bit timers
------------------------------------------------------- */
const TimerCompare* compareFromIOPin(const IOPin* pin){
  50:	9f 92       	push	r9
  52:	af 92       	push	r10
  54:	bf 92       	push	r11
  56:	cf 92       	push	r12
  58:	df 92       	push	r13
  5a:	ef 92       	push	r14
  5c:	ff 92       	push	r15
  5e:	0f 93       	push	r16
  60:	1f 93       	push	r17
  62:	cf 93       	push	r28
  64:	df 93       	push	r29
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  66:	b0 90 00 00 	lds	r11, 0x0000
  6a:	20 e0       	ldi	r18, 0x00	; 0
  6c:	30 e0       	ldi	r19, 0x00	; 0
// channel - in which case give priority to 16 bit timers
------------------------------------------------------- */
const TimerCompare* compareFromIOPin(const IOPin* pin){
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;
  6e:	40 e0       	ldi	r20, 0x00	; 0
  70:	50 e0       	ldi	r21, 0x00	; 0

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  72:	d1 2c       	mov	r13, r1
  74:	00 c0       	rjmp	.+0      	; 0x76 <compareFromIOPin+0x26>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
  76:	f9 01       	movw	r30, r18
  78:	a4 90       	lpm	r10, Z
		const Timer * timer = &pgm_Timers[t];

		// Iterate over the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(c=0;c<numCompare;c++){
  7a:	c0 e0       	ldi	r28, 0x00	; 0
  7c:	d0 e0       	ldi	r29, 0x00	; 0
  7e:	c1 2c       	mov	r12, r1
//  May return null if this pin is not to do with a timer
//  or it does not exist on this system board
//  An IOPin may actually support more than one compare
// channel - in which case give priority to 16 bit timers
------------------------------------------------------- */
const TimerCompare* compareFromIOPin(const IOPin* pin){
  80:	3f 96       	adiw	r30, 0x0f	; 15
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  82:	e5 90       	lpm	r14, Z+
  84:	f4 90       	lpm	r15, Z
  86:	f9 01       	movw	r30, r18
  88:	32 97       	sbiw	r30, 0x02	; 2
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
  8a:	94 90       	lpm	r9, Z
	for(t=0; t < NUMBER_OF_TIMERS; t++){
		const Timer * timer = &pgm_Timers[t];

		// Iterate over the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(c=0;c<numCompare;c++){
  8c:	00 c0       	rjmp	.+0      	; 0x8e <compareFromIOPin+0x3e>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  8e:	d7 01       	movw	r26, r14
  90:	ac 0f       	add	r26, r28
  92:	bd 1f       	adc	r27, r29
//  Get the pin which this channel uses for output
//  Return IOpin* or null if it has no header pins
//
------------------------------------------------------- */
static __inline__ const IOPin * compareGetPin(const TimerCompare* channel){
	return  (const IOPin *)pgm_read_word(&channel->pgm_pwm);
  94:	fd 01       	movw	r30, r26
  96:	3e 96       	adiw	r30, 0x0e	; 14
  98:	05 91       	lpm	r16, Z+
  9a:	14 91       	lpm	r17, Z
			const TimerCompare* channel = timerGetCompare(timer,c);
			const IOPin* thisPin = compareGetPin(channel);
			if(thisPin != null && thisPin==pin){
  9c:	01 15       	cp	r16, r1
  9e:	11 05       	cpc	r17, r1
  a0:	01 f0       	breq	.+0      	; 0xa2 <compareFromIOPin+0x52>
  a2:	08 17       	cp	r16, r24
  a4:	19 07       	cpc	r17, r25
  a6:	01 f4       	brne	.+0      	; 0xa8 <compareFromIOPin+0x58>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  a8:	ad 01       	movw	r20, r26
				rtn = channel;					// remember the channel
				if(timerIs16bit(timer)){
  aa:	91 10       	cpse	r9, r1
  ac:	00 c0       	rjmp	.+0      	; 0xae <compareFromIOPin+0x5e>
	for(t=0; t < NUMBER_OF_TIMERS; t++){
		const Timer * timer = &pgm_Timers[t];

		// Iterate over the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(c=0;c<numCompare;c++){
  ae:	c3 94       	inc	r12
  b0:	60 96       	adiw	r28, 0x10	; 16
  b2:	ca 10       	cpse	r12, r10
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <compareFromIOPin+0x66>
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  b6:	d3 94       	inc	r13
  b8:	24 5d       	subi	r18, 0xD4	; 212
  ba:	3f 4f       	sbci	r19, 0xFF	; 255
  bc:	db 10       	cpse	r13, r11
  be:	00 c0       	rjmp	.+0      	; 0xc0 <compareFromIOPin+0x70>
			}
		}
	}

	return rtn;
}
  c0:	ca 01       	movw	r24, r20
  c2:	df 91       	pop	r29
  c4:	cf 91       	pop	r28
  c6:	1f 91       	pop	r17
  c8:	0f 91       	pop	r16
  ca:	ff 90       	pop	r15
  cc:	ef 90       	pop	r14
  ce:	df 90       	pop	r13
  d0:	cf 90       	pop	r12
  d2:	bf 90       	pop	r11
  d4:	af 90       	pop	r10
  d6:	9f 90       	pop	r9
  d8:	08 95       	ret

timerOverflow.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000009e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000009e  2**0
                  ALLOC
  3 .debug_info   0000066f  00000000  00000000  0000009e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000020a  00000000  00000000  0000070d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000197  00000000  00000000  00000917  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000aae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000de  00000000  00000000  00000ace  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000054c  00000000  00000000  00000bac  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .comment      0000002a  00000000  00000000  000010f8  2**0
                  CONTENTS, READONLY
 10 .debug_frame  00000048  00000000  00000000  00001124  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerOverflowAttach>:
//  This function is called during an interrupt so should
//  be quick.
//
------------------------------------------------------- */
void timerOverflowAttach(const Timer* timer, TimerCallback callback, void* user_data )
{
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	8b 01       	movw	r16, r22
  12:	7a 01       	movw	r14, r20
	// Turn off interrupts whilst changing
	// in case an interrupt happens half way through
	CRITICAL_SECTION_START;
  14:	df b6       	in	r13, 0x3f	; 63
  16:	f8 94       	cli
	if(callback!=null && timerGetData(timer)->overflow_callback != null){
  18:	61 15       	cp	r22, r1
  1a:	71 05       	cpc	r23, r1
  1c:	01 f0       	breq	.+0      	; 0x1e <timerOverflowAttach+0x1e>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  1e:	fc 01       	movw	r30, r24
  20:	a5 91       	lpm	r26, Z+
  22:	b4 91       	lpm	r27, Z
  24:	12 96       	adiw	r26, 0x02	; 2
  26:	8d 91       	ld	r24, X+
  28:	9c 91       	ld	r25, X
  2a:	13 97       	sbiw	r26, 0x03	; 3
  2c:	89 2b       	or	r24, r25
  2e:	01 f0       	breq	.+0      	; 0x30 <timerOverflowAttach+0x30>
		setError(TIMER_OVERFLOW_CALLBACK_EXISTS);
  30:	8c ef       	ldi	r24, 0xFC	; 252
  32:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
  36:	fe 01       	movw	r30, r28
  38:	85 91       	lpm	r24, Z+
  3a:	94 91       	lpm	r25, Z
  3c:	fc 01       	movw	r30, r24
	}

	// Set callback
	TimerData* data = timerGetData(timer);
	data->overflow_callback = callback;
  3e:	13 83       	std	Z+3, r17	; 0x03
  40:	02 83       	std	Z+2, r16	; 0x02
	data->overflow_data = user_data;
  42:	f5 82       	std	Z+5, r15	; 0x05
  44:	e4 82       	std	Z+4, r14	; 0x04
  46:	ce 01       	movw	r24, r28
  48:	49 96       	adiw	r24, 0x19	; 25

	// enable interrupt if there is callback
	if(callback!=null){
  4a:	01 2b       	or	r16, r17
  4c:	01 f0       	breq	.+0      	; 0x4e <timerOverflowAttach+0x4e>
		// enable overflow interrupts
		__portMaskSet(&timer->pgm_overflowint);
  4e:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
  52:	00 c0       	rjmp	.+0      	; 0x54 <timerOverflowAttach+0x54>
	}else{
		// Disable overflow interrupts
		__portMaskClear(&timer->pgm_overflowint);
  54:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
	}

	CRITICAL_SECTION_END;
  58:	df be       	out	0x3f, r13	; 63
}
  5a:	df 91       	pop	r29
  5c:	cf 91       	pop	r28
  5e:	1f 91       	pop	r17
  60:	0f 91       	pop	r16
  62:	ff 90       	pop	r15
  64:	ef 90       	pop	r14
  66:	df 90       	pop	r13
  68:	08 95       	ret

timerPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000570  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000005a4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000005a4  2**0
                  ALLOC
  3 .debug_info   00000abb  00000000  00000000  000005a4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000002ee  00000000  00000000  0000105f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000ce1  00000000  00000000  0000134d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000202e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 000000a0  00000000  00000000  0000204e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001cd  00000000  00000000  000020ee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000654  00000000  00000000  000022bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  0000290f  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000d4  00000000  00000000  0000293c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__timerPWMGetDeciHertz>:


// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	18 2f       	mov	r17, r24
  12:	fb 01       	movw	r30, r22
  14:	d4 2f       	mov	r29, r20
  16:	c5 2f       	mov	r28, r21
	uint32_t deciHertz=0;
	uint16_t top = icr;
	uint32_t cpuDivPrescale = cpu_speed * 10 / prescaler;
  18:	20 91 00 00 	lds	r18, 0x0000
  1c:	30 91 00 00 	lds	r19, 0x0000
  20:	40 91 00 00 	lds	r20, 0x0000
  24:	50 91 00 00 	lds	r21, 0x0000
  28:	aa e0       	ldi	r26, 0x0A	; 10
  2a:	b0 e0       	ldi	r27, 0x00	; 0
  2c:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  30:	9f 01       	movw	r18, r30
  32:	40 e0       	ldi	r20, 0x00	; 0
  34:	50 e0       	ldi	r21, 0x00	; 0
  36:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  3a:	69 01       	movw	r12, r18
  3c:	7a 01       	movw	r14, r20

	switch(mode){
  3e:	16 30       	cpi	r17, 0x06	; 6
  40:	01 f0       	breq	.+0      	; 0x42 <__timerPWMGetDeciHertz+0x42>
  42:	00 f4       	brcc	.+0      	; 0x44 <__timerPWMGetDeciHertz+0x44>
  44:	12 30       	cpi	r17, 0x02	; 2
  46:	01 f0       	breq	.+0      	; 0x48 <__timerPWMGetDeciHertz+0x48>
  48:	00 f4       	brcc	.+0      	; 0x4a <__timerPWMGetDeciHertz+0x4a>
  4a:	11 30       	cpi	r17, 0x01	; 1
  4c:	01 f4       	brne	.+0      	; 0x4e <__timerPWMGetDeciHertz+0x4e>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <__timerPWMGetDeciHertz+0x50>
  50:	13 30       	cpi	r17, 0x03	; 3
  52:	01 f0       	breq	.+0      	; 0x54 <__timerPWMGetDeciHertz+0x54>
  54:	15 30       	cpi	r17, 0x05	; 5
  56:	01 f4       	brne	.+0      	; 0x58 <__timerPWMGetDeciHertz+0x58>
  58:	00 c0       	rjmp	.+0      	; 0x5a <__timerPWMGetDeciHertz+0x5a>
  5a:	18 30       	cpi	r17, 0x08	; 8
  5c:	01 f0       	breq	.+0      	; 0x5e <__timerPWMGetDeciHertz+0x5e>
  5e:	00 f0       	brcs	.+0      	; 0x60 <__timerPWMGetDeciHertz+0x60>
  60:	1a 30       	cpi	r17, 0x0A	; 10
  62:	01 f0       	breq	.+0      	; 0x64 <__timerPWMGetDeciHertz+0x64>
  64:	1e 30       	cpi	r17, 0x0E	; 14
  66:	01 f4       	brne	.+0      	; 0x68 <__timerPWMGetDeciHertz+0x68>
// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
	uint32_t deciHertz=0;
	uint16_t top = icr;
  68:	0d 2f       	mov	r16, r29
  6a:	1c 2f       	mov	r17, r28
  6c:	00 c0       	rjmp	.+0      	; 0x6e <__timerPWMGetDeciHertz+0x6e>
  6e:	2d 2f       	mov	r18, r29
  70:	3c 2f       	mov	r19, r28
  72:	00 c0       	rjmp	.+0      	; 0x74 <__timerPWMGetDeciHertz+0x74>
	switch(mode){
	case TIMER_MODE_PWM8_PHASE_CORRECT:
		top=0xffU;
		goto PhaseCorrect;
	case TIMER_MODE_PWM9_PHASE_CORRECT:
		top=0x1ffU;
  74:	2f ef       	ldi	r18, 0xFF	; 255
  76:	31 e0       	ldi	r19, 0x01	; 1
		goto PhaseCorrect;
  78:	00 c0       	rjmp	.+0      	; 0x7a <__timerPWMGetDeciHertz+0x7a>
	case TIMER_MODE_PWM10_PHASE_CORRECT:
		top=0x3ffU;
  7a:	2f ef       	ldi	r18, 0xFF	; 255
  7c:	33 e0       	ldi	r19, 0x03	; 3
		goto PhaseCorrect;
  7e:	00 c0       	rjmp	.+0      	; 0x80 <__timerPWMGetDeciHertz+0x80>
	uint16_t top = icr;
	uint32_t cpuDivPrescale = cpu_speed * 10 / prescaler;

	switch(mode){
	case TIMER_MODE_PWM8_PHASE_CORRECT:
		top=0xffU;
  80:	2f ef       	ldi	r18, 0xFF	; 255
  82:	30 e0       	ldi	r19, 0x00	; 0
	case TIMER_MODE_PWM_PHASE_FREQ_ICR:
	case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
		PhaseCorrect:
		// freq      = clock / (prescaler * 2 * top);
		deciHertz = cpuDivPrescale;
		deciHertz /= top;
  84:	40 e0       	ldi	r20, 0x00	; 0
  86:	50 e0       	ldi	r21, 0x00	; 0
  88:	c7 01       	movw	r24, r14
  8a:	b6 01       	movw	r22, r12
  8c:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
		deciHertz /= 2;
  90:	56 95       	lsr	r21
  92:	47 95       	ror	r20
  94:	37 95       	ror	r19
  96:	27 95       	ror	r18
		break;
  98:	00 c0       	rjmp	.+0      	; 0x9a <__timerPWMGetDeciHertz+0x9a>

	case TIMER_MODE_PWM8_FAST:
		top=0xffU;
		goto Fast;
	case TIMER_MODE_PWM9_FAST:
		top=0x1ffU;
  9a:	0f ef       	ldi	r16, 0xFF	; 255
  9c:	11 e0       	ldi	r17, 0x01	; 1
		goto Fast;
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <__timerPWMGetDeciHertz+0xa0>
	case TIMER_MODE_PWM10_FAST:
		top=0x3ffU;
  a0:	0f ef       	ldi	r16, 0xFF	; 255
  a2:	13 e0       	ldi	r17, 0x03	; 3
		goto Fast;
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <__timerPWMGetDeciHertz+0xa6>
		deciHertz /= 2;
		break;


	case TIMER_MODE_PWM8_FAST:
		top=0xffU;
  a6:	0f ef       	ldi	r16, 0xFF	; 255
  a8:	10 e0       	ldi	r17, 0x00	; 0
		goto Fast;
	case TIMER_MODE_PWM_FAST_ICR:
		Fast:
		// freq = clock / ( prescaler * (1+top) );
		deciHertz = cpuDivPrescale;
		deciHertz /= (((uint32_t)(top))+1UL);
  aa:	98 01       	movw	r18, r16
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	50 e0       	ldi	r21, 0x00	; 0
  b0:	2f 5f       	subi	r18, 0xFF	; 255
  b2:	3f 4f       	sbci	r19, 0xFF	; 255
  b4:	4f 4f       	sbci	r20, 0xFF	; 255
  b6:	5f 4f       	sbci	r21, 0xFF	; 255
  b8:	c7 01       	movw	r24, r14
  ba:	b6 01       	movw	r22, r12
  bc:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <__timerPWMGetDeciHertz+0xc2>

// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
	uint32_t deciHertz=0;
  c2:	20 e0       	ldi	r18, 0x00	; 0
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	a9 01       	movw	r20, r18
	default:
		break;

	}
	return deciHertz;
}
  c8:	b9 01       	movw	r22, r18
  ca:	ca 01       	movw	r24, r20
  cc:	df 91       	pop	r29
  ce:	cf 91       	pop	r28
  d0:	1f 91       	pop	r17
  d2:	0f 91       	pop	r16
  d4:	ff 90       	pop	r15
  d6:	ef 90       	pop	r14
  d8:	df 90       	pop	r13
  da:	cf 90       	pop	r12
  dc:	08 95       	ret

000000de <TimerGetPwmDeciHertz>:

uint32_t TimerGetPwmDeciHertz(const Timer* timer){
  de:	cf 93       	push	r28
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
  e0:	fc 01       	movw	r30, r24
  e2:	34 96       	adiw	r30, 0x04	; 4
  e4:	25 91       	lpm	r18, Z+
  e6:	34 91       	lpm	r19, Z
  e8:	f9 01       	movw	r30, r18
  ea:	20 81       	ld	r18, Z
  ec:	27 70       	andi	r18, 0x07	; 7
  ee:	01 f0       	breq	.+0      	; 0xf0 <TimerGetPwmDeciHertz+0x12>
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <TimerGetPwmDeciHertz+0x14>
	if(timerIsInUse(timer)){
		TIMER_MODE mode = timerGetMode(timer);
		uint16_t prescale = timerGetPrescaler(timer);
		uint16_t icr;
		if(modeIsICR(mode)){
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
  f2:	fc 01       	movw	r30, r24
  f4:	7f 96       	adiw	r30, 0x1f	; 31
  f6:	25 91       	lpm	r18, Z+
  f8:	34 91       	lpm	r19, Z
			icr = _SFR_MEM16(icrPort);
  fa:	f9 01       	movw	r30, r18
  fc:	40 81       	ld	r20, Z
  fe:	51 81       	ldd	r21, Z+1	; 0x01
		}else{
			icr = 0;
		}
		rtn =  __timerPWMGetDeciHertz(mode,prescale,icr);
 100:	8c 2f       	mov	r24, r28
	}
	return rtn;
}
 102:	cf 91       	pop	r28
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
			icr = _SFR_MEM16(icrPort);
		}else{
			icr = 0;
		}
		rtn =  __timerPWMGetDeciHertz(mode,prescale,icr);
 104:	0c 94 00 00 	jmp	0	; 0x0 <__timerPWMGetDeciHertz>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 108:	fc 01       	movw	r30, r24
 10a:	a5 91       	lpm	r26, Z+
 10c:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
 10e:	1a 96       	adiw	r26, 0x0a	; 10
 110:	cc 91       	ld	r28, X
 112:	1a 97       	sbiw	r26, 0x0a	; 10
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
 114:	6d 91       	ld	r22, X+
 116:	7c 91       	ld	r23, X
	uint32_t rtn = 0;
	if(timerIsInUse(timer)){
		TIMER_MODE mode = timerGetMode(timer);
		uint16_t prescale = timerGetPrescaler(timer);
		uint16_t icr;
		if(modeIsICR(mode)){
 118:	21 e0       	ldi	r18, 0x01	; 1
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	0c 2e       	mov	r0, r28
 11e:	00 c0       	rjmp	.+0      	; 0x120 <TimerGetPwmDeciHertz+0x42>
 120:	22 0f       	add	r18, r18
 122:	33 1f       	adc	r19, r19
 124:	0a 94       	dec	r0
 126:	02 f4       	brpl	.+0      	; 0x128 <TimerGetPwmDeciHertz+0x4a>
 128:	22 27       	eor	r18, r18
 12a:	35 75       	andi	r19, 0x55	; 85
 12c:	23 2b       	or	r18, r19
 12e:	01 f4       	brne	.+0      	; 0x130 <TimerGetPwmDeciHertz+0x52>
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
			icr = _SFR_MEM16(icrPort);
		}else{
			icr = 0;
 130:	40 e0       	ldi	r20, 0x00	; 0
 132:	50 e0       	ldi	r21, 0x00	; 0
 134:	00 c0       	rjmp	.+0      	; 0x136 <TimerGetPwmDeciHertz+0x58>
		}
		rtn =  __timerPWMGetDeciHertz(mode,prescale,icr);
	}
	return rtn;
}
 136:	60 e0       	ldi	r22, 0x00	; 0
 138:	70 e0       	ldi	r23, 0x00	; 0
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	cf 91       	pop	r28
 140:	08 95       	ret

00000142 <timerCalcPwm>:

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
 142:	2f 92       	push	r2
 144:	3f 92       	push	r3
 146:	4f 92       	push	r4
 148:	5f 92       	push	r5
 14a:	6f 92       	push	r6
 14c:	7f 92       	push	r7
 14e:	8f 92       	push	r8
 150:	9f 92       	push	r9
 152:	af 92       	push	r10
 154:	bf 92       	push	r11
 156:	cf 92       	push	r12
 158:	df 92       	push	r13
 15a:	ef 92       	push	r14
 15c:	ff 92       	push	r15
 15e:	0f 93       	push	r16
 160:	1f 93       	push	r17
 162:	cf 93       	push	r28
 164:	df 93       	push	r29
 166:	cd b7       	in	r28, 0x3d	; 61
 168:	de b7       	in	r29, 0x3e	; 62
 16a:	a2 97       	sbiw	r28, 0x22	; 34
 16c:	0f b6       	in	r0, 0x3f	; 63
 16e:	f8 94       	cli
 170:	de bf       	out	0x3e, r29	; 62
 172:	0f be       	out	0x3f, r0	; 63
 174:	cd bf       	out	0x3d, r28	; 61
 176:	1c 01       	movw	r2, r24
 178:	4a 01       	movw	r8, r20
 17a:	5b 01       	movw	r10, r22
 17c:	38 8b       	std	Y+16, r19	; 0x10
 17e:	2f 87       	std	Y+15, r18	; 0x0f
 180:	1a 8b       	std	Y+18, r17	; 0x12
 182:	09 8b       	std	Y+17, r16	; 0x11
 184:	fc 8a       	std	Y+20, r15	; 0x14
 186:	eb 8a       	std	Y+19, r14	; 0x13
 188:	de 8a       	std	Y+22, r13	; 0x16
 18a:	cd 8a       	std	Y+21, r12	; 0x15
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 18c:	fc 01       	movw	r30, r24
 18e:	34 96       	adiw	r30, 0x04	; 4
 190:	85 91       	lpm	r24, Z+
 192:	94 91       	lpm	r25, Z
 194:	fc 01       	movw	r30, r24
 196:	80 81       	ld	r24, Z
 198:	87 70       	andi	r24, 0x07	; 7
 19a:	01 f0       	breq	.+0      	; 0x19c <timerCalcPwm+0x5a>
 19c:	00 c0       	rjmp	.+0      	; 0x19e <timerCalcPwm+0x5c>
	TIMER_MODE min = 0;
	TIMER_MODE max = MAX_MODES-1;
 19e:	2f e0       	ldi	r18, 0x0F	; 15
 1a0:	29 83       	std	Y+1, r18	; 0x01
	}
	return rtn;
}

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
	TIMER_MODE min = 0;
 1a2:	e0 e0       	ldi	r30, 0x00	; 0
	// Only try the current setting if the timer is in use
	if(timerIsInUse(timer)){
		min = max = timerGetMode(timer);
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);
 1a4:	40 90 00 00 	lds	r4, 0x0000
 1a8:	50 90 00 00 	lds	r5, 0x0000
 1ac:	60 90 00 00 	lds	r6, 0x0000
 1b0:	70 90 00 00 	lds	r7, 0x0000
			case TIMER_MODE_PWM_FAST_ICR:
				top = 0xffffU;
				Fast:
				// freq      = clock / ( prescaler * (1+top) );
				// prescaler = clock / ( freq * (1+top) )
				exactPrescaler = cpu_speed * 10; // convert deciHertz to Hertz
 1b4:	aa e0       	ldi	r26, 0x0A	; 10
 1b6:	b0 e0       	ldi	r27, 0x00	; 0
 1b8:	a3 01       	movw	r20, r6
 1ba:	92 01       	movw	r18, r4
 1bc:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 1c0:	6b 87       	std	Y+11, r22	; 0x0b
 1c2:	7c 87       	std	Y+12, r23	; 0x0c
 1c4:	8d 87       	std	Y+13, r24	; 0x0d
 1c6:	9e 87       	std	Y+14, r25	; 0x0e
	// Only try the current setting if the timer is in use
	if(timerIsInUse(timer)){
		min = max = timerGetMode(timer);
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);
 1c8:	56 95       	lsr	r21
 1ca:	47 95       	ror	r20
 1cc:	37 95       	ror	r19
 1ce:	27 95       	ror	r18
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
 1d0:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 1d4:	6f 83       	std	Y+7, r22	; 0x07
 1d6:	78 87       	std	Y+8, r23	; 0x08
 1d8:	89 87       	std	Y+9, r24	; 0x09
 1da:	9a 87       	std	Y+10, r25	; 0x0a
	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;

	for(TIMER_MODE mode = min ; mode <= max; mode++){
 1dc:	e9 a3       	std	Y+33, r30	; 0x21
	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;
 1de:	1e 82       	std	Y+6, r1	; 0x06
 1e0:	1d 82       	std	Y+5, r1	; 0x05

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
 1e2:	1c 82       	std	Y+4, r1	; 0x04
 1e4:	1b 82       	std	Y+3, r1	; 0x03
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
 1e6:	1a 82       	std	Y+2, r1	; 0x02
		min = max = timerGetMode(timer);
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
 1e8:	c1 2c       	mov	r12, r1
 1ea:	d1 2c       	mov	r13, r1
 1ec:	76 01       	movw	r14, r12
}

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
	TIMER_MODE min = 0;
	TIMER_MODE max = MAX_MODES-1;
	boolean rtn = FALSE;	// Default return is that it cannot be set
 1ee:	1a a2       	std	Y+34, r1	; 0x22
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
 1f0:	f1 01       	movw	r30, r2
 1f2:	39 96       	adiw	r30, 0x09	; 9
 1f4:	45 91       	lpm	r20, Z+
 1f6:	54 91       	lpm	r21, Z
 1f8:	5c 8f       	std	Y+28, r21	; 0x1c
 1fa:	4b 8f       	std	Y+27, r20	; 0x1b
						default:
							break;
						}

					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
					icr = CLAMP(tempTop, steps, 0xffffu);
 1fc:	af 85       	ldd	r26, Y+15	; 0x0f
 1fe:	b8 89       	ldd	r27, Y+16	; 0x10
 200:	cd 01       	movw	r24, r26
 202:	a0 e0       	ldi	r26, 0x00	; 0
 204:	b0 e0       	ldi	r27, 0x00	; 0
 206:	8f 8b       	std	Y+23, r24	; 0x17
 208:	98 8f       	std	Y+24, r25	; 0x18
 20a:	a9 8f       	std	Y+25, r26	; 0x19
 20c:	ba 8f       	std	Y+26, r27	; 0x1a
	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;

	for(TIMER_MODE mode = min ; mode <= max; mode++){
 20e:	00 c0       	rjmp	.+0      	; 0x210 <timerCalcPwm+0xce>
		// Try the next mode
		if(modeIsPWM(mode) && timerIsModeSupported(timer,mode)){
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	90 e0       	ldi	r25, 0x00	; 0
 214:	09 a0       	ldd	r0, Y+33	; 0x21
 216:	00 c0       	rjmp	.+0      	; 0x218 <timerCalcPwm+0xd6>
 218:	88 0f       	add	r24, r24
 21a:	99 1f       	adc	r25, r25
 21c:	0a 94       	dec	r0
 21e:	02 f4       	brpl	.+0      	; 0x220 <timerCalcPwm+0xde>
 220:	9c 01       	movw	r18, r24
 222:	2e 7e       	andi	r18, 0xEE	; 238
 224:	3f 7c       	andi	r19, 0xCF	; 207
 226:	23 2b       	or	r18, r19
 228:	01 f4       	brne	.+0      	; 0x22a <timerCalcPwm+0xe8>
 22a:	00 c0       	rjmp	.+0      	; 0x22c <timerCalcPwm+0xea>
 22c:	eb 8d       	ldd	r30, Y+27	; 0x1b
 22e:	fc 8d       	ldd	r31, Y+28	; 0x1c
 230:	8e 23       	and	r24, r30
 232:	9f 23       	and	r25, r31
 234:	89 2b       	or	r24, r25
 236:	01 f4       	brne	.+0      	; 0x238 <timerCalcPwm+0xf6>
 238:	00 c0       	rjmp	.+0      	; 0x23a <timerCalcPwm+0xf8>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <timerCalcPwm+0xfa>
				goto PhaseCorrect;
			case TIMER_MODE_PWM_PHASE_FREQ_ICR:
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
 23c:	66 24       	eor	r6, r6
 23e:	6a 94       	dec	r6
 240:	76 2c       	mov	r7, r6
 242:	00 c0       	rjmp	.+0      	; 0x244 <timerCalcPwm+0x102>
				goto PhaseCorrect;
			case TIMER_MODE_PWM9_PHASE_CORRECT:
				top=0x1ffU;
				goto PhaseCorrect;
			case TIMER_MODE_PWM10_PHASE_CORRECT:
				top=0x3ffU;
 244:	66 24       	eor	r6, r6
 246:	6a 94       	dec	r6
 248:	63 e0       	ldi	r22, 0x03	; 3
 24a:	76 2e       	mov	r7, r22
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
				if(deciHertz){
 24c:	81 14       	cp	r8, r1
 24e:	91 04       	cpc	r9, r1
 250:	a1 04       	cpc	r10, r1
 252:	b1 04       	cpc	r11, r1
 254:	01 f0       	breq	.+0      	; 0x256 <timerCalcPwm+0x114>
					exactPrescaler /= deciHertz;
 256:	6f 81       	ldd	r22, Y+7	; 0x07
 258:	78 85       	ldd	r23, Y+8	; 0x08
 25a:	89 85       	ldd	r24, Y+9	; 0x09
 25c:	9a 85       	ldd	r25, Y+10	; 0x0a
 25e:	a5 01       	movw	r20, r10
 260:	94 01       	movw	r18, r8
 262:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 266:	f9 01       	movw	r30, r18
 268:	14 2f       	mov	r17, r20
 26a:	05 2f       	mov	r16, r21
 26c:	00 c0       	rjmp	.+0      	; 0x26e <timerCalcPwm+0x12c>
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
 26e:	ef 81       	ldd	r30, Y+7	; 0x07
 270:	f8 85       	ldd	r31, Y+8	; 0x08
 272:	19 85       	ldd	r17, Y+9	; 0x09
 274:	0a 85       	ldd	r16, Y+10	; 0x0a
				if(deciHertz){
					exactPrescaler /= deciHertz;
				}
				exactPrescaler /= top;
 276:	93 01       	movw	r18, r6
 278:	40 e0       	ldi	r20, 0x00	; 0
 27a:	50 e0       	ldi	r21, 0x00	; 0
 27c:	00 c0       	rjmp	.+0      	; 0x27e <timerCalcPwm+0x13c>
				goto Fast;
			case TIMER_MODE_PWM10_FAST:
				top=0x3ffU;
				goto Fast;
			case TIMER_MODE_PWM_FAST_ICR:
				top = 0xffffU;
 27e:	66 24       	eor	r6, r6
 280:	6a 94       	dec	r6
 282:	76 2c       	mov	r7, r6
 284:	00 c0       	rjmp	.+0      	; 0x286 <timerCalcPwm+0x144>
				goto Fast;
			case TIMER_MODE_PWM9_FAST:
				top=0x1ffU;
				goto Fast;
			case TIMER_MODE_PWM10_FAST:
				top=0x3ffU;
 286:	66 24       	eor	r6, r6
 288:	6a 94       	dec	r6
 28a:	53 e0       	ldi	r21, 0x03	; 3
 28c:	75 2e       	mov	r7, r21
				Fast:
				// freq      = clock / ( prescaler * (1+top) );
				// prescaler = clock / ( freq * (1+top) )
				exactPrescaler = cpu_speed * 10; // convert deciHertz to Hertz
				// avoid div by 0
				if(deciHertz){
 28e:	81 14       	cp	r8, r1
 290:	91 04       	cpc	r9, r1
 292:	a1 04       	cpc	r10, r1
 294:	b1 04       	cpc	r11, r1
 296:	01 f0       	breq	.+0      	; 0x298 <timerCalcPwm+0x156>
					exactPrescaler /= deciHertz;
 298:	6b 85       	ldd	r22, Y+11	; 0x0b
 29a:	7c 85       	ldd	r23, Y+12	; 0x0c
 29c:	8d 85       	ldd	r24, Y+13	; 0x0d
 29e:	9e 85       	ldd	r25, Y+14	; 0x0e
 2a0:	a5 01       	movw	r20, r10
 2a2:	94 01       	movw	r18, r8
 2a4:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 2a8:	f9 01       	movw	r30, r18
 2aa:	14 2f       	mov	r17, r20
 2ac:	05 2f       	mov	r16, r21
 2ae:	00 c0       	rjmp	.+0      	; 0x2b0 <timerCalcPwm+0x16e>
			case TIMER_MODE_PWM_FAST_ICR:
				top = 0xffffU;
				Fast:
				// freq      = clock / ( prescaler * (1+top) );
				// prescaler = clock / ( freq * (1+top) )
				exactPrescaler = cpu_speed * 10; // convert deciHertz to Hertz
 2b0:	eb 85       	ldd	r30, Y+11	; 0x0b
 2b2:	fc 85       	ldd	r31, Y+12	; 0x0c
 2b4:	1d 85       	ldd	r17, Y+13	; 0x0d
 2b6:	0e 85       	ldd	r16, Y+14	; 0x0e
				// avoid div by 0
				if(deciHertz){
					exactPrescaler /= deciHertz;
				}
				exactPrescaler /= ( ((uint32_t)(top)) + 1UL );
 2b8:	93 01       	movw	r18, r6
 2ba:	40 e0       	ldi	r20, 0x00	; 0
 2bc:	50 e0       	ldi	r21, 0x00	; 0
 2be:	2f 5f       	subi	r18, 0xFF	; 255
 2c0:	3f 4f       	sbci	r19, 0xFF	; 255
 2c2:	4f 4f       	sbci	r20, 0xFF	; 255
 2c4:	5f 4f       	sbci	r21, 0xFF	; 255
 2c6:	bf 01       	movw	r22, r30
 2c8:	81 2f       	mov	r24, r17
 2ca:	90 2f       	mov	r25, r16
 2cc:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <timerCalcPwm+0x190>
				break;
			}

			if(usable){
				// Make sure the prescaler is in valid bounds - even tho value may not be available
				uint16_t prescaler = CLAMP(exactPrescaler, 1, MAX_PRESCALE);
 2d2:	da 01       	movw	r26, r20
 2d4:	c9 01       	movw	r24, r18
 2d6:	21 30       	cpi	r18, 0x01	; 1
 2d8:	f4 e0       	ldi	r31, 0x04	; 4
 2da:	3f 07       	cpc	r19, r31
 2dc:	41 05       	cpc	r20, r1
 2de:	51 05       	cpc	r21, r1
 2e0:	00 f0       	brcs	.+0      	; 0x2e2 <timerCalcPwm+0x1a0>
 2e2:	80 e0       	ldi	r24, 0x00	; 0
 2e4:	94 e0       	ldi	r25, 0x04	; 4
 2e6:	a0 e0       	ldi	r26, 0x00	; 0
 2e8:	b0 e0       	ldi	r27, 0x00	; 0
 2ea:	bc 01       	movw	r22, r24
				uint16_t icr = 0;
				uint32_t tempTop=0;

				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);
 2ec:	c1 01       	movw	r24, r2
 2ee:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>

				if(deciHertz==PWM_SLOWEST){
 2f2:	81 14       	cp	r8, r1
 2f4:	91 04       	cpc	r9, r1
 2f6:	a1 04       	cpc	r10, r1
 2f8:	b1 04       	cpc	r11, r1
 2fa:	01 f4       	brne	.+0      	; 0x2fc <timerCalcPwm+0x1ba>
 2fc:	00 c0       	rjmp	.+0      	; 0x2fe <timerCalcPwm+0x1bc>
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
 2fe:	2f ef       	ldi	r18, 0xFF	; 255
 300:	82 16       	cp	r8, r18
 302:	92 06       	cpc	r9, r18
 304:	a2 06       	cpc	r10, r18
 306:	b2 06       	cpc	r11, r18
 308:	01 f4       	brne	.+0      	; 0x30a <timerCalcPwm+0x1c8>
 30a:	00 c0       	rjmp	.+0      	; 0x30c <timerCalcPwm+0x1ca>
					prescaler = 1;
					icr = steps;		// At least the required number of steps
				}else{
					// Work out the value for top
					prescaler--;
 30c:	8c 01       	movw	r16, r24
 30e:	01 50       	subi	r16, 0x01	; 1
 310:	11 09       	sbc	r17, r1

			if(usable){
				// Make sure the prescaler is in valid bounds - even tho value may not be available
				uint16_t prescaler = CLAMP(exactPrescaler, 1, MAX_PRESCALE);
				uint16_t icr = 0;
				uint32_t tempTop=0;
 312:	20 e0       	ldi	r18, 0x00	; 0
 314:	30 e0       	ldi	r19, 0x00	; 0
 316:	a9 01       	movw	r20, r18
					icr = steps;		// At least the required number of steps
				}else{
					// Work out the value for top
					prescaler--;
					do{
						prescaler = timerGetClosestPrescale(timer, ++prescaler);
 318:	b8 01       	movw	r22, r16
 31a:	6f 5f       	subi	r22, 0xFF	; 255
 31c:	7f 4f       	sbci	r23, 0xFF	; 255
 31e:	c1 01       	movw	r24, r2
 320:	2f 8f       	std	Y+31, r18	; 0x1f
 322:	38 a3       	std	Y+32, r19	; 0x20
 324:	4d 8f       	std	Y+29, r20	; 0x1d
 326:	5e 8f       	std	Y+30, r21	; 0x1e
 328:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 32c:	8c 01       	movw	r16, r24

						// Find value for TOP
						switch(mode){
 32e:	2f 8d       	ldd	r18, Y+31	; 0x1f
 330:	38 a1       	ldd	r19, Y+32	; 0x20
 332:	4d 8d       	ldd	r20, Y+29	; 0x1d
 334:	5e 8d       	ldd	r21, Y+30	; 0x1e
 336:	89 a1       	ldd	r24, Y+33	; 0x21
 338:	8a 30       	cpi	r24, 0x0A	; 10
 33a:	01 f0       	breq	.+0      	; 0x33c <timerCalcPwm+0x1fa>
 33c:	8e 30       	cpi	r24, 0x0E	; 14
 33e:	01 f0       	breq	.+0      	; 0x340 <timerCalcPwm+0x1fe>
 340:	88 30       	cpi	r24, 0x08	; 8
 342:	01 f4       	brne	.+0      	; 0x344 <timerCalcPwm+0x202>
						case TIMER_MODE_PWM_PHASE_FREQ_ICR:
						case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
							// freq = clock / (prescaler * 2 * top);
							// top  = clock / (prescaler * 2 * freq);
							tempTop = clockDiv2 * 10;
							tempTop /= deciHertz;
 344:	6f 81       	ldd	r22, Y+7	; 0x07
 346:	78 85       	ldd	r23, Y+8	; 0x08
 348:	89 85       	ldd	r24, Y+9	; 0x09
 34a:	9a 85       	ldd	r25, Y+10	; 0x0a
 34c:	a5 01       	movw	r20, r10
 34e:	94 01       	movw	r18, r8
 350:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
							tempTop /= prescaler;
 354:	28 01       	movw	r4, r16
 356:	61 2c       	mov	r6, r1
 358:	71 2c       	mov	r7, r1
 35a:	ca 01       	movw	r24, r20
 35c:	b9 01       	movw	r22, r18
 35e:	a3 01       	movw	r20, r6
 360:	92 01       	movw	r18, r4
 362:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
							break;
 366:	00 c0       	rjmp	.+0      	; 0x368 <timerCalcPwm+0x226>
						case TIMER_MODE_PWM_FAST_ICR:
							// freq = clock / ( prescaler * (1+top) );
							// top  = (clock / ( prescaler * freq)) - 1
							tempTop = cpu_speed * 10;
							tempTop /= deciHertz;
 368:	6b 85       	ldd	r22, Y+11	; 0x0b
 36a:	7c 85       	ldd	r23, Y+12	; 0x0c
 36c:	8d 85       	ldd	r24, Y+13	; 0x0d
 36e:	9e 85       	ldd	r25, Y+14	; 0x0e
 370:	a5 01       	movw	r20, r10
 372:	94 01       	movw	r18, r8
 374:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
							tempTop /= prescaler;
 378:	28 01       	movw	r4, r16
 37a:	61 2c       	mov	r6, r1
 37c:	71 2c       	mov	r7, r1
 37e:	ca 01       	movw	r24, r20
 380:	b9 01       	movw	r22, r18
 382:	a3 01       	movw	r20, r6
 384:	92 01       	movw	r18, r4
 386:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
							tempTop--;
 38a:	21 50       	subi	r18, 0x01	; 1
 38c:	31 09       	sbc	r19, r1
 38e:	41 09       	sbc	r20, r1
 390:	51 09       	sbc	r21, r1
							break;
						default:
							break;
						}

					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
 392:	01 15       	cp	r16, r1
 394:	94 e0       	ldi	r25, 0x04	; 4
 396:	19 07       	cpc	r17, r25
 398:	00 f0       	brcs	.+0      	; 0x39a <timerCalcPwm+0x258>
					icr = CLAMP(tempTop, steps, 0xffffu);
 39a:	da 01       	movw	r26, r20
 39c:	c9 01       	movw	r24, r18
 39e:	21 15       	cp	r18, r1
 3a0:	31 05       	cpc	r19, r1
 3a2:	e1 e0       	ldi	r30, 0x01	; 1
 3a4:	4e 07       	cpc	r20, r30
 3a6:	51 05       	cpc	r21, r1
 3a8:	00 f0       	brcs	.+0      	; 0x3aa <timerCalcPwm+0x268>
 3aa:	8f ef       	ldi	r24, 0xFF	; 255
 3ac:	9f ef       	ldi	r25, 0xFF	; 255
 3ae:	a0 e0       	ldi	r26, 0x00	; 0
 3b0:	b0 e0       	ldi	r27, 0x00	; 0
 3b2:	2f 89       	ldd	r18, Y+23	; 0x17
 3b4:	38 8d       	ldd	r19, Y+24	; 0x18
 3b6:	49 8d       	ldd	r20, Y+25	; 0x19
 3b8:	5a 8d       	ldd	r21, Y+26	; 0x1a
 3ba:	82 17       	cp	r24, r18
 3bc:	93 07       	cpc	r25, r19
 3be:	a4 07       	cpc	r26, r20
 3c0:	b5 07       	cpc	r27, r21
 3c2:	00 f4       	brcc	.+0      	; 0x3c4 <timerCalcPwm+0x282>
 3c4:	da 01       	movw	r26, r20
 3c6:	c9 01       	movw	r24, r18
 3c8:	9c 01       	movw	r18, r24
 3ca:	00 c0       	rjmp	.+0      	; 0x3cc <timerCalcPwm+0x28a>
							break;
						default:
							break;
						}

					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
 3cc:	da 01       	movw	r26, r20
 3ce:	c9 01       	movw	r24, r18
 3d0:	88 27       	eor	r24, r24
 3d2:	99 27       	eor	r25, r25
 3d4:	89 2b       	or	r24, r25
 3d6:	8a 2b       	or	r24, r26
 3d8:	8b 2b       	or	r24, r27
 3da:	01 f0       	breq	.+0      	; 0x3dc <timerCalcPwm+0x29a>
 3dc:	00 c0       	rjmp	.+0      	; 0x3de <timerCalcPwm+0x29c>
 3de:	00 c0       	rjmp	.+0      	; 0x3e0 <timerCalcPwm+0x29e>
				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
 3e0:	2f ef       	ldi	r18, 0xFF	; 255
 3e2:	3f ef       	ldi	r19, 0xFF	; 255

				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
 3e4:	00 e0       	ldi	r16, 0x00	; 0
 3e6:	14 e0       	ldi	r17, 0x04	; 4
 3e8:	00 c0       	rjmp	.+0      	; 0x3ea <timerCalcPwm+0x2a8>
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
					prescaler = 1;
					icr = steps;		// At least the required number of steps
 3ea:	2f 85       	ldd	r18, Y+15	; 0x0f
 3ec:	38 89       	ldd	r19, Y+16	; 0x10

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
					prescaler = 1;
 3ee:	01 e0       	ldi	r16, 0x01	; 1
 3f0:	10 e0       	ldi	r17, 0x00	; 0
					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
					icr = CLAMP(tempTop, steps, 0xffffu);
				}

				// Now calc the frequency it would achieve
				uint32_t actual = __timerPWMGetDeciHertz(mode,prescaler,icr);
 3f2:	a9 01       	movw	r20, r18
 3f4:	b8 01       	movw	r22, r16
 3f6:	89 a1       	ldd	r24, Y+33	; 0x21
 3f8:	2f 8f       	std	Y+31, r18	; 0x1f
 3fa:	38 a3       	std	Y+32, r19	; 0x20
 3fc:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;
 400:	2f 8d       	ldd	r18, Y+31	; 0x1f
 402:	38 a1       	ldd	r19, Y+32	; 0x20
 404:	86 16       	cp	r8, r22
 406:	97 06       	cpc	r9, r23
 408:	a8 06       	cpc	r10, r24
 40a:	b9 06       	cpc	r11, r25
 40c:	00 f4       	brcc	.+0      	; 0x40e <timerCalcPwm+0x2cc>
 40e:	2b 01       	movw	r4, r22
 410:	3c 01       	movw	r6, r24
 412:	48 18       	sub	r4, r8
 414:	59 08       	sbc	r5, r9
 416:	6a 08       	sbc	r6, r10
 418:	7b 08       	sbc	r7, r11
 41a:	00 c0       	rjmp	.+0      	; 0x41c <timerCalcPwm+0x2da>
 41c:	24 01       	movw	r4, r8
 41e:	35 01       	movw	r6, r10
 420:	46 1a       	sub	r4, r22
 422:	57 0a       	sbc	r5, r23
 424:	68 0a       	sbc	r6, r24
 426:	79 0a       	sbc	r7, r25

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 428:	4a a1       	ldd	r20, Y+34	; 0x22
 42a:	44 23       	and	r20, r20
 42c:	01 f0       	breq	.+0      	; 0x42e <timerCalcPwm+0x2ec>
 42e:	4c 14       	cp	r4, r12
 430:	5d 04       	cpc	r5, r13
 432:	6e 04       	cpc	r6, r14
 434:	7f 04       	cpc	r7, r15
 436:	00 f0       	brcs	.+0      	; 0x438 <timerCalcPwm+0x2f6>
 438:	00 c0       	rjmp	.+0      	; 0x43a <timerCalcPwm+0x2f8>
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
					bestICR = icr;
 43a:	3e 83       	std	Y+6, r19	; 0x06
 43c:	2d 83       	std	Y+5, r18	; 0x05
				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
 43e:	1c 83       	std	Y+4, r17	; 0x04
 440:	0b 83       	std	Y+3, r16	; 0x03

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 442:	59 a1       	ldd	r21, Y+33	; 0x21
 444:	5a 83       	std	Y+2, r21	; 0x02
 446:	73 01       	movw	r14, r6
 448:	62 01       	movw	r12, r4
					bestError = error;
					rtn = TRUE;
 44a:	8f ef       	ldi	r24, 0xFF	; 255
 44c:	8a a3       	std	Y+34, r24	; 0x22
 44e:	00 c0       	rjmp	.+0      	; 0x450 <timerCalcPwm+0x30e>
					bestMode = mode;
					bestPrescaler = prescaler;
					bestICR = icr;
 450:	3e 83       	std	Y+6, r19	; 0x06
 452:	2d 83       	std	Y+5, r18	; 0x05
				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
 454:	1c 83       	std	Y+4, r17	; 0x04
 456:	0b 83       	std	Y+3, r16	; 0x03

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 458:	99 a1       	ldd	r25, Y+33	; 0x21
 45a:	9a 83       	std	Y+2, r25	; 0x02
 45c:	73 01       	movw	r14, r6
 45e:	62 01       	movw	r12, r4
					bestError = error;
					rtn = TRUE;
 460:	af ef       	ldi	r26, 0xFF	; 255
 462:	aa a3       	std	Y+34, r26	; 0x22
	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;

	for(TIMER_MODE mode = min ; mode <= max; mode++){
 464:	b9 a1       	ldd	r27, Y+33	; 0x21
 466:	bf 5f       	subi	r27, 0xFF	; 255
 468:	b9 a3       	std	Y+33, r27	; 0x21
 46a:	e9 a1       	ldd	r30, Y+33	; 0x21
 46c:	f9 81       	ldd	r31, Y+1	; 0x01
 46e:	fe 17       	cp	r31, r30
 470:	00 f0       	brcs	.+0      	; 0x472 <timerCalcPwm+0x330>
 472:	00 c0       	rjmp	.+0      	; 0x474 <timerCalcPwm+0x332>
			} // End if usable
		} // this mode cannot be used
	} // next mode

	// Return values
	if(rtn){
 474:	2a a1       	ldd	r18, Y+34	; 0x22
 476:	22 23       	and	r18, r18
 478:	01 f4       	brne	.+0      	; 0x47a <timerCalcPwm+0x338>
 47a:	00 c0       	rjmp	.+0      	; 0x47c <timerCalcPwm+0x33a>
		if(modeRtn){
 47c:	49 89       	ldd	r20, Y+17	; 0x11
 47e:	5a 89       	ldd	r21, Y+18	; 0x12
 480:	41 15       	cp	r20, r1
 482:	51 05       	cpc	r21, r1
 484:	01 f0       	breq	.+0      	; 0x486 <timerCalcPwm+0x344>
			*modeRtn = bestMode;
 486:	ea 81       	ldd	r30, Y+2	; 0x02
 488:	da 01       	movw	r26, r20
 48a:	ec 93       	st	X, r30
		}
		if(icrRtn){
 48c:	2b 89       	ldd	r18, Y+19	; 0x13
 48e:	3c 89       	ldd	r19, Y+20	; 0x14
 490:	21 15       	cp	r18, r1
 492:	31 05       	cpc	r19, r1
 494:	01 f0       	breq	.+0      	; 0x496 <timerCalcPwm+0x354>
			*icrRtn = bestICR;
 496:	ed 81       	ldd	r30, Y+5	; 0x05
 498:	fe 81       	ldd	r31, Y+6	; 0x06
 49a:	d9 01       	movw	r26, r18
 49c:	ed 93       	st	X+, r30
 49e:	fc 93       	st	X, r31
		}
		if(prescaleRtn){
 4a0:	2d 89       	ldd	r18, Y+21	; 0x15
 4a2:	3e 89       	ldd	r19, Y+22	; 0x16
 4a4:	21 15       	cp	r18, r1
 4a6:	31 05       	cpc	r19, r1
 4a8:	01 f4       	brne	.+0      	; 0x4aa <timerCalcPwm+0x368>
 4aa:	00 c0       	rjmp	.+0      	; 0x4ac <timerCalcPwm+0x36a>
			*prescaleRtn = bestPrescaler;
 4ac:	eb 81       	ldd	r30, Y+3	; 0x03
 4ae:	fc 81       	ldd	r31, Y+4	; 0x04
 4b0:	d9 01       	movw	r26, r18
 4b2:	ed 93       	st	X+, r30
 4b4:	fc 93       	st	X, r31
 4b6:	00 c0       	rjmp	.+0      	; 0x4b8 <timerCalcPwm+0x376>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 4b8:	f1 01       	movw	r30, r2
 4ba:	a5 91       	lpm	r26, Z+
 4bc:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
 4be:	1a 96       	adiw	r26, 0x0a	; 10
 4c0:	fc 91       	ld	r31, X
 4c2:	f9 83       	std	Y+1, r31	; 0x01
	TIMER_MODE max = MAX_MODES-1;
	boolean rtn = FALSE;	// Default return is that it cannot be set

	// Only try the current setting if the timer is in use
	if(timerIsInUse(timer)){
		min = max = timerGetMode(timer);
 4c4:	ef 2f       	mov	r30, r31
 4c6:	00 c0       	rjmp	.+0      	; 0x4c8 <timerCalcPwm+0x386>
			// The timer supports this mode
			uint16_t top;
			uint32_t exactPrescaler;
			boolean usable=FALSE;

			switch(mode){
 4c8:	29 a1       	ldd	r18, Y+33	; 0x21
 4ca:	26 30       	cpi	r18, 0x06	; 6
 4cc:	01 f0       	breq	.+0      	; 0x4ce <timerCalcPwm+0x38c>
 4ce:	00 f4       	brcc	.+0      	; 0x4d0 <timerCalcPwm+0x38e>
 4d0:	22 30       	cpi	r18, 0x02	; 2
 4d2:	01 f0       	breq	.+0      	; 0x4d4 <timerCalcPwm+0x392>
 4d4:	00 f4       	brcc	.+0      	; 0x4d6 <timerCalcPwm+0x394>
 4d6:	21 30       	cpi	r18, 0x01	; 1
 4d8:	01 f4       	brne	.+0      	; 0x4da <timerCalcPwm+0x398>
 4da:	00 c0       	rjmp	.+0      	; 0x4dc <timerCalcPwm+0x39a>
 4dc:	39 a1       	ldd	r19, Y+33	; 0x21
 4de:	33 30       	cpi	r19, 0x03	; 3
 4e0:	01 f4       	brne	.+0      	; 0x4e2 <timerCalcPwm+0x3a0>
 4e2:	00 c0       	rjmp	.+0      	; 0x4e4 <timerCalcPwm+0x3a2>
 4e4:	35 30       	cpi	r19, 0x05	; 5
 4e6:	01 f0       	breq	.+0      	; 0x4e8 <timerCalcPwm+0x3a6>
 4e8:	00 c0       	rjmp	.+0      	; 0x4ea <timerCalcPwm+0x3a8>
 4ea:	00 c0       	rjmp	.+0      	; 0x4ec <timerCalcPwm+0x3aa>
 4ec:	49 a1       	ldd	r20, Y+33	; 0x21
 4ee:	48 30       	cpi	r20, 0x08	; 8
 4f0:	01 f4       	brne	.+0      	; 0x4f2 <timerCalcPwm+0x3b0>
 4f2:	00 c0       	rjmp	.+0      	; 0x4f4 <timerCalcPwm+0x3b2>
 4f4:	00 f4       	brcc	.+0      	; 0x4f6 <timerCalcPwm+0x3b4>
 4f6:	00 c0       	rjmp	.+0      	; 0x4f8 <timerCalcPwm+0x3b6>
 4f8:	4a 30       	cpi	r20, 0x0A	; 10
 4fa:	01 f4       	brne	.+0      	; 0x4fc <timerCalcPwm+0x3ba>
 4fc:	00 c0       	rjmp	.+0      	; 0x4fe <timerCalcPwm+0x3bc>
 4fe:	4e 30       	cpi	r20, 0x0E	; 14
 500:	01 f0       	breq	.+0      	; 0x502 <timerCalcPwm+0x3c0>
 502:	00 c0       	rjmp	.+0      	; 0x504 <timerCalcPwm+0x3c2>
 504:	00 c0       	rjmp	.+0      	; 0x506 <timerCalcPwm+0x3c4>
				}
				exactPrescaler /= top;
				goto Usable;

			case TIMER_MODE_PWM8_FAST:
				top=0xffU;
 506:	66 24       	eor	r6, r6
 508:	6a 94       	dec	r6
 50a:	71 2c       	mov	r7, r1
 50c:	00 c0       	rjmp	.+0      	; 0x50e <timerCalcPwm+0x3cc>
			uint32_t exactPrescaler;
			boolean usable=FALSE;

			switch(mode){
			case TIMER_MODE_PWM8_PHASE_CORRECT:
				top=0xffU;
 50e:	66 24       	eor	r6, r6
 510:	6a 94       	dec	r6
 512:	71 2c       	mov	r7, r1
 514:	00 c0       	rjmp	.+0      	; 0x516 <timerCalcPwm+0x3d4>

			case TIMER_MODE_PWM8_FAST:
				top=0xffU;
				goto Fast;
			case TIMER_MODE_PWM9_FAST:
				top=0x1ffU;
 516:	66 24       	eor	r6, r6
 518:	6a 94       	dec	r6
 51a:	77 24       	eor	r7, r7
 51c:	73 94       	inc	r7
 51e:	00 c0       	rjmp	.+0      	; 0x520 <timerCalcPwm+0x3de>
			switch(mode){
			case TIMER_MODE_PWM8_PHASE_CORRECT:
				top=0xffU;
				goto PhaseCorrect;
			case TIMER_MODE_PWM9_PHASE_CORRECT:
				top=0x1ffU;
 520:	66 24       	eor	r6, r6
 522:	6a 94       	dec	r6
 524:	77 24       	eor	r7, r7
 526:	73 94       	inc	r7
 528:	00 c0       	rjmp	.+0      	; 0x52a <timerCalcPwm+0x3e8>
				break;
			}

			if(usable){
				// Make sure the prescaler is in valid bounds - even tho value may not be available
				uint16_t prescaler = CLAMP(exactPrescaler, 1, MAX_PRESCALE);
 52a:	22 30       	cpi	r18, 0x02	; 2
 52c:	31 05       	cpc	r19, r1
 52e:	41 05       	cpc	r20, r1
 530:	51 05       	cpc	r21, r1
 532:	00 f0       	brcs	.+0      	; 0x534 <timerCalcPwm+0x3f2>
 534:	00 c0       	rjmp	.+0      	; 0x536 <timerCalcPwm+0x3f4>
 536:	61 e0       	ldi	r22, 0x01	; 1
 538:	70 e0       	ldi	r23, 0x00	; 0
 53a:	00 c0       	rjmp	.+0      	; 0x53c <timerCalcPwm+0x3fa>
			*prescaleRtn = bestPrescaler;
		}
	}

	return rtn;
}
 53c:	8a a1       	ldd	r24, Y+34	; 0x22
 53e:	a2 96       	adiw	r28, 0x22	; 34
 540:	0f b6       	in	r0, 0x3f	; 63
 542:	f8 94       	cli
 544:	de bf       	out	0x3e, r29	; 62
 546:	0f be       	out	0x3f, r0	; 63
 548:	cd bf       	out	0x3d, r28	; 61
 54a:	df 91       	pop	r29
 54c:	cf 91       	pop	r28
 54e:	1f 91       	pop	r17
 550:	0f 91       	pop	r16
 552:	ff 90       	pop	r15
 554:	ef 90       	pop	r14
 556:	df 90       	pop	r13
 558:	cf 90       	pop	r12
 55a:	bf 90       	pop	r11
 55c:	af 90       	pop	r10
 55e:	9f 90       	pop	r9
 560:	8f 90       	pop	r8
 562:	7f 90       	pop	r7
 564:	6f 90       	pop	r6
 566:	5f 90       	pop	r5
 568:	4f 90       	pop	r4
 56a:	3f 90       	pop	r3
 56c:	2f 90       	pop	r2
 56e:	08 95       	ret

uart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000206  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000023a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000023a  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  0000023a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000007de  00000000  00000000  00000246  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000027e  00000000  00000000  00000a24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000047c  00000000  00000000  00000ca2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000111e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000144  00000000  00000000  0000113e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003a8  00000000  00000000  00001282  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .comment      0000002a  00000000  00000000  0000162a  2**0
                  CONTENTS, READONLY
 11 .debug_frame  000000d8  00000000  00000000  00001654  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__uartHWSetBaudRate>:


// Sets the uart baud rate.
// Argument should be in bits-per-second, like uartSetBaudRate(9600);
// or may be BAUD_RATE_MAX to use the highest possible(if inaccurate) baud rate
void __uartHWSetBaudRate(UART* uart, BAUD_RATE baudrate){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	bf 92       	push	r11
   6:	cf 92       	push	r12
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	ec 01       	movw	r28, r24
  18:	6a 01       	movw	r12, r20
  1a:	7b 01       	movw	r14, r22
	HW_UART* hwUart = (HW_UART*)uart;
	CRITICAL_SECTION_START;
  1c:	bf b6       	in	r11, 0x3f	; 63
  1e:	f8 94       	cli
	// calculate division factor for requested baud rate, and set it
	uint16_t bauddiv = (baudrate==BAUD_RATE_MAX) ? 1 : ((cpu_speed + (baudrate*8L))/(baudrate*16L)-1);
  20:	4f 3f       	cpi	r20, 0xFF	; 255
  22:	8f ef       	ldi	r24, 0xFF	; 255
  24:	58 07       	cpc	r21, r24
  26:	68 07       	cpc	r22, r24
  28:	78 07       	cpc	r23, r24
  2a:	01 f0       	breq	.+0      	; 0x2c <__uartHWSetBaudRate+0x2c>
  2c:	cb 01       	movw	r24, r22
  2e:	ba 01       	movw	r22, r20
  30:	a3 e0       	ldi	r26, 0x03	; 3
  32:	66 0f       	add	r22, r22
  34:	77 1f       	adc	r23, r23
  36:	88 1f       	adc	r24, r24
  38:	99 1f       	adc	r25, r25
  3a:	aa 95       	dec	r26
  3c:	01 f4       	brne	.+0      	; 0x3e <__uartHWSetBaudRate+0x3e>
  3e:	00 91 00 00 	lds	r16, 0x0000
  42:	10 91 00 00 	lds	r17, 0x0000
  46:	20 91 00 00 	lds	r18, 0x0000
  4a:	30 91 00 00 	lds	r19, 0x0000
  4e:	60 0f       	add	r22, r16
  50:	71 1f       	adc	r23, r17
  52:	82 1f       	adc	r24, r18
  54:	93 1f       	adc	r25, r19
  56:	a7 01       	movw	r20, r14
  58:	96 01       	movw	r18, r12
  5a:	b4 e0       	ldi	r27, 0x04	; 4
  5c:	22 0f       	add	r18, r18
  5e:	33 1f       	adc	r19, r19
  60:	44 1f       	adc	r20, r20
  62:	55 1f       	adc	r21, r21
  64:	ba 95       	dec	r27
  66:	01 f4       	brne	.+0      	; 0x68 <__uartHWSetBaudRate+0x68>
  68:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>
  6c:	49 01       	movw	r8, r18
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	88 1a       	sub	r8, r24
  72:	91 08       	sbc	r9, r1
  74:	00 c0       	rjmp	.+0      	; 0x76 <__uartHWSetBaudRate+0x76>
  76:	88 24       	eor	r8, r8
  78:	83 94       	inc	r8
  7a:	91 2c       	mov	r9, r1
	if(hwUart->u2xMask != 0){
  7c:	9e a1       	ldd	r25, Y+38	; 0x26
  7e:	99 23       	and	r25, r25
  80:	01 f0       	breq	.+0      	; 0x82 <__uartHWSetBaudRate+0x82>
		_SFR_MEM8(hwUart->statusA) &=  ~(hwUart->u2xMask);	// turn off u2x
  82:	ea 8d       	ldd	r30, Y+26	; 0x1a
  84:	fb 8d       	ldd	r31, Y+27	; 0x1b
  86:	80 81       	ld	r24, Z
  88:	90 95       	com	r25
  8a:	89 23       	and	r24, r25
  8c:	80 83       	st	Z, r24
		uint16_t bauddiv2 = (baudrate==BAUD_RATE_MAX) ? 1 : ((cpu_speed + (baudrate*4L))/(baudrate*8L)-1);
  8e:	8f ef       	ldi	r24, 0xFF	; 255
  90:	c8 16       	cp	r12, r24
  92:	d8 06       	cpc	r13, r24
  94:	e8 06       	cpc	r14, r24
  96:	f8 06       	cpc	r15, r24
  98:	01 f0       	breq	.+0      	; 0x9a <__uartHWSetBaudRate+0x9a>
  9a:	c7 01       	movw	r24, r14
  9c:	b6 01       	movw	r22, r12
  9e:	22 e0       	ldi	r18, 0x02	; 2
  a0:	66 0f       	add	r22, r22
  a2:	77 1f       	adc	r23, r23
  a4:	88 1f       	adc	r24, r24
  a6:	99 1f       	adc	r25, r25
  a8:	2a 95       	dec	r18
  aa:	01 f4       	brne	.+0      	; 0xac <__uartHWSetBaudRate+0xac>
  ac:	00 91 00 00 	lds	r16, 0x0000
  b0:	10 91 00 00 	lds	r17, 0x0000
  b4:	20 91 00 00 	lds	r18, 0x0000
  b8:	30 91 00 00 	lds	r19, 0x0000
  bc:	60 0f       	add	r22, r16
  be:	71 1f       	adc	r23, r17
  c0:	82 1f       	adc	r24, r18
  c2:	93 1f       	adc	r25, r19
  c4:	a7 01       	movw	r20, r14
  c6:	96 01       	movw	r18, r12
  c8:	e3 e0       	ldi	r30, 0x03	; 3
  ca:	22 0f       	add	r18, r18
  cc:	33 1f       	adc	r19, r19
  ce:	44 1f       	adc	r20, r20
  d0:	55 1f       	adc	r21, r21
  d2:	ea 95       	dec	r30
  d4:	01 f4       	brne	.+0      	; 0xd6 <__uartHWSetBaudRate+0xd6>
  d6:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>
  da:	21 50       	subi	r18, 0x01	; 1
  dc:	31 09       	sbc	r19, r1
  de:	00 c0       	rjmp	.+0      	; 0xe0 <__uartHWSetBaudRate+0xe0>
  e0:	21 e0       	ldi	r18, 0x01	; 1
  e2:	30 e0       	ldi	r19, 0x00	; 0
		if(bauddiv2 >= bauddiv){
  e4:	28 15       	cp	r18, r8
  e6:	39 05       	cpc	r19, r9
  e8:	00 f0       	brcs	.+0      	; 0xea <__uartHWSetBaudRate+0xea>
			_SFR_MEM8(hwUart->statusA) |=  hwUart->u2xMask;	// turn on u2x
  ea:	ea 8d       	ldd	r30, Y+26	; 0x1a
  ec:	fb 8d       	ldd	r31, Y+27	; 0x1b
  ee:	80 81       	ld	r24, Z
  f0:	9e a1       	ldd	r25, Y+38	; 0x26
  f2:	89 2b       	or	r24, r25
  f4:	80 83       	st	Z, r24
  f6:	49 01       	movw	r8, r18
			bauddiv = bauddiv2;
		}
	}
	_SFR_MEM8(hwUart->baudL) =  bauddiv;
  f8:	ee 8d       	ldd	r30, Y+30	; 0x1e
  fa:	ff 8d       	ldd	r31, Y+31	; 0x1f
  fc:	80 82       	st	Z, r8
	_SFR_MEM8(hwUart->baudH) = bauddiv>>8;
  fe:	e8 a1       	ldd	r30, Y+32	; 0x20
 100:	f9 a1       	ldd	r31, Y+33	; 0x21
 102:	90 82       	st	Z, r9
	CRITICAL_SECTION_END;
 104:	bf be       	out	0x3f, r11	; 63
}
 106:	df 91       	pop	r29
 108:	cf 91       	pop	r28
 10a:	1f 91       	pop	r17
 10c:	0f 91       	pop	r16
 10e:	ff 90       	pop	r15
 110:	ef 90       	pop	r14
 112:	df 90       	pop	r13
 114:	cf 90       	pop	r12
 116:	bf 90       	pop	r11
 118:	9f 90       	pop	r9
 11a:	8f 90       	pop	r8
 11c:	08 95       	ret

0000011e <__uartHWOff>:

	_SFR_MEM8(uart->statusB) = statB;
}

// Disable the uart
static void __uartHWOff(UART * _uart){
 11e:	fc 01       	movw	r30, r24
	HW_UART* uart = (HW_UART*) _uart;

	_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
 120:	a4 8d       	ldd	r26, Z+28	; 0x1c
 122:	b5 8d       	ldd	r27, Z+29	; 0x1d
 124:	8c 91       	ld	r24, X
 126:	87 72       	andi	r24, 0x27	; 39
 128:	8c 93       	st	X, r24

	if(uart->u2xMask != 0){
 12a:	96 a1       	ldd	r25, Z+38	; 0x26
 12c:	99 23       	and	r25, r25
 12e:	01 f0       	breq	.+0      	; 0x130 <__uartHWOff+0x12>
		_SFR_MEM8(uart->statusA) &=  ~(uart->u2xMask);	// turn off u2x
 130:	02 8c       	ldd	r0, Z+26	; 0x1a
 132:	f3 8d       	ldd	r31, Z+27	; 0x1b
 134:	e0 2d       	mov	r30, r0
 136:	80 81       	ld	r24, Z
 138:	90 95       	com	r25
 13a:	89 23       	and	r24, r25
 13c:	80 83       	st	Z, r24
 13e:	08 95       	ret

00000140 <__uartHWStartXmit>:
}

// Sends a single byte over the uart.
void __uartHWStartXmit(UART* _uart, uint8_t txData){
	HW_UART* uart = (HW_UART*)_uart;
	_SFR_MEM8(uart->data) = txData;		// Start sending the character
 140:	dc 01       	movw	r26, r24
 142:	92 96       	adiw	r26, 0x22	; 34
 144:	ed 91       	ld	r30, X+
 146:	fc 91       	ld	r31, X
 148:	93 97       	sbiw	r26, 0x23	; 35
 14a:	60 83       	st	Z, r22
 14c:	08 95       	ret

0000014e <__uartHWInit>:

// Initializes one UART to the default baud rate
// After running this init function, the processor
// I/O pins that used for uart communications (RXD, TXD)
// are no long available for general purpose I/O.
void __uartHWInit(UART* _uart, BAUD_RATE baud){
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	ec 01       	movw	r28, r24
	HW_UART* uart = (HW_UART*) _uart;

	// set default baud rate
	uartSetBaudRate(uart, baud);
 154:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>


	uint8_t statB = 0;
	if(_uartIsOneWire(_uart)){
 158:	8d 89       	ldd	r24, Y+21	; 0x15
 15a:	81 11       	cpse	r24, r1
 15c:	00 c0       	rjmp	.+0      	; 0x15e <__uartHWInit+0x10>
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
	}else{
		// enable RxD/TxD and interrupts
		if(uart->_uart_.rx_pin){
 15e:	8d 85       	ldd	r24, Y+13	; 0x0d
 160:	9e 85       	ldd	r25, Y+14	; 0x0e
 162:	89 2b       	or	r24, r25
 164:	01 f4       	brne	.+0      	; 0x166 <__uartHWInit+0x18>

	// set default baud rate
	uartSetBaudRate(uart, baud);


	uint8_t statB = 0;
 166:	20 e0       	ldi	r18, 0x00	; 0
 168:	00 c0       	rjmp	.+0      	; 0x16a <__uartHWInit+0x1c>
	if(_uartIsOneWire(_uart)){
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
	}else{
		// enable RxD/TxD and interrupts
		if(uart->_uart_.rx_pin){
			statB = BV(RXCIE) | BV(RXEN);
 16a:	20 e9       	ldi	r18, 0x90	; 144
		}
		if(uart->_uart_.tx_pin){
 16c:	8f 85       	ldd	r24, Y+15	; 0x0f
 16e:	98 89       	ldd	r25, Y+16	; 0x10
 170:	89 2b       	or	r24, r25
 172:	01 f0       	breq	.+0      	; 0x174 <__uartHWInit+0x26>
			statB |= BV(TXCIE) | BV(TXEN);
 174:	28 64       	ori	r18, 0x48	; 72
 176:	00 c0       	rjmp	.+0      	; 0x178 <__uartHWInit+0x2a>
	uartSetBaudRate(uart, baud);


	uint8_t statB = 0;
	if(_uartIsOneWire(_uart)){
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
 178:	20 e9       	ldi	r18, 0x90	; 144
		}

//		_SFR_MEM8(uart->statusB) =  BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN);
	}

	_SFR_MEM8(uart->statusB) = statB;
 17a:	ec 8d       	ldd	r30, Y+28	; 0x1c
 17c:	fd 8d       	ldd	r31, Y+29	; 0x1d
 17e:	20 83       	st	Z, r18
}
 180:	df 91       	pop	r29
 182:	cf 91       	pop	r28
 184:	08 95       	ret

00000186 <oneWireReceiveMode>:

}


// If one wire - then go into receive mode
static void oneWireReceiveMode(UART* _uart){
 186:	fc 01       	movw	r30, r24
	if(_uartIsOneWire(_uart)){
 188:	85 89       	ldd	r24, Z+21	; 0x15
 18a:	88 23       	and	r24, r24
 18c:	01 f0       	breq	.+0      	; 0x18e <oneWireReceiveMode+0x8>
		HW_UART* uart = (HW_UART*)_uart;
		// Place into receive mode and turn transmitter off
		_SFR_MEM8(uart->statusB) &=  ~(BV(TXCIE)|BV(TXEN));		// Tx Off
 18e:	a4 8d       	ldd	r26, Z+28	; 0x1c
 190:	b5 8d       	ldd	r27, Z+29	; 0x1d
 192:	8c 91       	ld	r24, X
 194:	87 7b       	andi	r24, 0xB7	; 183
 196:	8c 93       	st	X, r24
		_SFR_MEM8(uart->statusB) |=  (BV(RXCIE)|BV(RXEN));		// Rx on
 198:	04 8c       	ldd	r0, Z+28	; 0x1c
 19a:	f5 8d       	ldd	r31, Z+29	; 0x1d
 19c:	e0 2d       	mov	r30, r0
 19e:	80 81       	ld	r24, Z
 1a0:	80 69       	ori	r24, 0x90	; 144
 1a2:	80 83       	st	Z, r24
 1a4:	08 95       	ret

000001a6 <startXmitMode>:
	_SFR_MEM8(uart->data) = txData;		// Start sending the character
}


// Put the uart into xmit mode
static void	startXmitMode(UART* _uart){
 1a6:	fc 01       	movw	r30, r24
	if(_uartIsOneWire(_uart)){
 1a8:	85 89       	ldd	r24, Z+21	; 0x15
 1aa:	88 23       	and	r24, r24
 1ac:	01 f0       	breq	.+0      	; 0x1ae <startXmitMode+0x8>
		HW_UART* uart = (HW_UART*)_uart;
		// Place into transmit mode and turn receiver off
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE)|BV(RXEN));		// Rx Off
 1ae:	a4 8d       	ldd	r26, Z+28	; 0x1c
 1b0:	b5 8d       	ldd	r27, Z+29	; 0x1d
 1b2:	8c 91       	ld	r24, X
 1b4:	8f 76       	andi	r24, 0x6F	; 111
 1b6:	8c 93       	st	X, r24
		_SFR_MEM8(uart->statusB) |=  (BV(TXCIE)|BV(TXEN));		// Tx on
 1b8:	04 8c       	ldd	r0, Z+28	; 0x1c
 1ba:	f5 8d       	ldd	r31, Z+29	; 0x1d
 1bc:	e0 2d       	mov	r30, r0
 1be:	80 81       	ld	r24, Z
 1c0:	88 64       	ori	r24, 0x48	; 72
 1c2:	80 83       	st	Z, r24
 1c4:	08 95       	ret

000001c6 <uartReceivePollingMode>:
		&__uartHWOff,			\
		&startXmitMode, \
		&oneWireReceiveMode );

// Put the receiver in polling mode (TRUE) or interrupt mode (FALSE)
void uartReceivePollingMode(const HW_UART* uart,boolean polling){
 1c6:	dc 01       	movw	r26, r24
 1c8:	5c 96       	adiw	r26, 0x1c	; 28
 1ca:	ed 91       	ld	r30, X+
 1cc:	fc 91       	ld	r31, X
 1ce:	5d 97       	sbiw	r26, 0x1d	; 29
	if(polling){
		// turn off receive interrupts
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE));		// Rx Off
 1d0:	80 81       	ld	r24, Z
		&startXmitMode, \
		&oneWireReceiveMode );

// Put the receiver in polling mode (TRUE) or interrupt mode (FALSE)
void uartReceivePollingMode(const HW_UART* uart,boolean polling){
	if(polling){
 1d2:	66 23       	and	r22, r22
 1d4:	01 f0       	breq	.+0      	; 0x1d6 <uartReceivePollingMode+0x10>
		// turn off receive interrupts
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE));		// Rx Off
 1d6:	8f 77       	andi	r24, 0x7F	; 127
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <uartReceivePollingMode+0x14>
	}else{
		// turn on receive interrupts
		_SFR_MEM8(uart->statusB) |=  BV(RXCIE);			// Rx On
 1da:	80 68       	ori	r24, 0x80	; 128
 1dc:	80 83       	st	Z, r24
 1de:	08 95       	ret

000001e0 <uartPollByte>:


// Poll the hardware for the next receive character
int uartPollByte(const HW_UART* uart){
	int ch=-1;
	if( _SFR_MEM8(uart->statusA) & BV(RXC)){
 1e0:	dc 01       	movw	r26, r24
 1e2:	5a 96       	adiw	r26, 0x1a	; 26
 1e4:	ed 91       	ld	r30, X+
 1e6:	fc 91       	ld	r31, X
 1e8:	5b 97       	sbiw	r26, 0x1b	; 27
 1ea:	20 81       	ld	r18, Z
 1ec:	27 ff       	sbrs	r18, 7
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <uartPollByte+0x10>
		// A character is waiting
		ch = _SFR_MEM8(uart->data);
 1f0:	92 96       	adiw	r26, 0x22	; 34
 1f2:	ed 91       	ld	r30, X+
 1f4:	fc 91       	ld	r31, X
 1f6:	93 97       	sbiw	r26, 0x23	; 35
 1f8:	20 81       	ld	r18, Z
 1fa:	30 e0       	ldi	r19, 0x00	; 0
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <uartPollByte+0x1e>
}


// Poll the hardware for the next receive character
int uartPollByte(const HW_UART* uart){
	int ch=-1;
 1fe:	2f ef       	ldi	r18, 0xFF	; 255
 200:	3f ef       	ldi	r19, 0xFF	; 255
		// A character is waiting
		ch = _SFR_MEM8(uart->data);

	}
	return ch;
}
 202:	c9 01       	movw	r24, r18
 204:	08 95       	ret

uartsw.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005ec  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000620  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000620  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000620  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001b30  00000000  00000000  0000062c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000468  00000000  00000000  0000215c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000156f  00000000  00000000  000025c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00003b33  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000030  00000000  00000000  00003b53  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000002c5  00000000  00000000  00003b83  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000a06  00000000  00000000  00003e48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .comment      0000002a  00000000  00000000  0000484e  2**0
                  CONTENTS, READONLY
 12 .debug_frame  00000204  00000000  00000000  00004878  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__uartswSetBaudRate>:
	}
	oneWireReceiveMode(_uart);
}


void __uartswSetBaudRate(UART* _uart, BAUD_RATE baudrate){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <__uartswSetBaudRate+0x26>
  26:	1f 92       	push	r1
  28:	cd b7       	in	r28, 0x3d	; 61
  2a:	de b7       	in	r29, 0x3e	; 62
  2c:	8c 01       	movw	r16, r24
  2e:	4a 01       	movw	r8, r20
  30:	5b 01       	movw	r10, r22
	SW_UART* uart = (SW_UART*)_uart;

	const Timer* timer = &pgm_Timers[uart->timer];
  32:	fc 01       	movw	r30, r24
  34:	92 8d       	ldd	r25, Z+26	; 0x1a
  36:	8c e2       	ldi	r24, 0x2C	; 44
  38:	98 9f       	mul	r25, r24
  3a:	90 01       	movw	r18, r0
  3c:	11 24       	eor	r1, r1
  3e:	20 50       	subi	r18, 0x00	; 0
  40:	30 40       	sbci	r19, 0x00	; 0
  42:	3b 83       	std	Y+3, r19	; 0x03
  44:	2a 83       	std	Y+2, r18	; 0x02
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
  46:	f9 01       	movw	r30, r18
  48:	34 96       	adiw	r30, 0x04	; 4
  4a:	85 91       	lpm	r24, Z+
  4c:	94 91       	lpm	r25, Z
  4e:	fc 01       	movw	r30, r24
  50:	80 81       	ld	r24, Z
  52:	87 70       	andi	r24, 0x07	; 7
  54:	01 f4       	brne	.+0      	; 0x56 <__uartswSetBaudRate+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <__uartswSetBaudRate+0x58>
	boolean	isMyTimer = FALSE;
  58:	19 82       	std	Y+1, r1	; 0x01
		timerSetPrescaler(timer,1);

		isMyTimer = TRUE;
	}

	uint16_t top = timerGetTOP(timer);
  5a:	8a 81       	ldd	r24, Y+2	; 0x02
  5c:	9b 81       	ldd	r25, Y+3	; 0x03
  5e:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
  62:	3c 01       	movw	r6, r24
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  64:	ea 81       	ldd	r30, Y+2	; 0x02
  66:	fb 81       	ldd	r31, Y+3	; 0x03
  68:	a5 91       	lpm	r26, Z+
  6a:	b4 91       	lpm	r27, Z
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
  6c:	4d 90       	ld	r4, X+
  6e:	5c 90       	ld	r5, X
	// Get the current prescaler
	uint16_t prescale = timerGetPrescaler(timer);

	// calculate division factor for requested baud rate, and set it
calcBaud:
	uart->dataBitLength = (uint16_t)(  (cpu_speed+(baudrate/2L)) / (prescale * baudrate * 1L)  );
  70:	75 01       	movw	r14, r10
  72:	64 01       	movw	r12, r8
  74:	f6 94       	lsr	r15
  76:	e7 94       	ror	r14
  78:	d7 94       	ror	r13
  7a:	c7 94       	ror	r12
  7c:	40 91 00 00 	lds	r20, 0x0000
  80:	50 91 00 00 	lds	r21, 0x0000
  84:	60 91 00 00 	lds	r22, 0x0000
  88:	70 91 00 00 	lds	r23, 0x0000
  8c:	c4 0e       	add	r12, r20
  8e:	d5 1e       	adc	r13, r21
  90:	e6 1e       	adc	r14, r22
  92:	f7 1e       	adc	r15, r23
  94:	d2 01       	movw	r26, r4
  96:	a5 01       	movw	r20, r10
  98:	94 01       	movw	r18, r8
  9a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
  9e:	9b 01       	movw	r18, r22
  a0:	ac 01       	movw	r20, r24
  a2:	c7 01       	movw	r24, r14
  a4:	b6 01       	movw	r22, r12
  a6:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
  aa:	f8 01       	movw	r30, r16
  ac:	32 a3       	std	Z+34, r19	; 0x22
  ae:	21 a3       	std	Z+33, r18	; 0x21

	// Fudge factor compensates for interrupt processing overhead
	// The larger this number then the shorter the start bit
	//
	uint16_t pre = prescale;
  b0:	c2 01       	movw	r24, r4
	uint16_t fudge = 104U;
  b2:	28 e6       	ldi	r18, 0x68	; 104
  b4:	30 e0       	ldi	r19, 0x00	; 0
	while(pre > 1){
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <__uartswSetBaudRate+0xb8>
		fudge>>=1;
  b8:	36 95       	lsr	r19
  ba:	27 95       	ror	r18
		pre>>=1;
  bc:	96 95       	lsr	r25
  be:	87 95       	ror	r24
	// Fudge factor compensates for interrupt processing overhead
	// The larger this number then the shorter the start bit
	//
	uint16_t pre = prescale;
	uint16_t fudge = 104U;
	while(pre > 1){
  c0:	82 30       	cpi	r24, 0x02	; 2
  c2:	91 05       	cpc	r25, r1
  c4:	00 f4       	brcc	.+0      	; 0xc6 <__uartswSetBaudRate+0xc6>
		fudge>>=1;
		pre>>=1;
	}
	uart->startBitLength = uart->dataBitLength - fudge;
  c6:	f8 01       	movw	r30, r16
  c8:	81 a1       	ldd	r24, Z+33	; 0x21
  ca:	92 a1       	ldd	r25, Z+34	; 0x22
  cc:	82 1b       	sub	r24, r18
  ce:	93 0b       	sbc	r25, r19
  d0:	90 a3       	std	Z+32, r25	; 0x20
  d2:	87 8f       	std	Z+31, r24	; 0x1f

	if(uart->dataBitLength > top){
  d4:	81 a1       	ldd	r24, Z+33	; 0x21
  d6:	92 a1       	ldd	r25, Z+34	; 0x22
  d8:	68 16       	cp	r6, r24
  da:	79 06       	cpc	r7, r25
  dc:	00 f4       	brcc	.+0      	; 0xde <__uartswSetBaudRate+0xde>
		uart->dataBitLength = top;
  de:	72 a2       	std	Z+34, r7	; 0x22
  e0:	61 a2       	std	Z+33, r6	; 0x21
		if(isMyTimer){
  e2:	f9 81       	ldd	r31, Y+1	; 0x01
  e4:	ff 23       	and	r31, r31
  e6:	01 f0       	breq	.+0      	; 0xe8 <__uartswSetBaudRate+0xe8>
			// Try increasing the prescaler
			uint16_t nextpre = timerGetClosestPrescale(timer, prescale+1);
  e8:	b2 01       	movw	r22, r4
  ea:	6f 5f       	subi	r22, 0xFF	; 255
  ec:	7f 4f       	sbci	r23, 0xFF	; 255
  ee:	8a 81       	ldd	r24, Y+2	; 0x02
  f0:	9b 81       	ldd	r25, Y+3	; 0x03
  f2:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
  f6:	1c 01       	movw	r2, r24
			if(nextpre != prescale){
  f8:	84 15       	cp	r24, r4
  fa:	95 05       	cpc	r25, r5
  fc:	01 f0       	breq	.+0      	; 0xfe <__uartswSetBaudRate+0xfe>
				prescale = nextpre;
				timerSetPrescaler(timer,prescale);
  fe:	bc 01       	movw	r22, r24
 100:	8a 81       	ldd	r24, Y+2	; 0x02
 102:	9b 81       	ldd	r25, Y+3	; 0x03
 104:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 108:	21 01       	movw	r4, r2
				goto calcBaud;
 10a:	00 c0       	rjmp	.+0      	; 0x10c <__uartswSetBaudRate+0x10c>
	const Timer* timer = &pgm_Timers[uart->timer];
	boolean	isMyTimer = FALSE;

	// Make sure the timer is in normal mode
	if(!timerIsInUse(timer)){
		timerSetMode(timer,TIMER_MODE_NORMAL);
 10c:	60 e0       	ldi	r22, 0x00	; 0
 10e:	8a 81       	ldd	r24, Y+2	; 0x02
 110:	9b 81       	ldd	r25, Y+3	; 0x03
 112:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
		// set timer prescaler
		timerSetPrescaler(timer,1);
 116:	61 e0       	ldi	r22, 0x01	; 1
 118:	70 e0       	ldi	r23, 0x00	; 0
 11a:	8a 81       	ldd	r24, Y+2	; 0x02
 11c:	9b 81       	ldd	r25, Y+3	; 0x03
 11e:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		isMyTimer = TRUE;
 122:	2f ef       	ldi	r18, 0xFF	; 255
 124:	29 83       	std	Y+1, r18	; 0x01
 126:	00 c0       	rjmp	.+0      	; 0x128 <__uartswSetBaudRate+0x128>
		}
	}



}
 128:	0f 90       	pop	r0
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	1f 91       	pop	r17
 134:	0f 91       	pop	r16
 136:	ff 90       	pop	r15
 138:	ef 90       	pop	r14
 13a:	df 90       	pop	r13
 13c:	cf 90       	pop	r12
 13e:	bf 90       	pop	r11
 140:	af 90       	pop	r10
 142:	9f 90       	pop	r9
 144:	8f 90       	pop	r8
 146:	7f 90       	pop	r7
 148:	6f 90       	pop	r6
 14a:	5f 90       	pop	r5
 14c:	4f 90       	pop	r4
 14e:	3f 90       	pop	r3
 150:	2f 90       	pop	r2
 152:	08 95       	ret

00000154 <uartswRxBitService>:
	// reset bit counter and data
	uart->rxBitNum = uart->rxData = 0;

}

static void uartswRxBitService(const TimerCompare *channel, void* _uart){
 154:	ef 92       	push	r14
 156:	ff 92       	push	r15
 158:	0f 93       	push	r16
 15a:	1f 93       	push	r17
 15c:	cf 93       	push	r28
 15e:	df 93       	push	r29
 160:	1f 92       	push	r1
 162:	cd b7       	in	r28, 0x3d	; 61
 164:	de b7       	in	r29, 0x3e	; 62
 166:	8c 01       	movw	r16, r24
 168:	7b 01       	movw	r14, r22
	SW_UART* uart = (SW_UART*)_uart;
	// start bit has already been received
	// we're in the data bits

	// shift data byte to make room for new bit
	uart->rxData >>= 1;
 16a:	fb 01       	movw	r30, r22
 16c:	83 8d       	ldd	r24, Z+27	; 0x1b
 16e:	86 95       	lsr	r24
 170:	83 8f       	std	Z+27, r24	; 0x1b

	// sample the data line
	if(uart->inverted){
 172:	23 a1       	ldd	r18, Z+35	; 0x23
 174:	85 85       	ldd	r24, Z+13	; 0x0d
 176:	96 85       	ldd	r25, Z+14	; 0x0e
 178:	22 23       	and	r18, r18
 17a:	01 f0       	breq	.+0      	; 0x17c <uartswRxBitService+0x28>
		if( pin_is_low(uart->_uart_.rx_pin) ){
 17c:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 180:	81 11       	cpse	r24, r1
 182:	00 c0       	rjmp	.+0      	; 0x184 <uartswRxBitService+0x30>
 184:	00 c0       	rjmp	.+0      	; 0x186 <uartswRxBitService+0x32>
			uart->rxData |= 0x80;
		}
	}else{
		if( pin_is_high(uart->_uart_.rx_pin) ){
 186:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 18a:	88 23       	and	r24, r24
 18c:	01 f0       	breq	.+0      	; 0x18e <uartswRxBitService+0x3a>
			uart->rxData |= 0x80;
 18e:	f7 01       	movw	r30, r14
 190:	83 8d       	ldd	r24, Z+27	; 0x1b
 192:	80 68       	ori	r24, 0x80	; 128
 194:	83 8f       	std	Z+27, r24	; 0x1b
		}
	}

	// schedule next bit sample
	compareSetThreshold(channel, (compareGetThreshold(channel) + uart->dataBitLength));
 196:	c8 01       	movw	r24, r16
 198:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 19c:	f7 01       	movw	r30, r14
 19e:	61 a1       	ldd	r22, Z+33	; 0x21
 1a0:	72 a1       	ldd	r23, Z+34	; 0x22
 1a2:	68 0f       	add	r22, r24
 1a4:	79 1f       	adc	r23, r25
 1a6:	c8 01       	movw	r24, r16
 1a8:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

	// check if we have a full byte
	if(++uart->rxBitNum >= 8)
 1ac:	f7 01       	movw	r30, r14
 1ae:	84 8d       	ldd	r24, Z+28	; 0x1c
 1b0:	8f 5f       	subi	r24, 0xFF	; 255
 1b2:	84 8f       	std	Z+28, r24	; 0x1c
 1b4:	88 30       	cpi	r24, 0x08	; 8
 1b6:	00 f0       	brcs	.+0      	; 0x1b8 <uartswRxBitService+0x64>
	{
		uint8_t c = uart->rxData;
 1b8:	63 8d       	ldd	r22, Z+27	; 0x1b

		// Detach the OC1B interrupt
//		compareDetach(channel);
		__portMaskClear(&channel->pgm_intenable);		// turn interrupt off
 1ba:	c8 01       	movw	r24, r16
 1bc:	03 96       	adiw	r24, 0x03	; 3
 1be:	69 83       	std	Y+1, r22	; 0x01
 1c0:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 1c4:	f8 01       	movw	r30, r16
 1c6:	32 96       	adiw	r30, 0x02	; 2
 1c8:	04 91       	lpm	r16, Z

		// attach RxBit service routine to ICP
		// trigger on rising edge if inverted, or falling if not
//		timerCaptureAttach(compareGetTimer(channel), uartswRxStartService, uart, uart->inverted );
		const Timer* timer = compareGetTimer(channel);
 1ca:	fc e2       	ldi	r31, 0x2C	; 44
 1cc:	0f 9f       	mul	r16, r31
 1ce:	80 01       	movw	r16, r0
 1d0:	11 24       	eor	r1, r1
 1d2:	00 50       	subi	r16, 0x00	; 0
 1d4:	10 40       	sbci	r17, 0x00	; 0
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
 1d6:	c8 01       	movw	r24, r16
 1d8:	84 96       	adiw	r24, 0x24	; 36
 1da:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
		timerCaptureClearInterruptPending(timer);	// Clear any pending capture interrupt flag
		__portMaskSet(&timer->pgm_captureint);		// Re-enable capture interrupt
 1de:	c8 01       	movw	r24, r16
 1e0:	81 96       	adiw	r24, 0x21	; 33
 1e2:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		// save data in receive buffer
		__uartReceiveService(&uart->_uart_, c);
 1e6:	69 81       	ldd	r22, Y+1	; 0x01
 1e8:	c7 01       	movw	r24, r14
	}
}
 1ea:	0f 90       	pop	r0
 1ec:	df 91       	pop	r29
 1ee:	cf 91       	pop	r28
 1f0:	1f 91       	pop	r17
 1f2:	0f 91       	pop	r16
 1f4:	ff 90       	pop	r15
 1f6:	ef 90       	pop	r14
		const Timer* timer = compareGetTimer(channel);
		timerCaptureClearInterruptPending(timer);	// Clear any pending capture interrupt flag
		__portMaskSet(&timer->pgm_captureint);		// Re-enable capture interrupt

		// save data in receive buffer
		__uartReceiveService(&uart->_uart_, c);
 1f8:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>
	}
}
 1fc:	0f 90       	pop	r0
 1fe:	df 91       	pop	r29
 200:	cf 91       	pop	r28
 202:	1f 91       	pop	r17
 204:	0f 91       	pop	r16
 206:	ff 90       	pop	r15
 208:	ef 90       	pop	r14
 20a:	08 95       	ret

0000020c <__uartswOff>:

// Disable the uart
static void __uartswOff(UART * _uart){
 20c:	0f 93       	push	r16
 20e:	1f 93       	push	r17
 210:	cf 93       	push	r28
 212:	df 93       	push	r29
	SW_UART* uart = (SW_UART*) _uart;

	const Timer* timer = &pgm_Timers[uart->timer];
 214:	fc 01       	movw	r30, r24
 216:	c2 8d       	ldd	r28, Z+26	; 0x1a
 218:	fc e2       	ldi	r31, 0x2C	; 44
 21a:	cf 9f       	mul	r28, r31
 21c:	e0 01       	movw	r28, r0
 21e:	11 24       	eor	r1, r1
 220:	c0 50       	subi	r28, 0x00	; 0
 222:	d0 40       	sbci	r29, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 224:	fe 01       	movw	r30, r28
 226:	77 96       	adiw	r30, 0x17	; 23
 228:	05 91       	lpm	r16, Z+
 22a:	14 91       	lpm	r17, Z

	// detach the service routines
	compareDetach(timerGetCompare(timer,0));
 22c:	c8 01       	movw	r24, r16
 22e:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	compareDetach(timerGetCompare(timer,1));
 232:	c8 01       	movw	r24, r16
 234:	40 96       	adiw	r24, 0x10	; 16
 236:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	timerCaptureDetach(timer);
 23a:	ce 01       	movw	r24, r28
}
 23c:	df 91       	pop	r29
 23e:	cf 91       	pop	r28
 240:	1f 91       	pop	r17
 242:	0f 91       	pop	r16
	const Timer* timer = &pgm_Timers[uart->timer];

	// detach the service routines
	compareDetach(timerGetCompare(timer,0));
	compareDetach(timerGetCompare(timer,1));
	timerCaptureDetach(timer);
 244:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>

00000248 <uartswTxBitService>:
static void	startXmitMode(UART* _uart);
static void	endXmitMode(UART* _uart);
static void oneWireReceiveMode(const UART* _uart);

static void uartswTxBitService(const TimerCompare *channel, void* _uart)
{
 248:	ef 92       	push	r14
 24a:	ff 92       	push	r15
 24c:	0f 93       	push	r16
 24e:	1f 93       	push	r17
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	8c 01       	movw	r16, r24
 256:	eb 01       	movw	r28, r22
	SW_UART* uart = (SW_UART*) _uart;
	if(uart->txBitNum)
 258:	8e 8d       	ldd	r24, Y+30	; 0x1e
 25a:	88 23       	and	r24, r24
 25c:	01 f0       	breq	.+0      	; 0x25e <uartswTxBitService+0x16>
	{
		// there are bits still waiting to be transmitted
		if(uart->txBitNum > 1)
 25e:	2e 8d       	ldd	r18, Y+30	; 0x1e
 260:	8f 85       	ldd	r24, Y+15	; 0x0f
 262:	98 89       	ldd	r25, Y+16	; 0x10
 264:	22 30       	cpi	r18, 0x02	; 2
 266:	00 f0       	brcs	.+0      	; 0x268 <uartswTxBitService+0x20>
		{
			// transmit data bits (inverted, LSB first)
			if( (uart->txData & 0x01) )
 268:	2d 8d       	ldd	r18, Y+29	; 0x1d
 26a:	20 ff       	sbrs	r18, 0
 26c:	00 c0       	rjmp	.+0      	; 0x26e <uartswTxBitService+0x26>
				pin_high(uart->_uart_.tx_pin);
 26e:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 272:	00 c0       	rjmp	.+0      	; 0x274 <uartswTxBitService+0x2c>
			else
				pin_low(uart->_uart_.tx_pin);
 274:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
			// shift bits down
			uart->txData >>= 1;
 278:	8d 8d       	ldd	r24, Y+29	; 0x1d
 27a:	86 95       	lsr	r24
 27c:	8d 8f       	std	Y+29, r24	; 0x1d
 27e:	00 c0       	rjmp	.+0      	; 0x280 <uartswTxBitService+0x38>
		}
		else
		{
			// transmit stop bit
			if(uart->inverted){
 280:	2b a1       	ldd	r18, Y+35	; 0x23
 282:	22 23       	and	r18, r18
 284:	01 f0       	breq	.+0      	; 0x286 <uartswTxBitService+0x3e>
				pin_low(uart->_uart_.tx_pin);
 286:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <uartswTxBitService+0x44>
			}else{
				pin_high(uart->_uart_.tx_pin);
 28c:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 290:	f8 01       	movw	r30, r16
 292:	32 96       	adiw	r30, 0x02	; 2
 294:	84 91       	lpm	r24, Z
			}
		}
		// schedule the next bit
		uint16_t top = 1 + timerGetTOP(compareGetTimer(channel));
 296:	2c e2       	ldi	r18, 0x2C	; 44
 298:	82 9f       	mul	r24, r18
 29a:	c0 01       	movw	r24, r0
 29c:	11 24       	eor	r1, r1
 29e:	80 50       	subi	r24, 0x00	; 0
 2a0:	90 40       	sbci	r25, 0x00	; 0
 2a2:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 2a6:	01 96       	adiw	r24, 0x01	; 1
 2a8:	7c 01       	movw	r14, r24
		uint16_t next = (compareGetThreshold(channel) + uart->dataBitLength);
 2aa:	c8 01       	movw	r24, r16
 2ac:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 2b0:	69 a1       	ldd	r22, Y+33	; 0x21
 2b2:	7a a1       	ldd	r23, Y+34	; 0x22
 2b4:	68 0f       	add	r22, r24
 2b6:	79 1f       	adc	r23, r25
		if(next >= top){
 2b8:	6e 15       	cp	r22, r14
 2ba:	7f 05       	cpc	r23, r15
 2bc:	00 f0       	brcs	.+0      	; 0x2be <uartswTxBitService+0x76>
			next -= top;
 2be:	6e 19       	sub	r22, r14
 2c0:	7f 09       	sbc	r23, r15
		}
		compareSetThreshold(channel, next );
 2c2:	c8 01       	movw	r24, r16
 2c4:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		// count down
		uart->txBitNum--;
 2c8:	8e 8d       	ldd	r24, Y+30	; 0x1e
 2ca:	81 50       	subi	r24, 0x01	; 1
 2cc:	8e 8f       	std	Y+30, r24	; 0x1e
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <uartswTxBitService+0x88>
	}
	else
	{
		// We have finished sending the current byte - look for the next byte to send
		__uartTransmitService(&uart->_uart_);
 2d0:	cb 01       	movw	r24, r22
	}
}
 2d2:	df 91       	pop	r29
 2d4:	cf 91       	pop	r28
 2d6:	1f 91       	pop	r17
 2d8:	0f 91       	pop	r16
 2da:	ff 90       	pop	r15
 2dc:	ef 90       	pop	r14
		uart->txBitNum--;
	}
	else
	{
		// We have finished sending the current byte - look for the next byte to send
		__uartTransmitService(&uart->_uart_);
 2de:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>
	}
}
 2e2:	df 91       	pop	r29
 2e4:	cf 91       	pop	r28
 2e6:	1f 91       	pop	r17
 2e8:	0f 91       	pop	r16
 2ea:	ff 90       	pop	r15
 2ec:	ef 90       	pop	r14
 2ee:	08 95       	ret

000002f0 <uartswRxStartService>:


// Start receiving a new byte. Caused by a change on the input capture
static void uartswRxStartService(const Timer *timer, void* _uart){
 2f0:	0f 93       	push	r16
 2f2:	1f 93       	push	r17
 2f4:	cf 93       	push	r28
 2f6:	df 93       	push	r29
 2f8:	8c 01       	movw	r16, r24
 2fa:	eb 01       	movw	r28, r22
	SW_UART* uart = (SW_UART*)_uart;
	// disable ICP interrupt - as remainder are done by OC1B
	__portMaskClear(&timer->pgm_captureint);
 2fc:	81 96       	adiw	r24, 0x21	; 33
 2fe:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

	// Get the timer value of when the interrupt happened
	PORT icr = pgm_read_word(&timer->pgm_icr);
 302:	f8 01       	movw	r30, r16
 304:	7f 96       	adiw	r30, 0x1f	; 31
 306:	85 91       	lpm	r24, Z+
 308:	94 91       	lpm	r25, Z
	uint16_t capture = _SFR_MEM16(icr);
 30a:	fc 01       	movw	r30, r24
 30c:	80 81       	ld	r24, Z
 30e:	91 81       	ldd	r25, Z+1	; 0x01
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 310:	09 5e       	subi	r16, 0xE9	; 233
 312:	1f 4f       	sbci	r17, 0xFF	; 255
 314:	f8 01       	movw	r30, r16
 316:	05 91       	lpm	r16, Z+
 318:	14 91       	lpm	r17, Z

	// attach RxBit service routine to OC1B for 1.5 bit from now
	const TimerCompare* rx = timerGetCompare(timer,1);
	compareSetThreshold(rx, (capture + uart->dataBitLength + uart->dataBitLength/2) );
 31a:	49 a1       	ldd	r20, Y+33	; 0x21
 31c:	5a a1       	ldd	r21, Y+34	; 0x22
 31e:	69 a1       	ldd	r22, Y+33	; 0x21
 320:	7a a1       	ldd	r23, Y+34	; 0x22
 322:	76 95       	lsr	r23
 324:	67 95       	ror	r22
 326:	64 0f       	add	r22, r20
 328:	75 1f       	adc	r23, r21
 32a:	68 0f       	add	r22, r24
 32c:	79 1f       	adc	r23, r25
 32e:	c8 01       	movw	r24, r16
 330:	40 96       	adiw	r24, 0x10	; 16
 332:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 336:	c8 01       	movw	r24, r16
 338:	48 96       	adiw	r24, 0x18	; 24
 33a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	compareClearInterruptPending(rx);		// clear any interrupt pending
	__portMaskSet(&rx->pgm_intenable);		// turn interrupt on
 33e:	c8 01       	movw	r24, r16
 340:	43 96       	adiw	r24, 0x13	; 19
 342:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

	// reset bit counter and data
	uart->rxBitNum = uart->rxData = 0;
 346:	1b 8e       	std	Y+27, r1	; 0x1b
 348:	1c 8e       	std	Y+28, r1	; 0x1c

}
 34a:	df 91       	pop	r29
 34c:	cf 91       	pop	r28
 34e:	1f 91       	pop	r17
 350:	0f 91       	pop	r16
 352:	08 95       	ret

00000354 <oneWireReceiveMode.part.1>:

	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
 354:	1f 93       	push	r17
 356:	cf 93       	push	r28
 358:	df 93       	push	r29
	if(_uartIsOneWire(_uart)){
		const SW_UART* uart = (const SW_UART*)_uart;
		// Place into receive mode and turn transmitter off

		const Timer* timer = &pgm_Timers[uart->timer];
 35a:	fc 01       	movw	r30, r24
 35c:	c2 8d       	ldd	r28, Z+26	; 0x1a
 35e:	fc e2       	ldi	r31, 0x2C	; 44
 360:	cf 9f       	mul	r28, r31
 362:	e0 01       	movw	r28, r0
 364:	11 24       	eor	r1, r1
 366:	c0 50       	subi	r28, 0x00	; 0
 368:	d0 40       	sbci	r29, 0x00	; 0

		CRITICAL_SECTION_START;
 36a:	1f b7       	in	r17, 0x3f	; 63
 36c:	f8 94       	cli

		// Turn the transmitter/receiver pin back into an output
//		setTxIdle(uart);

		// Turn the xmit into an input pin with pullup
		pin_make_input(_uart->tx_pin,TRUE);
 36e:	6f ef       	ldi	r22, 0xFF	; 255
 370:	fc 01       	movw	r30, r24
 372:	87 85       	ldd	r24, Z+15	; 0x0f
 374:	90 89       	ldd	r25, Z+16	; 0x10
 376:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
 37a:	ce 01       	movw	r24, r28
 37c:	84 96       	adiw	r24, 0x24	; 36
 37e:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		// Clear any pending capture interrupt flag
		timerCaptureClearInterruptPending(timer);

		// Re-enable the input capture to detect the start of a byte
		__portMaskSet(&timer->pgm_captureint);
 382:	ce 01       	movw	r24, r28
 384:	81 96       	adiw	r24, 0x21	; 33
 386:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		CRITICAL_SECTION_END;
 38a:	1f bf       	out	0x3f, r17	; 63
	}
}
 38c:	df 91       	pop	r29
 38e:	cf 91       	pop	r28
 390:	1f 91       	pop	r17
 392:	08 95       	ret

00000394 <__uartswInit>:
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
}


// enable and initialize the software uart - called with interrupts turned off
void __uartswInit(UART* _uart, BAUD_RATE baud){
 394:	df 92       	push	r13
 396:	ef 92       	push	r14
 398:	ff 92       	push	r15
 39a:	0f 93       	push	r16
 39c:	1f 93       	push	r17
 39e:	cf 93       	push	r28
 3a0:	df 93       	push	r29
 3a2:	ec 01       	movw	r28, r24
	SW_UART* uart = (SW_UART*) _uart;
	if(uart->_uart_.rx_pin!=null || uart->_uart_.tx_pin!=null){
 3a4:	8d 85       	ldd	r24, Y+13	; 0x0d
 3a6:	9e 85       	ldd	r25, Y+14	; 0x0e
 3a8:	89 2b       	or	r24, r25
 3aa:	01 f4       	brne	.+0      	; 0x3ac <__uartswInit+0x18>
 3ac:	8f 85       	ldd	r24, Y+15	; 0x0f
 3ae:	98 89       	ldd	r25, Y+16	; 0x10
 3b0:	89 2b       	or	r24, r25
 3b2:	01 f4       	brne	.+0      	; 0x3b4 <__uartswInit+0x20>
 3b4:	00 c0       	rjmp	.+0      	; 0x3b6 <__uartswInit+0x22>

		const Timer* timer = &pgm_Timers[uart->timer];
 3b6:	0a 8d       	ldd	r16, Y+26	; 0x1a
 3b8:	8c e2       	ldi	r24, 0x2C	; 44
 3ba:	08 9f       	mul	r16, r24
 3bc:	80 01       	movw	r16, r0
 3be:	11 24       	eor	r1, r1
 3c0:	00 50       	subi	r16, 0x00	; 0
 3c2:	10 40       	sbci	r17, 0x00	; 0

		// initialize baud rate
		uartSetBaudRate(uart, baud);
 3c4:	ce 01       	movw	r24, r28
 3c6:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		// setup the transmitter
		if(uart->_uart_.tx_pin!=null){
 3ca:	8f 85       	ldd	r24, Y+15	; 0x0f
 3cc:	98 89       	ldd	r25, Y+16	; 0x10
 3ce:	00 97       	sbiw	r24, 0x00	; 0
 3d0:	01 f0       	breq	.+0      	; 0x3d2 <__uartswInit+0x3e>
			uart->txBitNum=0;
 3d2:	1e 8e       	std	Y+30, r1	; 0x1e

			// set the output idle state of the transmitter
			if(!uartIsOneWire(uart)){
 3d4:	2d 89       	ldd	r18, Y+21	; 0x15
 3d6:	21 11       	cpse	r18, r1
 3d8:	00 c0       	rjmp	.+0      	; 0x3da <__uartswInit+0x46>
}


static void setTxIdle(SW_UART* uart){
	// set the output idle state of the transmitter
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
 3da:	2b a1       	ldd	r18, Y+35	; 0x23
 3dc:	22 23       	and	r18, r18
 3de:	01 f0       	breq	.+0      	; 0x3e0 <__uartswInit+0x4c>
 3e0:	60 e0       	ldi	r22, 0x00	; 0
 3e2:	00 c0       	rjmp	.+0      	; 0x3e4 <__uartswInit+0x50>
 3e4:	6f ef       	ldi	r22, 0xFF	; 255
 3e6:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
			// set the output idle state of the transmitter
			if(!uartIsOneWire(uart)){
				setTxIdle(uart);
			}

			CRITICAL_SECTION{
 3ea:	df b6       	in	r13, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 3ec:	f8 94       	cli
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 3ee:	f8 01       	movw	r30, r16
 3f0:	77 96       	adiw	r30, 0x17	; 23
 3f2:	85 91       	lpm	r24, Z+
 3f4:	94 91       	lpm	r25, Z
 3f6:	7c 01       	movw	r14, r24
				const TimerCompare* channel = timerGetCompare(timer,0);
				// Mark the transmit channel as in use
				compareAttach(channel,&uartswTxBitService,0,uart);
 3f8:	9e 01       	movw	r18, r28
 3fa:	40 e0       	ldi	r20, 0x00	; 0
 3fc:	50 e0       	ldi	r21, 0x00	; 0
 3fe:	60 e0       	ldi	r22, 0x00	; 0
 400:	70 e0       	ldi	r23, 0x00	; 0
 402:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

				// But turn off interrupt for now
				__portMaskClear(&channel->pgm_intenable);
 406:	c7 01       	movw	r24, r14
 408:	03 96       	adiw	r24, 0x03	; 3
 40a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 40e:	df be       	out	0x3f, r13	; 63
			}

		}

		// setup the receiver
		if(uart->_uart_.rx_pin!=null){
 410:	2d 85       	ldd	r18, Y+13	; 0x0d
 412:	3e 85       	ldd	r19, Y+14	; 0x0e
 414:	21 15       	cp	r18, r1
 416:	31 05       	cpc	r19, r1
 418:	01 f0       	breq	.+0      	; 0x41a <__uartswInit+0x86>
//  Get the capture pin for a timer
//  Return the IOPin or null if there isn't one
//
------------------------------------------------------- */
static __inline__ const IOPin* timerGetCapturePin(const Timer* timer){
	return (const IOPin*)(pgm_read_word(&timer->pgm_capturepin));
 41a:	f8 01       	movw	r30, r16
 41c:	ba 96       	adiw	r30, 0x2a	; 42
 41e:	45 91       	lpm	r20, Z+
 420:	54 91       	lpm	r21, Z
 422:	ca 01       	movw	r24, r20

			// Locate the timer whose capture input is this pin
			const IOPin* tCapture = timerGetCapturePin(timer);
			if(tCapture!=uart->_uart_.rx_pin){
 424:	42 17       	cp	r20, r18
 426:	53 07       	cpc	r21, r19
 428:	01 f0       	breq	.+0      	; 0x42a <__uartswInit+0x96>
				setError(UARTSW_NOT_CAPTURE);
 42a:	89 ee       	ldi	r24, 0xE9	; 233
 42c:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 430:	00 c0       	rjmp	.+0      	; 0x432 <__uartswInit+0x9e>
			}else{
				// Make the Rx pin an input with no pullup
				pin_make_input(uart->_uart_.rx_pin,FALSE);
 432:	60 e0       	ldi	r22, 0x00	; 0
 434:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

				// attach RxBit service routine to ICP
				// trigger on rising edge if inverted, falling if not
				timerCaptureAttach(timer, uartswRxStartService, uart, uart->inverted );
 438:	2b a1       	ldd	r18, Y+35	; 0x23
 43a:	ae 01       	movw	r20, r28
 43c:	60 e0       	ldi	r22, 0x00	; 0
 43e:	70 e0       	ldi	r23, 0x00	; 0
 440:	c8 01       	movw	r24, r16
 442:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 446:	09 5e       	subi	r16, 0xE9	; 233
 448:	1f 4f       	sbci	r17, 0xFF	; 255
 44a:	f8 01       	movw	r30, r16
 44c:	e5 90       	lpm	r14, Z+
 44e:	f4 90       	lpm	r15, Z
 450:	87 01       	movw	r16, r14
 452:	00 5f       	subi	r16, 0xF0	; 240
 454:	1f 4f       	sbci	r17, 0xFF	; 255

				// Set up receive interrupt for bit handling - then immediately disable it
				const TimerCompare* rx = timerGetCompare(timer,1);
				compareAttach(rx, uartswRxBitService, compareGetThreshold(rx)-1, uart);
 456:	c8 01       	movw	r24, r16
 458:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 45c:	ac 01       	movw	r20, r24
 45e:	41 50       	subi	r20, 0x01	; 1
 460:	51 09       	sbc	r21, r1
 462:	9e 01       	movw	r18, r28
 464:	60 e0       	ldi	r22, 0x00	; 0
 466:	70 e0       	ldi	r23, 0x00	; 0
 468:	c8 01       	movw	r24, r16
 46a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
				__portMaskClear(&rx->pgm_intenable);	// turn interrupt off
 46e:	c7 01       	movw	r24, r14
 470:	43 96       	adiw	r24, 0x13	; 19
 472:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 476:	c7 01       	movw	r24, r14
 478:	48 96       	adiw	r24, 0x18	; 24
 47a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
	if(_uartIsOneWire(_uart)){
 47e:	8d 89       	ldd	r24, Y+21	; 0x15
 480:	88 23       	and	r24, r24
 482:	01 f0       	breq	.+0      	; 0x484 <__uartswInit+0xf0>
 484:	ce 01       	movw	r24, r28
				compareClearInterruptPending(rx);		// clear any interrupt pending
			}
		}
	}
	oneWireReceiveMode(_uart);
}
 486:	df 91       	pop	r29
 488:	cf 91       	pop	r28
 48a:	1f 91       	pop	r17
 48c:	0f 91       	pop	r16
 48e:	ff 90       	pop	r15
 490:	ef 90       	pop	r14
 492:	df 90       	pop	r13
 494:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>
 498:	df 91       	pop	r29
 49a:	cf 91       	pop	r28
 49c:	1f 91       	pop	r17
 49e:	0f 91       	pop	r16
 4a0:	ff 90       	pop	r15
 4a2:	ef 90       	pop	r14
 4a4:	df 90       	pop	r13
 4a6:	08 95       	ret

000004a8 <__uartswStartXmit>:


}

// Start transmitting the given byte
void __uartswStartXmit(UART* _uart, uint8_t data){
 4a8:	cf 92       	push	r12
 4aa:	df 92       	push	r13
 4ac:	ef 92       	push	r14
 4ae:	ff 92       	push	r15
 4b0:	0f 93       	push	r16
 4b2:	1f 93       	push	r17
 4b4:	cf 93       	push	r28
 4b6:	df 93       	push	r29
 4b8:	ec 01       	movw	r28, r24

	SW_UART* uart = (SW_UART*)_uart;

	// save data
	uart->txData = (uart->inverted) ? ~data : data;
 4ba:	8b a1       	ldd	r24, Y+35	; 0x23
 4bc:	81 11       	cpse	r24, r1
 4be:	60 95       	com	r22
 4c0:	6d 8f       	std	Y+29, r22	; 0x1d

	// set number of bits (+1 for stop bit)
	uart->txBitNum = 9;
 4c2:	89 e0       	ldi	r24, 0x09	; 9
 4c4:	8e 8f       	std	Y+30, r24	; 0x1e

	const Timer* timer = &pgm_Timers[uart->timer];
 4c6:	ea 8c       	ldd	r14, Y+26	; 0x1a
 4c8:	8c e2       	ldi	r24, 0x2C	; 44
 4ca:	e8 9e       	mul	r14, r24
 4cc:	70 01       	movw	r14, r0
 4ce:	11 24       	eor	r1, r1
 4d0:	80 e0       	ldi	r24, 0x00	; 0
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	e8 0e       	add	r14, r24
 4d6:	f9 1e       	adc	r15, r25

	// Get the time when the start bit is set
	uint16_t start;
	start = timerGetCounter(timer);
 4d8:	c7 01       	movw	r24, r14
 4da:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 4de:	6c 01       	movw	r12, r24
	// set the start bit
	if(uart->inverted){
 4e0:	2b a1       	ldd	r18, Y+35	; 0x23
 4e2:	8f 85       	ldd	r24, Y+15	; 0x0f
 4e4:	98 89       	ldd	r25, Y+16	; 0x10
 4e6:	22 23       	and	r18, r18
 4e8:	01 f0       	breq	.+0      	; 0x4ea <__uartswStartXmit+0x42>
		pin_high(uart->_uart_.tx_pin);
 4ea:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 4ee:	00 c0       	rjmp	.+0      	; 0x4f0 <__uartswStartXmit+0x48>
	}else{
		pin_low(uart->_uart_.tx_pin);
 4f0:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	}

	if(uart->_uart_.tx_pin){
 4f4:	8f 85       	ldd	r24, Y+15	; 0x0f
 4f6:	98 89       	ldd	r25, Y+16	; 0x10
 4f8:	89 2b       	or	r24, r25
 4fa:	01 f0       	breq	.+0      	; 0x4fc <__uartswStartXmit+0x54>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 4fc:	f7 01       	movw	r30, r14
 4fe:	77 96       	adiw	r30, 0x17	; 23
 500:	25 91       	lpm	r18, Z+
 502:	34 91       	lpm	r19, Z
 504:	89 01       	movw	r16, r18
		const TimerCompare* channel = timerGetCompare(timer,0);

		// schedule the next bit
		uint16_t top = 1 + timerGetTOP(timer);
 506:	c7 01       	movw	r24, r14
 508:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
 50c:	01 96       	adiw	r24, 0x01	; 1
		uint16_t next = (start + uart->startBitLength);
 50e:	6f 8d       	ldd	r22, Y+31	; 0x1f
 510:	78 a1       	ldd	r23, Y+32	; 0x20
 512:	6c 0d       	add	r22, r12
 514:	7d 1d       	adc	r23, r13
		if(next >= top){
 516:	68 17       	cp	r22, r24
 518:	79 07       	cpc	r23, r25
 51a:	00 f0       	brcs	.+0      	; 0x51c <__uartswStartXmit+0x74>
			next -= top;
 51c:	68 1b       	sub	r22, r24
 51e:	79 0b       	sbc	r23, r25
		}
		compareSetThreshold(channel, next);
 520:	c8 01       	movw	r24, r16
 522:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 526:	c8 01       	movw	r24, r16
 528:	08 96       	adiw	r24, 0x08	; 8
 52a:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>

		// No interrupt pending
		compareClearInterruptPending(channel);

		// Allow compare interrupts
		__portMaskSet(&channel->pgm_intenable);
 52e:	c8 01       	movw	r24, r16
 530:	03 96       	adiw	r24, 0x03	; 3
	}else{
		// There is no iopin - so we have finished sending the current byte
		__uartTransmitService(&uart->_uart_);
	}

}
 532:	df 91       	pop	r29
 534:	cf 91       	pop	r28
 536:	1f 91       	pop	r17
 538:	0f 91       	pop	r16
 53a:	ff 90       	pop	r15
 53c:	ef 90       	pop	r14
 53e:	df 90       	pop	r13
 540:	cf 90       	pop	r12

		// No interrupt pending
		compareClearInterruptPending(channel);

		// Allow compare interrupts
		__portMaskSet(&channel->pgm_intenable);
 542:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>

	}else{
		// There is no iopin - so we have finished sending the current byte
		__uartTransmitService(&uart->_uart_);
 546:	ce 01       	movw	r24, r28
	}

}
 548:	df 91       	pop	r29
 54a:	cf 91       	pop	r28
 54c:	1f 91       	pop	r17
 54e:	0f 91       	pop	r16
 550:	ff 90       	pop	r15
 552:	ef 90       	pop	r14
 554:	df 90       	pop	r13
 556:	cf 90       	pop	r12
		// Allow compare interrupts
		__portMaskSet(&channel->pgm_intenable);

	}else{
		// There is no iopin - so we have finished sending the current byte
		__uartTransmitService(&uart->_uart_);
 558:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>

0000055c <endXmitMode>:
		CRITICAL_SECTION_END;
	}
}

// We have finished sending stuff
static void	endXmitMode(UART* _uart){
 55c:	cf 93       	push	r28
 55e:	df 93       	push	r29
 560:	ec 01       	movw	r28, r24
	const SW_UART* uart = (const SW_UART*)_uart;
	// Turn timer interrupt off
	const Timer* timer = &pgm_Timers[uart->timer];
 562:	ea 8d       	ldd	r30, Y+26	; 0x1a
 564:	8c e2       	ldi	r24, 0x2C	; 44
 566:	e8 9f       	mul	r30, r24
 568:	f0 01       	movw	r30, r0
 56a:	11 24       	eor	r1, r1
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 56c:	e0 50       	subi	r30, 0x00	; 0
 56e:	f0 40       	sbci	r31, 0x00	; 0
 570:	85 91       	lpm	r24, Z+
 572:	94 91       	lpm	r25, Z
	const TimerCompare* channel = timerGetCompare(timer,0);
	__portMaskClear(&channel->pgm_intenable);
 574:	03 96       	adiw	r24, 0x03	; 3
 576:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
	if(_uartIsOneWire(_uart)){
 57a:	8d 89       	ldd	r24, Y+21	; 0x15
 57c:	88 23       	and	r24, r24
 57e:	01 f0       	breq	.+0      	; 0x580 <endXmitMode+0x24>
 580:	ce 01       	movw	r24, r28
	const Timer* timer = &pgm_Timers[uart->timer];
	const TimerCompare* channel = timerGetCompare(timer,0);
	__portMaskClear(&channel->pgm_intenable);

	oneWireReceiveMode(_uart);
}
 582:	df 91       	pop	r29
 584:	cf 91       	pop	r28
 586:	0c 94 00 00 	jmp	0	; 0x0 <__uartswSetBaudRate>
 58a:	df 91       	pop	r29
 58c:	cf 91       	pop	r28
 58e:	08 95       	ret

00000590 <startXmitMode>:
	}

}

// We are about to start sending stuff
static void	startXmitMode(UART* _uart){
 590:	ff 92       	push	r15
 592:	0f 93       	push	r16
 594:	1f 93       	push	r17
 596:	cf 93       	push	r28
 598:	df 93       	push	r29
 59a:	ec 01       	movw	r28, r24
	if(_uartIsOneWire(_uart)){
 59c:	8d 89       	ldd	r24, Y+21	; 0x15
 59e:	88 23       	and	r24, r24
 5a0:	01 f0       	breq	.+0      	; 0x5a2 <startXmitMode+0x12>
		SW_UART* uart = (SW_UART*)_uart;
		// Place into transmit mode and turn receiver off
		const Timer* timer = &pgm_Timers[uart->timer];
 5a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5a4:	2c e2       	ldi	r18, 0x2C	; 44
 5a6:	82 9f       	mul	r24, r18
 5a8:	c0 01       	movw	r24, r0
 5aa:	11 24       	eor	r1, r1
 5ac:	80 50       	subi	r24, 0x00	; 0
 5ae:	90 40       	sbci	r25, 0x00	; 0
 5b0:	fc 01       	movw	r30, r24
 5b2:	77 96       	adiw	r30, 0x17	; 23
 5b4:	05 91       	lpm	r16, Z+
 5b6:	14 91       	lpm	r17, Z
		const TimerCompare* rx = timerGetCompare(timer,1);

		CRITICAL_SECTION_START;
 5b8:	ff b6       	in	r15, 0x3f	; 63
 5ba:	f8 94       	cli

		// Disable the input capture
		__portMaskClear(&timer->pgm_captureint);	// disable capture interrupt on timer
 5bc:	81 96       	adiw	r24, 0x21	; 33
 5be:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
		__portMaskClear(&rx->pgm_intenable);		// disable timer compare interrupt for recv bits
 5c2:	c8 01       	movw	r24, r16
 5c4:	43 96       	adiw	r24, 0x13	; 19
 5c6:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
}


static void setTxIdle(SW_UART* uart){
	// set the output idle state of the transmitter
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
 5ca:	8b a1       	ldd	r24, Y+35	; 0x23
 5cc:	88 23       	and	r24, r24
 5ce:	01 f0       	breq	.+0      	; 0x5d0 <startXmitMode+0x40>
 5d0:	60 e0       	ldi	r22, 0x00	; 0
 5d2:	00 c0       	rjmp	.+0      	; 0x5d4 <startXmitMode+0x44>
 5d4:	6f ef       	ldi	r22, 0xFF	; 255
 5d6:	8f 85       	ldd	r24, Y+15	; 0x0f
 5d8:	98 89       	ldd	r25, Y+16	; 0x10
 5da:	0e 94 00 00 	call	0	; 0x0 <__uartswSetBaudRate>
		__portMaskClear(&rx->pgm_intenable);		// disable timer compare interrupt for recv bits

		// Turn the transmitter pin back into an output
		setTxIdle(uart);

		CRITICAL_SECTION_END;
 5de:	ff be       	out	0x3f, r15	; 63

	}
}
 5e0:	df 91       	pop	r29
 5e2:	cf 91       	pop	r28
 5e4:	1f 91       	pop	r17
 5e6:	0f 91       	pop	r16
 5e8:	ff 90       	pop	r15
 5ea:	08 95       	ret
