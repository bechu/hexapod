In archive libWebbot-ATMega640.a:

BufferQueue.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000094  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000c8  2**0
                  ALLOC
  3 .debug_info   000001ea  00000000  00000000  000000c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000111  00000000  00000000  000002b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001d3  00000000  00000000  000003c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000596  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f9  00000000  00000000  000005b6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000151  00000000  00000000  000006af  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  00000800  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferQueue>:
 *  Created on: 21 Jun 2011
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	7b 01       	movw	r14, r22
  10:	8a 01       	movw	r16, r20
	boolean rtn = FALSE;
	if(buffer && buffer->size){
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <bufferQueue+0x16>
  16:	8a 81       	ldd	r24, Y+2	; 0x02
  18:	9b 81       	ldd	r25, Y+3	; 0x03
  1a:	00 97       	sbiw	r24, 0x00	; 0
  1c:	01 f0       	breq	.+0      	; 0x1e <bufferQueue+0x1e>
		CRITICAL_SECTION{
  1e:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  20:	f8 94       	cli
			// Check there is enough space
			if(buffer->size - buffer->datalength >= len){
  22:	6a 81       	ldd	r22, Y+2	; 0x02
  24:	7b 81       	ldd	r23, Y+3	; 0x03
  26:	ec 81       	ldd	r30, Y+4	; 0x04
  28:	fd 81       	ldd	r31, Y+5	; 0x05
  2a:	cb 01       	movw	r24, r22
  2c:	8e 1b       	sub	r24, r30
  2e:	9f 0b       	sbc	r25, r31
  30:	80 17       	cp	r24, r16
  32:	91 07       	cpc	r25, r17
  34:	00 f0       	brcs	.+0      	; 0x36 <bufferQueue+0x36>
				rtn = TRUE;
				const uint8_t* srcBytes = (const uint8_t*)src;

				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
  36:	8e 81       	ldd	r24, Y+6	; 0x06
  38:	9f 81       	ldd	r25, Y+7	; 0x07
  3a:	8e 0f       	add	r24, r30
  3c:	9f 1f       	adc	r25, r31
  3e:	0e 94 00 00 	call	0	; 0x0 <bufferQueue>
  42:	9c 01       	movw	r18, r24
				// Get the final length of the buffer
				buffer->datalength += len;
  44:	c8 01       	movw	r24, r16
  46:	8e 0f       	add	r24, r30
  48:	9f 1f       	adc	r25, r31
  4a:	9d 83       	std	Y+5, r25	; 0x05
  4c:	8c 83       	std	Y+4, r24	; 0x04
 *  Created on: 21 Jun 2011
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
  4e:	0e 0d       	add	r16, r14
  50:	1f 1d       	adc	r17, r15
	if(buffer && buffer->size){
		CRITICAL_SECTION{
			// Check there is enough space
			if(buffer->size - buffer->datalength >= len){
				rtn = TRUE;
				const uint8_t* srcBytes = (const uint8_t*)src;
  52:	d7 01       	movw	r26, r14
				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
				// Get the final length of the buffer
				buffer->datalength += len;
				// Put out all the bytes
				while(len--){
  54:	00 c0       	rjmp	.+0      	; 0x56 <bufferQueue+0x56>
					buffer->dataptr[dstIndex++] = *srcBytes++;
  56:	8d 91       	ld	r24, X+
  58:	e8 81       	ld	r30, Y
  5a:	f9 81       	ldd	r31, Y+1	; 0x01
  5c:	e2 0f       	add	r30, r18
  5e:	f3 1f       	adc	r31, r19
  60:	80 83       	st	Z, r24
  62:	2f 5f       	subi	r18, 0xFF	; 255
  64:	3f 4f       	sbci	r19, 0xFF	; 255
					if(dstIndex == buffer->size){
  66:	8a 81       	ldd	r24, Y+2	; 0x02
  68:	9b 81       	ldd	r25, Y+3	; 0x03
  6a:	28 17       	cp	r18, r24
  6c:	39 07       	cpc	r19, r25
  6e:	01 f4       	brne	.+0      	; 0x70 <bufferQueue+0x70>
						dstIndex = 0;
  70:	20 e0       	ldi	r18, 0x00	; 0
  72:	30 e0       	ldi	r19, 0x00	; 0
				// Get the current put location
				size_t dstIndex = (buffer->dataindex + buffer->datalength) % buffer->size;
				// Get the final length of the buffer
				buffer->datalength += len;
				// Put out all the bytes
				while(len--){
  74:	a0 17       	cp	r26, r16
  76:	b1 07       	cpc	r27, r17
  78:	01 f4       	brne	.+0      	; 0x7a <bufferQueue+0x7a>
  7a:	8f ef       	ldi	r24, 0xFF	; 255
  7c:	00 c0       	rjmp	.+0      	; 0x7e <bufferQueue+0x7e>
boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
	boolean rtn = FALSE;
	if(buffer && buffer->size){
		CRITICAL_SECTION{
			// Check there is enough space
			if(buffer->size - buffer->datalength >= len){
  7e:	80 e0       	ldi	r24, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  80:	4f bf       	out	0x3f, r20	; 63
  82:	00 c0       	rjmp	.+0      	; 0x84 <bufferQueue+0x84>
 *      Author: Clive Webster
 */
#include "buffer.h"

boolean bufferQueue(cBuffer* buffer, const void* src, size_t len){
	boolean rtn = FALSE;
  84:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	return rtn;
}
  86:	df 91       	pop	r29
  88:	cf 91       	pop	r28
  8a:	1f 91       	pop	r17
  8c:	0f 91       	pop	r16
  8e:	ff 90       	pop	r15
  90:	ef 90       	pop	r14
  92:	08 95       	ret

avrcam.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000aa0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000f  00000000  00000000  00000ad4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000102  00000000  00000000  00000ae3  2**0
                  ALLOC
  3 .progmem.data 00000027  00000000  00000000  00000ae3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000018b9  00000000  00000000  00000b0a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000413  00000000  00000000  000023c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000159e  00000000  00000000  000027d6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00003d74  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000128  00000000  00000000  00003d94  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000031c  00000000  00000000  00003ebc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000760  00000000  00000000  000041d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000002cc  00000000  00000000  00004938  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <xres>:
}

static uint16_t  xres(CAMERA* camera){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	return (uint16_t)176;
}
   0:	80 eb       	ldi	r24, 0xB0	; 176
   2:	90 e0       	ldi	r25, 0x00	; 0
   4:	08 95       	ret

00000006 <yres>:

static uint16_t  yres(CAMERA* camera){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	return (uint16_t)144;
}
   6:	80 e9       	ldi	r24, 0x90	; 144
   8:	90 e0       	ldi	r25, 0x00	; 0
   a:	08 95       	ret

0000000c <sendChar>:
#define flush(camera) __uartFlushReceiveBuffer(camera->_camera_.uart)


static UART* active;

static MAKE_WRITER(sendChar) {
   c:	cf 93       	push	r28
   e:	c8 2f       	mov	r28, r24
	_uartSendByte(active,byte);
  10:	80 91 00 00 	lds	r24, 0x0000
  14:	90 91 00 00 	lds	r25, 0x0000
  18:	6c 2f       	mov	r22, r28
  1a:	0e 94 00 00 	call	0	; 0x0 <xres>
	return byte;
}
  1e:	8c 2f       	mov	r24, r28
  20:	cf 91       	pop	r28
  22:	08 95       	ret

00000024 <setBin>:
static boolean ping(AVRCAM* camera){
	return sendCmd(camera,"PG");
}

// Set the value of a colour bin to RGB
static boolean setBin(CAMERA* camera, uint8_t binNo, const COLOR* min, const COLOR* max){
  24:	cf 92       	push	r12
  26:	df 92       	push	r13
  28:	ef 92       	push	r14
  2a:	ff 92       	push	r15
  2c:	0f 93       	push	r16
  2e:	1f 93       	push	r17
  30:	cf 93       	push	r28
  32:	df 93       	push	r29
  34:	cd b7       	in	r28, 0x3d	; 61
  36:	de b7       	in	r29, 0x3e	; 62
  38:	28 97       	sbiw	r28, 0x08	; 8
  3a:	0f b6       	in	r0, 0x3f	; 63
  3c:	f8 94       	cli
  3e:	de bf       	out	0x3e, r29	; 62
  40:	0f be       	out	0x3f, r0	; 63
  42:	cd bf       	out	0x3d, r28	; 61
  44:	fc 01       	movw	r30, r24
  46:	69 01       	movw	r12, r18
//	AVRCAM* avrcam = (AVRCAM*)camera;
	boolean rtn = FALSE;

	if(binNo < AVRCAM_BINS){
  48:	68 30       	cpi	r22, 0x08	; 8
  4a:	00 f0       	brcs	.+0      	; 0x4c <setBin+0x28>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <setBin+0x2a>
		CAMERA_BIN* bin = &camera->bins[binNo];
  4e:	70 e0       	ldi	r23, 0x00	; 0
  50:	cb 01       	movw	r24, r22
  52:	23 e0       	ldi	r18, 0x03	; 3
  54:	88 0f       	add	r24, r24
  56:	99 1f       	adc	r25, r25
  58:	2a 95       	dec	r18
  5a:	01 f4       	brne	.+0      	; 0x5c <setBin+0x38>
  5c:	86 0f       	add	r24, r22
  5e:	97 1f       	adc	r25, r23
  60:	e4 80       	ldd	r14, Z+4	; 0x04
  62:	f5 80       	ldd	r15, Z+5	; 0x05
  64:	e8 0e       	add	r14, r24
  66:	f9 1e       	adc	r15, r25
		COLOR _max;
		COLOR_RGB *_minRGB;
		COLOR_RGB *_maxRGB;

		// Convert min to rgb
		_minRGB = color2rgb(min, &_min);
  68:	ca 01       	movw	r24, r20
  6a:	be 01       	movw	r22, r28
  6c:	6b 5f       	subi	r22, 0xFB	; 251
  6e:	7f 4f       	sbci	r23, 0xFF	; 255
  70:	0e 94 00 00 	call	0	; 0x0 <xres>
  74:	8c 01       	movw	r16, r24

		// Convert max to rgb
		_maxRGB = color2rgb(max, &_max);
  76:	c6 01       	movw	r24, r12
  78:	be 01       	movw	r22, r28
  7a:	6f 5f       	subi	r22, 0xFF	; 255
  7c:	7f 4f       	sbci	r23, 0xFF	; 255
  7e:	0e 94 00 00 	call	0	; 0x0 <xres>
  82:	fc 01       	movw	r30, r24

		if(_minRGB->r > _maxRGB->r){
  84:	d8 01       	movw	r26, r16
  86:	8c 91       	ld	r24, X
  88:	90 81       	ld	r25, Z
  8a:	98 17       	cp	r25, r24
  8c:	00 f4       	brcc	.+0      	; 0x8e <setBin+0x6a>
			// swap the red values
			uint8_t c = _minRGB->r;
			_minRGB->r = _maxRGB->r;
  8e:	9c 93       	st	X, r25
			_maxRGB->r = c;
  90:	80 83       	st	Z, r24
		}

		if(_minRGB->g > _maxRGB->g){
  92:	d8 01       	movw	r26, r16
  94:	11 96       	adiw	r26, 0x01	; 1
  96:	8c 91       	ld	r24, X
  98:	11 97       	sbiw	r26, 0x01	; 1
  9a:	91 81       	ldd	r25, Z+1	; 0x01
  9c:	98 17       	cp	r25, r24
  9e:	00 f4       	brcc	.+0      	; 0xa0 <setBin+0x7c>
			// swap the green values
			uint8_t c = _minRGB->g;
			_minRGB->g = _maxRGB->g;
  a0:	11 96       	adiw	r26, 0x01	; 1
  a2:	9c 93       	st	X, r25
			_maxRGB->g = c;
  a4:	81 83       	std	Z+1, r24	; 0x01
		}

		if(_minRGB->b > _maxRGB->b){
  a6:	d8 01       	movw	r26, r16
  a8:	12 96       	adiw	r26, 0x02	; 2
  aa:	8c 91       	ld	r24, X
  ac:	12 97       	sbiw	r26, 0x02	; 2
  ae:	92 81       	ldd	r25, Z+2	; 0x02
  b0:	98 17       	cp	r25, r24
  b2:	00 f4       	brcc	.+0      	; 0xb4 <setBin+0x90>
			// swap the blue values
			uint8_t c = _minRGB->b;
			_minRGB->b = _maxRGB->b;
  b4:	12 96       	adiw	r26, 0x02	; 2
  b6:	9c 93       	st	X, r25
			_maxRGB->b = c;
  b8:	82 83       	std	Z+2, r24	; 0x02
		}

		if(colorEquals(&_min, &bin->min)==FALSE || colorEquals(&_max, &bin->max)==FALSE){
  ba:	ce 2c       	mov	r12, r14
  bc:	0f 2d       	mov	r16, r15
  be:	ce 01       	movw	r24, r28
  c0:	05 96       	adiw	r24, 0x05	; 5
  c2:	b7 01       	movw	r22, r14
  c4:	0e 94 00 00 	call	0	; 0x0 <xres>
  c8:	88 23       	and	r24, r24
  ca:	01 f0       	breq	.+0      	; 0xcc <setBin+0xa8>
  cc:	97 01       	movw	r18, r14
  ce:	2c 5f       	subi	r18, 0xFC	; 252
  d0:	3f 4f       	sbci	r19, 0xFF	; 255
  d2:	ce 01       	movw	r24, r28
  d4:	01 96       	adiw	r24, 0x01	; 1
  d6:	b9 01       	movw	r22, r18
  d8:	0e 94 00 00 	call	0	; 0x0 <xres>
  dc:	88 23       	and	r24, r24
  de:	01 f4       	brne	.+0      	; 0xe0 <setBin+0xbc>
			// The colours have changed

			// Put into color bank table
			color2rgb(&_min, &bin->min);
  e0:	ce 01       	movw	r24, r28
  e2:	05 96       	adiw	r24, 0x05	; 5
  e4:	6c 2d       	mov	r22, r12
  e6:	70 2f       	mov	r23, r16
  e8:	0e 94 00 00 	call	0	; 0x0 <xres>
			color2rgb(&_max, &bin->max);
  ec:	b7 01       	movw	r22, r14
  ee:	6c 5f       	subi	r22, 0xFC	; 252
  f0:	7f 4f       	sbci	r23, 0xFF	; 255
  f2:	ce 01       	movw	r24, r28
  f4:	01 96       	adiw	r24, 0x01	; 1
  f6:	0e 94 00 00 	call	0	; 0x0 <xres>
			bin->dirty = TRUE;
  fa:	f7 01       	movw	r30, r14
  fc:	80 85       	ldd	r24, Z+8	; 0x08
  fe:	81 60       	ori	r24, 0x01	; 1
 100:	80 87       	std	Z+8, r24	; 0x08
		}

		rtn = bin->active = TRUE;
 102:	d7 01       	movw	r26, r14
 104:	18 96       	adiw	r26, 0x08	; 8
 106:	8c 91       	ld	r24, X
 108:	18 97       	sbiw	r26, 0x08	; 8
 10a:	82 60       	ori	r24, 0x02	; 2
 10c:	18 96       	adiw	r26, 0x08	; 8
 10e:	8c 93       	st	X, r24
 110:	18 97       	sbiw	r26, 0x08	; 8
 112:	8f ef       	ldi	r24, 0xFF	; 255
 114:	00 c0       	rjmp	.+0      	; 0x116 <setBin+0xf2>
}

// Set the value of a colour bin to RGB
static boolean setBin(CAMERA* camera, uint8_t binNo, const COLOR* min, const COLOR* max){
//	AVRCAM* avrcam = (AVRCAM*)camera;
	boolean rtn = FALSE;
 116:	80 e0       	ldi	r24, 0x00	; 0

		rtn = bin->active = TRUE;

	}
	return rtn;
}
 118:	28 96       	adiw	r28, 0x08	; 8
 11a:	0f b6       	in	r0, 0x3f	; 63
 11c:	f8 94       	cli
 11e:	de bf       	out	0x3e, r29	; 62
 120:	0f be       	out	0x3f, r0	; 63
 122:	cd bf       	out	0x3d, r28	; 61
 124:	df 91       	pop	r29
 126:	cf 91       	pop	r28
 128:	1f 91       	pop	r17
 12a:	0f 91       	pop	r16
 12c:	ff 90       	pop	r15
 12e:	ef 90       	pop	r14
 130:	df 90       	pop	r13
 132:	cf 90       	pop	r12
 134:	08 95       	ret

00000136 <getResponse.isra.1.constprop.3>:
	}
	return rtn;
}

// Get a line of response and return the length (0=error)
static size_t getResponse(AVRCAM* camera, char chStart, char chEnd, size_t minLen, size_t maxLen) {
 136:	2f 92       	push	r2
 138:	3f 92       	push	r3
 13a:	4f 92       	push	r4
 13c:	5f 92       	push	r5
 13e:	6f 92       	push	r6
 140:	7f 92       	push	r7
 142:	8f 92       	push	r8
 144:	9f 92       	push	r9
 146:	af 92       	push	r10
 148:	bf 92       	push	r11
 14a:	cf 92       	push	r12
 14c:	df 92       	push	r13
 14e:	ef 92       	push	r14
 150:	ff 92       	push	r15
 152:	0f 93       	push	r16
 154:	1f 93       	push	r17
 156:	cf 93       	push	r28
 158:	df 93       	push	r29
 15a:	00 d0       	rcall	.+0      	; 0x15c <getResponse.isra.1.constprop.3+0x26>
 15c:	0f 92       	push	r0
 15e:	cd b7       	in	r28, 0x3d	; 61
 160:	de b7       	in	r29, 0x3e	; 62
 162:	1c 01       	movw	r2, r24
 164:	06 2f       	mov	r16, r22
 166:	29 01       	movw	r4, r18
	size_t		counter=0;		// Counts the length of the string

	// Have we located the start character yet?
	boolean		inLine= (chStart) ? FALSE : TRUE;
 168:	66 23       	and	r22, r22
 16a:	01 f0       	breq	.+0      	; 0x16c <getResponse.isra.1.constprop.3+0x36>
 16c:	10 e0       	ldi	r17, 0x00	; 0
 16e:	00 c0       	rjmp	.+0      	; 0x170 <getResponse.isra.1.constprop.3+0x3a>
 170:	1f ef       	ldi	r17, 0xFF	; 255
	if (! maxLen) {
		maxLen=MAX_REPLY;
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
 172:	49 83       	std	Y+1, r20	; 0x01
 174:	0e 94 00 00 	call	0	; 0x0 <xres>
 178:	4b 01       	movw	r8, r22
 17a:	5c 01       	movw	r10, r24
	return rtn;
}

// Get a line of response and return the length (0=error)
static size_t getResponse(AVRCAM* camera, char chStart, char chEnd, size_t minLen, size_t maxLen) {
	size_t		counter=0;		// Counts the length of the string
 17c:	1b 82       	std	Y+3, r1	; 0x03
 17e:	1a 82       	std	Y+2, r1	; 0x02
		maxLen=MAX_REPLY;
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
 180:	40 e6       	ldi	r20, 0x60	; 96
 182:	e4 2e       	mov	r14, r20
 184:	4a ee       	ldi	r20, 0xEA	; 234
 186:	f4 2e       	mov	r15, r20
					return 0;
				}
			}
		}else{
			// we are waiting for start of line
			if(temp == chStart){
 188:	60 2e       	mov	r6, r16
 18a:	77 24       	eor	r7, r7
			noclock = 60000;
		}

		if(inLine){
			// We are processing the line
			if(temp==chEnd && counter>=minLen) {
 18c:	49 81       	ldd	r20, Y+1	; 0x01
 18e:	c4 2e       	mov	r12, r20
 190:	dd 24       	eor	r13, r13

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
	while(noclock) {
		if(g_heartbeat){
 192:	80 91 00 00 	lds	r24, 0x0000
 196:	90 91 00 00 	lds	r25, 0x0000
 19a:	00 97       	sbiw	r24, 0x00	; 0
 19c:	01 f0       	breq	.+0      	; 0x19e <getResponse.isra.1.constprop.3+0x68>
			if(clockHasElapsed(startTime, TIMEOUT)){
 19e:	c5 01       	movw	r24, r10
 1a0:	b4 01       	movw	r22, r8
 1a2:	20 ee       	ldi	r18, 0xE0	; 224
 1a4:	33 e9       	ldi	r19, 0x93	; 147
 1a6:	44 e0       	ldi	r20, 0x04	; 4
 1a8:	50 e0       	ldi	r21, 0x00	; 0
 1aa:	0e 94 00 00 	call	0	; 0x0 <xres>
 1ae:	88 23       	and	r24, r24
 1b0:	01 f0       	breq	.+0      	; 0x1b2 <getResponse.isra.1.constprop.3+0x7c>
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <getResponse.isra.1.constprop.3+0x7e>
				// We've timed out
				return 0;
			}
		}else{
			noclock--;
 1b4:	08 94       	sec
 1b6:	e1 08       	sbc	r14, r1
 1b8:	f1 08       	sbc	r15, r1
		}

		// Get next byte, or -1 if none
		int temp=__uartGetByte(camera->_camera_.uart);
 1ba:	f1 01       	movw	r30, r2
 1bc:	80 81       	ld	r24, Z
 1be:	91 81       	ldd	r25, Z+1	; 0x01
 1c0:	0e 94 00 00 	call	0	; 0x0 <xres>

		if(temp!=-1){
 1c4:	ff ef       	ldi	r31, 0xFF	; 255
 1c6:	8f 3f       	cpi	r24, 0xFF	; 255
 1c8:	9f 07       	cpc	r25, r31
 1ca:	01 f0       	breq	.+0      	; 0x1cc <getResponse.isra.1.constprop.3+0x96>
			noclock = 60000;
 1cc:	30 e6       	ldi	r19, 0x60	; 96
 1ce:	e3 2e       	mov	r14, r19
 1d0:	3a ee       	ldi	r19, 0xEA	; 234
 1d2:	f3 2e       	mov	r15, r19
		}

		if(inLine){
 1d4:	11 23       	and	r17, r17
 1d6:	01 f0       	breq	.+0      	; 0x1d8 <getResponse.isra.1.constprop.3+0xa2>
			// We are processing the line
			if(temp==chEnd && counter>=minLen) {
 1d8:	8c 15       	cp	r24, r12
 1da:	9d 05       	cpc	r25, r13
 1dc:	01 f4       	brne	.+0      	; 0x1de <getResponse.isra.1.constprop.3+0xa8>
 1de:	2a 81       	ldd	r18, Y+2	; 0x02
 1e0:	3b 81       	ldd	r19, Y+3	; 0x03
 1e2:	24 15       	cp	r18, r4
 1e4:	35 05       	cpc	r19, r5
 1e6:	00 f0       	brcs	.+0      	; 0x1e8 <getResponse.isra.1.constprop.3+0xb2>
				// Found the end of the line
				response[counter]='\0';
 1e8:	f9 01       	movw	r30, r18
 1ea:	e0 50       	subi	r30, 0x00	; 0
 1ec:	f0 40       	sbci	r31, 0x00	; 0
 1ee:	10 82       	st	Z, r1
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <getResponse.isra.1.constprop.3+0xbc>
				return counter;
			}else if (temp != -1) {
 1f2:	3f ef       	ldi	r19, 0xFF	; 255
 1f4:	8f 3f       	cpi	r24, 0xFF	; 255
 1f6:	93 07       	cpc	r25, r19
 1f8:	01 f0       	breq	.+0      	; 0x1fa <getResponse.isra.1.constprop.3+0xc4>
				// Save the next character
				response[counter++]=temp;
 1fa:	ea 81       	ldd	r30, Y+2	; 0x02
 1fc:	fb 81       	ldd	r31, Y+3	; 0x03
 1fe:	e0 50       	subi	r30, 0x00	; 0
 200:	f0 40       	sbci	r31, 0x00	; 0
 202:	80 83       	st	Z, r24
 204:	8a 81       	ldd	r24, Y+2	; 0x02
 206:	9b 81       	ldd	r25, Y+3	; 0x03
 208:	01 96       	adiw	r24, 0x01	; 1
 20a:	9b 83       	std	Y+3, r25	; 0x03
 20c:	8a 83       	std	Y+2, r24	; 0x02

				// Check if the line is too long
				if (counter>=maxLen) {
 20e:	8f 3f       	cpi	r24, 0xFF	; 255
 210:	91 05       	cpc	r25, r1
 212:	00 f0       	brcs	.+0      	; 0x214 <getResponse.isra.1.constprop.3+0xde>
 214:	00 c0       	rjmp	.+0      	; 0x216 <getResponse.isra.1.constprop.3+0xe0>
					return 0;
				}
			}
		}else{
			// we are waiting for start of line
			if(temp == chStart){
 216:	86 15       	cp	r24, r6
 218:	97 05       	cpc	r25, r7
 21a:	01 f4       	brne	.+0      	; 0x21c <getResponse.isra.1.constprop.3+0xe6>
				inLine = TRUE;
 21c:	1f ef       	ldi	r17, 0xFF	; 255
	}

	// Save the start time
	TICK_COUNT startTime=clockGetus();
	uint16_t noclock = 60000;
	while(noclock) {
 21e:	e1 14       	cp	r14, r1
 220:	f1 04       	cpc	r15, r1
 222:	01 f0       	breq	.+0      	; 0x224 <getResponse.isra.1.constprop.3+0xee>
 224:	00 c0       	rjmp	.+0      	; 0x226 <getResponse.isra.1.constprop.3+0xf0>
				// Save the next character
				response[counter++]=temp;

				// Check if the line is too long
				if (counter>=maxLen) {
					return 0;
 226:	1b 82       	std	Y+3, r1	; 0x03
 228:	1a 82       	std	Y+2, r1	; 0x02
				inLine = TRUE;
			}
		}
	}
	return 0;
}
 22a:	8a 81       	ldd	r24, Y+2	; 0x02
 22c:	9b 81       	ldd	r25, Y+3	; 0x03
 22e:	0f 90       	pop	r0
 230:	0f 90       	pop	r0
 232:	0f 90       	pop	r0
 234:	df 91       	pop	r29
 236:	cf 91       	pop	r28
 238:	1f 91       	pop	r17
 23a:	0f 91       	pop	r16
 23c:	ff 90       	pop	r15
 23e:	ef 90       	pop	r14
 240:	df 90       	pop	r13
 242:	cf 90       	pop	r12
 244:	bf 90       	pop	r11
 246:	af 90       	pop	r10
 248:	9f 90       	pop	r9
 24a:	8f 90       	pop	r8
 24c:	7f 90       	pop	r7
 24e:	6f 90       	pop	r6
 250:	5f 90       	pop	r5
 252:	4f 90       	pop	r4
 254:	3f 90       	pop	r3
 256:	2f 90       	pop	r2
 258:	08 95       	ret

0000025a <sendCmd>:



// Send a null terminated string and await response
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
 25a:	ef 92       	push	r14
 25c:	ff 92       	push	r15
 25e:	0f 93       	push	r16
 260:	1f 93       	push	r17
 262:	cf 93       	push	r28
 264:	df 93       	push	r29
 266:	ec 01       	movw	r28, r24
 268:	7b 01       	movw	r14, r22
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 26a:	8a 81       	ldd	r24, Y+2	; 0x02
 26c:	9b 81       	ldd	r25, Y+3	; 0x03
 26e:	90 93 00 00 	sts	0x0000, r25
 272:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 276:	80 e0       	ldi	r24, 0x00	; 0
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	0e 94 00 00 	call	0	; 0x0 <xres>
 27e:	8c 01       	movw	r16, r24
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
	boolean rtn = FALSE;

	Writer old = setActive(camera);
	flush(camera);							// Flush receive buffer
 280:	8a 81       	ldd	r24, Y+2	; 0x02
 282:	9b 81       	ldd	r25, Y+3	; 0x03
 284:	0e 94 00 00 	call	0	; 0x0 <xres>
	rprintf("%s\r",cmd);					// Send the command
 288:	00 d0       	rcall	.+0      	; 0x28a <sendCmd+0x30>
 28a:	00 d0       	rcall	.+0      	; 0x28c <sendCmd+0x32>
 28c:	0f 92       	push	r0
 28e:	ed b7       	in	r30, 0x3d	; 61
 290:	fe b7       	in	r31, 0x3e	; 62
 292:	31 96       	adiw	r30, 0x01	; 1
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	ad b7       	in	r26, 0x3d	; 61
 298:	be b7       	in	r27, 0x3e	; 62
 29a:	11 96       	adiw	r26, 0x01	; 1
 29c:	8c 93       	st	X, r24
 29e:	80 e0       	ldi	r24, 0x00	; 0
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	92 83       	std	Z+2, r25	; 0x02
 2a4:	81 83       	std	Z+1, r24	; 0x01
 2a6:	f4 82       	std	Z+4, r15	; 0x04
 2a8:	e3 82       	std	Z+3, r14	; 0x03
 2aa:	0e 94 00 00 	call	0	; 0x0 <xres>
	rprintfInit(old);
 2ae:	0f 90       	pop	r0
 2b0:	0f 90       	pop	r0
 2b2:	0f 90       	pop	r0
 2b4:	0f 90       	pop	r0
 2b6:	0f 90       	pop	r0
 2b8:	c8 01       	movw	r24, r16
 2ba:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Read the response
	size_t len=getResponse(camera, 0,'\r',0,0);
 2be:	ce 01       	movw	r24, r28
 2c0:	02 96       	adiw	r24, 0x02	; 2
 2c2:	60 e0       	ldi	r22, 0x00	; 0
 2c4:	4d e0       	ldi	r20, 0x0D	; 13
 2c6:	20 e0       	ldi	r18, 0x00	; 0
 2c8:	30 e0       	ldi	r19, 0x00	; 0
 2ca:	0e 94 00 00 	call	0	; 0x0 <xres>

	if (len>0) {
 2ce:	00 97       	sbiw	r24, 0x00	; 0
 2d0:	01 f0       	breq	.+0      	; 0x2d2 <sendCmd+0x78>
		char * ack=response+len-3;			// Look at last 3 characters
 2d2:	03 97       	sbiw	r24, 0x03	; 3

		// Test for an ACK response
		if(ack[0]=='A' && ack[1]=='C' && ack[2]=='K'){
 2d4:	fc 01       	movw	r30, r24
 2d6:	e0 50       	subi	r30, 0x00	; 0
 2d8:	f0 40       	sbci	r31, 0x00	; 0
 2da:	20 81       	ld	r18, Z
 2dc:	21 34       	cpi	r18, 0x41	; 65
 2de:	01 f4       	brne	.+0      	; 0x2e0 <sendCmd+0x86>
 2e0:	fc 01       	movw	r30, r24
 2e2:	e0 50       	subi	r30, 0x00	; 0
 2e4:	f0 40       	sbci	r31, 0x00	; 0
 2e6:	20 81       	ld	r18, Z
 2e8:	23 34       	cpi	r18, 0x43	; 67
 2ea:	01 f4       	brne	.+0      	; 0x2ec <sendCmd+0x92>
 2ec:	80 50       	subi	r24, 0x00	; 0
 2ee:	90 40       	sbci	r25, 0x00	; 0
 2f0:	fc 01       	movw	r30, r24
 2f2:	80 81       	ld	r24, Z
 2f4:	8b 34       	cpi	r24, 0x4B	; 75
 2f6:	01 f0       	breq	.+0      	; 0x2f8 <sendCmd+0x9e>


// Send a null terminated string and await response
// Return TRUE if successfull
static boolean  sendCmd(AVRCAM* camera, const char* cmd){
	boolean rtn = FALSE;
 2f8:	80 e0       	ldi	r24, 0x00	; 0
 2fa:	00 c0       	rjmp	.+0      	; 0x2fc <sendCmd+0xa2>
	if (len>0) {
		char * ack=response+len-3;			// Look at last 3 characters

		// Test for an ACK response
		if(ack[0]=='A' && ack[1]=='C' && ack[2]=='K'){
			rtn = TRUE;
 2fc:	8f ef       	ldi	r24, 0xFF	; 255
		}
	}
	return rtn;
}
 2fe:	df 91       	pop	r29
 300:	cf 91       	pop	r28
 302:	1f 91       	pop	r17
 304:	0f 91       	pop	r16
 306:	ff 90       	pop	r15
 308:	ef 90       	pop	r14
 30a:	08 95       	ret

0000030c <getVersion>:
	return camera->numBlobs;
}

// Get the version of camera software
static char *getVersion(CAMERA* camera) {
	return(sendCmd((AVRCAM*)camera,"GV")) ? response : null;
 30c:	60 e0       	ldi	r22, 0x00	; 0
 30e:	70 e0       	ldi	r23, 0x00	; 0
 310:	0e 94 00 00 	call	0	; 0x0 <xres>
 314:	88 23       	and	r24, r24
 316:	01 f0       	breq	.+0      	; 0x318 <getVersion+0xc>
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	90 e0       	ldi	r25, 0x00	; 0
 31c:	08 95       	ret
 31e:	80 e0       	ldi	r24, 0x00	; 0
 320:	90 e0       	ldi	r25, 0x00	; 0
}
 322:	08 95       	ret

00000324 <trackStop>:
	return (camera->tracking) ? TRUE : FALSE;
}

// Turn off tracking mode
// return TRUE if tacking mode disabled
static boolean trackStop(AVRCAM* camera) {
 324:	cf 93       	push	r28
 326:	df 93       	push	r29
 328:	ec 01       	movw	r28, r24
	if(camera->tracking) {
 32a:	8d 85       	ldd	r24, Y+13	; 0x0d
 32c:	80 ff       	sbrs	r24, 0
 32e:	00 c0       	rjmp	.+0      	; 0x330 <trackStop+0xc>
		if(sendCmd(camera, "DT")){
 330:	ce 01       	movw	r24, r28
 332:	60 e0       	ldi	r22, 0x00	; 0
 334:	70 e0       	ldi	r23, 0x00	; 0
 336:	0e 94 00 00 	call	0	; 0x0 <xres>
 33a:	88 23       	and	r24, r24
 33c:	01 f0       	breq	.+0      	; 0x33e <trackStop+0x1a>
			camera->tracking = FALSE;
 33e:	8d 85       	ldd	r24, Y+13	; 0x0d
 340:	8e 7f       	andi	r24, 0xFE	; 254
 342:	8d 87       	std	Y+13, r24	; 0x0d
		}
	}
	return (camera->tracking) ? FALSE : TRUE;
 344:	8d 85       	ldd	r24, Y+13	; 0x0d
 346:	80 ff       	sbrs	r24, 0
 348:	00 c0       	rjmp	.+0      	; 0x34a <trackStop+0x26>
 34a:	80 e0       	ldi	r24, 0x00	; 0
 34c:	00 c0       	rjmp	.+0      	; 0x34e <trackStop+0x2a>
 34e:	8f ef       	ldi	r24, 0xFF	; 255
}
 350:	df 91       	pop	r29
 352:	cf 91       	pop	r28
 354:	08 95       	ret

00000356 <setCameraReg>:
	flush(avrcam);
	return rtn;
}

// Set a register
static boolean setCameraReg(AVRCAM* avrcam, uint8_t reg, uint8_t val) {
 356:	ef 92       	push	r14
 358:	ff 92       	push	r15
 35a:	0f 93       	push	r16
 35c:	1f 93       	push	r17
 35e:	cf 93       	push	r28
 360:	df 93       	push	r29
 362:	00 d0       	rcall	.+0      	; 0x364 <setCameraReg+0xe>
 364:	cd b7       	in	r28, 0x3d	; 61
 366:	de b7       	in	r29, 0x3e	; 62
 368:	7c 01       	movw	r14, r24
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 36a:	dc 01       	movw	r26, r24
 36c:	12 96       	adiw	r26, 0x02	; 2
 36e:	8d 91       	ld	r24, X+
 370:	9c 91       	ld	r25, X
 372:	13 97       	sbiw	r26, 0x03	; 3
 374:	90 93 00 00 	sts	0x0000, r25
 378:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 37c:	80 e0       	ldi	r24, 0x00	; 0
 37e:	90 e0       	ldi	r25, 0x00	; 0
 380:	4a 83       	std	Y+2, r20	; 0x02
 382:	69 83       	std	Y+1, r22	; 0x01
 384:	0e 94 00 00 	call	0	; 0x0 <xres>
 388:	8c 01       	movw	r16, r24
}

// Set a register
static boolean setCameraReg(AVRCAM* avrcam, uint8_t reg, uint8_t val) {
	Writer old = setActive(avrcam);
	rprintf("CR %d %d",reg,val);
 38a:	ed b7       	in	r30, 0x3d	; 61
 38c:	fe b7       	in	r31, 0x3e	; 62
 38e:	37 97       	sbiw	r30, 0x07	; 7
 390:	0f b6       	in	r0, 0x3f	; 63
 392:	f8 94       	cli
 394:	fe bf       	out	0x3e, r31	; 62
 396:	0f be       	out	0x3f, r0	; 63
 398:	ed bf       	out	0x3d, r30	; 61
 39a:	31 96       	adiw	r30, 0x01	; 1
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	ad b7       	in	r26, 0x3d	; 61
 3a0:	be b7       	in	r27, 0x3e	; 62
 3a2:	11 96       	adiw	r26, 0x01	; 1
 3a4:	8c 93       	st	X, r24
 3a6:	80 e0       	ldi	r24, 0x00	; 0
 3a8:	90 e0       	ldi	r25, 0x00	; 0
 3aa:	92 83       	std	Z+2, r25	; 0x02
 3ac:	81 83       	std	Z+1, r24	; 0x01
 3ae:	69 81       	ldd	r22, Y+1	; 0x01
 3b0:	63 83       	std	Z+3, r22	; 0x03
 3b2:	14 82       	std	Z+4, r1	; 0x04
 3b4:	4a 81       	ldd	r20, Y+2	; 0x02
 3b6:	45 83       	std	Z+5, r20	; 0x05
 3b8:	16 82       	std	Z+6, r1	; 0x06
 3ba:	0e 94 00 00 	call	0	; 0x0 <xres>
	boolean rtn = sendCmd(avrcam, NULL);
 3be:	ed b7       	in	r30, 0x3d	; 61
 3c0:	fe b7       	in	r31, 0x3e	; 62
 3c2:	37 96       	adiw	r30, 0x07	; 7
 3c4:	0f b6       	in	r0, 0x3f	; 63
 3c6:	f8 94       	cli
 3c8:	fe bf       	out	0x3e, r31	; 62
 3ca:	0f be       	out	0x3f, r0	; 63
 3cc:	ed bf       	out	0x3d, r30	; 61
 3ce:	c7 01       	movw	r24, r14
 3d0:	60 e0       	ldi	r22, 0x00	; 0
 3d2:	70 e0       	ldi	r23, 0x00	; 0
 3d4:	0e 94 00 00 	call	0	; 0x0 <xres>
 3d8:	e8 2e       	mov	r14, r24
	rprintfInit(old);
 3da:	c8 01       	movw	r24, r16
 3dc:	0e 94 00 00 	call	0	; 0x0 <xres>
	return rtn;
}
 3e0:	8e 2d       	mov	r24, r14
 3e2:	0f 90       	pop	r0
 3e4:	0f 90       	pop	r0
 3e6:	df 91       	pop	r29
 3e8:	cf 91       	pop	r28
 3ea:	1f 91       	pop	r17
 3ec:	0f 91       	pop	r16
 3ee:	ff 90       	pop	r15
 3f0:	ef 90       	pop	r14
 3f2:	08 95       	ret

000003f4 <getBlobs>:
	}
	return 0;
}

// Read the blobs for a given color bin
static uint8_t	getBlobs(CAMERA* camera, uint8_t bin){
 3f4:	2f 92       	push	r2
 3f6:	3f 92       	push	r3
 3f8:	4f 92       	push	r4
 3fa:	5f 92       	push	r5
 3fc:	6f 92       	push	r6
 3fe:	7f 92       	push	r7
 400:	8f 92       	push	r8
 402:	9f 92       	push	r9
 404:	af 92       	push	r10
 406:	bf 92       	push	r11
 408:	cf 92       	push	r12
 40a:	df 92       	push	r13
 40c:	ef 92       	push	r14
 40e:	ff 92       	push	r15
 410:	0f 93       	push	r16
 412:	1f 93       	push	r17
 414:	cf 93       	push	r28
 416:	df 93       	push	r29
 418:	cd b7       	in	r28, 0x3d	; 61
 41a:	de b7       	in	r29, 0x3e	; 62
 41c:	6b 97       	sbiw	r28, 0x1b	; 27
 41e:	0f b6       	in	r0, 0x3f	; 63
 420:	f8 94       	cli
 422:	de bf       	out	0x3e, r29	; 62
 424:	0f be       	out	0x3f, r0	; 63
 426:	cd bf       	out	0x3d, r28	; 61
 428:	7c 01       	movw	r14, r24
 42a:	26 2e       	mov	r2, r22
	AVRCAM* avrcam = (AVRCAM*)camera;
	camera->numBlobs = 0;
 42c:	dc 01       	movw	r26, r24
 42e:	1c 96       	adiw	r26, 0x0c	; 12
 430:	1c 92       	st	X, r1
 432:	1c 97       	sbiw	r26, 0x0c	; 12
}

// Turn on tracking mode
// return TRUE if tracking mode enabled
static boolean trackStart(AVRCAM* camera) {
	if(!camera->tracking) {
 434:	1d 96       	adiw	r26, 0x0d	; 13
 436:	8c 91       	ld	r24, X
 438:	1d 97       	sbiw	r26, 0x0d	; 13
 43a:	80 fd       	sbrc	r24, 0
 43c:	00 c0       	rjmp	.+0      	; 0x43e <getBlobs+0x4a>
// This will only do something if the color bins have changed
static boolean sendBins(AVRCAM* camera){
	// See if anything is dirty
	boolean dirty = FALSE;
	for (uint8_t index=0; index<AVRCAM_BINS; index++) {
		CAMERA_BIN* bin = &camera->_camera_.bins[index];
 43e:	14 96       	adiw	r26, 0x04	; 4
 440:	2d 91       	ld	r18, X+
 442:	3c 91       	ld	r19, X
 444:	15 97       	sbiw	r26, 0x05	; 5
 446:	80 e0       	ldi	r24, 0x00	; 0
 448:	90 e0       	ldi	r25, 0x00	; 0
 44a:	50 e0       	ldi	r21, 0x00	; 0
		dirty |= bin->dirty;
 44c:	f9 01       	movw	r30, r18
 44e:	e8 0f       	add	r30, r24
 450:	f9 1f       	adc	r31, r25
 452:	40 85       	ldd	r20, Z+8	; 0x08
 454:	47 95       	ror	r20
 456:	44 27       	eor	r20, r20
 458:	47 95       	ror	r20
 45a:	44 0f       	add	r20, r20
 45c:	44 0b       	sbc	r20, r20
 45e:	54 2b       	or	r21, r20
 460:	09 96       	adiw	r24, 0x09	; 9
// Send the color bins to the camera
// This will only do something if the color bins have changed
static boolean sendBins(AVRCAM* camera){
	// See if anything is dirty
	boolean dirty = FALSE;
	for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 462:	88 34       	cpi	r24, 0x48	; 72
 464:	91 05       	cpc	r25, r1
 466:	01 f4       	brne	.+0      	; 0x468 <getBlobs+0x74>
		CAMERA_BIN* bin = &camera->_camera_.bins[index];
		dirty |= bin->dirty;
	}
	if(dirty==FALSE){
 468:	55 23       	and	r21, r21
 46a:	01 f4       	brne	.+0      	; 0x46c <getBlobs+0x78>
 46c:	00 c0       	rjmp	.+0      	; 0x46e <getBlobs+0x7a>
	return byte;
}

static Writer setActive(AVRCAM* camera){
	// Set the active uart
	active = camera->_camera_.uart;
 46e:	f7 01       	movw	r30, r14
 470:	82 81       	ldd	r24, Z+2	; 0x02
 472:	93 81       	ldd	r25, Z+3	; 0x03
 474:	90 93 00 00 	sts	0x0000, r25
 478:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&sendChar);
 47c:	80 e0       	ldi	r24, 0x00	; 0
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	0e 94 00 00 	call	0	; 0x0 <xres>
 484:	9b 8f       	std	Y+27, r25	; 0x1b
 486:	8a 8f       	std	Y+26, r24	; 0x1a

	// Send rprintf output to the camera
	Writer old = setActive(camera);

	// Command for set colour maps
	rprintf("SM");
 488:	00 d0       	rcall	.+0      	; 0x48a <getBlobs+0x96>
 48a:	0f 92       	push	r0
 48c:	81 e0       	ldi	r24, 0x01	; 1
 48e:	ad b7       	in	r26, 0x3d	; 61
 490:	be b7       	in	r27, 0x3e	; 62
 492:	11 96       	adiw	r26, 0x01	; 1
 494:	8c 93       	st	X, r24
 496:	11 97       	sbiw	r26, 0x01	; 1
 498:	80 e0       	ldi	r24, 0x00	; 0
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	13 96       	adiw	r26, 0x03	; 3
 49e:	9c 93       	st	X, r25
 4a0:	8e 93       	st	-X, r24
 4a2:	12 97       	sbiw	r26, 0x02	; 2
 4a4:	0e 94 00 00 	call	0	; 0x0 <xres>
 4a8:	0f 90       	pop	r0
 4aa:	0f 90       	pop	r0
 4ac:	0f 90       	pop	r0

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
 4ae:	dd 24       	eor	r13, r13
		rprintf(" 0");							// First entry is always 0
 4b0:	00 d0       	rcall	.+0      	; 0x4b2 <getBlobs+0xbe>
 4b2:	0f 92       	push	r0
 4b4:	81 e0       	ldi	r24, 0x01	; 1
 4b6:	ed b7       	in	r30, 0x3d	; 61
 4b8:	fe b7       	in	r31, 0x3e	; 62
 4ba:	81 83       	std	Z+1, r24	; 0x01
 4bc:	80 e0       	ldi	r24, 0x00	; 0
 4be:	90 e0       	ldi	r25, 0x00	; 0
 4c0:	93 83       	std	Z+3, r25	; 0x03
 4c2:	82 83       	std	Z+2, r24	; 0x02
 4c4:	0e 94 00 00 	call	0	; 0x0 <xres>
 4c8:	0f 90       	pop	r0
 4ca:	0f 90       	pop	r0
 4cc:	0f 90       	pop	r0
 4ce:	50 e1       	ldi	r21, 0x10	; 16
 4d0:	a5 2e       	mov	r10, r21
 4d2:	b1 2c       	mov	r11, r1

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
					entry |= 1<<index;
				}											// Set bit
			}
			rprintf(" %d",entry);							// Send byte
 4d4:	33 24       	eor	r3, r3
 4d6:	33 94       	inc	r3
 4d8:	00 c0       	rjmp	.+0      	; 0x4da <getBlobs+0xe6>
			for (uint8_t index=0; index<AVRCAM_BINS; index++) {

				// Get the min and max colours
				uint8_t high,low;

				CAMERA_BIN* bin = &camera->_camera_.bins[index];
 4da:	d7 01       	movw	r26, r14
 4dc:	14 96       	adiw	r26, 0x04	; 4
 4de:	0d 91       	ld	r16, X+
 4e0:	1c 91       	ld	r17, X
 4e2:	15 97       	sbiw	r26, 0x05	; 5
 4e4:	06 0d       	add	r16, r6
 4e6:	17 1d       	adc	r17, r7
				COLOR min,max;
				COLOR_RGB* minRGB = color2rgb(&bin->min, &min);
 4e8:	c8 01       	movw	r24, r16
 4ea:	be 01       	movw	r22, r28
 4ec:	6b 5f       	subi	r22, 0xFB	; 251
 4ee:	7f 4f       	sbci	r23, 0xFF	; 255
 4f0:	0e 94 00 00 	call	0	; 0x0 <xres>
 4f4:	4c 01       	movw	r8, r24
				COLOR_RGB* maxRGB = color2rgb(&bin->max, &max);
 4f6:	c8 01       	movw	r24, r16
 4f8:	04 96       	adiw	r24, 0x04	; 4
 4fa:	be 01       	movw	r22, r28
 4fc:	6f 5f       	subi	r22, 0xFF	; 255
 4fe:	7f 4f       	sbci	r23, 0xFF	; 255
 500:	0e 94 00 00 	call	0	; 0x0 <xres>
 504:	fc 01       	movw	r30, r24

				if (color==0) {
 506:	dd 20       	and	r13, r13
 508:	01 f4       	brne	.+0      	; 0x50a <getBlobs+0x116>
					// Red
					high=maxRGB->r;
 50a:	20 81       	ld	r18, Z
					low =minRGB->r;
 50c:	f4 01       	movw	r30, r8
 50e:	80 81       	ld	r24, Z
 510:	00 c0       	rjmp	.+0      	; 0x512 <getBlobs+0x11e>
				} else if (color==1) {
 512:	81 e0       	ldi	r24, 0x01	; 1
 514:	d8 16       	cp	r13, r24
 516:	01 f4       	brne	.+0      	; 0x518 <getBlobs+0x124>
					// Green
					high=maxRGB->g;
 518:	21 81       	ldd	r18, Z+1	; 0x01
					low =minRGB->g;
 51a:	d4 01       	movw	r26, r8
 51c:	11 96       	adiw	r26, 0x01	; 1
 51e:	8c 91       	ld	r24, X
 520:	11 97       	sbiw	r26, 0x01	; 1
 522:	00 c0       	rjmp	.+0      	; 0x524 <getBlobs+0x130>
				} else if (color==2) {
					// Blue
					high=maxRGB->b;
 524:	22 81       	ldd	r18, Z+2	; 0x02
					low =minRGB->b;
 526:	f4 01       	movw	r30, r8
 528:	82 81       	ldd	r24, Z+2	; 0x02
				}

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
 52a:	90 e0       	ldi	r25, 0x00	; 0
 52c:	a8 16       	cp	r10, r24
 52e:	b9 06       	cpc	r11, r25
 530:	04 f0       	brlt	.+0      	; 0x532 <getBlobs+0x13e>
 532:	82 2f       	mov	r24, r18
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	8a 15       	cp	r24, r10
 538:	9b 05       	cpc	r25, r11
 53a:	04 f0       	brlt	.+0      	; 0x53c <getBlobs+0x148>
					entry |= 1<<index;
 53c:	81 e0       	ldi	r24, 0x01	; 1
 53e:	90 e0       	ldi	r25, 0x00	; 0
 540:	04 2c       	mov	r0, r4
 542:	00 c0       	rjmp	.+0      	; 0x544 <getBlobs+0x150>
 544:	88 0f       	add	r24, r24
 546:	99 1f       	adc	r25, r25
 548:	0a 94       	dec	r0
 54a:	02 f4       	brpl	.+0      	; 0x54c <getBlobs+0x158>
 54c:	c8 2a       	or	r12, r24
 54e:	08 94       	sec
 550:	41 1c       	adc	r4, r1
 552:	51 1c       	adc	r5, r1
 554:	89 e0       	ldi	r24, 0x09	; 9
 556:	90 e0       	ldi	r25, 0x00	; 0
 558:	68 0e       	add	r6, r24
 55a:	79 1e       	adc	r7, r25

		for(uint8_t i=1; i<16; i++) {			// Step through bits of the grid
			uint8_t entry=0;

			// Step through the color map entries
			for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 55c:	98 e4       	ldi	r25, 0x48	; 72
 55e:	69 16       	cp	r6, r25
 560:	71 04       	cpc	r7, r1
 562:	01 f0       	breq	.+0      	; 0x564 <getBlobs+0x170>
 564:	00 c0       	rjmp	.+0      	; 0x566 <getBlobs+0x172>

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
					entry |= 1<<index;
				}											// Set bit
			}
			rprintf(" %d",entry);							// Send byte
 566:	00 d0       	rcall	.+0      	; 0x568 <getBlobs+0x174>
 568:	00 d0       	rcall	.+0      	; 0x56a <getBlobs+0x176>
 56a:	0f 92       	push	r0
 56c:	ed b7       	in	r30, 0x3d	; 61
 56e:	fe b7       	in	r31, 0x3e	; 62
 570:	31 96       	adiw	r30, 0x01	; 1
 572:	ad b7       	in	r26, 0x3d	; 61
 574:	be b7       	in	r27, 0x3e	; 62
 576:	11 96       	adiw	r26, 0x01	; 1
 578:	3c 92       	st	X, r3
 57a:	80 e0       	ldi	r24, 0x00	; 0
 57c:	90 e0       	ldi	r25, 0x00	; 0
 57e:	92 83       	std	Z+2, r25	; 0x02
 580:	81 83       	std	Z+1, r24	; 0x01
 582:	c3 82       	std	Z+3, r12	; 0x03
 584:	14 82       	std	Z+4, r1	; 0x04
 586:	0e 94 00 00 	call	0	; 0x0 <xres>
 58a:	a0 e1       	ldi	r26, 0x10	; 16
 58c:	b0 e0       	ldi	r27, 0x00	; 0
 58e:	aa 0e       	add	r10, r26
 590:	bb 1e       	adc	r11, r27

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
		rprintf(" 0");							// First entry is always 0

		for(uint8_t i=1; i<16; i++) {			// Step through bits of the grid
 592:	0f 90       	pop	r0
 594:	0f 90       	pop	r0
 596:	0f 90       	pop	r0
 598:	0f 90       	pop	r0
 59a:	0f 90       	pop	r0
 59c:	b0 e0       	ldi	r27, 0x00	; 0
 59e:	ab 16       	cp	r10, r27
 5a0:	b1 e0       	ldi	r27, 0x01	; 1
 5a2:	bb 06       	cpc	r11, r27
 5a4:	01 f0       	breq	.+0      	; 0x5a6 <getBlobs+0x1b2>
					// Blue
					high=maxRGB->b;
					low =minRGB->b;
				}

				if ((low<=i*16) && (high>=i*16) ) {	// Is value between the high and low?
 5a6:	66 24       	eor	r6, r6
 5a8:	77 24       	eor	r7, r7
 5aa:	44 24       	eor	r4, r4
 5ac:	55 24       	eor	r5, r5
 5ae:	cc 24       	eor	r12, r12
 5b0:	00 c0       	rjmp	.+0      	; 0x5b2 <getBlobs+0x1be>

	// Command for set colour maps
	rprintf("SM");

	// 0=red, 1=green, 2=blue
	for(uint8_t color=0; color<3; color++) {
 5b2:	d3 94       	inc	r13
 5b4:	e3 e0       	ldi	r30, 0x03	; 3
 5b6:	de 16       	cp	r13, r30
 5b8:	01 f0       	breq	.+0      	; 0x5ba <getBlobs+0x1c6>
 5ba:	00 c0       	rjmp	.+0      	; 0x5bc <getBlobs+0x1c8>
			}
			rprintf(" %d",entry);							// Send byte
		}
	}
	// Restore rprintf destination
	rprintfInit(old);
 5bc:	8a 8d       	ldd	r24, Y+26	; 0x1a
 5be:	9b 8d       	ldd	r25, Y+27	; 0x1b
 5c0:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Send a null command
	boolean rtn = sendCmd(camera, NULL);
 5c4:	c7 01       	movw	r24, r14
 5c6:	60 e0       	ldi	r22, 0x00	; 0
 5c8:	70 e0       	ldi	r23, 0x00	; 0
 5ca:	0e 94 00 00 	call	0	; 0x0 <xres>

	// If success - then clear all dirty flags
	if(rtn){
 5ce:	88 23       	and	r24, r24
 5d0:	01 f0       	breq	.+0      	; 0x5d2 <getBlobs+0x1de>
 5d2:	80 e0       	ldi	r24, 0x00	; 0
 5d4:	90 e0       	ldi	r25, 0x00	; 0
		for (uint8_t index=0; index<AVRCAM_BINS; index++) {
			CAMERA_BIN* bin = &camera->_camera_.bins[index];
			bin->dirty = FALSE;
 5d6:	d7 01       	movw	r26, r14
 5d8:	14 96       	adiw	r26, 0x04	; 4
 5da:	ed 91       	ld	r30, X+
 5dc:	fc 91       	ld	r31, X
 5de:	15 97       	sbiw	r26, 0x05	; 5
 5e0:	e8 0f       	add	r30, r24
 5e2:	f9 1f       	adc	r31, r25
 5e4:	20 85       	ldd	r18, Z+8	; 0x08
 5e6:	2e 7f       	andi	r18, 0xFE	; 254
 5e8:	20 87       	std	Z+8, r18	; 0x08
 5ea:	09 96       	adiw	r24, 0x09	; 9
	// Send a null command
	boolean rtn = sendCmd(camera, NULL);

	// If success - then clear all dirty flags
	if(rtn){
		for (uint8_t index=0; index<AVRCAM_BINS; index++) {
 5ec:	88 34       	cpi	r24, 0x48	; 72
 5ee:	91 05       	cpc	r25, r1
 5f0:	01 f4       	brne	.+0      	; 0x5f2 <getBlobs+0x1fe>
static boolean trackStart(AVRCAM* camera) {
	if(!camera->tracking) {
		// Send any colour bin changes
		if(sendBins(camera)){
			// Now put into tracing mode
			if(sendCmd(camera, "ET")){
 5f2:	c7 01       	movw	r24, r14
 5f4:	60 e0       	ldi	r22, 0x00	; 0
 5f6:	70 e0       	ldi	r23, 0x00	; 0
 5f8:	0e 94 00 00 	call	0	; 0x0 <xres>
 5fc:	88 23       	and	r24, r24
 5fe:	01 f0       	breq	.+0      	; 0x600 <getBlobs+0x20c>
				camera->tracking = TRUE;
 600:	f7 01       	movw	r30, r14
 602:	85 85       	ldd	r24, Z+13	; 0x0d
 604:	81 60       	ori	r24, 0x01	; 1
 606:	85 87       	std	Z+13, r24	; 0x0d
			}
		}
	}
	return (camera->tracking) ? TRUE : FALSE;
 608:	d7 01       	movw	r26, r14
 60a:	1d 96       	adiw	r26, 0x0d	; 13
 60c:	8c 91       	ld	r24, X
 60e:	1d 97       	sbiw	r26, 0x0d	; 13
 610:	80 ff       	sbrs	r24, 0
 612:	00 c0       	rjmp	.+0      	; 0x614 <getBlobs+0x220>

	if(trackStart(avrcam)){
		// ok we are in tracking mode

		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
 614:	c7 01       	movw	r24, r14
 616:	02 96       	adiw	r24, 0x02	; 2
 618:	6a e0       	ldi	r22, 0x0A	; 10
 61a:	4f ef       	ldi	r20, 0xFF	; 255
 61c:	20 e0       	ldi	r18, 0x00	; 0
 61e:	30 e0       	ldi	r19, 0x00	; 0
 620:	0e 94 00 00 	call	0	; 0x0 <xres>
		if (len>0) {
 624:	00 97       	sbiw	r24, 0x00	; 0
 626:	01 f0       	breq	.+0      	; 0x628 <getBlobs+0x234>
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
 628:	d0 90 00 00 	lds	r13, 0x0000
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 62c:	10 e0       	ldi	r17, 0x00	; 0

		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
		if (len>0) {
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
 62e:	01 e0       	ldi	r16, 0x01	; 1
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 630:	00 c0       	rjmp	.+0      	; 0x632 <getBlobs+0x23e>
				CAMERA_BLOB aBlob;									// Build the blob info here

				aBlob.bin = response[ptr++];						// Get the color bin
 632:	e0 2f       	mov	r30, r16
 634:	f0 e0       	ldi	r31, 0x00	; 0
 636:	e0 50       	subi	r30, 0x00	; 0
 638:	f0 40       	sbci	r31, 0x00	; 0
 63a:	80 81       	ld	r24, Z
 63c:	89 8f       	std	Y+25, r24	; 0x19
 63e:	e0 2f       	mov	r30, r16
 640:	ef 5f       	subi	r30, 0xFF	; 255
				aBlob.left = response[ptr++];						// Get left
 642:	f0 e0       	ldi	r31, 0x00	; 0
 644:	e0 50       	subi	r30, 0x00	; 0
 646:	f0 40       	sbci	r31, 0x00	; 0
 648:	90 81       	ld	r25, Z
 64a:	99 87       	std	Y+9, r25	; 0x09
 64c:	1a 86       	std	Y+10, r1	; 0x0a
 64e:	e0 2f       	mov	r30, r16
 650:	ee 5f       	subi	r30, 0xFE	; 254
				aBlob.top  = response[ptr++];						// Get top
 652:	f0 e0       	ldi	r31, 0x00	; 0
 654:	e0 50       	subi	r30, 0x00	; 0
 656:	f0 40       	sbci	r31, 0x00	; 0
 658:	90 81       	ld	r25, Z
 65a:	9d 87       	std	Y+13, r25	; 0x0d
 65c:	1e 86       	std	Y+14, r1	; 0x0e
 65e:	e0 2f       	mov	r30, r16
 660:	ed 5f       	subi	r30, 0xFD	; 253
				aBlob.right = response[ptr++];						// Get right
 662:	f0 e0       	ldi	r31, 0x00	; 0
 664:	e0 50       	subi	r30, 0x00	; 0
 666:	f0 40       	sbci	r31, 0x00	; 0
 668:	90 81       	ld	r25, Z
 66a:	9b 87       	std	Y+11, r25	; 0x0b
 66c:	1c 86       	std	Y+12, r1	; 0x0c
 66e:	e0 2f       	mov	r30, r16
 670:	ec 5f       	subi	r30, 0xFC	; 252
				aBlob.bottom  = response[ptr++];					// Get bottom
 672:	f0 e0       	ldi	r31, 0x00	; 0
 674:	e0 50       	subi	r30, 0x00	; 0
 676:	f0 40       	sbci	r31, 0x00	; 0
 678:	90 81       	ld	r25, Z
 67a:	9f 87       	std	Y+15, r25	; 0x0f
 67c:	18 8a       	std	Y+16, r1	; 0x10
 67e:	0b 5f       	subi	r16, 0xFB	; 251

				// Ignore if it is not for the correct bin
				if(bin == CAMERA_ALL_BINS || aBlob.bin == bin){
 680:	bf ef       	ldi	r27, 0xFF	; 255
 682:	2b 16       	cp	r2, r27
 684:	01 f0       	breq	.+0      	; 0x686 <getBlobs+0x292>
 686:	82 15       	cp	r24, r2
 688:	01 f4       	brne	.+0      	; 0x68a <getBlobs+0x296>
					_cameraInsertBlob(camera,&aBlob);
 68a:	c7 01       	movw	r24, r14
 68c:	be 01       	movw	r22, r28
 68e:	67 5f       	subi	r22, 0xF7	; 247
 690:	7f 4f       	sbci	r23, 0xFF	; 255
 692:	0e 94 00 00 	call	0	; 0x0 <xres>
		// Read the next tracking line
		size_t len=getResponse(avrcam, 0x0A,0xFF,0,0);
		if (len>0) {
			uint8_t ptr=0;
			uint8_t lineBlobs = response[ptr++];					// Get the number of returned blobs
			for (uint8_t i=0; i<lineBlobs; i++) {					// Iterate through the blobs
 696:	1f 5f       	subi	r17, 0xFF	; 255
 698:	1d 15       	cp	r17, r13
 69a:	01 f4       	brne	.+0      	; 0x69c <getBlobs+0x2a8>
				}
			}
		}
	}
	// Make sure tracking is off
	trackStop(avrcam);
 69c:	c7 01       	movw	r24, r14
 69e:	0e 94 00 00 	call	0	; 0x0 <xres>
	return camera->numBlobs;
}
 6a2:	f7 01       	movw	r30, r14
 6a4:	84 85       	ldd	r24, Z+12	; 0x0c
 6a6:	6b 96       	adiw	r28, 0x1b	; 27
 6a8:	0f b6       	in	r0, 0x3f	; 63
 6aa:	f8 94       	cli
 6ac:	de bf       	out	0x3e, r29	; 62
 6ae:	0f be       	out	0x3f, r0	; 63
 6b0:	cd bf       	out	0x3d, r28	; 61
 6b2:	df 91       	pop	r29
 6b4:	cf 91       	pop	r28
 6b6:	1f 91       	pop	r17
 6b8:	0f 91       	pop	r16
 6ba:	ff 90       	pop	r15
 6bc:	ef 90       	pop	r14
 6be:	df 90       	pop	r13
 6c0:	cf 90       	pop	r12
 6c2:	bf 90       	pop	r11
 6c4:	af 90       	pop	r10
 6c6:	9f 90       	pop	r9
 6c8:	8f 90       	pop	r8
 6ca:	7f 90       	pop	r7
 6cc:	6f 90       	pop	r6
 6ce:	5f 90       	pop	r5
 6d0:	4f 90       	pop	r4
 6d2:	3f 90       	pop	r3
 6d4:	2f 90       	pop	r2
 6d6:	08 95       	ret

000006d8 <init>:
	active = camera->_camera_.uart;
	return rprintfInit(&sendChar);
}


static void init(CAMERA* camera){
 6d8:	af 92       	push	r10
 6da:	bf 92       	push	r11
 6dc:	df 92       	push	r13
 6de:	ef 92       	push	r14
 6e0:	ff 92       	push	r15
 6e2:	0f 93       	push	r16
 6e4:	1f 93       	push	r17
 6e6:	cf 93       	push	r28
 6e8:	df 93       	push	r29
 6ea:	cd b7       	in	r28, 0x3d	; 61
 6ec:	de b7       	in	r29, 0x3e	; 62
 6ee:	28 97       	sbiw	r28, 0x08	; 8
 6f0:	0f b6       	in	r0, 0x3f	; 63
 6f2:	f8 94       	cli
 6f4:	de bf       	out	0x3e, r29	; 62
 6f6:	0f be       	out	0x3f, r0	; 63
 6f8:	cd bf       	out	0x3d, r28	; 61
 6fa:	8c 01       	movw	r16, r24
	AVRCAM* avrcam = (AVRCAM*)camera;

	// set camera to 115200 baud - this is fixed by the camera
	_uartInit(avrcam->_camera_.uart, (BAUD_RATE) 115200);
 6fc:	dc 01       	movw	r26, r24
 6fe:	12 96       	adiw	r26, 0x02	; 2
 700:	8d 91       	ld	r24, X+
 702:	9c 91       	ld	r25, X
 704:	13 97       	sbiw	r26, 0x03	; 3
 706:	40 e0       	ldi	r20, 0x00	; 0
 708:	52 ec       	ldi	r21, 0xC2	; 194
 70a:	61 e0       	ldi	r22, 0x01	; 1
 70c:	70 e0       	ldi	r23, 0x00	; 0
 70e:	0e 94 00 00 	call	0	; 0x0 <xres>
	flush(avrcam);
 712:	f8 01       	movw	r30, r16
 714:	82 81       	ldd	r24, Z+2	; 0x02
 716:	93 81       	ldd	r25, Z+3	; 0x03
 718:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Make sure tracking mode is turned off
	trackStop(avrcam);
 71c:	c8 01       	movw	r24, r16
 71e:	0e 94 00 00 	call	0	; 0x0 <xres>

	// Make RAM space for the colour bins
	if(camera->bins == NULL){
 722:	d8 01       	movw	r26, r16
 724:	14 96       	adiw	r26, 0x04	; 4
 726:	8d 91       	ld	r24, X+
 728:	9c 91       	ld	r25, X
 72a:	15 97       	sbiw	r26, 0x05	; 5
 72c:	00 97       	sbiw	r24, 0x00	; 0
 72e:	01 f4       	brne	.+0      	; 0x730 <init+0x58>
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
 730:	88 e4       	ldi	r24, 0x48	; 72
 732:	90 e0       	ldi	r25, 0x00	; 0
 734:	0e 94 00 00 	call	0	; 0x0 <xres>
 738:	f8 01       	movw	r30, r16
 73a:	84 83       	std	Z+4, r24	; 0x04
 73c:	95 83       	std	Z+5, r25	; 0x05
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
 73e:	d8 01       	movw	r26, r16
 740:	14 96       	adiw	r26, 0x04	; 4
 742:	8d 91       	ld	r24, X+
 744:	9c 91       	ld	r25, X
 746:	15 97       	sbiw	r26, 0x05	; 5
 748:	00 97       	sbiw	r24, 0x00	; 0
 74a:	01 f0       	breq	.+0      	; 0x74c <init+0x74>
 74c:	aa 24       	eor	r10, r10
 74e:	bb 24       	eor	r11, r11
 750:	ff 24       	eor	r15, r15
COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
	color->bands.rgb.r = r;
 752:	74 eb       	ldi	r23, 0xB4	; 180
 754:	e7 2e       	mov	r14, r23
 756:	dd 24       	eor	r13, r13
 758:	da 94       	dec	r13
		for(uint8_t i = 0; i < AVRCAM_BINS; i++){
			CAMERA_BIN* bin = &camera->bins[i];
 75a:	d8 01       	movw	r26, r16
 75c:	14 96       	adiw	r26, 0x04	; 4
 75e:	ed 91       	ld	r30, X+
 760:	fc 91       	ld	r31, X
 762:	15 97       	sbiw	r26, 0x05	; 5
 764:	ea 0d       	add	r30, r10
 766:	fb 1d       	adc	r31, r11
			bin->active = bin->dirty = FALSE;
 768:	80 85       	ldd	r24, Z+8	; 0x08
 76a:	8c 7f       	andi	r24, 0xFC	; 252
 76c:	80 87       	std	Z+8, r24	; 0x08
			if(i==0){
 76e:	ff 20       	and	r15, r15
 770:	01 f4       	brne	.+0      	; 0x772 <init+0x9a>

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 772:	1d 82       	std	Y+5, r1	; 0x05
	color->bands.rgb.r = r;
 774:	ee 82       	std	Y+6, r14	; 0x06
	color->bands.rgb.g = g;
 776:	ef 82       	std	Y+7, r14	; 0x07
	color->bands.rgb.b = b;
 778:	e8 86       	std	Y+8, r14	; 0x08

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 77a:	19 82       	std	Y+1, r1	; 0x01
	color->bands.rgb.r = r;
 77c:	da 82       	std	Y+2, r13	; 0x02
	color->bands.rgb.g = g;
 77e:	db 82       	std	Y+3, r13	; 0x03
	color->bands.rgb.b = b;
 780:	dc 82       	std	Y+4, r13	; 0x04
				COLOR min,max;
				colorSetRGB(&min,180,180,180);
				colorSetRGB(&max,255,255,255);
				setBin(camera,i,&min,&max);
 782:	c8 01       	movw	r24, r16
 784:	60 e0       	ldi	r22, 0x00	; 0
 786:	ae 01       	movw	r20, r28
 788:	4b 5f       	subi	r20, 0xFB	; 251
 78a:	5f 4f       	sbci	r21, 0xFF	; 255
 78c:	9e 01       	movw	r18, r28
 78e:	2f 5f       	subi	r18, 0xFF	; 255
 790:	3f 4f       	sbci	r19, 0xFF	; 255
 792:	0e 94 00 00 	call	0	; 0x0 <xres>
 796:	00 c0       	rjmp	.+0      	; 0x798 <init+0xc0>

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 798:	10 82       	st	Z, r1
	color->bands.rgb.r = r;
 79a:	11 82       	std	Z+1, r1	; 0x01
	color->bands.rgb.g = g;
 79c:	12 82       	std	Z+2, r1	; 0x02
	color->bands.rgb.b = b;
 79e:	13 82       	std	Z+3, r1	; 0x03

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 7a0:	14 82       	std	Z+4, r1	; 0x04
	color->bands.rgb.r = r;
 7a2:	15 82       	std	Z+5, r1	; 0x05
	color->bands.rgb.g = g;
 7a4:	16 82       	std	Z+6, r1	; 0x06
	color->bands.rgb.b = b;
 7a6:	17 82       	std	Z+7, r1	; 0x07
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
		for(uint8_t i = 0; i < AVRCAM_BINS; i++){
 7a8:	f3 94       	inc	r15
 7aa:	e9 e0       	ldi	r30, 0x09	; 9
 7ac:	f0 e0       	ldi	r31, 0x00	; 0
 7ae:	ae 0e       	add	r10, r30
 7b0:	bf 1e       	adc	r11, r31
 7b2:	f8 e0       	ldi	r31, 0x08	; 8
 7b4:	ff 16       	cp	r15, r31
 7b6:	01 f4       	brne	.+0      	; 0x7b8 <init+0xe0>
			}
		}
	}

	// Allocate space for blobs
	if(camera->blobs == null){
 7b8:	d8 01       	movw	r26, r16
 7ba:	16 96       	adiw	r26, 0x06	; 6
 7bc:	8d 91       	ld	r24, X+
 7be:	9c 91       	ld	r25, X
 7c0:	17 97       	sbiw	r26, 0x07	; 7
 7c2:	00 97       	sbiw	r24, 0x00	; 0
 7c4:	01 f4       	brne	.+0      	; 0x7c6 <init+0xee>
		camera->blobs = malloc(AVRCAM_BLOBS * sizeof(CAMERA_BLOB));
 7c6:	88 e8       	ldi	r24, 0x88	; 136
 7c8:	90 e0       	ldi	r25, 0x00	; 0
 7ca:	0e 94 00 00 	call	0	; 0x0 <xres>
 7ce:	f8 01       	movw	r30, r16
 7d0:	86 83       	std	Z+6, r24	; 0x06
 7d2:	97 83       	std	Z+7, r25	; 0x07
	if(camera->bins == NULL){
		camera->bins = malloc(AVRCAM_BINS * sizeof(CAMERA_BIN));
	}

	// Zap all colour bins to RGB(0,0,0) except bin#0
	if(camera->bins != NULL){
 7d4:	6f e0       	ldi	r22, 0x0F	; 15
 7d6:	f6 2e       	mov	r15, r22
}

// ping the camera
// return TRUE if ok, FALSE if not
static boolean ping(AVRCAM* camera){
	return sendCmd(camera,"PG");
 7d8:	c8 01       	movw	r24, r16
 7da:	60 e0       	ldi	r22, 0x00	; 0
 7dc:	70 e0       	ldi	r23, 0x00	; 0
 7de:	0e 94 00 00 	call	0	; 0x0 <xres>
		camera->blobs = malloc(AVRCAM_BLOBS * sizeof(CAMERA_BLOB));
	}

	// Try an initial ping of the camera
	uint8_t cnt = 15;
	while(!ping(avrcam) && --cnt);
 7e2:	88 23       	and	r24, r24
 7e4:	01 f4       	brne	.+0      	; 0x7e6 <init+0x10e>
 7e6:	fa 94       	dec	r15
 7e8:	01 f4       	brne	.+0      	; 0x7ea <init+0x112>
 7ea:	00 c0       	rjmp	.+0      	; 0x7ec <init+0x114>

	if(cnt){
 7ec:	ff 20       	and	r15, r15
 7ee:	01 f0       	breq	.+0      	; 0x7f0 <init+0x118>
		// We got a reply to our ping
		delay_us(TIMEOUT);
 7f0:	60 ee       	ldi	r22, 0xE0	; 224
 7f2:	73 e9       	ldi	r23, 0x93	; 147
 7f4:	84 e0       	ldi	r24, 0x04	; 4
 7f6:	90 e0       	ldi	r25, 0x00	; 0
 7f8:	0e 94 00 00 	call	0	; 0x0 <xres>
		flush(avrcam);
 7fc:	d8 01       	movw	r26, r16
 7fe:	12 96       	adiw	r26, 0x02	; 2
 800:	8d 91       	ld	r24, X+
 802:	9c 91       	ld	r25, X
 804:	13 97       	sbiw	r26, 0x03	; 3
 806:	0e 94 00 00 	call	0	; 0x0 <xres>

		setCameraReg(avrcam,0x12,0x28);					// AGC=on, RGB mode, AWB=off
 80a:	c8 01       	movw	r24, r16
 80c:	62 e1       	ldi	r22, 0x12	; 18
 80e:	48 e2       	ldi	r20, 0x28	; 40
 810:	0e 94 00 00 	call	0	; 0x0 <xres>
//		setCameraReg(avrcam,0x12,0x2C);					// AGC=on, RGB mode, AWB=on

		setCameraReg(avrcam,0x13,0);					// Turn off auto mode adjust
 814:	c8 01       	movw	r24, r16
 816:	63 e1       	ldi	r22, 0x13	; 19
 818:	40 e0       	ldi	r20, 0x00	; 0
 81a:	0e 94 00 00 	call	0	; 0x0 <xres>
//		setCameraReg(avrcam,0x13,1);					// Turn on auto mode adjust

		setCameraReg(avrcam,0x2D,3);					// Turn off flourescent lighting filer
 81e:	c8 01       	movw	r24, r16
 820:	6d e2       	ldi	r22, 0x2D	; 45
 822:	43 e0       	ldi	r20, 0x03	; 3
 824:	0e 94 00 00 	call	0	; 0x0 <xres>

		// Update camera with our initial colour bins
//		sendBins(avrcam);
	}

}
 828:	28 96       	adiw	r28, 0x08	; 8
 82a:	0f b6       	in	r0, 0x3f	; 63
 82c:	f8 94       	cli
 82e:	de bf       	out	0x3e, r29	; 62
 830:	0f be       	out	0x3f, r0	; 63
 832:	cd bf       	out	0x3d, r28	; 61
 834:	df 91       	pop	r29
 836:	cf 91       	pop	r28
 838:	1f 91       	pop	r17
 83a:	0f 91       	pop	r16
 83c:	ff 90       	pop	r15
 83e:	ef 90       	pop	r14
 840:	df 90       	pop	r13
 842:	bf 90       	pop	r11
 844:	af 90       	pop	r10
 846:	08 95       	ret

00000848 <getPixel>:
	boolean rtn = sendCmd(avrcam, NULL);
	rprintfInit(old);
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
 848:	2f 92       	push	r2
 84a:	3f 92       	push	r3
 84c:	4f 92       	push	r4
 84e:	5f 92       	push	r5
 850:	6f 92       	push	r6
 852:	7f 92       	push	r7
 854:	8f 92       	push	r8
 856:	9f 92       	push	r9
 858:	af 92       	push	r10
 85a:	bf 92       	push	r11
 85c:	cf 92       	push	r12
 85e:	df 92       	push	r13
 860:	ef 92       	push	r14
 862:	ff 92       	push	r15
 864:	0f 93       	push	r16
 866:	1f 93       	push	r17
 868:	cf 93       	push	r28
 86a:	df 93       	push	r29
 86c:	cd b7       	in	r28, 0x3d	; 61
 86e:	de b7       	in	r29, 0x3e	; 62
 870:	63 97       	sbiw	r28, 0x13	; 19
 872:	0f b6       	in	r0, 0x3f	; 63
 874:	f8 94       	cli
 876:	de bf       	out	0x3e, r29	; 62
 878:	0f be       	out	0x3f, r0	; 63
 87a:	cd bf       	out	0x3d, r28	; 61
 87c:	9c 87       	std	Y+12, r25	; 0x0c
 87e:	8b 87       	std	Y+11, r24	; 0x0b
 880:	3e 83       	std	Y+6, r19	; 0x06
 882:	2d 83       	std	Y+5, r18	; 0x05
// A frame DUMP can take 4 seconds to transmit all of its data so very slow!
static boolean sampleRectangle(AVRCAM* avrcam, uint16_t minX, uint16_t minY, uint16_t width, uint16_t height,
		COLOR* rtnMin, COLOR *rtnMax, COLOR* rtnMean
		) {
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
 884:	76 95       	lsr	r23
 886:	67 95       	ror	r22
 888:	16 2f       	mov	r17, r22
	uint8_t rectMinY = minY / 2;
 88a:	56 95       	lsr	r21
 88c:	47 95       	ror	r20
	uint8_t rectMaxX = rectMinX + (width+1)/2;
 88e:	86 2f       	mov	r24, r22
 890:	8f 5f       	subi	r24, 0xFF	; 255
 892:	8d 87       	std	Y+13, r24	; 0x0d
	uint8_t rectMaxY = rectMinY + (height+1)/2;
 894:	94 2f       	mov	r25, r20
 896:	9f 5f       	subi	r25, 0xFF	; 255
 898:	9e 87       	std	Y+14, r25	; 0x0e
	COLOR  clrMax;
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
 89a:	8b 85       	ldd	r24, Y+11	; 0x0b
 89c:	9c 85       	ldd	r25, Y+12	; 0x0c
 89e:	60 e0       	ldi	r22, 0x00	; 0
 8a0:	70 e0       	ldi	r23, 0x00	; 0
 8a2:	49 8b       	std	Y+17, r20	; 0x11
 8a4:	0e 94 00 00 	call	0	; 0x0 <xres>
 8a8:	88 23       	and	r24, r24
 8aa:	01 f4       	brne	.+0      	; 0x8ac <getPixel+0x64>
 8ac:	00 c0       	rjmp	.+0      	; 0x8ae <getPixel+0x66>
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;

		// Takes a while for data to start
		delay_ms(1000);
 8ae:	68 ee       	ldi	r22, 0xE8	; 232
 8b0:	73 e0       	ldi	r23, 0x03	; 3
 8b2:	80 e0       	ldi	r24, 0x00	; 0
 8b4:	90 e0       	ldi	r25, 0x00	; 0
 8b6:	0e 94 00 00 	call	0	; 0x0 <xres>
 8ba:	09 e4       	ldi	r16, 0x49	; 73
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;
 8bc:	1a 86       	std	Y+10, r1	; 0x0a
 8be:	19 86       	std	Y+9, r1	; 0x09
 8c0:	18 86       	std	Y+8, r1	; 0x08
 8c2:	1f 82       	std	Y+7, r1	; 0x07
 8c4:	66 24       	eor	r6, r6
 8c6:	77 24       	eor	r7, r7
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;

	if(sendCmd(avrcam, "DF")) {
		totalRed=totalGreen=totalBlue=0;
 8c8:	22 24       	eor	r2, r2
 8ca:	33 24       	eor	r3, r3
 8cc:	21 01       	movw	r4, r2
 8ce:	88 24       	eor	r8, r8
 8d0:	99 24       	eor	r9, r9
 8d2:	54 01       	movw	r10, r8
 8d4:	cc 24       	eor	r12, r12
 8d6:	dd 24       	eor	r13, r13
 8d8:	76 01       	movw	r14, r12
	uint8_t	cnt=yres(&avrcam->_camera_) / 2;
	uint8_t rectMinX = minX / 2;
	uint8_t rectMinY = minY / 2;
	uint8_t rectMaxX = rectMinX + (width+1)/2;
	uint8_t rectMaxY = rectMinY + (height+1)/2;
	boolean first = TRUE;
 8da:	5f ef       	ldi	r21, 0xFF	; 255
	return sampleRectangle((AVRCAM*)camera, x,y,1,1,NULL,NULL,color);
}


// Create the class for the AVRcam
const CAMERA_CLASS c_avrcam = MAKE_CAMERA_CLASS( &init, &xres, &yres, AVRCAM_BINS, AVRCAM_BLOBS,&setBin, &getBlobs, &getPixel, &getVersion);
 8dc:	ab 85       	ldd	r26, Y+11	; 0x0b
 8de:	bc 85       	ldd	r27, Y+12	; 0x0c
 8e0:	12 96       	adiw	r26, 0x02	; 2
 8e2:	b8 8b       	std	Y+16, r27	; 0x10
 8e4:	af 87       	std	Y+15, r26	; 0x0f
 8e6:	49 89       	ldd	r20, Y+17	; 0x11
 8e8:	74 2f       	mov	r23, r20
 8ea:	00 c0       	rjmp	.+0      	; 0x8ec <getPixel+0xa4>

		// Takes a while for data to start
		delay_ms(1000);
		while(cnt--) {
			// NB line numbers can be sent in any order
			size_t len=getResponse(avrcam,0x0B,0x0F,2,0);
 8ec:	8f 85       	ldd	r24, Y+15	; 0x0f
 8ee:	98 89       	ldd	r25, Y+16	; 0x10
 8f0:	6b e0       	ldi	r22, 0x0B	; 11
 8f2:	4f e0       	ldi	r20, 0x0F	; 15
 8f4:	22 e0       	ldi	r18, 0x02	; 2
 8f6:	30 e0       	ldi	r19, 0x00	; 0
 8f8:	5b 8b       	std	Y+19, r21	; 0x13
 8fa:	79 8b       	std	Y+17, r23	; 0x11
 8fc:	0e 94 00 00 	call	0	; 0x0 <xres>
			uint8_t line=response[0];
 900:	20 91 00 00 	lds	r18, 0x0000
			if(len==177) {
 904:	5b 89       	ldd	r21, Y+19	; 0x13
 906:	79 89       	ldd	r23, Y+17	; 0x11
 908:	81 3b       	cpi	r24, 0xB1	; 177
 90a:	91 05       	cpc	r25, r1
 90c:	01 f0       	breq	.+0      	; 0x90e <getPixel+0xc6>
 90e:	00 c0       	rjmp	.+0      	; 0x910 <getPixel+0xc8>
				if(line>=rectMinY && line<=rectMaxY) {
 910:	27 17       	cp	r18, r23
 912:	00 f4       	brcc	.+0      	; 0x914 <getPixel+0xcc>
 914:	00 c0       	rjmp	.+0      	; 0x916 <getPixel+0xce>
 916:	be 85       	ldd	r27, Y+14	; 0x0e
 918:	b2 17       	cp	r27, r18
 91a:	00 f0       	brcs	.+0      	; 0x91c <getPixel+0xd4>
 91c:	00 c0       	rjmp	.+0      	; 0x91e <getPixel+0xd6>
 91e:	00 c0       	rjmp	.+0      	; 0x920 <getPixel+0xd8>
	boolean rtn = sendCmd(avrcam, NULL);
	rprintfInit(old);
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
 920:	ee 0f       	add	r30, r30
 922:	ef 5f       	subi	r30, 0xFF	; 255
					// The line number is in range
					// So process the required X pixels
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
						uint8_t ptr=1+i*2;
						// Get the rgb colours for the pixel
						uint8_t x1=response[ptr];
 924:	f0 e0       	ldi	r31, 0x00	; 0
 926:	e0 50       	subi	r30, 0x00	; 0
 928:	f0 40       	sbci	r31, 0x00	; 0
 92a:	30 81       	ld	r19, Z
						uint8_t x2=response[ptr+1];
 92c:	81 81       	ldd	r24, Z+1	; 0x01
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
						uint8_t gL=MIN(g1,g2);

						if(first) {
 92e:	99 23       	and	r25, r25
 930:	01 f4       	brne	.+0      	; 0x932 <getPixel+0xea>
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
						uint8_t ptr=1+i*2;
						// Get the rgb colours for the pixel
						uint8_t x1=response[ptr];
						uint8_t x2=response[ptr+1];
						uint8_t	g1=x1&0xF0;
 932:	93 2f       	mov	r25, r19
 934:	90 7f       	andi	r25, 0xF0	; 240
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
 936:	28 2f       	mov	r18, r24
 938:	20 7f       	andi	r18, 0xF0	; 240

							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
 93a:	82 95       	swap	r24
 93c:	80 7f       	andi	r24, 0xF0	; 240
 93e:	c8 0e       	add	r12, r24
 940:	d1 1c       	adc	r13, r1
 942:	e1 1c       	adc	r14, r1
 944:	f1 1c       	adc	r15, r1
 946:	08 94       	sec
 948:	61 1c       	adc	r6, r1
 94a:	71 1c       	adc	r7, r1
						uint8_t	g1=x1&0xF0;
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
						uint8_t gL=MIN(g1,g2);
 94c:	82 2f       	mov	r24, r18
 94e:	92 17       	cp	r25, r18
 950:	00 f4       	brcc	.+0      	; 0x952 <getPixel+0x10a>
 952:	89 2f       	mov	r24, r25
							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
							totalGreen += gL;
 954:	48 2f       	mov	r20, r24
 956:	50 e0       	ldi	r21, 0x00	; 0
 958:	60 e0       	ldi	r22, 0x00	; 0
 95a:	70 e0       	ldi	r23, 0x00	; 0
						uint8_t x2=response[ptr+1];
						uint8_t	g1=x1&0xF0;
						uint8_t	b=(x1&0x0F)<<4;
						uint8_t	g2=x2&0xF0;
						uint8_t	r=(x2&0x0F)<<4;
						uint8_t gH=MAX(g1,g2);
 95c:	29 17       	cp	r18, r25
 95e:	00 f4       	brcc	.+0      	; 0x960 <getPixel+0x118>
 960:	29 2f       	mov	r18, r25
							clrMax.bands.rgb.r = MAX(r ,clrMax.bands.rgb.r);
							clrMax.bands.rgb.g = MAX(gH,clrMax.bands.rgb.g);
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
							totalGreen += gL;
 962:	db 01       	movw	r26, r22
 964:	ca 01       	movw	r24, r20
 966:	82 0f       	add	r24, r18
 968:	91 1d       	adc	r25, r1
 96a:	a1 1d       	adc	r26, r1
 96c:	b1 1d       	adc	r27, r1
							totalGreen += gH; numGreen+=2;
 96e:	88 0e       	add	r8, r24
 970:	99 1e       	adc	r9, r25
 972:	aa 1e       	adc	r10, r26
 974:	bb 1e       	adc	r11, r27
 976:	ef 81       	ldd	r30, Y+7	; 0x07
 978:	f8 85       	ldd	r31, Y+8	; 0x08
 97a:	32 96       	adiw	r30, 0x02	; 2
 97c:	f8 87       	std	Y+8, r31	; 0x08
 97e:	ef 83       	std	Y+7, r30	; 0x07
							totalBlue += b; ++numBlue;
 980:	83 2f       	mov	r24, r19
 982:	82 95       	swap	r24
 984:	80 7f       	andi	r24, 0xF0	; 240
 986:	28 0e       	add	r2, r24
 988:	31 1c       	adc	r3, r1
 98a:	41 1c       	adc	r4, r1
 98c:	51 1c       	adc	r5, r1
 98e:	89 85       	ldd	r24, Y+9	; 0x09
 990:	9a 85       	ldd	r25, Y+10	; 0x0a
 992:	01 96       	adiw	r24, 0x01	; 1
 994:	9a 87       	std	Y+10, r25	; 0x0a
 996:	89 87       	std	Y+9, r24	; 0x09
 998:	a9 81       	ldd	r26, Y+1	; 0x01
 99a:	ba 81       	ldd	r27, Y+2	; 0x02
 99c:	11 96       	adiw	r26, 0x01	; 1
 99e:	ba 83       	std	Y+2, r27	; 0x02
 9a0:	a9 83       	std	Y+1, r26	; 0x01
 9a2:	90 e0       	ldi	r25, 0x00	; 0
 9a4:	00 c0       	rjmp	.+0      	; 0x9a6 <getPixel+0x15e>
		while(cnt--) {
			// NB line numbers can be sent in any order
			size_t len=getResponse(avrcam,0x0B,0x0F,2,0);
			uint8_t line=response[0];
			if(len==177) {
				if(line>=rectMinY && line<=rectMaxY) {
 9a6:	1a 82       	std	Y+2, r1	; 0x02
 9a8:	19 82       	std	Y+1, r1	; 0x01
 9aa:	7a 8b       	std	Y+18, r23	; 0x12
 9ac:	95 2f       	mov	r25, r21
							clrMax.bands.rgb.b = MAX(b ,clrMax.bands.rgb.b);

							totalRed += r; ++numRed;
							totalGreen += gL;
							totalGreen += gH; numGreen+=2;
							totalBlue += b; ++numBlue;
 9ae:	e9 81       	ldd	r30, Y+1	; 0x01
 9b0:	e1 0f       	add	r30, r17
			uint8_t line=response[0];
			if(len==177) {
				if(line>=rectMinY && line<=rectMaxY) {
					// The line number is in range
					// So process the required X pixels
					for(uint8_t i=rectMinX;i<=rectMaxX;i++) {
 9b2:	bd 85       	ldd	r27, Y+13	; 0x0d
 9b4:	be 17       	cp	r27, r30
 9b6:	00 f0       	brcs	.+0      	; 0x9b8 <getPixel+0x170>
 9b8:	00 c0       	rjmp	.+0      	; 0x9ba <getPixel+0x172>
 9ba:	7a 89       	ldd	r23, Y+18	; 0x12
 9bc:	59 2f       	mov	r21, r25
 9be:	01 50       	subi	r16, 0x01	; 1
		totalRed=totalGreen=totalBlue=0;
		numRed=numGreen=numBlue = 0;

		// Takes a while for data to start
		delay_ms(1000);
		while(cnt--) {
 9c0:	01 f0       	breq	.+0      	; 0x9c2 <getPixel+0x17a>
 9c2:	00 c0       	rjmp	.+0      	; 0x9c4 <getPixel+0x17c>
 9c4:	00 c0       	rjmp	.+0      	; 0x9c6 <getPixel+0x17e>
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
			totalRed = (numRed==0) ? 0 : totalRed / numRed;
			totalGreen = (numGreen==0) ? 0 : totalGreen / numGreen;
			totalBlue = (numBlue==0) ? 0 : totalBlue / numBlue;
 9c6:	10 e0       	ldi	r17, 0x00	; 0
 9c8:	00 c0       	rjmp	.+0      	; 0x9ca <getPixel+0x182>
		}
		if(rtnMax){
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
			totalRed = (numRed==0) ? 0 : totalRed / numRed;
 9ca:	61 14       	cp	r6, r1
 9cc:	71 04       	cpc	r7, r1
 9ce:	01 f0       	breq	.+0      	; 0x9d0 <getPixel+0x188>
 9d0:	93 01       	movw	r18, r6
 9d2:	40 e0       	ldi	r20, 0x00	; 0
 9d4:	50 e0       	ldi	r21, 0x00	; 0
 9d6:	c7 01       	movw	r24, r14
 9d8:	b6 01       	movw	r22, r12
 9da:	0e 94 00 00 	call	0	; 0x0 <xres>
 9de:	29 83       	std	Y+1, r18	; 0x01
 9e0:	3a 83       	std	Y+2, r19	; 0x02
 9e2:	4b 83       	std	Y+3, r20	; 0x03
 9e4:	5c 83       	std	Y+4, r21	; 0x04
 9e6:	00 c0       	rjmp	.+0      	; 0x9e8 <getPixel+0x1a0>
 9e8:	19 82       	std	Y+1, r1	; 0x01
 9ea:	1a 82       	std	Y+2, r1	; 0x02
 9ec:	1b 82       	std	Y+3, r1	; 0x03
 9ee:	1c 82       	std	Y+4, r1	; 0x04
			totalGreen = (numGreen==0) ? 0 : totalGreen / numGreen;
 9f0:	ef 81       	ldd	r30, Y+7	; 0x07
 9f2:	f8 85       	ldd	r31, Y+8	; 0x08
 9f4:	30 97       	sbiw	r30, 0x00	; 0
 9f6:	01 f0       	breq	.+0      	; 0x9f8 <getPixel+0x1b0>
 9f8:	9f 01       	movw	r18, r30
 9fa:	40 e0       	ldi	r20, 0x00	; 0
 9fc:	50 e0       	ldi	r21, 0x00	; 0
 9fe:	c5 01       	movw	r24, r10
 a00:	b4 01       	movw	r22, r8
 a02:	0e 94 00 00 	call	0	; 0x0 <xres>
 a06:	69 01       	movw	r12, r18
 a08:	7a 01       	movw	r14, r20
 a0a:	00 c0       	rjmp	.+0      	; 0xa0c <getPixel+0x1c4>
 a0c:	cc 24       	eor	r12, r12
 a0e:	dd 24       	eor	r13, r13
 a10:	76 01       	movw	r14, r12
			totalBlue = (numBlue==0) ? 0 : totalBlue / numBlue;
 a12:	89 85       	ldd	r24, Y+9	; 0x09
 a14:	9a 85       	ldd	r25, Y+10	; 0x0a
 a16:	00 97       	sbiw	r24, 0x00	; 0
 a18:	01 f0       	breq	.+0      	; 0xa1a <getPixel+0x1d2>
 a1a:	9c 01       	movw	r18, r24
 a1c:	40 e0       	ldi	r20, 0x00	; 0
 a1e:	50 e0       	ldi	r21, 0x00	; 0
 a20:	c2 01       	movw	r24, r4
 a22:	b1 01       	movw	r22, r2
 a24:	0e 94 00 00 	call	0	; 0x0 <xres>
 a28:	89 01       	movw	r16, r18
 a2a:	9a 01       	movw	r18, r20
 a2c:	00 c0       	rjmp	.+0      	; 0xa2e <getPixel+0x1e6>
 a2e:	00 e0       	ldi	r16, 0x00	; 0
 a30:	10 e0       	ldi	r17, 0x00	; 0
 a32:	20 e0       	ldi	r18, 0x00	; 0
 a34:	30 e0       	ldi	r19, 0x00	; 0

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 a36:	ad 81       	ldd	r26, Y+5	; 0x05
 a38:	be 81       	ldd	r27, Y+6	; 0x06
 a3a:	1c 92       	st	X, r1
			colorSetRGB(rtnMean, (uint8_t)totalRed, (uint8_t)totalGreen, (uint8_t)totalBlue);
 a3c:	e9 81       	ldd	r30, Y+1	; 0x01
 a3e:	11 96       	adiw	r26, 0x01	; 1
 a40:	ec 93       	st	X, r30
 a42:	11 97       	sbiw	r26, 0x01	; 1
 a44:	12 96       	adiw	r26, 0x02	; 2
 a46:	cc 92       	st	X, r12
 a48:	12 97       	sbiw	r26, 0x02	; 2
 a4a:	13 96       	adiw	r26, 0x03	; 3
 a4c:	0c 93       	st	X, r16
	boolean first = TRUE;
	COLOR  clrMin;
	COLOR  clrMax;
	uint32_t totalRed,totalGreen,totalBlue;
	uint16_t numRed,numGreen,numBlue;
	boolean rtn = TRUE;
 a4e:	1f ef       	ldi	r17, 0xFF	; 255
			colorSetRGB(rtnMean, (uint8_t)totalRed, (uint8_t)totalGreen, (uint8_t)totalBlue);
		}
	}

	// Flush out anything left over
	flush(avrcam);
 a50:	ab 85       	ldd	r26, Y+11	; 0x0b
 a52:	bc 85       	ldd	r27, Y+12	; 0x0c
 a54:	12 96       	adiw	r26, 0x02	; 2
 a56:	8d 91       	ld	r24, X+
 a58:	9c 91       	ld	r25, X
 a5a:	13 97       	sbiw	r26, 0x03	; 3
 a5c:	0e 94 00 00 	call	0	; 0x0 <xres>
	return rtn;
}

static boolean getPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
	return sampleRectangle((AVRCAM*)camera, x,y,1,1,NULL,NULL,color);
}
 a60:	81 2f       	mov	r24, r17
 a62:	63 96       	adiw	r28, 0x13	; 19
 a64:	0f b6       	in	r0, 0x3f	; 63
 a66:	f8 94       	cli
 a68:	de bf       	out	0x3e, r29	; 62
 a6a:	0f be       	out	0x3f, r0	; 63
 a6c:	cd bf       	out	0x3d, r28	; 61
 a6e:	df 91       	pop	r29
 a70:	cf 91       	pop	r28
 a72:	1f 91       	pop	r17
 a74:	0f 91       	pop	r16
 a76:	ff 90       	pop	r15
 a78:	ef 90       	pop	r14
 a7a:	df 90       	pop	r13
 a7c:	cf 90       	pop	r12
 a7e:	bf 90       	pop	r11
 a80:	af 90       	pop	r10
 a82:	9f 90       	pop	r9
 a84:	8f 90       	pop	r8
 a86:	7f 90       	pop	r7
 a88:	6f 90       	pop	r6
 a8a:	5f 90       	pop	r5
 a8c:	4f 90       	pop	r4
 a8e:	3f 90       	pop	r3
 a90:	2f 90       	pop	r2
 a92:	08 95       	ret
			colorSetRGB(rtnMin,clrMin.bands.rgb.r,clrMin.bands.rgb.g,clrMin.bands.rgb.b);
		}
		if(rtnMax){
			colorSetRGB(rtnMax,clrMax.bands.rgb.r,clrMax.bands.rgb.g,clrMax.bands.rgb.b);
		}
		if(rtnMean){
 a94:	ed 81       	ldd	r30, Y+5	; 0x05
 a96:	fe 81       	ldd	r31, Y+6	; 0x06
 a98:	30 97       	sbiw	r30, 0x00	; 0
 a9a:	01 f0       	breq	.+0      	; 0xa9c <getPixel+0x254>
 a9c:	00 c0       	rjmp	.+0      	; 0xa9e <getPixel+0x256>
 a9e:	00 c0       	rjmp	.+0      	; 0xaa0 <getPixel+0x258>

blackfin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000448  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000047c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000001c  00000000  00000000  0000047c  2**0
                  ALLOC
  3 .progmem.data 00000014  00000000  00000000  0000047c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000c8f  00000000  00000000  00000490  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002a6  00000000  00000000  0000111f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000879  00000000  00000000  000013c5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001c3e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   000001e5  00000000  00000000  00001c5e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000682  00000000  00000000  00001e43  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000178  00000000  00000000  000024c8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_blackfin_putcmd>:



// rprintf destination to write to the command string
MAKE_WRITER(_blackfin_putcmd){
	_blackfin_command[_blackfin_index] = byte;
   0:	20 91 00 00 	lds	r18, 0x0000
   4:	30 91 00 00 	lds	r19, 0x0000
   8:	f9 01       	movw	r30, r18
   a:	e0 50       	subi	r30, 0x00	; 0
   c:	f0 40       	sbci	r31, 0x00	; 0
   e:	80 83       	st	Z, r24
	if(byte!='\0' && _blackfin_index < MAX_COMMAND){
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <_blackfin_putcmd+0x14>
  14:	29 31       	cpi	r18, 0x19	; 25
  16:	31 05       	cpc	r19, r1
  18:	00 f4       	brcc	.+0      	; 0x1a <_blackfin_putcmd+0x1a>
		_blackfin_index++;
  1a:	2f 5f       	subi	r18, 0xFF	; 255
  1c:	3f 4f       	sbci	r19, 0xFF	; 255
  1e:	30 93 00 00 	sts	0x0000, r19
  22:	20 93 00 00 	sts	0x0000, r18
	}
	_blackfin_command[_blackfin_index] = '\0';
  26:	e0 91 00 00 	lds	r30, 0x0000
  2a:	f0 91 00 00 	lds	r31, 0x0000
  2e:	e0 50       	subi	r30, 0x00	; 0
  30:	f0 40       	sbci	r31, 0x00	; 0
  32:	10 82       	st	Z, r1
	return byte;
}
  34:	08 95       	ret

00000036 <_blackfin_putchar>:

// Output a character to the Blackfin camera UART
MAKE_WRITER(_blackfin_putchar){
  36:	cf 93       	push	r28
  38:	c8 2f       	mov	r28, r24
	if(_blackfin_uart != null){
  3a:	20 91 00 00 	lds	r18, 0x0000
  3e:	30 91 00 00 	lds	r19, 0x0000
  42:	21 15       	cp	r18, r1
  44:	31 05       	cpc	r19, r1
  46:	01 f0       	breq	.+0      	; 0x48 <_blackfin_putchar+0x12>
		_uartSendByte(_blackfin_uart, byte);
  48:	c9 01       	movw	r24, r18
  4a:	6c 2f       	mov	r22, r28
  4c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	}
	return byte;
}
  50:	8c 2f       	mov	r24, r28
  52:	cf 91       	pop	r28
  54:	08 95       	ret

00000056 <_blackfin_set_active>:

// Set the active uart for rprintf to go to the Blackfin
Writer _blackfin_set_active(UART* uart){
	_blackfin_uart = uart;
  56:	90 93 00 00 	sts	0x0000, r25
  5a:	80 93 00 00 	sts	0x0000, r24
	return rprintfInit(&_blackfin_putchar);
  5e:	80 e0       	ldi	r24, 0x00	; 0
  60:	90 e0       	ldi	r25, 0x00	; 0
  62:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
}
  66:	08 95       	ret

00000068 <__blackfin_get_args>:


int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
  68:	af 92       	push	r10
  6a:	bf 92       	push	r11
  6c:	cf 92       	push	r12
  6e:	df 92       	push	r13
  70:	ef 92       	push	r14
  72:	ff 92       	push	r15
  74:	0f 93       	push	r16
  76:	1f 93       	push	r17
  78:	cf 93       	push	r28
  7a:	df 93       	push	r29
  7c:	6c 01       	movw	r12, r24
	int received=0;
  7e:	8b 01       	movw	r16, r22
	_blackfin_uart = uart;
	return rprintfInit(&_blackfin_putchar);
}


int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
  80:	5a 01       	movw	r10, r20
	int received=0;
	int args = 0;
  82:	ee 24       	eor	r14, r14
  84:	ff 24       	eor	r15, r15
	return rprintfInit(&_blackfin_putchar);
}


int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
	int received=0;
  86:	20 e0       	ldi	r18, 0x00	; 0
  88:	30 e0       	ldi	r19, 0x00	; 0
	int args = 0;
	char c;

	while(numValues>0 && received!='\n'){
  8a:	00 c0       	rjmp	.+0      	; 0x8c <__blackfin_get_args+0x24>
		boolean negative = FALSE;

		// Blank next value
		values[args] = 0;
  8c:	f8 01       	movw	r30, r16
  8e:	10 82       	st	Z, r1
  90:	11 82       	std	Z+1, r1	; 0x01
  92:	12 82       	std	Z+2, r1	; 0x02
  94:	13 82       	std	Z+3, r1	; 0x03
  96:	00 c0       	rjmp	.+0      	; 0x98 <__blackfin_get_args+0x30>
				if(trace){
					rprintfChar(c);
				}
#endif
				if( c=='-'){
					negative = (negative==FALSE) ? TRUE : FALSE;
  98:	cf ef       	ldi	r28, 0xFF	; 255
		// Blank next value
		values[args] = 0;

		// Get a character and ignore anything not a digit or newline
		while(1){
			received = __uartGetByte(camera->camera);
  9a:	f6 01       	movw	r30, r12
  9c:	80 81       	ld	r24, Z
  9e:	91 81       	ldd	r25, Z+1	; 0x01
  a0:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
  a4:	9c 01       	movw	r18, r24
			if(received!=-1){
  a6:	ff ef       	ldi	r31, 0xFF	; 255
  a8:	8f 3f       	cpi	r24, 0xFF	; 255
  aa:	9f 07       	cpc	r25, r31
  ac:	01 f0       	breq	.+0      	; 0xae <__blackfin_get_args+0x46>
#ifdef BLACKFIN_DEBUG
				if(trace){
					rprintfChar(c);
				}
#endif
				if( c=='-'){
  ae:	8d 32       	cpi	r24, 0x2D	; 45
  b0:	01 f4       	brne	.+0      	; 0xb2 <__blackfin_get_args+0x4a>
					negative = (negative==FALSE) ? TRUE : FALSE;
  b2:	cc 23       	and	r28, r28
  b4:	01 f0       	breq	.+0      	; 0xb6 <__blackfin_get_args+0x4e>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <__blackfin_get_args+0x50>
					continue;
				}
				if( (c>='0' && c<='9') || c=='\n'){
  b8:	98 2f       	mov	r25, r24
  ba:	90 53       	subi	r25, 0x30	; 48
  bc:	9a 30       	cpi	r25, 0x0A	; 10
  be:	00 f4       	brcc	.+0      	; 0xc0 <__blackfin_get_args+0x58>
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <__blackfin_get_args+0x5a>
  c2:	8a 30       	cpi	r24, 0x0A	; 10
  c4:	01 f4       	brne	.+0      	; 0xc6 <__blackfin_get_args+0x5e>
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <__blackfin_get_args+0x60>
					break;
				}
				negative = FALSE;
  c8:	c0 e0       	ldi	r28, 0x00	; 0
  ca:	00 c0       	rjmp	.+0      	; 0xcc <__blackfin_get_args+0x64>
		}

		// Now get the number
		for(;received!='\n';){
			if(received!=-1){
				char c = received;
  cc:	d2 2f       	mov	r29, r18
				if(c>='0' && c<='9'){
  ce:	82 2f       	mov	r24, r18
  d0:	80 53       	subi	r24, 0x30	; 48
  d2:	8a 30       	cpi	r24, 0x0A	; 10
  d4:	00 f4       	brcc	.+0      	; 0xd6 <__blackfin_get_args+0x6e>
					values[args] *= 10;
  d6:	f8 01       	movw	r30, r16
  d8:	60 81       	ld	r22, Z
  da:	71 81       	ldd	r23, Z+1	; 0x01
  dc:	82 81       	ldd	r24, Z+2	; 0x02
  de:	93 81       	ldd	r25, Z+3	; 0x03
  e0:	2a e0       	ldi	r18, 0x0A	; 10
  e2:	30 e0       	ldi	r19, 0x00	; 0
  e4:	40 e0       	ldi	r20, 0x00	; 0
  e6:	50 e0       	ldi	r21, 0x00	; 0
  e8:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
  ec:	ab 01       	movw	r20, r22
  ee:	bc 01       	movw	r22, r24
					values[args] += (c - '0');
  f0:	8d 2f       	mov	r24, r29
  f2:	90 e0       	ldi	r25, 0x00	; 0
  f4:	c0 97       	sbiw	r24, 0x30	; 48
  f6:	aa 27       	eor	r26, r26
  f8:	97 fd       	sbrc	r25, 7
  fa:	a0 95       	com	r26
  fc:	ba 2f       	mov	r27, r26
  fe:	48 0f       	add	r20, r24
 100:	59 1f       	adc	r21, r25
 102:	6a 1f       	adc	r22, r26
 104:	7b 1f       	adc	r23, r27
 106:	f8 01       	movw	r30, r16
 108:	40 83       	st	Z, r20
 10a:	51 83       	std	Z+1, r21	; 0x01
 10c:	62 83       	std	Z+2, r22	; 0x02
 10e:	73 83       	std	Z+3, r23	; 0x03
					// get next character
					while(1){
						received = __uartGetByte(camera->camera);
 110:	f6 01       	movw	r30, r12
 112:	80 81       	ld	r24, Z
 114:	91 81       	ldd	r25, Z+1	; 0x01
 116:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 11a:	9c 01       	movw	r18, r24
						if(received!=-1){
 11c:	ff ef       	ldi	r31, 0xFF	; 255
 11e:	8f 3f       	cpi	r24, 0xFF	; 255
 120:	9f 07       	cpc	r25, r31
 122:	01 f0       	breq	.+0      	; 0x124 <__blackfin_get_args+0xbc>
#ifdef BLACKFIN_DEBUG
							if(trace){
								rprintfChar(c);
							}
#endif
							if(c!='\r'){
 124:	8d 30       	cpi	r24, 0x0D	; 13
 126:	01 f4       	brne	.+0      	; 0x128 <__blackfin_get_args+0xc0>
 128:	00 c0       	rjmp	.+0      	; 0x12a <__blackfin_get_args+0xc2>
								break;
							}
						}
					}
				}else{
					if(negative){
 12a:	cc 23       	and	r28, r28
 12c:	01 f0       	breq	.+0      	; 0x12e <__blackfin_get_args+0xc6>
						values[args] *= -1;
 12e:	f8 01       	movw	r30, r16
 130:	80 81       	ld	r24, Z
 132:	91 81       	ldd	r25, Z+1	; 0x01
 134:	a2 81       	ldd	r26, Z+2	; 0x02
 136:	b3 81       	ldd	r27, Z+3	; 0x03
 138:	b0 95       	com	r27
 13a:	a0 95       	com	r26
 13c:	90 95       	com	r25
 13e:	81 95       	neg	r24
 140:	9f 4f       	sbci	r25, 0xFF	; 255
 142:	af 4f       	sbci	r26, 0xFF	; 255
 144:	bf 4f       	sbci	r27, 0xFF	; 255
 146:	80 83       	st	Z, r24
 148:	91 83       	std	Z+1, r25	; 0x01
 14a:	a2 83       	std	Z+2, r26	; 0x02
 14c:	b3 83       	std	Z+3, r27	; 0x03
 14e:	00 c0       	rjmp	.+0      	; 0x150 <__blackfin_get_args+0xe8>
				negative = FALSE;
			}
		}

		// Now get the number
		for(;received!='\n';){
 150:	2a 30       	cpi	r18, 0x0A	; 10
 152:	31 05       	cpc	r19, r1
 154:	01 f0       	breq	.+0      	; 0x156 <__blackfin_get_args+0xee>
 156:	00 c0       	rjmp	.+0      	; 0x158 <__blackfin_get_args+0xf0>
					}
					break; // no longer a digit so exit for loop
				}
			}
		}
		args++;
 158:	08 94       	sec
 15a:	e1 1c       	adc	r14, r1
 15c:	f1 1c       	adc	r15, r1
 15e:	0c 5f       	subi	r16, 0xFC	; 252
 160:	1f 4f       	sbci	r17, 0xFF	; 255
int __blackfin_get_args(const BLACKFIN_CAMERA* camera, int32_t * values, size_t numValues, boolean trace){
	int received=0;
	int args = 0;
	char c;

	while(numValues>0 && received!='\n'){
 162:	ea 14       	cp	r14, r10
 164:	fb 04       	cpc	r15, r11
 166:	01 f0       	breq	.+0      	; 0x168 <__blackfin_get_args+0x100>
 168:	2a 30       	cpi	r18, 0x0A	; 10
 16a:	31 05       	cpc	r19, r1
 16c:	01 f0       	breq	.+0      	; 0x16e <__blackfin_get_args+0x106>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <__blackfin_get_args+0x108>
		}
		args++;
		numValues--;
	}
	return args;
}
 170:	c7 01       	movw	r24, r14
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	1f 91       	pop	r17
 178:	0f 91       	pop	r16
 17a:	ff 90       	pop	r15
 17c:	ef 90       	pop	r14
 17e:	df 90       	pop	r13
 180:	cf 90       	pop	r12
 182:	bf 90       	pop	r11
 184:	af 90       	pop	r10
 186:	08 95       	ret

00000188 <__blackfinCommand>:
// error - The potential error msg or null if there isn't one
// values - Where to return the arguments
// numValues - The maximum number of arguments to return
// Returns the number of arguments found or -1 if there is an error

int __blackfinCommand(const BLACKFIN_CAMERA* camera, const char* response, const char* error, int32_t * values, size_t numValues){
 188:	2f 92       	push	r2
 18a:	3f 92       	push	r3
 18c:	4f 92       	push	r4
 18e:	5f 92       	push	r5
 190:	6f 92       	push	r6
 192:	7f 92       	push	r7
 194:	8f 92       	push	r8
 196:	9f 92       	push	r9
 198:	af 92       	push	r10
 19a:	bf 92       	push	r11
 19c:	cf 92       	push	r12
 19e:	df 92       	push	r13
 1a0:	ef 92       	push	r14
 1a2:	ff 92       	push	r15
 1a4:	0f 93       	push	r16
 1a6:	1f 93       	push	r17
 1a8:	cf 93       	push	r28
 1aa:	df 93       	push	r29
 1ac:	00 d0       	rcall	.+0      	; 0x1ae <__blackfinCommand+0x26>
 1ae:	00 d0       	rcall	.+0      	; 0x1b0 <__blackfinCommand+0x28>
 1b0:	cd b7       	in	r28, 0x3d	; 61
 1b2:	de b7       	in	r29, 0x3e	; 62
 1b4:	6c 01       	movw	r12, r24
 1b6:	1b 01       	movw	r2, r22
 1b8:	5a 01       	movw	r10, r20
 1ba:	3a 83       	std	Y+2, r19	; 0x02
 1bc:	29 83       	std	Y+1, r18	; 0x01
 1be:	28 01       	movw	r4, r16
	const char* msg=null;
//	char first = pgm_read_byte(&response[0]);


	// Terminate the command string
	_blackfin_putcmd('\0');
 1c0:	80 e0       	ldi	r24, 0x00	; 0
 1c2:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 1c6:	8a e0       	ldi	r24, 0x0A	; 10
 1c8:	88 2e       	mov	r8, r24
 1ca:	91 2c       	mov	r9, r1
	uint16_t noDataCounter;
	int counter;
	int attempt=0;
	int args = 0;
	char c;
	const char* msg=null;
 1cc:	ee 24       	eor	r14, r14
 1ce:	ff 24       	eor	r15, r15
			counter = 0;
		}

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
 1d0:	f1 01       	movw	r30, r2
 1d2:	74 90       	lpm	r7, Z
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
				if(c == pgm_read_byte(error)){
 1d4:	f5 01       	movw	r30, r10
 1d6:	64 90       	lpm	r6, Z
	// Wait for transmission to end
	while(__uartIsBusy(camera->debug));
#endif

	// Start using the queue
	__uartFlushReceiveBuffer(camera->camera);
 1d8:	f6 01       	movw	r30, r12
 1da:	80 81       	ld	r24, Z
 1dc:	91 81       	ldd	r25, Z+1	; 0x01
 1de:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 1e2:	00 e0       	ldi	r16, 0x00	; 0
 1e4:	10 e0       	ldi	r17, 0x00	; 0

	// Send the command to the camera
	char* str = _blackfin_command;
	while (*str)
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <__blackfinCommand+0x60>
		_uartSendByte(camera->camera, *str++);
 1e8:	f6 01       	movw	r30, r12
 1ea:	80 81       	ld	r24, Z
 1ec:	91 81       	ldd	r25, Z+1	; 0x01
 1ee:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	// Start using the queue
	__uartFlushReceiveBuffer(camera->camera);

	// Send the command to the camera
	char* str = _blackfin_command;
	while (*str)
 1f2:	f8 01       	movw	r30, r16
 1f4:	61 91       	ld	r22, Z+
 1f6:	8f 01       	movw	r16, r30
 1f8:	66 23       	and	r22, r22
 1fa:	01 f4       	brne	.+0      	; 0x1fc <__blackfinCommand+0x74>
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <__blackfinCommand+0x76>

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
				// Its the start of a response
				msg = response;
 1fe:	71 01       	movw	r14, r2
 200:	00 c0       	rjmp	.+0      	; 0x202 <__blackfinCommand+0x7a>
				goto getNext;
			}
			if(error){
				if(c == pgm_read_byte(error)){
 202:	75 01       	movw	r14, r10
 204:	40 e0       	ldi	r20, 0x00	; 0
 206:	50 e0       	ldi	r21, 0x00	; 0
		_uartSendByte(camera->camera, *str++);
	goto listen;


getNext:
	counter++;
 208:	4f 5f       	subi	r20, 0xFF	; 255
 20a:	5f 4f       	sbci	r21, 0xFF	; 255
	if(pgm_read_byte(&msg[counter]) == '\0'){
 20c:	f7 01       	movw	r30, r14
 20e:	e4 0f       	add	r30, r20
 210:	f5 1f       	adc	r31, r21
 212:	e4 91       	lpm	r30, Z
 214:	ee 23       	and	r30, r30
 216:	01 f4       	brne	.+0      	; 0x218 <__blackfinCommand+0x90>
 218:	00 c0       	rjmp	.+0      	; 0x21a <__blackfinCommand+0x92>
			if(c == pgm_read_byte(response)){
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
 21a:	40 e0       	ldi	r20, 0x00	; 0
 21c:	50 e0       	ldi	r21, 0x00	; 0
	// Now listen for the response
listen:
	received = __uartGetByte(camera->camera);
	if(received != -1){
		// Got a character
		noDataCounter = 0;	// we have received a byte
 21e:	00 e0       	ldi	r16, 0x00	; 0
 220:	10 e0       	ldi	r17, 0x00	; 0
		goto gotCmd;
	}

	// Now listen for the response
listen:
	received = __uartGetByte(camera->camera);
 222:	f6 01       	movw	r30, r12
 224:	80 81       	ld	r24, Z
 226:	91 81       	ldd	r25, Z+1	; 0x01
 228:	4b 83       	std	Y+3, r20	; 0x03
 22a:	5c 83       	std	Y+4, r21	; 0x04
 22c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	if(received != -1){
 230:	4b 81       	ldd	r20, Y+3	; 0x03
 232:	5c 81       	ldd	r21, Y+4	; 0x04
 234:	ff ef       	ldi	r31, 0xFF	; 255
 236:	8f 3f       	cpi	r24, 0xFF	; 255
 238:	9f 07       	cpc	r25, r31
 23a:	01 f0       	breq	.+0      	; 0x23c <__blackfinCommand+0xb4>
		// Got a character
		noDataCounter = 0;	// we have received a byte

		// Ignore carriage returns
		if(received=='\r'){
 23c:	8d 30       	cpi	r24, 0x0D	; 13
 23e:	91 05       	cpc	r25, r1
 240:	01 f0       	breq	.+0      	; 0x242 <__blackfinCommand+0xba>
		// Echo to debugger
		rprintfChar(received);
#endif

		// Translate to a character
		c = (received=='\n') ? '\0' : (char)received;
 242:	8a 30       	cpi	r24, 0x0A	; 10
 244:	91 05       	cpc	r25, r1
 246:	01 f4       	brne	.+0      	; 0x248 <__blackfinCommand+0xc0>
 248:	80 e0       	ldi	r24, 0x00	; 0

		// If its not the character we expected then start from beginning again
		if(counter != 0 && c != pgm_read_byte(&msg[counter])){
 24a:	41 15       	cp	r20, r1
 24c:	51 05       	cpc	r21, r1
 24e:	01 f0       	breq	.+0      	; 0x250 <__blackfinCommand+0xc8>
 250:	f7 01       	movw	r30, r14
 252:	e4 0f       	add	r30, r20
 254:	f5 1f       	adc	r31, r21
 256:	e4 91       	lpm	r30, Z
 258:	8e 17       	cp	r24, r30
 25a:	01 f0       	breq	.+0      	; 0x25c <__blackfinCommand+0xd4>
			counter = 0;
		}

		if(counter==0){
			// Check for start of a response or the start of an error msg
			if(c == pgm_read_byte(response)){
 25c:	87 15       	cp	r24, r7
 25e:	01 f0       	breq	.+0      	; 0x260 <__blackfinCommand+0xd8>
				// Its the start of a response
				msg = response;
				goto getNext;
			}
			if(error){
 260:	a1 14       	cp	r10, r1
 262:	b1 04       	cpc	r11, r1
 264:	01 f0       	breq	.+0      	; 0x266 <__blackfinCommand+0xde>
				if(c == pgm_read_byte(error)){
 266:	86 15       	cp	r24, r6
 268:	01 f4       	brne	.+0      	; 0x26a <__blackfinCommand+0xe2>
 26a:	00 c0       	rjmp	.+0      	; 0x26c <__blackfinCommand+0xe4>
	}else{

		// No character available

		// No data received yet - so increment loop count
		if(counter==0 && ++noDataCounter >= MAX_RETRIES){
 26c:	41 15       	cp	r20, r1
 26e:	51 05       	cpc	r21, r1
 270:	01 f4       	brne	.+0      	; 0x272 <__blackfinCommand+0xea>
 272:	0f 5f       	subi	r16, 0xFF	; 255
 274:	1f 4f       	sbci	r17, 0xFF	; 255
 276:	2d ef       	ldi	r18, 0xFD	; 253
 278:	08 3e       	cpi	r16, 0xE8	; 232
 27a:	12 07       	cpc	r17, r18
 27c:	00 f0       	brcs	.+0      	; 0x27e <__blackfinCommand+0xf6>
 27e:	08 94       	sec
 280:	81 08       	sbc	r8, r1
 282:	91 08       	sbc	r9, r1

			// Resend the command 10 timers
			if(++attempt < 10){
 284:	81 14       	cp	r8, r1
 286:	91 04       	cpc	r9, r1
 288:	01 f0       	breq	.+0      	; 0x28a <__blackfinCommand+0x102>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <__blackfinCommand+0x104>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <__blackfinCommand+0x106>
		goto listen;
	}

	// We have received the command
gotCmd:
	if(msg==error){
 28e:	ea 14       	cp	r14, r10
 290:	fb 04       	cpc	r15, r11
 292:	01 f0       	breq	.+0      	; 0x294 <__blackfinCommand+0x10c>
		rprintf("Recognised Error:");rprintfProgStr(error);rprintfCRLF();
#endif
		args = -1;
		goto exit;
	}
	args = __blackfin_get_args(camera, values, numValues, FALSE);
 294:	c6 01       	movw	r24, r12
 296:	69 81       	ldd	r22, Y+1	; 0x01
 298:	7a 81       	ldd	r23, Y+2	; 0x02
 29a:	a2 01       	movw	r20, r4
 29c:	20 e0       	ldi	r18, 0x00	; 0
 29e:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <__blackfinCommand+0x11c>
gotCmd:
	if(msg==error){
#ifdef BLACKFIN_DEBUG
		rprintf("Recognised Error:");rprintfProgStr(error);rprintfCRLF();
#endif
		args = -1;
 2a4:	8f ef       	ldi	r24, 0xFF	; 255
 2a6:	9f ef       	ldi	r25, 0xFF	; 255
#ifdef BLACKFIN_DEBUG
	// Restore rprintf to original position
	rprintfInit(old);
#endif
	return args;
}
 2a8:	0f 90       	pop	r0
 2aa:	0f 90       	pop	r0
 2ac:	0f 90       	pop	r0
 2ae:	0f 90       	pop	r0
 2b0:	df 91       	pop	r29
 2b2:	cf 91       	pop	r28
 2b4:	1f 91       	pop	r17
 2b6:	0f 91       	pop	r16
 2b8:	ff 90       	pop	r15
 2ba:	ef 90       	pop	r14
 2bc:	df 90       	pop	r13
 2be:	cf 90       	pop	r12
 2c0:	bf 90       	pop	r11
 2c2:	af 90       	pop	r10
 2c4:	9f 90       	pop	r9
 2c6:	8f 90       	pop	r8
 2c8:	7f 90       	pop	r7
 2ca:	6f 90       	pop	r6
 2cc:	5f 90       	pop	r5
 2ce:	4f 90       	pop	r4
 2d0:	3f 90       	pop	r3
 2d2:	2f 90       	pop	r2
 2d4:	08 95       	ret

000002d6 <blackfinSetResolution>:


void blackfinSetResolution(BLACKFIN_CAMERA* camera, BLACKFIN_RESOLUTION res){
 2d6:	ef 92       	push	r14
 2d8:	ff 92       	push	r15
 2da:	0f 93       	push	r16
 2dc:	1f 93       	push	r17
 2de:	cf 93       	push	r28
 2e0:	df 93       	push	r29
 2e2:	0f 92       	push	r0
 2e4:	cd b7       	in	r28, 0x3d	; 61
 2e6:	de b7       	in	r29, 0x3e	; 62
 2e8:	8c 01       	movw	r16, r24
	const char* response;

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
 2ea:	80 e0       	ldi	r24, 0x00	; 0
 2ec:	90 e0       	ldi	r25, 0x00	; 0
 2ee:	69 83       	std	Y+1, r22	; 0x01
 2f0:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 2f4:	7c 01       	movw	r14, r24
	_blackfin_index=0;
 2f6:	10 92 00 00 	sts	0x0000, r1
 2fa:	10 92 00 00 	sts	0x0000, r1


	// Remember the current resolution
	camera->res = res;
 2fe:	69 81       	ldd	r22, Y+1	; 0x01
 300:	f8 01       	movw	r30, r16
 302:	62 83       	std	Z+2, r22	; 0x02

	switch(res){
 304:	62 30       	cpi	r22, 0x02	; 2
 306:	01 f0       	breq	.+0      	; 0x308 <blackfinSetResolution+0x32>
 308:	63 30       	cpi	r22, 0x03	; 3
 30a:	01 f0       	breq	.+0      	; 0x30c <blackfinSetResolution+0x36>
 30c:	61 30       	cpi	r22, 0x01	; 1
 30e:	01 f4       	brne	.+0      	; 0x310 <blackfinSetResolution+0x3a>
 310:	00 c0       	rjmp	.+0      	; 0x312 <blackfinSetResolution+0x3c>
	case BLACKFIN_1280_BY_1024:
		rprintf("A");
 312:	00 d0       	rcall	.+0      	; 0x314 <blackfinSetResolution+0x3e>
 314:	0f 92       	push	r0
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	ed b7       	in	r30, 0x3d	; 61
 31a:	fe b7       	in	r31, 0x3e	; 62
 31c:	81 83       	std	Z+1, r24	; 0x01
 31e:	80 e0       	ldi	r24, 0x00	; 0
 320:	90 e0       	ldi	r25, 0x00	; 0
 322:	93 83       	std	Z+3, r25	; 0x03
 324:	82 83       	std	Z+2, r24	; 0x02
 326:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#A");
		break;
 32a:	0f 90       	pop	r0
 32c:	0f 90       	pop	r0
 32e:	0f 90       	pop	r0
	camera->res = res;

	switch(res){
	case BLACKFIN_1280_BY_1024:
		rprintf("A");
		response = PSTR("#A");
 330:	60 e0       	ldi	r22, 0x00	; 0
 332:	70 e0       	ldi	r23, 0x00	; 0
		break;
 334:	00 c0       	rjmp	.+0      	; 0x336 <blackfinSetResolution+0x60>
	case BLACKFIN_320_BY_240:
		rprintf("b");
 336:	00 d0       	rcall	.+0      	; 0x338 <blackfinSetResolution+0x62>
 338:	0f 92       	push	r0
 33a:	ed b7       	in	r30, 0x3d	; 61
 33c:	fe b7       	in	r31, 0x3e	; 62
 33e:	61 83       	std	Z+1, r22	; 0x01
 340:	80 e0       	ldi	r24, 0x00	; 0
 342:	90 e0       	ldi	r25, 0x00	; 0
 344:	93 83       	std	Z+3, r25	; 0x03
 346:	82 83       	std	Z+2, r24	; 0x02
 348:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#b");
		break;
 34c:	0f 90       	pop	r0
 34e:	0f 90       	pop	r0
 350:	0f 90       	pop	r0
		rprintf("A");
		response = PSTR("#A");
		break;
	case BLACKFIN_320_BY_240:
		rprintf("b");
		response = PSTR("#b");
 352:	60 e0       	ldi	r22, 0x00	; 0
 354:	70 e0       	ldi	r23, 0x00	; 0
		break;
 356:	00 c0       	rjmp	.+0      	; 0x358 <blackfinSetResolution+0x82>
	case BLACKFIN_640_BY_480:
		rprintf("c");
 358:	00 d0       	rcall	.+0      	; 0x35a <blackfinSetResolution+0x84>
 35a:	0f 92       	push	r0
 35c:	81 e0       	ldi	r24, 0x01	; 1
 35e:	ed b7       	in	r30, 0x3d	; 61
 360:	fe b7       	in	r31, 0x3e	; 62
 362:	81 83       	std	Z+1, r24	; 0x01
 364:	80 e0       	ldi	r24, 0x00	; 0
 366:	90 e0       	ldi	r25, 0x00	; 0
 368:	93 83       	std	Z+3, r25	; 0x03
 36a:	82 83       	std	Z+2, r24	; 0x02
 36c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#c");
		break;
 370:	0f 90       	pop	r0
 372:	0f 90       	pop	r0
 374:	0f 90       	pop	r0
		rprintf("b");
		response = PSTR("#b");
		break;
	case BLACKFIN_640_BY_480:
		rprintf("c");
		response = PSTR("#c");
 376:	60 e0       	ldi	r22, 0x00	; 0
 378:	70 e0       	ldi	r23, 0x00	; 0
		break;
 37a:	00 c0       	rjmp	.+0      	; 0x37c <blackfinSetResolution+0xa6>
	default:
		rprintf("a");
 37c:	00 d0       	rcall	.+0      	; 0x37e <blackfinSetResolution+0xa8>
 37e:	0f 92       	push	r0
 380:	81 e0       	ldi	r24, 0x01	; 1
 382:	ed b7       	in	r30, 0x3d	; 61
 384:	fe b7       	in	r31, 0x3e	; 62
 386:	81 83       	std	Z+1, r24	; 0x01
 388:	80 e0       	ldi	r24, 0x00	; 0
 38a:	90 e0       	ldi	r25, 0x00	; 0
 38c:	93 83       	std	Z+3, r25	; 0x03
 38e:	82 83       	std	Z+2, r24	; 0x02
 390:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
		response = PSTR("#a");
		break;
 394:	0f 90       	pop	r0
 396:	0f 90       	pop	r0
 398:	0f 90       	pop	r0
		rprintf("c");
		response = PSTR("#c");
		break;
	default:
		rprintf("a");
		response = PSTR("#a");
 39a:	60 e0       	ldi	r22, 0x00	; 0
 39c:	70 e0       	ldi	r23, 0x00	; 0
		break;
	}

	// Send the command
	__blackfinCommand(camera,response,null,null,0);
 39e:	c8 01       	movw	r24, r16
 3a0:	40 e0       	ldi	r20, 0x00	; 0
 3a2:	50 e0       	ldi	r21, 0x00	; 0
 3a4:	20 e0       	ldi	r18, 0x00	; 0
 3a6:	30 e0       	ldi	r19, 0x00	; 0
 3a8:	00 e0       	ldi	r16, 0x00	; 0
 3aa:	10 e0       	ldi	r17, 0x00	; 0
 3ac:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>

	// Restore rprintf to original position
	rprintfInit(old);
 3b0:	c7 01       	movw	r24, r14
 3b2:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>


	//must delay so that auto-brightness has time to adjust
	delay_ms(2000);
 3b6:	60 ed       	ldi	r22, 0xD0	; 208
 3b8:	77 e0       	ldi	r23, 0x07	; 7
 3ba:	80 e0       	ldi	r24, 0x00	; 0
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
}
 3c2:	0f 90       	pop	r0
 3c4:	df 91       	pop	r29
 3c6:	cf 91       	pop	r28
 3c8:	1f 91       	pop	r17
 3ca:	0f 91       	pop	r16
 3cc:	ff 90       	pop	r15
 3ce:	ef 90       	pop	r14
 3d0:	08 95       	ret

000003d2 <blackfinInit>:

void blackfinInit(BLACKFIN_CAMERA* camera){
 3d2:	cf 93       	push	r28
 3d4:	df 93       	push	r29
 3d6:	ec 01       	movw	r28, r24

//	__uartAttach(camera->camera, &__blackfin_discard);
//	_uartInit(camera->camera, 115200);

	// allocate space for color
	if(camera->mean == null){
 3d8:	8d 81       	ldd	r24, Y+5	; 0x05
 3da:	9e 81       	ldd	r25, Y+6	; 0x06
 3dc:	00 97       	sbiw	r24, 0x00	; 0
 3de:	01 f4       	brne	.+0      	; 0x3e0 <blackfinInit+0xe>
		camera->mean = malloc(sizeof(COLOR));
 3e0:	84 e0       	ldi	r24, 0x04	; 4
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 3e8:	8d 83       	std	Y+5, r24	; 0x05
 3ea:	9e 83       	std	Y+6, r25	; 0x06
	}

	if(camera->camera->rxBuffer== null){
 3ec:	e8 81       	ld	r30, Y
 3ee:	f9 81       	ldd	r31, Y+1	; 0x01
 3f0:	80 81       	ld	r24, Z
 3f2:	91 81       	ldd	r25, Z+1	; 0x01
 3f4:	00 97       	sbiw	r24, 0x00	; 0
 3f6:	01 f4       	brne	.+0      	; 0x3f8 <blackfinInit+0x26>
		setError(BLACKFIN_RX_BUFFER);
 3f8:	87 ee       	ldi	r24, 0xE7	; 231
 3fa:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	}

	// Set the current resolution
	blackfinSetResolution(camera, camera->res);
 3fe:	ce 01       	movw	r24, r28
 400:	6a 81       	ldd	r22, Y+2	; 0x02
 402:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>

}
 406:	df 91       	pop	r29
 408:	cf 91       	pop	r28
 40a:	08 95       	ret

0000040c <_blackfin_sendYUV>:


void _blackfin_sendYUV(uint8_t c){
 40c:	cf 93       	push	r28
 40e:	df 93       	push	r29
 410:	0f 92       	push	r0
 412:	cd b7       	in	r28, 0x3d	; 61
 414:	de b7       	in	r29, 0x3e	; 62
	rprintfChar( (c / 100)+'0'); c = c % 100;
 416:	64 e6       	ldi	r22, 0x64	; 100
 418:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 41c:	80 5d       	subi	r24, 0xD0	; 208
 41e:	99 83       	std	Y+1, r25	; 0x01
 420:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	rprintfChar( (c /  10)+'0'); c = c % 10;
 424:	99 81       	ldd	r25, Y+1	; 0x01
 426:	89 2f       	mov	r24, r25
 428:	6a e0       	ldi	r22, 0x0A	; 10
 42a:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
 42e:	80 5d       	subi	r24, 0xD0	; 208
 430:	99 83       	std	Y+1, r25	; 0x01
 432:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>
	rprintfChar( c +'0');
 436:	99 81       	ldd	r25, Y+1	; 0x01
 438:	89 2f       	mov	r24, r25
 43a:	80 5d       	subi	r24, 0xD0	; 208
 43c:	0e 94 00 00 	call	0	; 0x0 <_blackfin_putcmd>

}
 440:	0f 90       	pop	r0
 442:	df 91       	pop	r29
 444:	cf 91       	pop	r28
 446:	08 95       	ret

blackfin_vb.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001b2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001e6  2**0
                  ALLOC
  3 .progmem.data 00000014  00000000  00000000  000001e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000098a  00000000  00000000  000001fa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001f8  00000000  00000000  00000b84  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000022e  00000000  00000000  00000d7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000faa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000168  00000000  00000000  00000fca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000582  00000000  00000000  00001132  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000078  00000000  00000000  000016b4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinDetectBlobs>:
                 printf(" %d - %d %d %d %d  \r\n",
                     blobcnt[iy], blobx1[iy], blobx2[iy], bloby1[iy],bloby2[iy]);
             }

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	64 97       	sbiw	r28, 0x14	; 20
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	de bf       	out	0x3e, r29	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	cd bf       	out	0x3d, r28	; 61
  26:	5c 01       	movw	r10, r24
  28:	d6 2e       	mov	r13, r22
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;

	// allocate space for blob storage
	if(camera->blob==null){
  2a:	dc 01       	movw	r26, r24
  2c:	13 96       	adiw	r26, 0x03	; 3
  2e:	8d 91       	ld	r24, X+
  30:	9c 91       	ld	r25, X
  32:	14 97       	sbiw	r26, 0x04	; 4
  34:	00 97       	sbiw	r24, 0x00	; 0
  36:	01 f4       	brne	.+0      	; 0x38 <blackfinDetectBlobs+0x38>
		camera->blob = malloc(MAX_BLOBS * sizeof(BLACKFIN_BLOB)) ;
  38:	80 e4       	ldi	r24, 0x40	; 64
  3a:	90 e0       	ldi	r25, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
  40:	f5 01       	movw	r30, r10
  42:	83 83       	std	Z+3, r24	; 0x03
  44:	94 83       	std	Z+4, r25	; 0x04
	}
	dest = camera->blob;
  46:	d5 01       	movw	r26, r10
  48:	13 96       	adiw	r26, 0x03	; 3
  4a:	ed 90       	ld	r14, X+
  4c:	fc 90       	ld	r15, X
  4e:	14 97       	sbiw	r26, 0x04	; 4

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
  58:	4c 01       	movw	r8, r24
	_blackfin_index=0;
  5a:	10 92 00 00 	sts	0x0000, r1
  5e:	10 92 00 00 	sts	0x0000, r1

	rprintf("vb%d",bin);//start command, send bin #
  62:	00 d0       	rcall	.+0      	; 0x64 <blackfinDetectBlobs+0x64>
  64:	00 d0       	rcall	.+0      	; 0x66 <blackfinDetectBlobs+0x66>
  66:	0f 92       	push	r0
  68:	ed b7       	in	r30, 0x3d	; 61
  6a:	fe b7       	in	r31, 0x3e	; 62
  6c:	31 96       	adiw	r30, 0x01	; 1
  6e:	81 e0       	ldi	r24, 0x01	; 1
  70:	ad b7       	in	r26, 0x3d	; 61
  72:	be b7       	in	r27, 0x3e	; 62
  74:	11 96       	adiw	r26, 0x01	; 1
  76:	8c 93       	st	X, r24
  78:	80 e0       	ldi	r24, 0x00	; 0
  7a:	90 e0       	ldi	r25, 0x00	; 0
  7c:	92 83       	std	Z+2, r25	; 0x02
  7e:	81 83       	std	Z+1, r24	; 0x01
  80:	d3 82       	std	Z+3, r13	; 0x03
  82:	14 82       	std	Z+4, r1	; 0x04
  84:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	// process the command
	int args = __blackfinCommand(camera,PSTR("##vb"),PSTR("  vblob #"),values,2);
  88:	0f 90       	pop	r0
  8a:	0f 90       	pop	r0
  8c:	0f 90       	pop	r0
  8e:	0f 90       	pop	r0
  90:	0f 90       	pop	r0
  92:	c5 01       	movw	r24, r10
  94:	60 e0       	ldi	r22, 0x00	; 0
  96:	70 e0       	ldi	r23, 0x00	; 0
  98:	40 e0       	ldi	r20, 0x00	; 0
  9a:	50 e0       	ldi	r21, 0x00	; 0
  9c:	9e 01       	movw	r18, r28
  9e:	2f 5f       	subi	r18, 0xFF	; 255
  a0:	3f 4f       	sbci	r19, 0xFF	; 255
  a2:	02 e0       	ldi	r16, 0x02	; 2
  a4:	10 e0       	ldi	r17, 0x00	; 0
  a6:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	#ifdef BLACKFIN_DEBUG
	_blackfin_set_active(camera->debug);	//Send rprintf to the debugger
	#endif

	if(args==2 && values[0]==bin){
  aa:	82 30       	cpi	r24, 0x02	; 2
  ac:	91 05       	cpc	r25, r1
  ae:	01 f0       	breq	.+0      	; 0xb0 <blackfinDetectBlobs+0xb0>
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <blackfinDetectBlobs+0xb2>
  b2:	4d 2d       	mov	r20, r13
  b4:	50 e0       	ldi	r21, 0x00	; 0
  b6:	60 e0       	ldi	r22, 0x00	; 0
  b8:	70 e0       	ldi	r23, 0x00	; 0
  ba:	89 81       	ldd	r24, Y+1	; 0x01
  bc:	9a 81       	ldd	r25, Y+2	; 0x02
  be:	ab 81       	ldd	r26, Y+3	; 0x03
  c0:	bc 81       	ldd	r27, Y+4	; 0x04
  c2:	84 17       	cp	r24, r20
  c4:	95 07       	cpc	r25, r21
  c6:	a6 07       	cpc	r26, r22
  c8:	b7 07       	cpc	r27, r23
  ca:	01 f0       	breq	.+0      	; 0xcc <blackfinDetectBlobs+0xcc>
  cc:	00 c0       	rjmp	.+0      	; 0xce <blackfinDetectBlobs+0xce>
		int8_t numBlobs = values[1];		// The number of blobs
  ce:	0d 81       	ldd	r16, Y+5	; 0x05
  d0:	05 30       	cpi	r16, 0x05	; 5
  d2:	04 f0       	brlt	.+0      	; 0xd4 <blackfinDetectBlobs+0xd4>
  d4:	04 e0       	ldi	r16, 0x04	; 4
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
  d6:	dd 24       	eor	r13, r13

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;
  d8:	10 e0       	ldi	r17, 0x00	; 0
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
  da:	00 c0       	rjmp	.+0      	; 0xdc <blackfinDetectBlobs+0xdc>
			args = __blackfin_get_args(camera, values, 5, TRUE);
  dc:	c5 01       	movw	r24, r10
  de:	be 01       	movw	r22, r28
  e0:	6f 5f       	subi	r22, 0xFF	; 255
  e2:	7f 4f       	sbci	r23, 0xFF	; 255
  e4:	45 e0       	ldi	r20, 0x05	; 5
  e6:	50 e0       	ldi	r21, 0x00	; 0
  e8:	2f ef       	ldi	r18, 0xFF	; 255
  ea:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
			#ifdef BLACKFIN_DEBUG
			rprintf(" #%d=",(int)num);
			#endif
			if(args==5){
  ee:	85 30       	cpi	r24, 0x05	; 5
  f0:	91 05       	cpc	r25, r1
  f2:	01 f4       	brne	.+0      	; 0xf4 <blackfinDetectBlobs+0xf4>
				dest->pixels = values[0];
  f4:	89 81       	ldd	r24, Y+1	; 0x01
  f6:	9a 81       	ldd	r25, Y+2	; 0x02
  f8:	ab 81       	ldd	r26, Y+3	; 0x03
  fa:	bc 81       	ldd	r27, Y+4	; 0x04
  fc:	f7 01       	movw	r30, r14
  fe:	84 87       	std	Z+12, r24	; 0x0c
 100:	95 87       	std	Z+13, r25	; 0x0d
 102:	a6 87       	std	Z+14, r26	; 0x0e
 104:	b7 87       	std	Z+15, r27	; 0x0f
				dest->left 	 = values[1];
 106:	2d 81       	ldd	r18, Y+5	; 0x05
 108:	3e 81       	ldd	r19, Y+6	; 0x06
 10a:	31 83       	std	Z+1, r19	; 0x01
 10c:	20 83       	st	Z, r18
				dest->right  = values[2];
 10e:	89 85       	ldd	r24, Y+9	; 0x09
 110:	9a 85       	ldd	r25, Y+10	; 0x0a
 112:	93 83       	std	Z+3, r25	; 0x03
 114:	82 83       	std	Z+2, r24	; 0x02
				dest->top  	 = values[3];
 116:	4d 85       	ldd	r20, Y+13	; 0x0d
 118:	5e 85       	ldd	r21, Y+14	; 0x0e
 11a:	55 83       	std	Z+5, r21	; 0x05
 11c:	44 83       	std	Z+4, r20	; 0x04
				dest->bottom = values[4];
 11e:	69 89       	ldd	r22, Y+17	; 0x11
 120:	7a 89       	ldd	r23, Y+18	; 0x12
 122:	77 83       	std	Z+7, r23	; 0x07
 124:	66 83       	std	Z+6, r22	; 0x06
				dest->xCenter = dest->left + ((dest->right - dest->left)>>1);
 126:	82 1b       	sub	r24, r18
 128:	93 0b       	sbc	r25, r19
 12a:	96 95       	lsr	r25
 12c:	87 95       	ror	r24
 12e:	82 0f       	add	r24, r18
 130:	93 1f       	adc	r25, r19
 132:	91 87       	std	Z+9, r25	; 0x09
 134:	80 87       	std	Z+8, r24	; 0x08
				dest->yCenter = dest->top + ((dest->bottom - dest->top)>>1);
 136:	cb 01       	movw	r24, r22
 138:	84 1b       	sub	r24, r20
 13a:	95 0b       	sbc	r25, r21
 13c:	96 95       	lsr	r25
 13e:	87 95       	ror	r24
 140:	84 0f       	add	r24, r20
 142:	95 1f       	adc	r25, r21
 144:	93 87       	std	Z+11, r25	; 0x0b
 146:	82 87       	std	Z+10, r24	; 0x0a
					rprintfChar(',');
					rprintfNum(10,4,FALSE,'0',dest->bottom);
					rprintf(" Pixels=");rprintfNum(10,10,FALSE,' ',dest->pixels);
					rprintfCRLF();
				#endif
				dest++;
 148:	80 e1       	ldi	r24, 0x10	; 16
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	e8 0e       	add	r14, r24
 14e:	f9 1e       	adc	r15, r25
				actual++;
 150:	1f 5f       	subi	r17, 0xFF	; 255
				#ifdef BLACKFIN_DEBUG
					rprintf("Expected 5 args but got %d\n",args);
				#endif
			}
			// Read up to linefeed
			while(__uartGetByte(camera->camera)!='\n');
 152:	d5 01       	movw	r26, r10
 154:	8d 91       	ld	r24, X+
 156:	9c 91       	ld	r25, X
 158:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>
 15c:	8a 30       	cpi	r24, 0x0A	; 10
 15e:	91 05       	cpc	r25, r1
 160:	01 f4       	brne	.+0      	; 0x162 <blackfinDetectBlobs+0x162>
		#ifdef BLACKFIN_DEBUG
		rprintf(" %d blobs\n",(int)numBlobs);
		#endif

		// Get each blob
		for(int8_t num = 0; num < numBlobs; num++){
 162:	d3 94       	inc	r13
 164:	d0 16       	cp	r13, r16
 166:	04 f4       	brge	.+0      	; 0x168 <blackfinDetectBlobs+0x168>
 168:	00 c0       	rjmp	.+0      	; 0x16a <blackfinDetectBlobs+0x16a>
 16a:	00 c0       	rjmp	.+0      	; 0x16c <blackfinDetectBlobs+0x16c>

 */
uint8_t blackfinDetectBlobs (BLACKFIN_CAMERA* camera, uint8_t bin){
	int32_t values[5];
	BLACKFIN_BLOB* dest;
	uint8_t actual = 0;
 16c:	10 e0       	ldi	r17, 0x00	; 0
		rprintf("vb - missing num blobs\n");
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
 16e:	c4 01       	movw	r24, r8
 170:	0e 94 00 00 	call	0	; 0x0 <blackfinDetectBlobs>

	return actual;
}
 174:	81 2f       	mov	r24, r17
 176:	64 96       	adiw	r28, 0x14	; 20
 178:	0f b6       	in	r0, 0x3f	; 63
 17a:	f8 94       	cli
 17c:	de bf       	out	0x3e, r29	; 62
 17e:	0f be       	out	0x3f, r0	; 63
 180:	cd bf       	out	0x3d, r28	; 61
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	1f 91       	pop	r17
 188:	0f 91       	pop	r16
 18a:	ff 90       	pop	r15
 18c:	ef 90       	pop	r14
 18e:	df 90       	pop	r13
 190:	bf 90       	pop	r11
 192:	af 90       	pop	r10
 194:	9f 90       	pop	r9
 196:	8f 90       	pop	r8
 198:	08 95       	ret

0000019a <blackfinFetchBlob>:


const BLACKFIN_BLOB* blackfinFetchBlob(BLACKFIN_CAMERA* camera, uint8_t blobNo){
	return &camera->blob[blobNo];
 19a:	70 e0       	ldi	r23, 0x00	; 0
 19c:	24 e0       	ldi	r18, 0x04	; 4
 19e:	66 0f       	add	r22, r22
 1a0:	77 1f       	adc	r23, r23
 1a2:	2a 95       	dec	r18
 1a4:	01 f4       	brne	.+0      	; 0x1a6 <blackfinFetchBlob+0xc>
 1a6:	fc 01       	movw	r30, r24
 1a8:	83 81       	ldd	r24, Z+3	; 0x03
 1aa:	94 81       	ldd	r25, Z+4	; 0x04
 1ac:	86 0f       	add	r24, r22
 1ae:	97 1f       	adc	r25, r23
}
 1b0:	08 95       	ret

blackfin_vc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000148  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000017c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000017c  2**0
                  ALLOC
  3 .progmem.data 0000000a  00000000  00000000  0000017c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000006cc  00000000  00000000  00000186  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001cf  00000000  00000000  00000852  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000001ae  00000000  00000000  00000a21  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000bcf  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000121  00000000  00000000  00000bef  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003d6  00000000  00000000  00000d10  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000068  00000000  00000000  000010e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinSetBinRange>:
//example:	vc0090255000255000255      returns ##vc0
//              012345678901234567890
//sets color bin #0 using Y mean, 255, 0, 255, 0, 255 so
//pixels of higher than average brightness will appear in blob search

void blackfinSetBinRange(BLACKFIN_CAMERA* camera,uint8_t bin, const COLOR* min, const COLOR* max){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	cd b7       	in	r28, 0x3d	; 61
  18:	de b7       	in	r29, 0x3e	; 62
  1a:	2c 97       	sbiw	r28, 0x0c	; 12
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	de bf       	out	0x3e, r29	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	cd bf       	out	0x3d, r28	; 61
  26:	4c 01       	movw	r8, r24
  28:	d6 2e       	mov	r13, r22
  2a:	ca 01       	movw	r24, r20
  2c:	89 01       	movw	r16, r18

	COLOR yuvMin;
	COLOR yuvMax;

	// Convert the colors to the YUV color space
	COLOR_YUV* minPtr = color2yuv(min, &yuvMin);
  2e:	be 01       	movw	r22, r28
  30:	6b 5f       	subi	r22, 0xFB	; 251
  32:	7f 4f       	sbci	r23, 0xFF	; 255
  34:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  38:	7c 01       	movw	r14, r24
	COLOR_YUV* maxPtr = color2yuv(max, &yuvMax);
  3a:	c8 01       	movw	r24, r16
  3c:	be 01       	movw	r22, r28
  3e:	6f 5f       	subi	r22, 0xFF	; 255
  40:	7f 4f       	sbci	r23, 0xFF	; 255
  42:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  46:	8c 01       	movw	r16, r24

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  48:	80 e0       	ldi	r24, 0x00	; 0
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
  50:	5c 01       	movw	r10, r24
	_blackfin_index=0;
  52:	10 92 00 00 	sts	0x0000, r1
  56:	10 92 00 00 	sts	0x0000, r1

	// send 'vc' command
	rprintf("vc%d",(int)bin);//start command, send bin #
  5a:	00 d0       	rcall	.+0      	; 0x5c <blackfinSetBinRange+0x5c>
  5c:	00 d0       	rcall	.+0      	; 0x5e <blackfinSetBinRange+0x5e>
  5e:	0f 92       	push	r0
  60:	ed b7       	in	r30, 0x3d	; 61
  62:	fe b7       	in	r31, 0x3e	; 62
  64:	31 96       	adiw	r30, 0x01	; 1
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	ad b7       	in	r26, 0x3d	; 61
  6a:	be b7       	in	r27, 0x3e	; 62
  6c:	11 96       	adiw	r26, 0x01	; 1
  6e:	8c 93       	st	X, r24
  70:	80 e0       	ldi	r24, 0x00	; 0
  72:	90 e0       	ldi	r25, 0x00	; 0
  74:	92 83       	std	Z+2, r25	; 0x02
  76:	81 83       	std	Z+1, r24	; 0x01
  78:	d3 82       	std	Z+3, r13	; 0x03
  7a:	14 82       	std	Z+4, r1	; 0x04
  7c:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->y,maxPtr->y));	// minimum y
  80:	0f 90       	pop	r0
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	f8 01       	movw	r30, r16
  8c:	90 81       	ld	r25, Z
  8e:	d7 01       	movw	r26, r14
  90:	8c 91       	ld	r24, X
  92:	98 17       	cp	r25, r24
  94:	00 f4       	brcc	.+0      	; 0x96 <blackfinSetBinRange+0x96>
  96:	89 2f       	mov	r24, r25
  98:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->y,maxPtr->y));	// maximum y
  9c:	f8 01       	movw	r30, r16
  9e:	90 81       	ld	r25, Z
  a0:	d7 01       	movw	r26, r14
  a2:	8c 91       	ld	r24, X
  a4:	89 17       	cp	r24, r25
  a6:	00 f4       	brcc	.+0      	; 0xa8 <blackfinSetBinRange+0xa8>
  a8:	89 2f       	mov	r24, r25
  aa:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->u,maxPtr->u));	// minimum u
  ae:	f8 01       	movw	r30, r16
  b0:	91 81       	ldd	r25, Z+1	; 0x01
  b2:	d7 01       	movw	r26, r14
  b4:	11 96       	adiw	r26, 0x01	; 1
  b6:	8c 91       	ld	r24, X
  b8:	11 97       	sbiw	r26, 0x01	; 1
  ba:	98 17       	cp	r25, r24
  bc:	00 f4       	brcc	.+0      	; 0xbe <blackfinSetBinRange+0xbe>
  be:	89 2f       	mov	r24, r25
  c0:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->u,maxPtr->u));	// maximum u
  c4:	f8 01       	movw	r30, r16
  c6:	91 81       	ldd	r25, Z+1	; 0x01
  c8:	d7 01       	movw	r26, r14
  ca:	11 96       	adiw	r26, 0x01	; 1
  cc:	8c 91       	ld	r24, X
  ce:	11 97       	sbiw	r26, 0x01	; 1
  d0:	89 17       	cp	r24, r25
  d2:	00 f4       	brcc	.+0      	; 0xd4 <blackfinSetBinRange+0xd4>
  d4:	89 2f       	mov	r24, r25
  d6:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MIN(minPtr->v,maxPtr->v));	// minimum v
  da:	f8 01       	movw	r30, r16
  dc:	92 81       	ldd	r25, Z+2	; 0x02
  de:	d7 01       	movw	r26, r14
  e0:	12 96       	adiw	r26, 0x02	; 2
  e2:	8c 91       	ld	r24, X
  e4:	12 97       	sbiw	r26, 0x02	; 2
  e6:	98 17       	cp	r25, r24
  e8:	00 f4       	brcc	.+0      	; 0xea <blackfinSetBinRange+0xea>
  ea:	89 2f       	mov	r24, r25
  ec:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	_blackfin_sendYUV(MAX(minPtr->v,maxPtr->v));	// maximum v
  f0:	f8 01       	movw	r30, r16
  f2:	92 81       	ldd	r25, Z+2	; 0x02
  f4:	d7 01       	movw	r26, r14
  f6:	12 96       	adiw	r26, 0x02	; 2
  f8:	8c 91       	ld	r24, X
  fa:	12 97       	sbiw	r26, 0x02	; 2
  fc:	89 17       	cp	r24, r25
  fe:	00 f4       	brcc	.+0      	; 0x100 <blackfinSetBinRange+0x100>
 100:	89 2f       	mov	r24, r25
 102:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
		rprintf(" Min="); colorDump(min);
		rprintf(" Max="); colorDump(max);
		rprintfCRLF();
	}
	#else
	__blackfinCommand(camera,PSTR("##vc"),null,values,1);
 106:	c4 01       	movw	r24, r8
 108:	60 e0       	ldi	r22, 0x00	; 0
 10a:	70 e0       	ldi	r23, 0x00	; 0
 10c:	40 e0       	ldi	r20, 0x00	; 0
 10e:	50 e0       	ldi	r21, 0x00	; 0
 110:	9e 01       	movw	r18, r28
 112:	27 5f       	subi	r18, 0xF7	; 247
 114:	3f 4f       	sbci	r19, 0xFF	; 255
 116:	01 e0       	ldi	r16, 0x01	; 1
 118:	10 e0       	ldi	r17, 0x00	; 0
 11a:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
	#endif

	// Restore rprintf to original position
	rprintfInit(old);
 11e:	c5 01       	movw	r24, r10
 120:	0e 94 00 00 	call	0	; 0x0 <blackfinSetBinRange>
}
 124:	2c 96       	adiw	r28, 0x0c	; 12
 126:	0f b6       	in	r0, 0x3f	; 63
 128:	f8 94       	cli
 12a:	de bf       	out	0x3e, r29	; 62
 12c:	0f be       	out	0x3f, r0	; 63
 12e:	cd bf       	out	0x3d, r28	; 61
 130:	df 91       	pop	r29
 132:	cf 91       	pop	r28
 134:	1f 91       	pop	r17
 136:	0f 91       	pop	r16
 138:	ff 90       	pop	r15
 13a:	ef 90       	pop	r14
 13c:	df 90       	pop	r13
 13e:	bf 90       	pop	r11
 140:	af 90       	pop	r10
 142:	9f 90       	pop	r9
 144:	8f 90       	pop	r8
 146:	08 95       	ret

blackfin_vf.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000015a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000018e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000018e  2**0
                  ALLOC
  3 .progmem.data 0000000b  00000000  00000000  0000018e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000006ae  00000000  00000000  00000199  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001d1  00000000  00000000  00000847  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000233  00000000  00000000  00000a18  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000c4b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000012b  00000000  00000000  00000c6b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003bf  00000000  00000000  00000d96  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000008c  00000000  00000000  00001158  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinCountPixels>:

/*
 * Count the number of pixels in a rectangle that match a given color bin
 */

uint32_t blackfinCountPixels(BLACKFIN_CAMERA* camera,uint8_t bin, uint16_t x1, uint16_t x2, uint16_t y1, uint16_t y2){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <blackfinCountPixels+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <blackfinCountPixels+0x28>
  28:	0f 92       	push	r0
  2a:	cd b7       	in	r28, 0x3d	; 61
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	2c 01       	movw	r4, r24
  30:	5a 01       	movw	r10, r20
  32:	49 01       	movw	r8, r18
  34:	38 01       	movw	r6, r16
  36:	de 2c       	mov	r13, r14
  38:	cf 2c       	mov	r12, r15

	int32_t values[1];

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	6d 83       	std	Y+5, r22	; 0x05
  40:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
  44:	1c 01       	movw	r2, r24
	_blackfin_index=0;
  46:	10 92 00 00 	sts	0x0000, r1
  4a:	10 92 00 00 	sts	0x0000, r1

	// send 'vf' command
	rprintf("vf%d",(int)bin);//start command, send bin #
  4e:	00 d0       	rcall	.+0      	; 0x50 <blackfinCountPixels+0x50>
  50:	00 d0       	rcall	.+0      	; 0x52 <blackfinCountPixels+0x52>
  52:	0f 92       	push	r0
  54:	ed b7       	in	r30, 0x3d	; 61
  56:	fe b7       	in	r31, 0x3e	; 62
  58:	31 96       	adiw	r30, 0x01	; 1
  5a:	81 e0       	ldi	r24, 0x01	; 1
  5c:	ad b7       	in	r26, 0x3d	; 61
  5e:	be b7       	in	r27, 0x3e	; 62
  60:	11 96       	adiw	r26, 0x01	; 1
  62:	8c 93       	st	X, r24
  64:	80 e0       	ldi	r24, 0x00	; 0
  66:	90 e0       	ldi	r25, 0x00	; 0
  68:	92 83       	std	Z+2, r25	; 0x02
  6a:	81 83       	std	Z+1, r24	; 0x01
  6c:	6d 81       	ldd	r22, Y+5	; 0x05
  6e:	63 83       	std	Z+3, r22	; 0x03
  70:	14 82       	std	Z+4, r1	; 0x04
  72:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MIN(x1,x2));
  76:	0f 90       	pop	r0
  78:	0f 90       	pop	r0
  7a:	0f 90       	pop	r0
  7c:	0f 90       	pop	r0
  7e:	0f 90       	pop	r0
  80:	74 01       	movw	r14, r8
  82:	a8 14       	cp	r10, r8
  84:	b9 04       	cpc	r11, r9
  86:	00 f4       	brcc	.+0      	; 0x88 <blackfinCountPixels+0x88>
  88:	75 01       	movw	r14, r10
  8a:	00 e0       	ldi	r16, 0x00	; 0
  8c:	10 e0       	ldi	r17, 0x00	; 0
  8e:	8a e0       	ldi	r24, 0x0A	; 10
  90:	64 e0       	ldi	r22, 0x04	; 4
  92:	40 e0       	ldi	r20, 0x00	; 0
  94:	20 e3       	ldi	r18, 0x30	; 48
  96:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MAX(x1,x2));
  9a:	74 01       	movw	r14, r8
  9c:	8a 14       	cp	r8, r10
  9e:	9b 04       	cpc	r9, r11
  a0:	00 f4       	brcc	.+0      	; 0xa2 <blackfinCountPixels+0xa2>
  a2:	75 01       	movw	r14, r10
  a4:	00 e0       	ldi	r16, 0x00	; 0
  a6:	10 e0       	ldi	r17, 0x00	; 0
  a8:	8a e0       	ldi	r24, 0x0A	; 10
  aa:	64 e0       	ldi	r22, 0x04	; 4
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	20 e3       	ldi	r18, 0x30	; 48
  b0:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MIN(y1,y2));
  b4:	ed 2c       	mov	r14, r13
  b6:	fc 2c       	mov	r15, r12
  b8:	6e 14       	cp	r6, r14
  ba:	7f 04       	cpc	r7, r15
  bc:	00 f4       	brcc	.+0      	; 0xbe <blackfinCountPixels+0xbe>
  be:	73 01       	movw	r14, r6
  c0:	00 e0       	ldi	r16, 0x00	; 0
  c2:	10 e0       	ldi	r17, 0x00	; 0
  c4:	8a e0       	ldi	r24, 0x0A	; 10
  c6:	64 e0       	ldi	r22, 0x04	; 4
  c8:	40 e0       	ldi	r20, 0x00	; 0
  ca:	20 e3       	ldi	r18, 0x30	; 48
  cc:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
	rprintfNum(10,4,FALSE,'0',MAX(y1,y2));
  d0:	ed 2c       	mov	r14, r13
  d2:	fc 2c       	mov	r15, r12
  d4:	e6 14       	cp	r14, r6
  d6:	f7 04       	cpc	r15, r7
  d8:	00 f4       	brcc	.+0      	; 0xda <blackfinCountPixels+0xda>
  da:	73 01       	movw	r14, r6
  dc:	00 e0       	ldi	r16, 0x00	; 0
  de:	10 e0       	ldi	r17, 0x00	; 0
  e0:	8a e0       	ldi	r24, 0x0A	; 10
  e2:	64 e0       	ldi	r22, 0x04	; 4
  e4:	40 e0       	ldi	r20, 0x00	; 0
  e6:	20 e3       	ldi	r18, 0x30	; 48
  e8:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>

	// process the command

	int args = __blackfinCommand(camera,PSTR("##vf "),null,values,1);
  ec:	c2 01       	movw	r24, r4
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	70 e0       	ldi	r23, 0x00	; 0
  f2:	40 e0       	ldi	r20, 0x00	; 0
  f4:	50 e0       	ldi	r21, 0x00	; 0
  f6:	9e 01       	movw	r18, r28
  f8:	2f 5f       	subi	r18, 0xFF	; 255
  fa:	3f 4f       	sbci	r19, 0xFF	; 255
  fc:	01 e0       	ldi	r16, 0x01	; 1
  fe:	10 e0       	ldi	r17, 0x00	; 0
 100:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>
 104:	7c 01       	movw	r14, r24
		rprintfCRLF();
	}
	#endif

	// Restore rprintf to original position
	rprintfInit(old);
 106:	c1 01       	movw	r24, r2
 108:	0e 94 00 00 	call	0	; 0x0 <blackfinCountPixels>

	return (args==1) ? values[0] : 0;
 10c:	b1 e0       	ldi	r27, 0x01	; 1
 10e:	eb 16       	cp	r14, r27
 110:	f1 04       	cpc	r15, r1
 112:	01 f4       	brne	.+0      	; 0x114 <blackfinCountPixels+0x114>
 114:	09 81       	ldd	r16, Y+1	; 0x01
 116:	1a 81       	ldd	r17, Y+2	; 0x02
 118:	2b 81       	ldd	r18, Y+3	; 0x03
 11a:	3c 81       	ldd	r19, Y+4	; 0x04
 11c:	00 c0       	rjmp	.+0      	; 0x11e <blackfinCountPixels+0x11e>
 11e:	00 e0       	ldi	r16, 0x00	; 0
 120:	10 e0       	ldi	r17, 0x00	; 0
 122:	20 e0       	ldi	r18, 0x00	; 0
 124:	30 e0       	ldi	r19, 0x00	; 0
}
 126:	b8 01       	movw	r22, r16
 128:	c9 01       	movw	r24, r18
 12a:	0f 90       	pop	r0
 12c:	0f 90       	pop	r0
 12e:	0f 90       	pop	r0
 130:	0f 90       	pop	r0
 132:	0f 90       	pop	r0
 134:	df 91       	pop	r29
 136:	cf 91       	pop	r28
 138:	1f 91       	pop	r17
 13a:	0f 91       	pop	r16
 13c:	ff 90       	pop	r15
 13e:	ef 90       	pop	r14
 140:	df 90       	pop	r13
 142:	cf 90       	pop	r12
 144:	bf 90       	pop	r11
 146:	af 90       	pop	r10
 148:	9f 90       	pop	r9
 14a:	8f 90       	pop	r8
 14c:	7f 90       	pop	r7
 14e:	6f 90       	pop	r6
 150:	5f 90       	pop	r5
 152:	4f 90       	pop	r4
 154:	3f 90       	pop	r3
 156:	2f 90       	pop	r2
 158:	08 95       	ret

blackfin_vm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000142  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000176  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000176  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000176  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000068b  00000000  00000000  00000182  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001cb  00000000  00000000  0000080d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000121  00000000  00000000  000009d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000af9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000153  00000000  00000000  00000b19  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003c3  00000000  00000000  00000c6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000005c  00000000  00000000  00001030  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinMeanColor>:
 */
#include "blackfin.h"

#include "../../rprintf.h"

const COLOR * blackfinMeanColor(BLACKFIN_CAMERA* camera){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	2c 97       	sbiw	r28, 0x0c	; 12
  18:	0f b6       	in	r0, 0x3f	; 63
  1a:	f8 94       	cli
  1c:	de bf       	out	0x3e, r29	; 62
  1e:	0f be       	out	0x3f, r0	; 63
  20:	cd bf       	out	0x3d, r28	; 61
  22:	6c 01       	movw	r12, r24
	int32_t values[3];

	// Make rprintf go to _blackfin_command
	Writer old = rprintfInit(&_blackfin_putcmd);
  24:	80 e0       	ldi	r24, 0x00	; 0
  26:	90 e0       	ldi	r25, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>
  2c:	5c 01       	movw	r10, r24
	_blackfin_index=0;
  2e:	10 92 00 00 	sts	0x0000, r1
  32:	10 92 00 00 	sts	0x0000, r1

	// send 'vm' command to camera
	rprintf("vm");
  36:	00 d0       	rcall	.+0      	; 0x38 <blackfinMeanColor+0x38>
  38:	0f 92       	push	r0
  3a:	ff 24       	eor	r15, r15
  3c:	f3 94       	inc	r15
  3e:	ad b7       	in	r26, 0x3d	; 61
  40:	be b7       	in	r27, 0x3e	; 62
  42:	11 96       	adiw	r26, 0x01	; 1
  44:	fc 92       	st	X, r15
  46:	11 97       	sbiw	r26, 0x01	; 1
  48:	80 e0       	ldi	r24, 0x00	; 0
  4a:	90 e0       	ldi	r25, 0x00	; 0
  4c:	13 96       	adiw	r26, 0x03	; 3
  4e:	9c 93       	st	X, r25
  50:	8e 93       	st	-X, r24
  52:	12 97       	sbiw	r26, 0x02	; 2
  54:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	// process the command
	int args = __blackfinCommand(camera,PSTR("##vmean "),null,values,3);
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	0f 90       	pop	r0
  5e:	c6 01       	movw	r24, r12
  60:	60 e0       	ldi	r22, 0x00	; 0
  62:	70 e0       	ldi	r23, 0x00	; 0
  64:	40 e0       	ldi	r20, 0x00	; 0
  66:	50 e0       	ldi	r21, 0x00	; 0
  68:	9e 01       	movw	r18, r28
  6a:	2f 5f       	subi	r18, 0xFF	; 255
  6c:	3f 4f       	sbci	r19, 0xFF	; 255
  6e:	03 e0       	ldi	r16, 0x03	; 3
  70:	10 e0       	ldi	r17, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	#ifdef BLACKFIN_DEBUG
	_blackfin_set_active(camera->debug);	//Send rprintf to the debugger
	#endif

	if(args == 3){
  76:	83 30       	cpi	r24, 0x03	; 3
  78:	91 05       	cpc	r25, r1
  7a:	01 f0       	breq	.+0      	; 0x7c <blackfinMeanColor+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <blackfinMeanColor+0x7e>
		//save it away - stay within limits of 0 to 255 for each band
		CRITICAL_SECTION_START;
  7e:	2f b7       	in	r18, 0x3f	; 63
  80:	f8 94       	cli
		camera->mean->colorSpace = YUV;
  82:	d6 01       	movw	r26, r12
  84:	15 96       	adiw	r26, 0x05	; 5
  86:	ed 91       	ld	r30, X+
  88:	fc 91       	ld	r31, X
  8a:	16 97       	sbiw	r26, 0x06	; 6
  8c:	f0 82       	st	Z, r15
		camera->mean->bands.yuv.y = (uint8_t)CLAMP(values[0],0,255);
  8e:	89 81       	ldd	r24, Y+1	; 0x01
  90:	9a 81       	ldd	r25, Y+2	; 0x02
  92:	ab 81       	ldd	r26, Y+3	; 0x03
  94:	bc 81       	ldd	r27, Y+4	; 0x04
  96:	18 16       	cp	r1, r24
  98:	19 06       	cpc	r1, r25
  9a:	1a 06       	cpc	r1, r26
  9c:	1b 06       	cpc	r1, r27
  9e:	04 f4       	brge	.+0      	; 0xa0 <blackfinMeanColor+0xa0>
  a0:	8f 3f       	cpi	r24, 0xFF	; 255
  a2:	91 05       	cpc	r25, r1
  a4:	a1 05       	cpc	r26, r1
  a6:	b1 05       	cpc	r27, r1
  a8:	04 f4       	brge	.+0      	; 0xaa <blackfinMeanColor+0xaa>
  aa:	00 c0       	rjmp	.+0      	; 0xac <blackfinMeanColor+0xac>
  ac:	80 e0       	ldi	r24, 0x00	; 0
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <blackfinMeanColor+0xb0>
  b0:	8f ef       	ldi	r24, 0xFF	; 255
  b2:	81 83       	std	Z+1, r24	; 0x01
		camera->mean->bands.yuv.u = (uint8_t)CLAMP(values[1],0,255);
  b4:	d6 01       	movw	r26, r12
  b6:	15 96       	adiw	r26, 0x05	; 5
  b8:	ed 91       	ld	r30, X+
  ba:	fc 91       	ld	r31, X
  bc:	16 97       	sbiw	r26, 0x06	; 6
  be:	8d 81       	ldd	r24, Y+5	; 0x05
  c0:	9e 81       	ldd	r25, Y+6	; 0x06
  c2:	af 81       	ldd	r26, Y+7	; 0x07
  c4:	b8 85       	ldd	r27, Y+8	; 0x08
  c6:	18 16       	cp	r1, r24
  c8:	19 06       	cpc	r1, r25
  ca:	1a 06       	cpc	r1, r26
  cc:	1b 06       	cpc	r1, r27
  ce:	04 f4       	brge	.+0      	; 0xd0 <blackfinMeanColor+0xd0>
  d0:	8f 3f       	cpi	r24, 0xFF	; 255
  d2:	91 05       	cpc	r25, r1
  d4:	a1 05       	cpc	r26, r1
  d6:	b1 05       	cpc	r27, r1
  d8:	04 f4       	brge	.+0      	; 0xda <blackfinMeanColor+0xda>
  da:	00 c0       	rjmp	.+0      	; 0xdc <blackfinMeanColor+0xdc>
  dc:	80 e0       	ldi	r24, 0x00	; 0
  de:	00 c0       	rjmp	.+0      	; 0xe0 <blackfinMeanColor+0xe0>
  e0:	8f ef       	ldi	r24, 0xFF	; 255
  e2:	82 83       	std	Z+2, r24	; 0x02
		camera->mean->bands.yuv.v = (uint8_t)CLAMP(values[2],0,255);
  e4:	d6 01       	movw	r26, r12
  e6:	15 96       	adiw	r26, 0x05	; 5
  e8:	ed 91       	ld	r30, X+
  ea:	fc 91       	ld	r31, X
  ec:	16 97       	sbiw	r26, 0x06	; 6
  ee:	89 85       	ldd	r24, Y+9	; 0x09
  f0:	9a 85       	ldd	r25, Y+10	; 0x0a
  f2:	ab 85       	ldd	r26, Y+11	; 0x0b
  f4:	bc 85       	ldd	r27, Y+12	; 0x0c
  f6:	18 16       	cp	r1, r24
  f8:	19 06       	cpc	r1, r25
  fa:	1a 06       	cpc	r1, r26
  fc:	1b 06       	cpc	r1, r27
  fe:	04 f4       	brge	.+0      	; 0x100 <blackfinMeanColor+0x100>
 100:	8f 3f       	cpi	r24, 0xFF	; 255
 102:	91 05       	cpc	r25, r1
 104:	a1 05       	cpc	r26, r1
 106:	b1 05       	cpc	r27, r1
 108:	04 f4       	brge	.+0      	; 0x10a <blackfinMeanColor+0x10a>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <blackfinMeanColor+0x10c>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	00 c0       	rjmp	.+0      	; 0x110 <blackfinMeanColor+0x110>
 110:	8f ef       	ldi	r24, 0xFF	; 255
 112:	83 83       	std	Z+3, r24	; 0x03
		CRITICAL_SECTION_END;
 114:	2f bf       	out	0x3f, r18	; 63
		rprintf("vm got %d values!\n",args);
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
 116:	c5 01       	movw	r24, r10
 118:	0e 94 00 00 	call	0	; 0x0 <blackfinMeanColor>

	return camera->mean;
}
 11c:	f6 01       	movw	r30, r12
 11e:	85 81       	ldd	r24, Z+5	; 0x05
 120:	96 81       	ldd	r25, Z+6	; 0x06
 122:	2c 96       	adiw	r28, 0x0c	; 12
 124:	0f b6       	in	r0, 0x3f	; 63
 126:	f8 94       	cli
 128:	de bf       	out	0x3e, r29	; 62
 12a:	0f be       	out	0x3f, r0	; 63
 12c:	cd bf       	out	0x3d, r28	; 61
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	1f 91       	pop	r17
 134:	0f 91       	pop	r16
 136:	ff 90       	pop	r15
 138:	df 90       	pop	r13
 13a:	cf 90       	pop	r12
 13c:	bf 90       	pop	r11
 13e:	af 90       	pop	r10
 140:	08 95       	ret

blackfin_vp.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000ea  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000011e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000011e  2**0
                  ALLOC
  3 .progmem.data 00000009  00000000  00000000  0000011e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000006f4  00000000  00000000  00000127  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000212  00000000  00000000  0000081b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000218  00000000  00000000  00000a2d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000c45  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000126  00000000  00000000  00000c65  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003ce  00000000  00000000  00000d8b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000007c  00000000  00000000  0000115c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <blackfinGetPixel>:

/*
 * Fetch the pixel color at a given location
 */

void blackfinGetPixel(BLACKFIN_CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	cd b7       	in	r28, 0x3d	; 61
  20:	de b7       	in	r29, 0x3e	; 62
  22:	2c 97       	sbiw	r28, 0x0c	; 12
  24:	0f b6       	in	r0, 0x3f	; 63
  26:	f8 94       	cli
  28:	de bf       	out	0x3e, r29	; 62
  2a:	0f be       	out	0x3f, r0	; 63
  2c:	cd bf       	out	0x3d, r28	; 61
  2e:	3c 01       	movw	r6, r24
  30:	7b 01       	movw	r14, r22
  32:	4a 01       	movw	r8, r20
  34:	69 01       	movw	r12, r18

	int32_t values[3];

	// Make rprintf go to _blackfin_command
	 Writer old = rprintfInit(&_blackfin_putcmd);
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	90 e0       	ldi	r25, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
  3e:	2c 01       	movw	r4, r24
	_blackfin_index=0;
  40:	10 92 00 00 	sts	0x0000, r1
  44:	10 92 00 00 	sts	0x0000, r1

	// send 'vp' command
	rprintf("vp");
  48:	00 d0       	rcall	.+0      	; 0x4a <blackfinGetPixel+0x4a>
  4a:	0f 92       	push	r0
  4c:	bb 24       	eor	r11, r11
  4e:	b3 94       	inc	r11
  50:	ed b7       	in	r30, 0x3d	; 61
  52:	fe b7       	in	r31, 0x3e	; 62
  54:	b1 82       	std	Z+1, r11	; 0x01
  56:	80 e0       	ldi	r24, 0x00	; 0
  58:	90 e0       	ldi	r25, 0x00	; 0
  5a:	93 83       	std	Z+3, r25	; 0x03
  5c:	82 83       	std	Z+2, r24	; 0x02
  5e:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
	rprintfNum(10,4,FALSE,'0',x);
  62:	0f 90       	pop	r0
  64:	0f 90       	pop	r0
  66:	0f 90       	pop	r0
  68:	00 e0       	ldi	r16, 0x00	; 0
  6a:	10 e0       	ldi	r17, 0x00	; 0
  6c:	8a e0       	ldi	r24, 0x0A	; 10
  6e:	64 e0       	ldi	r22, 0x04	; 4
  70:	40 e0       	ldi	r20, 0x00	; 0
  72:	20 e3       	ldi	r18, 0x30	; 48
  74:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
	rprintfNum(10,4,FALSE,'0',y);
  78:	74 01       	movw	r14, r8
  7a:	00 e0       	ldi	r16, 0x00	; 0
  7c:	10 e0       	ldi	r17, 0x00	; 0
  7e:	8a e0       	ldi	r24, 0x0A	; 10
  80:	64 e0       	ldi	r22, 0x04	; 4
  82:	40 e0       	ldi	r20, 0x00	; 0
  84:	20 e3       	ldi	r18, 0x30	; 48
  86:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>

	// process the command

	int args = __blackfinCommand(camera,PSTR("##vp "),null,values,3);
  8a:	c3 01       	movw	r24, r6
  8c:	60 e0       	ldi	r22, 0x00	; 0
  8e:	70 e0       	ldi	r23, 0x00	; 0
  90:	40 e0       	ldi	r20, 0x00	; 0
  92:	50 e0       	ldi	r21, 0x00	; 0
  94:	9e 01       	movw	r18, r28
  96:	2f 5f       	subi	r18, 0xFF	; 255
  98:	3f 4f       	sbci	r19, 0xFF	; 255
  9a:	03 e0       	ldi	r16, 0x03	; 3
  9c:	10 e0       	ldi	r17, 0x00	; 0
  9e:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>

	if(args==3){
  a2:	83 30       	cpi	r24, 0x03	; 3
  a4:	91 05       	cpc	r25, r1
  a6:	01 f4       	brne	.+0      	; 0xa8 <blackfinGetPixel+0xa8>
		colorSetYUV(color,(uint8_t)(values[0]), (uint8_t)(values[1]),(uint8_t)(values[2]));
  a8:	29 81       	ldd	r18, Y+1	; 0x01
  aa:	9d 81       	ldd	r25, Y+5	; 0x05
  ac:	89 85       	ldd	r24, Y+9	; 0x09
	color->bands.rgb.g = g;
	color->bands.rgb.b = b;
}

static __inline__ void colorSetYUV(COLOR* color, uint8_t y, uint8_t u, uint8_t v ){
	color->colorSpace = YUV;
  ae:	f6 01       	movw	r30, r12
  b0:	b0 82       	st	Z, r11
	color->bands.yuv.y = y;
  b2:	21 83       	std	Z+1, r18	; 0x01
	color->bands.yuv.u = u;
  b4:	92 83       	std	Z+2, r25	; 0x02
	color->bands.yuv.v = v;
  b6:	83 83       	std	Z+3, r24	; 0x03
		rprintfCRLF();
		#endif
	}

	// Restore rprintf to original position
	rprintfInit(old);
  b8:	c2 01       	movw	r24, r4
  ba:	0e 94 00 00 	call	0	; 0x0 <blackfinGetPixel>
}
  be:	2c 96       	adiw	r28, 0x0c	; 12
  c0:	0f b6       	in	r0, 0x3f	; 63
  c2:	f8 94       	cli
  c4:	de bf       	out	0x3e, r29	; 62
  c6:	0f be       	out	0x3f, r0	; 63
  c8:	cd bf       	out	0x3d, r28	; 61
  ca:	df 91       	pop	r29
  cc:	cf 91       	pop	r28
  ce:	1f 91       	pop	r17
  d0:	0f 91       	pop	r16
  d2:	ff 90       	pop	r15
  d4:	ef 90       	pop	r14
  d6:	df 90       	pop	r13
  d8:	cf 90       	pop	r12
  da:	bf 90       	pop	r11
  dc:	9f 90       	pop	r9
  de:	8f 90       	pop	r8
  e0:	7f 90       	pop	r7
  e2:	6f 90       	pop	r6
  e4:	5f 90       	pop	r5
  e6:	4f 90       	pop	r4
  e8:	08 95       	ret

_camera_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002d2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000306  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000306  2**0
                  ALLOC
  3 .debug_info   00000d30  00000000  00000000  00000306  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000026f  00000000  00000000  00001036  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000898  00000000  00000000  000012a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001b3d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000172  00000000  00000000  00001b5d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004a8  00000000  00000000  00001ccf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000010c  00000000  00000000  00002178  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_cameraInit>:
#include <string.h>

void     _cameraInit(CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	void (*fn)(CAMERA*) = (void (*)(CAMERA*))pgm_read_word(&class->init);
   0:	dc 01       	movw	r26, r24
   2:	ed 91       	ld	r30, X+
   4:	fc 91       	ld	r31, X
   6:	11 97       	sbiw	r26, 0x01	; 1
   8:	25 91       	lpm	r18, Z+
   a:	34 91       	lpm	r19, Z
   c:	f9 01       	movw	r30, r18
	if(fn){
   e:	30 97       	sbiw	r30, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <_cameraInit+0x12>
		fn(camera);
  12:	09 95       	icall
  14:	08 95       	ret

00000016 <_cameraXresolution>:

uint16_t  _cameraXresolution(CAMERA* camera){
	uint16_t rtn = 0;
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->xResolution);
  16:	dc 01       	movw	r26, r24
  18:	ed 91       	ld	r30, X+
  1a:	fc 91       	ld	r31, X
  1c:	11 97       	sbiw	r26, 0x01	; 1
  1e:	32 96       	adiw	r30, 0x02	; 2
  20:	25 91       	lpm	r18, Z+
  22:	34 91       	lpm	r19, Z
  24:	f9 01       	movw	r30, r18
	if(fn){
  26:	30 97       	sbiw	r30, 0x00	; 0
  28:	01 f0       	breq	.+0      	; 0x2a <_cameraXresolution+0x14>
		rtn = fn(camera);
  2a:	09 95       	icall
  2c:	08 95       	ret
		fn(camera);
	}
}

uint16_t  _cameraXresolution(CAMERA* camera){
	uint16_t rtn = 0;
  2e:	80 e0       	ldi	r24, 0x00	; 0
  30:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->xResolution);
	if(fn){
		rtn = fn(camera);
	}
	return rtn;
}
  32:	08 95       	ret

00000034 <_cameraYresolution>:

uint16_t  _cameraYresolution(CAMERA* camera){
	uint16_t rtn = 0;
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->yResolution);
  34:	dc 01       	movw	r26, r24
  36:	ed 91       	ld	r30, X+
  38:	fc 91       	ld	r31, X
  3a:	11 97       	sbiw	r26, 0x01	; 1
  3c:	34 96       	adiw	r30, 0x04	; 4
  3e:	25 91       	lpm	r18, Z+
  40:	34 91       	lpm	r19, Z
  42:	f9 01       	movw	r30, r18
	if(fn){
  44:	30 97       	sbiw	r30, 0x00	; 0
  46:	01 f0       	breq	.+0      	; 0x48 <_cameraYresolution+0x14>
		rtn = fn(camera);
  48:	09 95       	icall
  4a:	08 95       	ret
	}
	return rtn;
}

uint16_t  _cameraYresolution(CAMERA* camera){
	uint16_t rtn = 0;
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t (*fn)(CAMERA*) = (uint16_t (*)(CAMERA*))pgm_read_word(&class->yResolution);
	if(fn){
		rtn = fn(camera);
	}
	return rtn;
}
  50:	08 95       	ret

00000052 <_cameraNumColorBins>:

uint8_t  _cameraNumColorBins(const CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->numColorBins);
  52:	dc 01       	movw	r26, r24
  54:	ed 91       	ld	r30, X+
  56:	fc 91       	ld	r31, X
  58:	11 97       	sbiw	r26, 0x01	; 1
  5a:	36 96       	adiw	r30, 0x06	; 6
  5c:	84 91       	lpm	r24, Z
}
  5e:	08 95       	ret

00000060 <_cameraMaxBlobs>:

uint8_t  _cameraMaxBlobs(const CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->maxBlobs);
  60:	dc 01       	movw	r26, r24
  62:	ed 91       	ld	r30, X+
  64:	fc 91       	ld	r31, X
  66:	11 97       	sbiw	r26, 0x01	; 1
  68:	37 96       	adiw	r30, 0x07	; 7
  6a:	84 91       	lpm	r24, Z
}
  6c:	08 95       	ret

0000006e <_cameraSetBin>:

boolean   _cameraSetBin(CAMERA* camera,uint8_t bin,const COLOR*min, const COLOR*max){
	boolean rtn = FALSE;
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*, uint8_t,const COLOR*,const COLOR*) =
		(boolean (*)(CAMERA*, uint8_t, const COLOR*, const COLOR*))pgm_read_word(&class->setBin);
  6e:	dc 01       	movw	r26, r24
  70:	ed 91       	ld	r30, X+
  72:	fc 91       	ld	r31, X
  74:	38 96       	adiw	r30, 0x08	; 8
  76:	a5 91       	lpm	r26, Z+
  78:	b4 91       	lpm	r27, Z
}

boolean   _cameraSetBin(CAMERA* camera,uint8_t bin,const COLOR*min, const COLOR*max){
	boolean rtn = FALSE;
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*, uint8_t,const COLOR*,const COLOR*) =
  7a:	fd 01       	movw	r30, r26
		(boolean (*)(CAMERA*, uint8_t, const COLOR*, const COLOR*))pgm_read_word(&class->setBin);
	if(fn){
  7c:	10 97       	sbiw	r26, 0x00	; 0
  7e:	01 f0       	breq	.+0      	; 0x80 <_cameraSetBin+0x12>
		rtn = fn(camera,bin,min,max);
  80:	09 95       	icall
  82:	08 95       	ret
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->maxBlobs);
}

boolean   _cameraSetBin(CAMERA* camera,uint8_t bin,const COLOR*min, const COLOR*max){
	boolean rtn = FALSE;
  84:	80 e0       	ldi	r24, 0x00	; 0
		(boolean (*)(CAMERA*, uint8_t, const COLOR*, const COLOR*))pgm_read_word(&class->setBin);
	if(fn){
		rtn = fn(camera,bin,min,max);
	}
	return rtn;
}
  86:	08 95       	ret

00000088 <_cameraGetBlobs>:

uint8_t   _cameraGetBlobs(CAMERA* camera,uint8_t bin){
	uint16_t rtn = 0;
	camera->numBlobs = 0;
  88:	dc 01       	movw	r26, r24
  8a:	1c 96       	adiw	r26, 0x0c	; 12
  8c:	1c 92       	st	X, r1
  8e:	1c 97       	sbiw	r26, 0x0c	; 12

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	uint8_t (*fn)(CAMERA*, uint8_t) = (uint8_t (*)(CAMERA*, uint8_t))pgm_read_word(&class->getBlobs);
  90:	ed 91       	ld	r30, X+
  92:	fc 91       	ld	r31, X
  94:	11 97       	sbiw	r26, 0x01	; 1
  96:	3a 96       	adiw	r30, 0x0a	; 10
  98:	25 91       	lpm	r18, Z+
  9a:	34 91       	lpm	r19, Z
  9c:	f9 01       	movw	r30, r18
	if(fn){
  9e:	30 97       	sbiw	r30, 0x00	; 0
  a0:	01 f0       	breq	.+0      	; 0xa2 <_cameraGetBlobs+0x1a>
		rtn = fn(camera,bin);
  a2:	09 95       	icall
  a4:	08 95       	ret
	}
	return rtn;
}

uint8_t   _cameraGetBlobs(CAMERA* camera,uint8_t bin){
	uint16_t rtn = 0;
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	90 e0       	ldi	r25, 0x00	; 0
	uint8_t (*fn)(CAMERA*, uint8_t) = (uint8_t (*)(CAMERA*, uint8_t))pgm_read_word(&class->getBlobs);
	if(fn){
		rtn = fn(camera,bin);
	}
	return rtn;
}
  aa:	08 95       	ret

000000ac <_cameraGetPixel>:
	boolean rtn = FALSE;

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*,uint16_t,uint16_t,COLOR*) = (boolean (*)(CAMERA*, uint16_t,uint16_t,COLOR*))
		pgm_read_word(&class->getPixel);
  ac:	dc 01       	movw	r26, r24
  ae:	ed 91       	ld	r30, X+
  b0:	fc 91       	ld	r31, X
  b2:	3c 96       	adiw	r30, 0x0c	; 12
  b4:	a5 91       	lpm	r26, Z+
  b6:	b4 91       	lpm	r27, Z
boolean _cameraGetPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
	boolean rtn = FALSE;

	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	boolean (*fn)(CAMERA*,uint16_t,uint16_t,COLOR*) = (boolean (*)(CAMERA*, uint16_t,uint16_t,COLOR*))
  b8:	fd 01       	movw	r30, r26
		pgm_read_word(&class->getPixel);
	if(fn){
  ba:	10 97       	sbiw	r26, 0x00	; 0
  bc:	01 f0       	breq	.+0      	; 0xbe <_cameraGetPixel+0x12>
		rtn = fn(camera,x,y,color);
  be:	09 95       	icall
  c0:	08 95       	ret
	}
	return rtn;
}

boolean _cameraGetPixel(CAMERA* camera,uint16_t x, uint16_t y, COLOR * color){
	boolean rtn = FALSE;
  c2:	80 e0       	ldi	r24, 0x00	; 0
	if(fn){
		rtn = fn(camera,x,y,color);
	}
	return rtn;

}
  c4:	08 95       	ret

000000c6 <_cameraInsertBlob>:



// Library only method to insert a new blob
// This uses an insert sort
void	_cameraInsertBlob(CAMERA* camera, const CAMERA_BLOB* blob){
  c6:	3f 92       	push	r3
  c8:	4f 92       	push	r4
  ca:	5f 92       	push	r5
  cc:	6f 92       	push	r6
  ce:	7f 92       	push	r7
  d0:	8f 92       	push	r8
  d2:	9f 92       	push	r9
  d4:	af 92       	push	r10
  d6:	bf 92       	push	r11
  d8:	cf 92       	push	r12
  da:	df 92       	push	r13
  dc:	ef 92       	push	r14
  de:	ff 92       	push	r15
  e0:	0f 93       	push	r16
  e2:	1f 93       	push	r17
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	7c 01       	movw	r14, r24
  ea:	2b 01       	movw	r4, r22
	uint16_t width = blob->right - blob->left + 1;
  ec:	db 01       	movw	r26, r22
  ee:	12 96       	adiw	r26, 0x02	; 2
  f0:	cd 90       	ld	r12, X+
  f2:	dc 90       	ld	r13, X
  f4:	13 97       	sbiw	r26, 0x03	; 3
  f6:	08 94       	sec
  f8:	c1 1c       	adc	r12, r1
  fa:	d1 1c       	adc	r13, r1
  fc:	8d 91       	ld	r24, X+
  fe:	9c 91       	ld	r25, X
 100:	11 97       	sbiw	r26, 0x01	; 1
 102:	c8 1a       	sub	r12, r24
 104:	d9 0a       	sbc	r13, r25
	uint16_t height = blob->bottom - blob->top + 1;
 106:	16 96       	adiw	r26, 0x06	; 6
 108:	6d 90       	ld	r6, X+
 10a:	7c 90       	ld	r7, X
 10c:	17 97       	sbiw	r26, 0x07	; 7
 10e:	08 94       	sec
 110:	61 1c       	adc	r6, r1
 112:	71 1c       	adc	r7, r1
 114:	14 96       	adiw	r26, 0x04	; 4
 116:	8d 91       	ld	r24, X+
 118:	9c 91       	ld	r25, X
 11a:	15 97       	sbiw	r26, 0x05	; 5
 11c:	68 1a       	sub	r6, r24
 11e:	79 0a       	sbc	r7, r25
	uint32_t pixels = width * height;
 120:	6c 9c       	mul	r6, r12
 122:	c0 01       	movw	r24, r0
 124:	6d 9c       	mul	r6, r13
 126:	90 0d       	add	r25, r0
 128:	7c 9c       	mul	r7, r12
 12a:	90 0d       	add	r25, r0
 12c:	11 24       	eor	r1, r1
 12e:	4c 01       	movw	r8, r24
 130:	aa 24       	eor	r10, r10
 132:	bb 24       	eor	r11, r11
	if(pixels >= camera->minBlobSize && camera->blobs != null){
 134:	f7 01       	movw	r30, r14
 136:	80 85       	ldd	r24, Z+8	; 0x08
 138:	91 85       	ldd	r25, Z+9	; 0x09
 13a:	a2 85       	ldd	r26, Z+10	; 0x0a
 13c:	b3 85       	ldd	r27, Z+11	; 0x0b
 13e:	88 16       	cp	r8, r24
 140:	99 06       	cpc	r9, r25
 142:	aa 06       	cpc	r10, r26
 144:	bb 06       	cpc	r11, r27
 146:	00 f4       	brcc	.+0      	; 0x148 <_cameraInsertBlob+0x82>
 148:	00 c0       	rjmp	.+0      	; 0x14a <_cameraInsertBlob+0x84>
 14a:	26 81       	ldd	r18, Z+6	; 0x06
 14c:	37 81       	ldd	r19, Z+7	; 0x07
 14e:	21 15       	cp	r18, r1
 150:	31 05       	cpc	r19, r1
 152:	01 f4       	brne	.+0      	; 0x154 <_cameraInsertBlob+0x8e>
 154:	00 c0       	rjmp	.+0      	; 0x156 <_cameraInsertBlob+0x90>
}

uint8_t  _cameraMaxBlobs(const CAMERA* camera){
	// Get the method implementation for this class of camera
	const CAMERA_CLASS* class = camera->class;
	return (uint8_t)pgm_read_byte(&class->maxBlobs);
 156:	01 90       	ld	r0, Z+
 158:	f0 81       	ld	r31, Z
 15a:	e0 2d       	mov	r30, r0
 15c:	37 96       	adiw	r30, 0x07	; 7
 15e:	34 90       	lpm	r3, Z
		// Its big enough to be considered
		uint8_t maxBlobs = _cameraMaxBlobs(camera);

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
 160:	d7 01       	movw	r26, r14
 162:	1c 96       	adiw	r26, 0x0c	; 12
 164:	5c 91       	ld	r21, X
 166:	1c 97       	sbiw	r26, 0x0c	; 12
 168:	40 e0       	ldi	r20, 0x00	; 0
 16a:	00 c0       	rjmp	.+0      	; 0x16c <_cameraInsertBlob+0xa6>
 16c:	2f 5e       	subi	r18, 0xEF	; 239
 16e:	3f 4f       	sbci	r19, 0xFF	; 255



// Library only method to insert a new blob
// This uses an insert sort
void	_cameraInsertBlob(CAMERA* camera, const CAMERA_BLOB* blob){
 170:	f9 01       	movw	r30, r18
 172:	35 97       	sbiw	r30, 0x05	; 5
		uint8_t maxBlobs = _cameraMaxBlobs(camera);

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
 174:	80 81       	ld	r24, Z
 176:	91 81       	ldd	r25, Z+1	; 0x01
 178:	a2 81       	ldd	r26, Z+2	; 0x02
 17a:	b3 81       	ldd	r27, Z+3	; 0x03
 17c:	88 15       	cp	r24, r8
 17e:	99 05       	cpc	r25, r9
 180:	aa 05       	cpc	r26, r10
 182:	bb 05       	cpc	r27, r11
 184:	00 f4       	brcc	.+0      	; 0x186 <_cameraInsertBlob+0xc0>
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
 186:	83 2d       	mov	r24, r3
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	01 97       	sbiw	r24, 0x01	; 1
 18c:	25 2f       	mov	r18, r21
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	82 17       	cp	r24, r18
 192:	93 07       	cpc	r25, r19
 194:	04 f4       	brge	.+0      	; 0x196 <_cameraInsertBlob+0xd0>
 196:	9c 01       	movw	r18, r24
				while( last < slot+1){
					memcpy(&camera->blobs[last], &camera->blobs[last-1], sizeof(CAMERA_BLOB));
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	b9 01       	movw	r22, r18
 19c:	e4 e0       	ldi	r30, 0x04	; 4
 19e:	66 0f       	add	r22, r22
 1a0:	77 1f       	adc	r23, r23
 1a2:	ea 95       	dec	r30
 1a4:	01 f4       	brne	.+0      	; 0x1a6 <_cameraInsertBlob+0xe0>
 1a6:	62 0f       	add	r22, r18
 1a8:	73 1f       	adc	r23, r19
 1aa:	c9 01       	movw	r24, r18
 1ac:	01 97       	sbiw	r24, 0x01	; 1
 1ae:	dc 01       	movw	r26, r24
 1b0:	f4 e0       	ldi	r31, 0x04	; 4
 1b2:	aa 0f       	add	r26, r26
 1b4:	bb 1f       	adc	r27, r27
 1b6:	fa 95       	dec	r31
 1b8:	01 f4       	brne	.+0      	; 0x1ba <_cameraInsertBlob+0xf4>
 1ba:	a8 0f       	add	r26, r24
 1bc:	b9 1f       	adc	r27, r25
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
				while( last < slot+1){
 1be:	04 2f       	mov	r16, r20
 1c0:	10 e0       	ldi	r17, 0x00	; 0
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <_cameraInsertBlob+0xfe>
					memcpy(&camera->blobs[last], &camera->blobs[last-1], sizeof(CAMERA_BLOB));
 1c4:	f7 01       	movw	r30, r14
 1c6:	86 81       	ldd	r24, Z+6	; 0x06
 1c8:	97 81       	ldd	r25, Z+7	; 0x07
 1ca:	ec 01       	movw	r28, r24
 1cc:	c6 0f       	add	r28, r22
 1ce:	d7 1f       	adc	r29, r23
 1d0:	fc 01       	movw	r30, r24
 1d2:	ea 0f       	add	r30, r26
 1d4:	fb 1f       	adc	r31, r27
 1d6:	81 e1       	ldi	r24, 0x11	; 17
 1d8:	01 90       	ld	r0, Z+
 1da:	09 92       	st	Y+, r0
 1dc:	81 50       	subi	r24, 0x01	; 1
 1de:	01 f4       	brne	.+0      	; 0x1e0 <_cameraInsertBlob+0x11a>
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
			if(camera->blobs[slot].pixels < pixels){
				// insert it here
				uint8_t last = MIN(camera->numBlobs, maxBlobs -1);
				while( last < slot+1){
 1e0:	02 17       	cp	r16, r18
 1e2:	13 07       	cpc	r17, r19
 1e4:	04 f4       	brge	.+0      	; 0x1e6 <_cameraInsertBlob+0x120>
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <_cameraInsertBlob+0x122>
		// Its big enough to be considered
		uint8_t maxBlobs = _cameraMaxBlobs(camera);

		uint8_t slot;
		// Find the position to insert it
		for(slot = 0; slot < camera->numBlobs; slot++){
 1e8:	4f 5f       	subi	r20, 0xFF	; 255
 1ea:	45 17       	cp	r20, r21
 1ec:	01 f0       	breq	.+0      	; 0x1ee <_cameraInsertBlob+0x128>
 1ee:	00 c0       	rjmp	.+0      	; 0x1f0 <_cameraInsertBlob+0x12a>
				break;
			}
		}

		// set variables at blob[slot]
		if(slot < maxBlobs){
 1f0:	43 15       	cp	r20, r3
 1f2:	00 f0       	brcs	.+0      	; 0x1f4 <_cameraInsertBlob+0x12e>
 1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <_cameraInsertBlob+0x130>
			CAMERA_BLOB* dest = &camera->blobs[slot];
 1f6:	84 2f       	mov	r24, r20
 1f8:	90 e0       	ldi	r25, 0x00	; 0
 1fa:	9c 01       	movw	r18, r24
 1fc:	54 e0       	ldi	r21, 0x04	; 4
 1fe:	22 0f       	add	r18, r18
 200:	33 1f       	adc	r19, r19
 202:	5a 95       	dec	r21
 204:	01 f4       	brne	.+0      	; 0x206 <_cameraInsertBlob+0x140>
 206:	28 0f       	add	r18, r24
 208:	39 1f       	adc	r19, r25
 20a:	d7 01       	movw	r26, r14
 20c:	16 96       	adiw	r26, 0x06	; 6
 20e:	0d 91       	ld	r16, X+
 210:	1c 91       	ld	r17, X
 212:	17 97       	sbiw	r26, 0x07	; 7
 214:	02 0f       	add	r16, r18
 216:	13 1f       	adc	r17, r19
			memcpy(dest, blob, sizeof(CAMERA_BLOB));
 218:	d8 01       	movw	r26, r16
 21a:	f2 01       	movw	r30, r4
 21c:	81 e1       	ldi	r24, 0x11	; 17
 21e:	01 90       	ld	r0, Z+
 220:	0d 92       	st	X+, r0
 222:	81 50       	subi	r24, 0x01	; 1
 224:	01 f4       	brne	.+0      	; 0x226 <_cameraInsertBlob+0x160>
			dest->pixels = pixels;
 226:	f8 01       	movw	r30, r16
 228:	84 86       	std	Z+12, r8	; 0x0c
 22a:	95 86       	std	Z+13, r9	; 0x0d
 22c:	a6 86       	std	Z+14, r10	; 0x0e
 22e:	b7 86       	std	Z+15, r11	; 0x0f
			dest->xCenter = (width / 2) + dest->left - (_cameraXresolution(camera) / 2);
 230:	e6 01       	movw	r28, r12
 232:	d6 95       	lsr	r29
 234:	c7 95       	ror	r28
 236:	80 81       	ld	r24, Z
 238:	91 81       	ldd	r25, Z+1	; 0x01
 23a:	c8 0f       	add	r28, r24
 23c:	d9 1f       	adc	r29, r25
 23e:	c7 01       	movw	r24, r14
 240:	0e 94 00 00 	call	0	; 0x0 <_cameraInit>
 244:	96 95       	lsr	r25
 246:	87 95       	ror	r24
 248:	c8 1b       	sub	r28, r24
 24a:	d9 0b       	sbc	r29, r25
 24c:	d8 01       	movw	r26, r16
 24e:	19 96       	adiw	r26, 0x09	; 9
 250:	dc 93       	st	X, r29
 252:	ce 93       	st	-X, r28
 254:	18 97       	sbiw	r26, 0x08	; 8
			dest->yCenter = (height / 2) + dest->top - (_cameraYresolution(camera) / 2);
 256:	e3 01       	movw	r28, r6
 258:	d6 95       	lsr	r29
 25a:	c7 95       	ror	r28
 25c:	14 96       	adiw	r26, 0x04	; 4
 25e:	8d 91       	ld	r24, X+
 260:	9c 91       	ld	r25, X
 262:	15 97       	sbiw	r26, 0x05	; 5
 264:	c8 0f       	add	r28, r24
 266:	d9 1f       	adc	r29, r25
 268:	c7 01       	movw	r24, r14
 26a:	0e 94 00 00 	call	0	; 0x0 <_cameraInit>
 26e:	96 95       	lsr	r25
 270:	87 95       	ror	r24
			dest->yCenter *= -1;
 272:	8c 1b       	sub	r24, r28
 274:	9d 0b       	sbc	r25, r29
 276:	f8 01       	movw	r30, r16
 278:	93 87       	std	Z+11, r25	; 0x0b
 27a:	82 87       	std	Z+10, r24	; 0x0a

			if(camera->numBlobs < maxBlobs){
 27c:	d7 01       	movw	r26, r14
 27e:	1c 96       	adiw	r26, 0x0c	; 12
 280:	8c 91       	ld	r24, X
 282:	1c 97       	sbiw	r26, 0x0c	; 12
 284:	83 15       	cp	r24, r3
 286:	00 f4       	brcc	.+0      	; 0x288 <_cameraInsertBlob+0x1c2>
				camera->numBlobs++;
 288:	8f 5f       	subi	r24, 0xFF	; 255
 28a:	1c 96       	adiw	r26, 0x0c	; 12
 28c:	8c 93       	st	X, r24
 28e:	1c 97       	sbiw	r26, 0x0c	; 12
			}
		}
	}
}
 290:	df 91       	pop	r29
 292:	cf 91       	pop	r28
 294:	1f 91       	pop	r17
 296:	0f 91       	pop	r16
 298:	ff 90       	pop	r15
 29a:	ef 90       	pop	r14
 29c:	df 90       	pop	r13
 29e:	cf 90       	pop	r12
 2a0:	bf 90       	pop	r11
 2a2:	af 90       	pop	r10
 2a4:	9f 90       	pop	r9
 2a6:	8f 90       	pop	r8
 2a8:	7f 90       	pop	r7
 2aa:	6f 90       	pop	r6
 2ac:	5f 90       	pop	r5
 2ae:	4f 90       	pop	r4
 2b0:	3f 90       	pop	r3
 2b2:	08 95       	ret

000002b4 <_cameraFetchBlob>:



const CAMERA_BLOB* _cameraFetchBlob(const CAMERA* camera, uint8_t blobNo){
	return &camera->blobs[blobNo];
 2b4:	70 e0       	ldi	r23, 0x00	; 0
 2b6:	9b 01       	movw	r18, r22
 2b8:	a4 e0       	ldi	r26, 0x04	; 4
 2ba:	22 0f       	add	r18, r18
 2bc:	33 1f       	adc	r19, r19
 2be:	aa 95       	dec	r26
 2c0:	01 f4       	brne	.+0      	; 0x2c2 <_cameraFetchBlob+0xe>
 2c2:	26 0f       	add	r18, r22
 2c4:	37 1f       	adc	r19, r23
 2c6:	fc 01       	movw	r30, r24
 2c8:	86 81       	ldd	r24, Z+6	; 0x06
 2ca:	97 81       	ldd	r25, Z+7	; 0x07
 2cc:	82 0f       	add	r24, r18
 2ce:	93 1f       	adc	r25, r19
}
 2d0:	08 95       	ret

Sabertooth.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000282  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002b6  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000002b6  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000b13  00000000  00000000  000002ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000028b  00000000  00000000  00000dcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000004c3  00000000  00000000  00001058  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000151b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000030  00000000  00000000  0000153b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001c9  00000000  00000000  0000156b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000005bd  00000000  00000000  00001734  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000c0  00000000  00000000  00001cf4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__saberOutput>:

#include "../../core.h"
#include "../../timer.h"

// speed is 0 to 127
static void __saberOutput(SABERTOOTH_MOTOR* remote, boolean fwd, uint8_t speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	06 2f       	mov	r16, r22
  12:	d4 2e       	mov	r13, r20

	UART* uart = remote->driver->uart;
  14:	ee 81       	ldd	r30, Y+6	; 0x06
  16:	ff 81       	ldd	r31, Y+7	; 0x07
  18:	e2 80       	ldd	r14, Z+2	; 0x02
  1a:	f3 80       	ldd	r15, Z+3	; 0x03

	switch(remote->driver->mode){
  1c:	80 85       	ldd	r24, Z+8	; 0x08
  1e:	88 23       	and	r24, r24
  20:	01 f0       	breq	.+0      	; 0x22 <__saberOutput+0x22>
  22:	81 30       	cpi	r24, 0x01	; 1
  24:	01 f0       	breq	.+0      	; 0x26 <__saberOutput+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <__saberOutput+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <__saberOutput+0x2a>
		case PACKETIZED:{
			uint8_t checksum=0;
			checksum += _uartSendByte(uart,remote->address);
  2a:	c7 01       	movw	r24, r14
  2c:	6c 81       	ldd	r22, Y+4	; 0x04
  2e:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  32:	18 2f       	mov	r17, r24

			uint8_t cmd;
			if(remote->motorNumber==1){
  34:	8d 81       	ldd	r24, Y+5	; 0x05
  36:	81 30       	cpi	r24, 0x01	; 1
  38:	01 f4       	brne	.+0      	; 0x3a <__saberOutput+0x3a>
				// motor 1
				cmd = (fwd) ? 0 : 1;
  3a:	61 e0       	ldi	r22, 0x01	; 1
  3c:	00 23       	and	r16, r16
  3e:	01 f0       	breq	.+0      	; 0x40 <__saberOutput+0x40>
  40:	60 e0       	ldi	r22, 0x00	; 0
  42:	00 c0       	rjmp	.+0      	; 0x44 <__saberOutput+0x44>
			}else{
				// motor 2
				cmd = (fwd) ? 4 : 5;
  44:	00 23       	and	r16, r16
  46:	01 f0       	breq	.+0      	; 0x48 <__saberOutput+0x48>
  48:	64 e0       	ldi	r22, 0x04	; 4
  4a:	00 c0       	rjmp	.+0      	; 0x4c <__saberOutput+0x4c>
  4c:	65 e0       	ldi	r22, 0x05	; 5
			}
			checksum += _uartSendByte(uart,cmd);
  4e:	c7 01       	movw	r24, r14
  50:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  54:	c8 2f       	mov	r28, r24

			checksum += _uartSendByte(uart,speed);
  56:	c7 01       	movw	r24, r14
  58:	6d 2d       	mov	r22, r13
  5a:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
				cmd = (fwd) ? 0 : 1;
			}else{
				// motor 2
				cmd = (fwd) ? 4 : 5;
			}
			checksum += _uartSendByte(uart,cmd);
  5e:	6c 2f       	mov	r22, r28
  60:	68 0f       	add	r22, r24

			checksum += _uartSendByte(uart,speed);
  62:	61 0f       	add	r22, r17

			_uartSendByte(uart, (checksum &0x7FU));
  64:	6f 77       	andi	r22, 0x7F	; 127
  66:	00 c0       	rjmp	.+0      	; 0x68 <__saberOutput+0x68>
		}
		break;

		case SIMPLE:{
			if(remote->motorNumber==1){
  68:	8d 81       	ldd	r24, Y+5	; 0x05
  6a:	81 30       	cpi	r24, 0x01	; 1
  6c:	01 f4       	brne	.+0      	; 0x6e <__saberOutput+0x6e>
				// 1 is full reverse, 64 is stop, 127 is full fwd
				speed = interpolate(speed, 0, 127, 64 , (fwd) ? 127 : 1);
  6e:	66 23       	and	r22, r22
  70:	01 f0       	breq	.+0      	; 0x72 <__saberOutput+0x72>
  72:	0f e7       	ldi	r16, 0x7F	; 127
  74:	10 e0       	ldi	r17, 0x00	; 0
  76:	00 c0       	rjmp	.+0      	; 0x78 <__saberOutput+0x78>
  78:	01 e0       	ldi	r16, 0x01	; 1
  7a:	10 e0       	ldi	r17, 0x00	; 0
  7c:	8d 2d       	mov	r24, r13
  7e:	90 e0       	ldi	r25, 0x00	; 0
  80:	60 e0       	ldi	r22, 0x00	; 0
  82:	70 e0       	ldi	r23, 0x00	; 0
  84:	4f e7       	ldi	r20, 0x7F	; 127
  86:	50 e0       	ldi	r21, 0x00	; 0
  88:	20 e4       	ldi	r18, 0x40	; 64
  8a:	30 e0       	ldi	r19, 0x00	; 0
  8c:	00 c0       	rjmp	.+0      	; 0x8e <__saberOutput+0x8e>
			}else{
				// 128 is full reverse, 192 is stop, 255 is full fwd
				speed = interpolate(speed, 0, 127, 192 , (fwd) ? 255 : 128);
  8e:	66 23       	and	r22, r22
  90:	01 f0       	breq	.+0      	; 0x92 <__saberOutput+0x92>
  92:	0f ef       	ldi	r16, 0xFF	; 255
  94:	10 e0       	ldi	r17, 0x00	; 0
  96:	00 c0       	rjmp	.+0      	; 0x98 <__saberOutput+0x98>
  98:	00 e8       	ldi	r16, 0x80	; 128
  9a:	10 e0       	ldi	r17, 0x00	; 0
  9c:	8d 2d       	mov	r24, r13
  9e:	90 e0       	ldi	r25, 0x00	; 0
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	70 e0       	ldi	r23, 0x00	; 0
  a4:	4f e7       	ldi	r20, 0x7F	; 127
  a6:	50 e0       	ldi	r21, 0x00	; 0
  a8:	20 ec       	ldi	r18, 0xC0	; 192
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  b0:	68 2f       	mov	r22, r24
			}
			_uartSendByte(uart, speed);
  b2:	c7 01       	movw	r24, r14
  b4:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		}
		break;
	}
}
  b8:	df 91       	pop	r29
  ba:	cf 91       	pop	r28
  bc:	1f 91       	pop	r17
  be:	0f 91       	pop	r16
  c0:	ff 90       	pop	r15
  c2:	ef 90       	pop	r14
  c4:	df 90       	pop	r13
  c6:	08 95       	ret

000000c8 <setConnected>:

static void setConnected(__ACTUATOR *actuator, boolean connected){
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(connected){
  c8:	66 23       	and	r22, r22
  ca:	01 f0       	breq	.+0      	; 0xcc <setConnected+0x4>
		motor->actuator.class=&c_Sabertooth;
		motor->driver = driver;
		act_setSpeed(motor,0);
		act_setConnected(motor,TRUE);
	}
}
  cc:	fc 01       	movw	r30, r24
  ce:	62 81       	ldd	r22, Z+2	; 0x02

static void setConnected(__ACTUATOR *actuator, boolean connected){
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(connected){
		DRIVE_SPEED speed = act_getSpeed(remote);
		actuator->required_speed=-128;
  d0:	20 e8       	ldi	r18, 0x80	; 128
  d2:	22 83       	std	Z+2, r18	; 0x02
		act_setSpeed(remote, speed);
  d4:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  d8:	08 95       	ret
	}else{
		// Set speed = 0 in forwards to coast
		__saberOutput(remote, TRUE, 0);
  da:	6f ef       	ldi	r22, 0xFF	; 255
  dc:	40 e0       	ldi	r20, 0x00	; 0
  de:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
  e2:	08 95       	ret

000000e4 <setSpeed>:
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  e4:	0f 93       	push	r16
  e6:	1f 93       	push	r17
  e8:	cf 93       	push	r28
  ea:	df 93       	push	r29
  ec:	ec 01       	movw	r28, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  ee:	8b 81       	ldd	r24, Y+3	; 0x03
  f0:	80 ff       	sbrs	r24, 0
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <setSpeed+0x10>
	SABERTOOTH_MOTOR* remote = (SABERTOOTH_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
  f4:	8a 81       	ldd	r24, Y+2	; 0x02
  f6:	86 17       	cp	r24, r22
  f8:	01 f0       	breq	.+0      	; 0xfa <setSpeed+0x16>
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);
  fa:	86 2f       	mov	r24, r22
  fc:	99 27       	eor	r25, r25
  fe:	87 fd       	sbrc	r24, 7
 100:	90 95       	com	r25
 102:	61 e8       	ldi	r22, 0x81	; 129
 104:	7f ef       	ldi	r23, 0xFF	; 255
 106:	4f e7       	ldi	r20, 0x7F	; 127
 108:	50 e0       	ldi	r21, 0x00	; 0
 10a:	21 e8       	ldi	r18, 0x81	; 129
 10c:	3f ef       	ldi	r19, 0xFF	; 255
 10e:	0f e7       	ldi	r16, 0x7F	; 127
 110:	10 e0       	ldi	r17, 0x00	; 0
 112:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
 116:	48 2f       	mov	r20, r24

		// If speed is 0 then set reverse to brake
		boolean fwd=TRUE;
		if(s <= 0){
 118:	18 16       	cp	r1, r24
 11a:	04 f0       	brlt	.+0      	; 0x11c <setSpeed+0x38>
			s = -s;
 11c:	41 95       	neg	r20
			fwd = FALSE;
 11e:	60 e0       	ldi	r22, 0x00	; 0
 120:	00 c0       	rjmp	.+0      	; 0x122 <setSpeed+0x3e>
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);

		// If speed is 0 then set reverse to brake
		boolean fwd=TRUE;
 122:	6f ef       	ldi	r22, 0xFF	; 255
		if(s <= 0){
			s = -s;
			fwd = FALSE;
		}

		__saberOutput(remote, fwd,s);
 124:	ce 01       	movw	r24, r28
 126:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
	}
}
 12a:	df 91       	pop	r29
 12c:	cf 91       	pop	r28
 12e:	1f 91       	pop	r17
 130:	0f 91       	pop	r16
 132:	08 95       	ret

00000134 <sabertoothInit>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 134:	af 92       	push	r10
 136:	bf 92       	push	r11
 138:	cf 92       	push	r12
 13a:	df 92       	push	r13
 13c:	ef 92       	push	r14
 13e:	ff 92       	push	r15
 140:	0f 93       	push	r16
 142:	1f 93       	push	r17
 144:	cf 93       	push	r28
 146:	df 93       	push	r29
 148:	8c 01       	movw	r16, r24


	switch(driver->mode){
 14a:	dc 01       	movw	r26, r24
 14c:	18 96       	adiw	r26, 0x08	; 8
 14e:	8c 91       	ld	r24, X
 150:	18 97       	sbiw	r26, 0x08	; 8
 152:	88 23       	and	r24, r24
 154:	01 f0       	breq	.+0      	; 0x156 <sabertoothInit+0x22>
 156:	81 30       	cpi	r24, 0x01	; 1
 158:	01 f0       	breq	.+0      	; 0x15a <sabertoothInit+0x26>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <sabertoothInit+0x28>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <sabertoothInit+0x2a>
		case PACKETIZED:{
			// Pause for 2s from power on
			delay_ms(2000);
 15e:	60 ed       	ldi	r22, 0xD0	; 208
 160:	77 e0       	ldi	r23, 0x07	; 7
 162:	80 e0       	ldi	r24, 0x00	; 0
 164:	90 e0       	ldi	r25, 0x00	; 0
 166:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			// Set baud rate
			_uartInit(driver->uart,driver->baudRate);
 16a:	f8 01       	movw	r30, r16
 16c:	44 81       	ldd	r20, Z+4	; 0x04
 16e:	55 81       	ldd	r21, Z+5	; 0x05
 170:	66 81       	ldd	r22, Z+6	; 0x06
 172:	77 81       	ldd	r23, Z+7	; 0x07
 174:	82 81       	ldd	r24, Z+2	; 0x02
 176:	93 81       	ldd	r25, Z+3	; 0x03
 178:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			// send bauding character
			_uartSendByte(driver->uart,0xaa);
 17c:	d8 01       	movw	r26, r16
 17e:	12 96       	adiw	r26, 0x02	; 2
 180:	8d 91       	ld	r24, X+
 182:	9c 91       	ld	r25, X
 184:	13 97       	sbiw	r26, 0x03	; 3
 186:	6a ea       	ldi	r22, 0xAA	; 170
 188:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 18c:	64 e1       	ldi	r22, 0x14	; 20
 18e:	70 e0       	ldi	r23, 0x00	; 0
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 198:	f8 01       	movw	r30, r16
 19a:	82 81       	ldd	r24, Z+2	; 0x02
 19c:	93 81       	ldd	r25, Z+3	; 0x03
 19e:	6a ea       	ldi	r22, 0xAA	; 170
 1a0:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1a4:	64 e1       	ldi	r22, 0x14	; 20
 1a6:	70 e0       	ldi	r23, 0x00	; 0
 1a8:	80 e0       	ldi	r24, 0x00	; 0
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1b0:	d8 01       	movw	r26, r16
 1b2:	12 96       	adiw	r26, 0x02	; 2
 1b4:	8d 91       	ld	r24, X+
 1b6:	9c 91       	ld	r25, X
 1b8:	13 97       	sbiw	r26, 0x03	; 3
 1ba:	6a ea       	ldi	r22, 0xAA	; 170
 1bc:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1c0:	64 e1       	ldi	r22, 0x14	; 20
 1c2:	70 e0       	ldi	r23, 0x00	; 0
 1c4:	80 e0       	ldi	r24, 0x00	; 0
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1cc:	f8 01       	movw	r30, r16
 1ce:	82 81       	ldd	r24, Z+2	; 0x02
 1d0:	93 81       	ldd	r25, Z+3	; 0x03
 1d2:	6a ea       	ldi	r22, 0xAA	; 170
 1d4:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1d8:	64 e1       	ldi	r22, 0x14	; 20
 1da:	70 e0       	ldi	r23, 0x00	; 0
 1dc:	80 e0       	ldi	r24, 0x00	; 0
 1de:	90 e0       	ldi	r25, 0x00	; 0
 1e0:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			_uartSendByte(driver->uart,0xaa);
 1e4:	d8 01       	movw	r26, r16
 1e6:	12 96       	adiw	r26, 0x02	; 2
 1e8:	8d 91       	ld	r24, X+
 1ea:	9c 91       	ld	r25, X
 1ec:	13 97       	sbiw	r26, 0x03	; 3
 1ee:	6a ea       	ldi	r22, 0xAA	; 170
 1f0:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
			delay_ms(20);
 1f4:	64 e1       	ldi	r22, 0x14	; 20
 1f6:	70 e0       	ldi	r23, 0x00	; 0
 1f8:	80 e0       	ldi	r24, 0x00	; 0
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 200:	ee 24       	eor	r14, r14
 202:	ff 24       	eor	r15, r15
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
		SABERTOOTH_MOTOR* motor = (SABERTOOTH_MOTOR*)pgm_read_word(&driver->motors[i]);
		motor->actuator.class=&c_Sabertooth;
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	a3 2e       	mov	r10, r19
 208:	30 e0       	ldi	r19, 0x00	; 0
 20a:	b3 2e       	mov	r11, r19
 20c:	00 c0       	rjmp	.+0      	; 0x20e <sabertoothInit+0xda>
			_uartSendByte(driver->uart,0xaa);
			delay_ms(20);
		}
		break;
		case SIMPLE:{
			_uartInit(driver->uart,driver->baudRate);
 20e:	f8 01       	movw	r30, r16
 210:	44 81       	ldd	r20, Z+4	; 0x04
 212:	55 81       	ldd	r21, Z+5	; 0x05
 214:	66 81       	ldd	r22, Z+6	; 0x06
 216:	77 81       	ldd	r23, Z+7	; 0x07
 218:	82 81       	ldd	r24, Z+2	; 0x02
 21a:	93 81       	ldd	r25, Z+3	; 0x03
 21c:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		}
		break;
 220:	00 c0       	rjmp	.+0      	; 0x222 <sabertoothInit+0xee>

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Sabertooth = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);


void sabertoothInit(SABERTOOTH_DRIVER* driver){
 222:	c7 01       	movw	r24, r14
 224:	88 0f       	add	r24, r24
 226:	99 1f       	adc	r25, r25
		break;
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
		SABERTOOTH_MOTOR* motor = (SABERTOOTH_MOTOR*)pgm_read_word(&driver->motors[i]);
 228:	d8 01       	movw	r26, r16
 22a:	ed 91       	ld	r30, X+
 22c:	fc 91       	ld	r31, X
 22e:	e8 0f       	add	r30, r24
 230:	f9 1f       	adc	r31, r25
 232:	c5 90       	lpm	r12, Z+
 234:	d4 90       	lpm	r13, Z
 236:	cc 2d       	mov	r28, r12
 238:	dd 2d       	mov	r29, r13
		motor->actuator.class=&c_Sabertooth;
 23a:	b9 82       	std	Y+1, r11	; 0x01
 23c:	a8 82       	st	Y, r10
		motor->driver = driver;
 23e:	1f 83       	std	Y+7, r17	; 0x07
 240:	0e 83       	std	Y+6, r16	; 0x06
		act_setSpeed(motor,0);
 242:	8c 2d       	mov	r24, r12
 244:	9d 2d       	mov	r25, r13
 246:	60 e0       	ldi	r22, 0x00	; 0
 248:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		act_setConnected(motor,TRUE);
 24c:	8c 2d       	mov	r24, r12
 24e:	9d 2d       	mov	r25, r13
 250:	6f ef       	ldi	r22, 0xFF	; 255
 252:	0e 94 00 00 	call	0	; 0x0 <__saberOutput>
		}
		break;
	}

	// set each motor to stop
	for(int i=0;i<driver->numMotors;i++){
 256:	08 94       	sec
 258:	e1 1c       	adc	r14, r1
 25a:	f1 1c       	adc	r15, r1
 25c:	d8 01       	movw	r26, r16
 25e:	19 96       	adiw	r26, 0x09	; 9
 260:	8c 91       	ld	r24, X
 262:	19 97       	sbiw	r26, 0x09	; 9
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	e8 16       	cp	r14, r24
 268:	f9 06       	cpc	r15, r25
 26a:	04 f0       	brlt	.+0      	; 0x26c <sabertoothInit+0x138>
		motor->actuator.class=&c_Sabertooth;
		motor->driver = driver;
		act_setSpeed(motor,0);
		act_setConnected(motor,TRUE);
	}
}
 26c:	df 91       	pop	r29
 26e:	cf 91       	pop	r28
 270:	1f 91       	pop	r17
 272:	0f 91       	pop	r16
 274:	ff 90       	pop	r15
 276:	ef 90       	pop	r14
 278:	df 90       	pop	r13
 27a:	cf 90       	pop	r12
 27c:	bf 90       	pop	r11
 27e:	af 90       	pop	r10
 280:	08 95       	ret

L293D.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000376  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003aa  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003aa  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000932  00000000  00000000  000003ae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000254  00000000  00000000  00000ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000063f  00000000  00000000  00000f34  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001573  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000058  00000000  00000000  00001593  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000014d  00000000  00000000  000015eb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000627  00000000  00000000  00001738  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000f8  00000000  00000000  00001d60  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	8c 01       	movw	r16, r24
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  10:	fc 01       	movw	r30, r24
  12:	84 81       	ldd	r24, Z+4	; 0x04
  14:	95 81       	ldd	r25, Z+5	; 0x05
  16:	69 83       	std	Y+1, r22	; 0x01
  18:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	// reverts to default output logic level of low
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  1c:	69 81       	ldd	r22, Y+1	; 0x01
  1e:	66 23       	and	r22, r22
  20:	01 f0       	breq	.+0      	; 0x22 <setConnected+0x22>
  22:	62 e0       	ldi	r22, 0x02	; 2
  24:	00 c0       	rjmp	.+0      	; 0x26 <setConnected+0x26>
  26:	60 e0       	ldi	r22, 0x00	; 0
  28:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	pin_make_output(motor->direction1,FALSE);
  2c:	f8 01       	movw	r30, r16
  2e:	86 81       	ldd	r24, Z+6	; 0x06
  30:	97 81       	ldd	r25, Z+7	; 0x07
  32:	60 e0       	ldi	r22, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  38:	0f 90       	pop	r0
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	1f 91       	pop	r17
  40:	0f 91       	pop	r16
  42:	08 95       	ret

00000044 <setSpeed>:
#include "../timer.h"
#include "../core.h"


// Call back - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  44:	af 92       	push	r10
  46:	bf 92       	push	r11
  48:	cf 92       	push	r12
  4a:	df 92       	push	r13
  4c:	ef 92       	push	r14
  4e:	ff 92       	push	r15
  50:	0f 93       	push	r16
  52:	1f 93       	push	r17
  54:	cf 93       	push	r28
  56:	df 93       	push	r29
  58:	0f 92       	push	r0
  5a:	cd b7       	in	r28, 0x3d	; 61
  5c:	de b7       	in	r29, 0x3e	; 62
  5e:	7c 01       	movw	r14, r24
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  60:	fc 01       	movw	r30, r24
  62:	84 81       	ldd	r24, Z+4	; 0x04
  64:	95 81       	ldd	r25, Z+5	; 0x05
  66:	69 83       	std	Y+1, r22	; 0x01
  68:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  6c:	5c 01       	movw	r10, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  6e:	fc 01       	movw	r30, r24
  70:	32 96       	adiw	r30, 0x02	; 2
  72:	e4 91       	lpm	r30, Z
  74:	f0 e0       	ldi	r31, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
  76:	2c e2       	ldi	r18, 0x2C	; 44
  78:	30 e0       	ldi	r19, 0x00	; 0
  7a:	e2 9f       	mul	r30, r18
  7c:	c0 01       	movw	r24, r0
  7e:	e3 9f       	mul	r30, r19
  80:	90 0d       	add	r25, r0
  82:	f2 9f       	mul	r31, r18
  84:	90 0d       	add	r25, r0
  86:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  88:	80 50       	subi	r24, 0x00	; 0
  8a:	90 40       	sbci	r25, 0x00	; 0
  8c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  90:	6c 01       	movw	r12, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  92:	69 81       	ldd	r22, Y+1	; 0x01
  94:	16 16       	cp	r1, r22
  96:	04 f4       	brge	.+0      	; 0x98 <setSpeed+0x54>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  98:	86 2f       	mov	r24, r22
  9a:	99 27       	eor	r25, r25
  9c:	87 fd       	sbrc	r24, 7
  9e:	90 95       	com	r25
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	70 e0       	ldi	r23, 0x00	; 0
  a4:	4f e7       	ldi	r20, 0x7F	; 127
  a6:	50 e0       	ldi	r21, 0x00	; 0
  a8:	20 e0       	ldi	r18, 0x00	; 0
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	86 01       	movw	r16, r12
  ae:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  b2:	8c 01       	movw	r16, r24

		if(motor->direction2==null){
  b4:	f7 01       	movw	r30, r14
  b6:	80 85       	ldd	r24, Z+8	; 0x08
  b8:	91 85       	ldd	r25, Z+9	; 0x09
  ba:	00 97       	sbiw	r24, 0x00	; 0
  bc:	01 f4       	brne	.+0      	; 0xbe <setSpeed+0x7a>
			// one wire so delay = top - delay
			delay = top - delay;
  be:	c6 01       	movw	r24, r12
  c0:	80 1b       	sub	r24, r16
  c2:	91 0b       	sbc	r25, r17
  c4:	8c 01       	movw	r16, r24
		}

		// Set direction1 high, direction2 low (if there is one)
		pin_make_output(motor->direction1,TRUE);
  c6:	f7 01       	movw	r30, r14
  c8:	86 81       	ldd	r24, Z+6	; 0x06
  ca:	97 81       	ldd	r25, Z+7	; 0x07
  cc:	6f ef       	ldi	r22, 0xFF	; 255
  ce:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,FALSE);
  d2:	f7 01       	movw	r30, r14
  d4:	80 85       	ldd	r24, Z+8	; 0x08
  d6:	91 85       	ldd	r25, Z+9	; 0x09
  d8:	60 e0       	ldi	r22, 0x00	; 0
  da:	00 c0       	rjmp	.+0      	; 0xdc <setSpeed+0x98>
	}else if(speed < 0){
  dc:	66 23       	and	r22, r22
  de:	01 f0       	breq	.+0      	; 0xe0 <setSpeed+0x9c>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  e0:	86 2f       	mov	r24, r22
  e2:	99 27       	eor	r25, r25
  e4:	87 fd       	sbrc	r24, 7
  e6:	90 95       	com	r25
  e8:	60 e0       	ldi	r22, 0x00	; 0
  ea:	70 e0       	ldi	r23, 0x00	; 0
  ec:	41 e8       	ldi	r20, 0x81	; 129
  ee:	5f ef       	ldi	r21, 0xFF	; 255
  f0:	20 e0       	ldi	r18, 0x00	; 0
  f2:	30 e0       	ldi	r19, 0x00	; 0
  f4:	86 01       	movw	r16, r12
  f6:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  fa:	8c 01       	movw	r16, r24

		// Set direction1 low, direction2 high (if there is one)
		pin_make_output(motor->direction1,FALSE);
  fc:	f7 01       	movw	r30, r14
  fe:	86 81       	ldd	r24, Z+6	; 0x06
 100:	97 81       	ldd	r25, Z+7	; 0x07
 102:	60 e0       	ldi	r22, 0x00	; 0
 104:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,TRUE);
 108:	f7 01       	movw	r30, r14
 10a:	80 85       	ldd	r24, Z+8	; 0x08
 10c:	91 85       	ldd	r25, Z+9	; 0x09
 10e:	6f ef       	ldi	r22, 0xFF	; 255
 110:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 114:	00 c0       	rjmp	.+0      	; 0x116 <setSpeed+0xd2>
	}else{
		// brake
		if(motor->direction2){
 116:	f7 01       	movw	r30, r14
 118:	80 85       	ldd	r24, Z+8	; 0x08
 11a:	91 85       	ldd	r25, Z+9	; 0x09
 11c:	26 81       	ldd	r18, Z+6	; 0x06
 11e:	37 81       	ldd	r19, Z+7	; 0x07
 120:	00 97       	sbiw	r24, 0x00	; 0
 122:	01 f0       	breq	.+0      	; 0x124 <setSpeed+0xe0>
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
 124:	c9 01       	movw	r24, r18
 126:	60 e0       	ldi	r22, 0x00	; 0
 128:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2,FALSE);
 12c:	f7 01       	movw	r30, r14
 12e:	80 85       	ldd	r24, Z+8	; 0x08
 130:	91 85       	ldd	r25, Z+9	; 0x09
 132:	60 e0       	ldi	r22, 0x00	; 0
 134:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			delay = top; // full speed brake
 138:	86 01       	movw	r16, r12
 13a:	00 c0       	rjmp	.+0      	; 0x13c <setSpeed+0xf8>
		}else{
			// Only has one direction pin
			// Set direction1 low
			pin_make_output(motor->direction1,FALSE);
 13c:	c9 01       	movw	r24, r18
 13e:	60 e0       	ldi	r22, 0x00	; 0
 140:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
	const Timer* timer = compareGetTimer(channel);
	uint16_t top = timerGetTOP(timer);

	// New compare threshold
	uint16_t delay=0;
 144:	00 e0       	ldi	r16, 0x00	; 0
 146:	10 e0       	ldi	r17, 0x00	; 0
			// ie both low = brake
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
 148:	c5 01       	movw	r24, r10
 14a:	b8 01       	movw	r22, r16
 14c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
 150:	0f 90       	pop	r0
 152:	df 91       	pop	r29
 154:	cf 91       	pop	r28
 156:	1f 91       	pop	r17
 158:	0f 91       	pop	r16
 15a:	ff 90       	pop	r15
 15c:	ef 90       	pop	r14
 15e:	df 90       	pop	r13
 160:	cf 90       	pop	r12
 162:	bf 90       	pop	r11
 164:	af 90       	pop	r10
 166:	08 95       	ret

00000168 <motorL293Init>:


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 168:	2f 92       	push	r2
 16a:	3f 92       	push	r3
 16c:	4f 92       	push	r4
 16e:	5f 92       	push	r5
 170:	6f 92       	push	r6
 172:	7f 92       	push	r7
 174:	8f 92       	push	r8
 176:	9f 92       	push	r9
 178:	af 92       	push	r10
 17a:	bf 92       	push	r11
 17c:	cf 92       	push	r12
 17e:	df 92       	push	r13
 180:	ef 92       	push	r14
 182:	ff 92       	push	r15
 184:	0f 93       	push	r16
 186:	1f 93       	push	r17
 188:	cf 93       	push	r28
 18a:	df 93       	push	r29
 18c:	cd b7       	in	r28, 0x3d	; 61
 18e:	de b7       	in	r29, 0x3e	; 62
 190:	2d 97       	sbiw	r28, 0x0d	; 13
 192:	0f b6       	in	r0, 0x3f	; 63
 194:	f8 94       	cli
 196:	de bf       	out	0x3e, r29	; 62
 198:	0f be       	out	0x3f, r0	; 63
 19a:	cd bf       	out	0x3d, r28	; 61
 19c:	1c 01       	movw	r2, r24
	uint32_t deciHertz = 10 * freq;
 19e:	cb 01       	movw	r24, r22
 1a0:	ba 01       	movw	r22, r20
 1a2:	2a e0       	ldi	r18, 0x0A	; 10
 1a4:	30 e0       	ldi	r19, 0x00	; 0
 1a6:	40 e0       	ldi	r20, 0x00	; 0
 1a8:	50 e0       	ldi	r21, 0x00	; 0
 1aa:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1ae:	6e 83       	std	Y+6, r22	; 0x06
 1b0:	7f 83       	std	Y+7, r23	; 0x07
 1b2:	88 87       	std	Y+8, r24	; 0x08
 1b4:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 1b6:	f1 01       	movw	r30, r2
 1b8:	82 81       	ldd	r24, Z+2	; 0x02
 1ba:	44 24       	eor	r4, r4
 1bc:	55 24       	eor	r5, r5


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	9c 01       	movw	r18, r24
 1c2:	21 50       	subi	r18, 0x01	; 1
 1c4:	30 40       	sbci	r19, 0x00	; 0
 1c6:	3b 87       	std	Y+11, r19	; 0x0b
 1c8:	2a 87       	std	Y+10, r18	; 0x0a
 1ca:	fc 01       	movw	r30, r24
 1cc:	e1 50       	subi	r30, 0x01	; 1
 1ce:	f0 48       	sbci	r31, 0x80	; 128
 1d0:	fd 87       	std	Y+13, r31	; 0x0d
 1d2:	ec 87       	std	Y+12, r30	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 1d4:	00 c0       	rjmp	.+0      	; 0x1d6 <motorL293Init+0x6e>


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 1d6:	8c 85       	ldd	r24, Y+12	; 0x0c
 1d8:	9d 85       	ldd	r25, Y+13	; 0x0d
 1da:	84 19       	sub	r24, r4
 1dc:	95 09       	sbc	r25, r5
 1de:	88 0f       	add	r24, r24
 1e0:	99 1f       	adc	r25, r25
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		MOTOR* motor = (MOTOR*)pgm_read_word(&driver->motors[i]);
 1e2:	f1 01       	movw	r30, r2
 1e4:	20 81       	ld	r18, Z
 1e6:	31 81       	ldd	r19, Z+1	; 0x01
 1e8:	28 0f       	add	r18, r24
 1ea:	39 1f       	adc	r19, r25
 1ec:	f9 01       	movw	r30, r18
 1ee:	85 91       	lpm	r24, Z+
 1f0:	94 91       	lpm	r25, Z
 1f2:	4c 01       	movw	r8, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 1f4:	fc 01       	movw	r30, r24
 1f6:	84 81       	ldd	r24, Z+4	; 0x04
 1f8:	95 81       	ldd	r25, Z+5	; 0x05
 1fa:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1fe:	3c 01       	movw	r6, r24
		if(channel==null){
 200:	00 97       	sbiw	r24, 0x00	; 0
 202:	01 f4       	brne	.+0      	; 0x204 <motorL293Init+0x9c>
			setError(PWM_PIN_NOT_AVAILABLE);
 204:	84 ef       	ldi	r24, 0xF4	; 244
 206:	00 c0       	rjmp	.+0      	; 0x208 <motorL293Init+0xa0>
			continue;
		}
		if(compareIsInUse(channel)){
 208:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 20c:	88 23       	and	r24, r24
 20e:	01 f0       	breq	.+0      	; 0x210 <motorL293Init+0xa8>
			setError(PWM_PIN_IN_USE);
 210:	83 ef       	ldi	r24, 0xF3	; 243
 212:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			continue;
 216:	00 c0       	rjmp	.+0      	; 0x218 <motorL293Init+0xb0>
 218:	f3 01       	movw	r30, r6
 21a:	32 96       	adiw	r30, 0x02	; 2
 21c:	e4 91       	lpm	r30, Z
 21e:	f0 e0       	ldi	r31, 0x00	; 0

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 220:	2c e2       	ldi	r18, 0x2C	; 44
 222:	30 e0       	ldi	r19, 0x00	; 0
 224:	e2 9f       	mul	r30, r18
 226:	50 01       	movw	r10, r0
 228:	e3 9f       	mul	r30, r19
 22a:	b0 0c       	add	r11, r0
 22c:	f2 9f       	mul	r31, r18
 22e:	b0 0c       	add	r11, r0
 230:	11 24       	eor	r1, r1
 232:	80 e0       	ldi	r24, 0x00	; 0
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	a8 0e       	add	r10, r24
 238:	b9 1e       	adc	r11, r25

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 23a:	c5 01       	movw	r24, r10
 23c:	4e 81       	ldd	r20, Y+6	; 0x06
 23e:	5f 81       	ldd	r21, Y+7	; 0x07
 240:	68 85       	ldd	r22, Y+8	; 0x08
 242:	79 85       	ldd	r23, Y+9	; 0x09
 244:	20 e8       	ldi	r18, 0x80	; 128
 246:	30 e0       	ldi	r19, 0x00	; 0
 248:	8e 01       	movw	r16, r28
 24a:	0f 5f       	subi	r16, 0xFF	; 255
 24c:	1f 4f       	sbci	r17, 0xFF	; 255
 24e:	a4 e0       	ldi	r26, 0x04	; 4
 250:	ea 2e       	mov	r14, r26
 252:	f1 2c       	mov	r15, r1
 254:	ec 0e       	add	r14, r28
 256:	fd 1e       	adc	r15, r29
 258:	b2 e0       	ldi	r27, 0x02	; 2
 25a:	cb 2e       	mov	r12, r27
 25c:	d1 2c       	mov	r13, r1
 25e:	cc 0e       	add	r12, r28
 260:	dd 1e       	adc	r13, r29
 262:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 266:	f5 01       	movw	r30, r10
 268:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 26a:	88 23       	and	r24, r24
 26c:	01 f4       	brne	.+0      	; 0x26e <motorL293Init+0x106>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 26e:	85 91       	lpm	r24, Z+
 270:	94 91       	lpm	r25, Z
 272:	fc 01       	movw	r30, r24
 274:	80 81       	ld	r24, Z
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	87 70       	andi	r24, 0x07	; 7
 27a:	90 70       	andi	r25, 0x00	; 0
 27c:	00 97       	sbiw	r24, 0x00	; 0
 27e:	01 f0       	breq	.+0      	; 0x280 <motorL293Init+0x118>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 280:	82 ef       	ldi	r24, 0xF2	; 242
 282:	00 c0       	rjmp	.+0      	; 0x284 <motorL293Init+0x11c>
 284:	83 ee       	ldi	r24, 0xE3	; 227
 286:	00 c0       	rjmp	.+0      	; 0x288 <motorL293Init+0x120>
 288:	85 91       	lpm	r24, Z+
 28a:	94 91       	lpm	r25, Z
 28c:	fc 01       	movw	r30, r24
 28e:	80 81       	ld	r24, Z
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	87 70       	andi	r24, 0x07	; 7
 294:	90 70       	andi	r25, 0x00	; 0
 296:	00 97       	sbiw	r24, 0x00	; 0
 298:	01 f4       	brne	.+0      	; 0x29a <motorL293Init+0x132>
 29a:	00 c0       	rjmp	.+0      	; 0x29c <motorL293Init+0x134>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 29c:	f5 01       	movw	r30, r10
 29e:	7f 96       	adiw	r30, 0x1f	; 31
 2a0:	85 91       	lpm	r24, Z+
 2a2:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 2a4:	fc 01       	movw	r30, r24
 2a6:	8c 81       	ldd	r24, Y+4	; 0x04
 2a8:	9d 81       	ldd	r25, Y+5	; 0x05
 2aa:	91 83       	std	Z+1, r25	; 0x01
 2ac:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_l293;
 2ae:	20 e0       	ldi	r18, 0x00	; 0
 2b0:	30 e0       	ldi	r19, 0x00	; 0
 2b2:	f4 01       	movw	r30, r8
 2b4:	31 83       	std	Z+1, r19	; 0x01
 2b6:	20 83       	st	Z, r18

			// Make sure the motor pins are set as output pins
			pin_make_output(motor->pwm, FALSE);
 2b8:	84 81       	ldd	r24, Z+4	; 0x04
 2ba:	95 81       	ldd	r25, Z+5	; 0x05
 2bc:	60 e0       	ldi	r22, 0x00	; 0
 2be:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction1, FALSE);
 2c2:	f4 01       	movw	r30, r8
 2c4:	86 81       	ldd	r24, Z+6	; 0x06
 2c6:	97 81       	ldd	r25, Z+7	; 0x07
 2c8:	60 e0       	ldi	r22, 0x00	; 0
 2ca:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2, FALSE);
 2ce:	f4 01       	movw	r30, r8
 2d0:	80 85       	ldd	r24, Z+8	; 0x08
 2d2:	91 85       	ldd	r25, Z+9	; 0x09
 2d4:	60 e0       	ldi	r22, 0x00	; 0
 2d6:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 2da:	c3 01       	movw	r24, r6
 2dc:	60 e0       	ldi	r22, 0x00	; 0
 2de:	70 e0       	ldi	r23, 0x00	; 0
 2e0:	40 e0       	ldi	r20, 0x00	; 0
 2e2:	50 e0       	ldi	r21, 0x00	; 0
 2e4:	20 e0       	ldi	r18, 0x00	; 0
 2e6:	30 e0       	ldi	r19, 0x00	; 0
 2e8:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 2ec:	6a 81       	ldd	r22, Y+2	; 0x02
 2ee:	7b 81       	ldd	r23, Y+3	; 0x03
 2f0:	c5 01       	movw	r24, r10
 2f2:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 2f6:	c4 01       	movw	r24, r8
 2f8:	60 e0       	ldi	r22, 0x00	; 0
 2fa:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 2fe:	c4 01       	movw	r24, r8
 300:	6f ef       	ldi	r22, 0xFF	; 255
 302:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 306:	08 94       	sec
 308:	41 1c       	adc	r4, r1
 30a:	51 1c       	adc	r5, r1


// Pass the list of motors, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void motorL293Init(MOTOR_DRIVER* driver, uint32_t freq){
 30c:	8a 85       	ldd	r24, Y+10	; 0x0a
 30e:	9b 85       	ldd	r25, Y+11	; 0x0b
 310:	84 19       	sub	r24, r4
 312:	95 09       	sbc	r25, r5
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 314:	ff ef       	ldi	r31, 0xFF	; 255
 316:	8f 3f       	cpi	r24, 0xFF	; 255
 318:	9f 07       	cpc	r25, r31
 31a:	01 f0       	breq	.+0      	; 0x31c <motorL293Init+0x1b4>
 31c:	00 c0       	rjmp	.+0      	; 0x31e <motorL293Init+0x1b6>
 31e:	00 c0       	rjmp	.+0      	; 0x320 <motorL293Init+0x1b8>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 320:	c5 01       	movw	r24, r10
 322:	69 81       	ldd	r22, Y+1	; 0x01
 324:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 328:	81 e0       	ldi	r24, 0x01	; 1
 32a:	90 e0       	ldi	r25, 0x00	; 0
 32c:	09 80       	ldd	r0, Y+1	; 0x01
 32e:	00 c0       	rjmp	.+0      	; 0x330 <motorL293Init+0x1c8>
 330:	88 0f       	add	r24, r24
 332:	99 1f       	adc	r25, r25
 334:	0a 94       	dec	r0
 336:	02 f4       	brpl	.+0      	; 0x338 <motorL293Init+0x1d0>
 338:	80 70       	andi	r24, 0x00	; 0
 33a:	95 75       	andi	r25, 0x55	; 85
 33c:	00 97       	sbiw	r24, 0x00	; 0
 33e:	01 f0       	breq	.+0      	; 0x340 <motorL293Init+0x1d8>
 340:	00 c0       	rjmp	.+0      	; 0x342 <motorL293Init+0x1da>
 342:	00 c0       	rjmp	.+0      	; 0x344 <motorL293Init+0x1dc>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 344:	2d 96       	adiw	r28, 0x0d	; 13
 346:	0f b6       	in	r0, 0x3f	; 63
 348:	f8 94       	cli
 34a:	de bf       	out	0x3e, r29	; 62
 34c:	0f be       	out	0x3f, r0	; 63
 34e:	cd bf       	out	0x3d, r28	; 61
 350:	df 91       	pop	r29
 352:	cf 91       	pop	r28
 354:	1f 91       	pop	r17
 356:	0f 91       	pop	r16
 358:	ff 90       	pop	r15
 35a:	ef 90       	pop	r14
 35c:	df 90       	pop	r13
 35e:	cf 90       	pop	r12
 360:	bf 90       	pop	r11
 362:	af 90       	pop	r10
 364:	9f 90       	pop	r9
 366:	8f 90       	pop	r8
 368:	7f 90       	pop	r7
 36a:	6f 90       	pop	r6
 36c:	5f 90       	pop	r5
 36e:	4f 90       	pop	r4
 370:	3f 90       	pop	r3
 372:	2f 90       	pop	r2
 374:	08 95       	ret

DualSerial.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000198  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001cc  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000001cc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000b03  00000000  00000000  000001d0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000275  00000000  00000000  00000cd3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000043d  00000000  00000000  00000f48  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001385  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  000013a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000179  00000000  00000000  000013bd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000599  00000000  00000000  00001536  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000c0  00000000  00000000  00001ad0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__pololuOutput>:
#include "DualSerial.h"
#include "../../core.h"
#include "../../timer.h"


static void __pololuOutput(POLOLU_DS_MOTOR* remote, uint8_t fwd, uint8_t speed){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	0f 92       	push	r0
   e:	cd b7       	in	r28, 0x3d	; 61
  10:	de b7       	in	r29, 0x3e	; 62
  12:	9c 01       	movw	r18, r24
  14:	f6 2e       	mov	r15, r22
	POLOLU_DS_DRIVER* driver = remote->driver;
  16:	fc 01       	movw	r30, r24
  18:	a4 81       	ldd	r26, Z+4	; 0x04
  1a:	b5 81       	ldd	r27, Z+5	; 0x05
	POLOLU_DS_MOTOR* first = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[0]);
  1c:	ed 91       	ld	r30, X+
  1e:	fc 91       	ld	r31, X
  20:	11 97       	sbiw	r26, 0x01	; 1
  22:	85 91       	lpm	r24, Z+
  24:	94 91       	lpm	r25, Z

	uint8_t motorNo =  remote - first;
  26:	28 1b       	sub	r18, r24
  28:	39 0b       	sbc	r19, r25
  2a:	35 95       	asr	r19
  2c:	27 95       	ror	r18
  2e:	6b ea       	ldi	r22, 0xAB	; 171
  30:	7a ea       	ldi	r23, 0xAA	; 170
  32:	26 9f       	mul	r18, r22
  34:	e0 2c       	mov	r14, r0
  36:	11 24       	eor	r1, r1
	motorNo += driver->firstMotorNumber;
  38:	19 96       	adiw	r26, 0x09	; 9
  3a:	8c 91       	ld	r24, X
  3c:	19 97       	sbiw	r26, 0x09	; 9
  3e:	e8 0e       	add	r14, r24
	UART* __pololuUART = driver->uart;
  40:	13 96       	adiw	r26, 0x03	; 3
  42:	0d 91       	ld	r16, X+
  44:	1c 91       	ld	r17, X
  46:	14 97       	sbiw	r26, 0x04	; 4

	_uartSendByte(__pololuUART,0x80);
  48:	c8 01       	movw	r24, r16
  4a:	60 e8       	ldi	r22, 0x80	; 128
  4c:	49 83       	std	Y+1, r20	; 0x01
  4e:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,0x0);
  52:	c8 01       	movw	r24, r16
  54:	60 e0       	ldi	r22, 0x00	; 0
  56:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,((motorNo<<1) & 0x7fU)|fwd);
  5a:	6e 2d       	mov	r22, r14
  5c:	66 0f       	add	r22, r22
  5e:	6f 77       	andi	r22, 0x7F	; 127
  60:	6f 29       	or	r22, r15
  62:	c8 01       	movw	r24, r16
  64:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	_uartSendByte(__pololuUART,(uint8_t)speed);
  68:	c8 01       	movw	r24, r16
  6a:	49 81       	ldd	r20, Y+1	; 0x01
  6c:	64 2f       	mov	r22, r20
  6e:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
}
  72:	0f 90       	pop	r0
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	1f 91       	pop	r17
  7a:	0f 91       	pop	r16
  7c:	ff 90       	pop	r15
  7e:	ef 90       	pop	r14
  80:	08 95       	ret

00000082 <setConnected>:

static void setConnected(__ACTUATOR *actuator, boolean connected){
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(connected){
  82:	66 23       	and	r22, r22
  84:	01 f0       	breq	.+0      	; 0x86 <setConnected+0x4>
		act_setSpeed(act,0);
		act_setConnected(act,TRUE);
	}
	// Pause for 100ms
	delay_ms(100);
}
  86:	fc 01       	movw	r30, r24
  88:	62 81       	ldd	r22, Z+2	; 0x02

static void setConnected(__ACTUATOR *actuator, boolean connected){
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(connected){
		DRIVE_SPEED speed = act_getSpeed(remote);
		actuator->required_speed=-128;
  8a:	20 e8       	ldi	r18, 0x80	; 128
  8c:	22 83       	std	Z+2, r18	; 0x02
		act_setSpeed(remote, speed);
  8e:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
  92:	08 95       	ret
	}else{
		// Set speed = 0 in forwards to coast
		__pololuOutput(remote, 1, 0);
  94:	61 e0       	ldi	r22, 0x01	; 1
  96:	40 e0       	ldi	r20, 0x00	; 0
  98:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
  9c:	08 95       	ret

0000009e <setSpeed>:
	}
}

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  9e:	0f 93       	push	r16
  a0:	1f 93       	push	r17
  a2:	cf 93       	push	r28
  a4:	df 93       	push	r29
  a6:	ec 01       	movw	r28, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  a8:	8b 81       	ldd	r24, Y+3	; 0x03
  aa:	80 ff       	sbrs	r24, 0
  ac:	00 c0       	rjmp	.+0      	; 0xae <setSpeed+0x10>
	POLOLU_DS_MOTOR* remote = (POLOLU_DS_MOTOR*)actuator;
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
  ae:	8a 81       	ldd	r24, Y+2	; 0x02
  b0:	86 17       	cp	r24, r22
  b2:	01 f0       	breq	.+0      	; 0xb4 <setSpeed+0x16>
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);
  b4:	86 2f       	mov	r24, r22
  b6:	99 27       	eor	r25, r25
  b8:	87 fd       	sbrc	r24, 7
  ba:	90 95       	com	r25
  bc:	61 e8       	ldi	r22, 0x81	; 129
  be:	7f ef       	ldi	r23, 0xFF	; 255
  c0:	4f e7       	ldi	r20, 0x7F	; 127
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	21 e8       	ldi	r18, 0x81	; 129
  c6:	3f ef       	ldi	r19, 0xFF	; 255
  c8:	0f e7       	ldi	r16, 0x7F	; 127
  ca:	10 e0       	ldi	r17, 0x00	; 0
  cc:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
  d0:	48 2f       	mov	r20, r24

		// If speed is 0 then set reverse to brake
		uint8_t fwd=1;
		if(s <= 0){
  d2:	18 16       	cp	r1, r24
  d4:	04 f0       	brlt	.+0      	; 0xd6 <setSpeed+0x38>
			s = -s;
  d6:	41 95       	neg	r20
			fwd = 0;
  d8:	60 e0       	ldi	r22, 0x00	; 0
  da:	00 c0       	rjmp	.+0      	; 0xdc <setSpeed+0x3e>
	if(act_isConnected(remote) && act_getSpeed(remote)!=speed){
		// controller speed is 0 to 127
		int8_t s = interpolate(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, -127 , 127);

		// If speed is 0 then set reverse to brake
		uint8_t fwd=1;
  dc:	61 e0       	ldi	r22, 0x01	; 1
		if(s <= 0){
			s = -s;
			fwd = 0;
		}

		__pololuOutput(remote, fwd,s);
  de:	ce 01       	movw	r24, r28
  e0:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	}
}
  e4:	df 91       	pop	r29
  e6:	cf 91       	pop	r28
  e8:	1f 91       	pop	r17
  ea:	0f 91       	pop	r16
  ec:	08 95       	ret

000000ee <pololuDualSerialInit>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
  ee:	af 92       	push	r10
  f0:	bf 92       	push	r11
  f2:	cf 92       	push	r12
  f4:	df 92       	push	r13
  f6:	ef 92       	push	r14
  f8:	ff 92       	push	r15
  fa:	0f 93       	push	r16
  fc:	1f 93       	push	r17
  fe:	cf 93       	push	r28
 100:	df 93       	push	r29
 102:	8c 01       	movw	r16, r24
	_uartInit(driver->uart,driver->baudRate);
 104:	dc 01       	movw	r26, r24
 106:	15 96       	adiw	r26, 0x05	; 5
 108:	4d 91       	ld	r20, X+
 10a:	5d 91       	ld	r21, X+
 10c:	6d 91       	ld	r22, X+
 10e:	7c 91       	ld	r23, X
 110:	18 97       	sbiw	r26, 0x08	; 8
 112:	13 96       	adiw	r26, 0x03	; 3
 114:	8d 91       	ld	r24, X+
 116:	9c 91       	ld	r25, X
 118:	14 97       	sbiw	r26, 0x04	; 4
 11a:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
	for(int i=0;i<driver->num_devices;i++){
 11e:	ee 24       	eor	r14, r14
 120:	ff 24       	eor	r15, r15
		POLOLU_DS_MOTOR* act = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[i]);
		act->actuator.class = &c_Pololu_DualSerial;
 122:	e0 e0       	ldi	r30, 0x00	; 0
 124:	ae 2e       	mov	r10, r30
 126:	e0 e0       	ldi	r30, 0x00	; 0
 128:	be 2e       	mov	r11, r30
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
 12a:	00 c0       	rjmp	.+0      	; 0x12c <pololuDualSerialInit+0x3e>
}

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
 12c:	c7 01       	movw	r24, r14
 12e:	88 0f       	add	r24, r24
 130:	99 1f       	adc	r25, r25
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
		POLOLU_DS_MOTOR* act = (POLOLU_DS_MOTOR*)pgm_read_word(&driver->devices[i]);
 132:	d8 01       	movw	r26, r16
 134:	ed 91       	ld	r30, X+
 136:	fc 91       	ld	r31, X
 138:	e8 0f       	add	r30, r24
 13a:	f9 1f       	adc	r31, r25
 13c:	c5 90       	lpm	r12, Z+
 13e:	d4 90       	lpm	r13, Z
 140:	cc 2d       	mov	r28, r12
 142:	dd 2d       	mov	r29, r13
		act->actuator.class = &c_Pololu_DualSerial;
 144:	b9 82       	std	Y+1, r11	; 0x01
 146:	a8 82       	st	Y, r10
		act->driver = driver;
 148:	1d 83       	std	Y+5, r17	; 0x05
 14a:	0c 83       	std	Y+4, r16	; 0x04
		act_setSpeed(act,0);
 14c:	8c 2d       	mov	r24, r12
 14e:	9d 2d       	mov	r25, r13
 150:	60 e0       	ldi	r22, 0x00	; 0
 152:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
		act_setConnected(act,TRUE);
 156:	8c 2d       	mov	r24, r12
 158:	9d 2d       	mov	r25, r13
 15a:	6f ef       	ldi	r22, 0xFF	; 255
 15c:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_Pololu_DualSerial = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

void pololuDualSerialInit(POLOLU_DS_DRIVER* driver){
	_uartInit(driver->uart,driver->baudRate);
	for(int i=0;i<driver->num_devices;i++){
 160:	08 94       	sec
 162:	e1 1c       	adc	r14, r1
 164:	f1 1c       	adc	r15, r1
 166:	d8 01       	movw	r26, r16
 168:	12 96       	adiw	r26, 0x02	; 2
 16a:	8c 91       	ld	r24, X
 16c:	12 97       	sbiw	r26, 0x02	; 2
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	e8 16       	cp	r14, r24
 172:	f9 06       	cpc	r15, r25
 174:	04 f0       	brlt	.+0      	; 0x176 <pololuDualSerialInit+0x88>
		act->driver = driver;
		act_setSpeed(act,0);
		act_setConnected(act,TRUE);
	}
	// Pause for 100ms
	delay_ms(100);
 176:	64 e6       	ldi	r22, 0x64	; 100
 178:	70 e0       	ldi	r23, 0x00	; 0
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	90 e0       	ldi	r25, 0x00	; 0
 17e:	0e 94 00 00 	call	0	; 0x0 <__pololuOutput>
}
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	1f 91       	pop	r17
 188:	0f 91       	pop	r16
 18a:	ff 90       	pop	r15
 18c:	ef 90       	pop	r14
 18e:	df 90       	pop	r13
 190:	cf 90       	pop	r12
 192:	bf 90       	pop	r11
 194:	af 90       	pop	r10
 196:	08 95       	ret

LB1836M.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003d2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000406  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000406  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000406  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a74  00000000  00000000  0000040a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002a0  00000000  00000000  00000e7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000008e0  00000000  00000000  0000111e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000019fe  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000068  00000000  00000000  00001a1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000185  00000000  00000000  00001a86  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000068c  00000000  00000000  00001c0b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000150  00000000  00000000  00002298  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	ec 01       	movw	r28, r24
  14:	f6 2e       	mov	r15, r22
	SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  16:	8c 81       	ldd	r24, Y+4	; 0x04
  18:	9d 81       	ldd	r25, Y+5	; 0x05
  1a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  1e:	5c 01       	movw	r10, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  20:	8e 81       	ldd	r24, Y+6	; 0x06
  22:	9f 81       	ldd	r25, Y+7	; 0x07
  24:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  28:	6c 01       	movw	r12, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  2a:	1f 14       	cp	r1, r15
  2c:	04 f4       	brge	.+0      	; 0x2e <setSpeed+0x2e>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  2e:	fc 01       	movw	r30, r24
  30:	32 96       	adiw	r30, 0x02	; 2
  32:	e4 91       	lpm	r30, Z
  34:	f0 e0       	ldi	r31, 0x00	; 0
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0, timerGetTOP(compareGetTimer(channel2)));
  36:	2c e2       	ldi	r18, 0x2C	; 44
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	e2 9f       	mul	r30, r18
  3c:	c0 01       	movw	r24, r0
  3e:	e3 9f       	mul	r30, r19
  40:	90 0d       	add	r25, r0
  42:	f2 9f       	mul	r31, r18
  44:	90 0d       	add	r25, r0
  46:	11 24       	eor	r1, r1
  48:	80 50       	subi	r24, 0x00	; 0
  4a:	90 40       	sbci	r25, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  50:	8c 01       	movw	r16, r24
  52:	8f 2d       	mov	r24, r15
  54:	99 27       	eor	r25, r25
  56:	87 fd       	sbrc	r24, 7
  58:	90 95       	com	r25
  5a:	60 e0       	ldi	r22, 0x00	; 0
  5c:	70 e0       	ldi	r23, 0x00	; 0
  5e:	4f e7       	ldi	r20, 0x7F	; 127
  60:	50 e0       	ldi	r21, 0x00	; 0
  62:	20 e0       	ldi	r18, 0x00	; 0
  64:	30 e0       	ldi	r19, 0x00	; 0
  66:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  6a:	ec 01       	movw	r28, r24
		compareSetThreshold(channel1,0);	    // Keep permanently high
  6c:	c5 01       	movw	r24, r10
  6e:	60 e0       	ldi	r22, 0x00	; 0
  70:	70 e0       	ldi	r23, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,delay);	// pwm channel 2
  76:	c6 01       	movw	r24, r12
  78:	00 c0       	rjmp	.+0      	; 0x7a <setSpeed+0x7a>
	}else if(speed < 0){
  7a:	ff 20       	and	r15, r15
  7c:	01 f0       	breq	.+0      	; 0x7e <setSpeed+0x7e>
  7e:	f5 01       	movw	r30, r10
  80:	32 96       	adiw	r30, 0x02	; 2
  82:	e4 91       	lpm	r30, Z
  84:	f0 e0       	ldi	r31, 0x00	; 0
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , timerGetTOP(compareGetTimer(channel1)));
  86:	2c e2       	ldi	r18, 0x2C	; 44
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	e2 9f       	mul	r30, r18
  8c:	c0 01       	movw	r24, r0
  8e:	e3 9f       	mul	r30, r19
  90:	90 0d       	add	r25, r0
  92:	f2 9f       	mul	r31, r18
  94:	90 0d       	add	r25, r0
  96:	11 24       	eor	r1, r1
  98:	80 50       	subi	r24, 0x00	; 0
  9a:	90 40       	sbci	r25, 0x00	; 0
  9c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  a0:	8c 01       	movw	r16, r24
  a2:	8f 2d       	mov	r24, r15
  a4:	99 27       	eor	r25, r25
  a6:	87 fd       	sbrc	r24, 7
  a8:	90 95       	com	r25
  aa:	60 e0       	ldi	r22, 0x00	; 0
  ac:	70 e0       	ldi	r23, 0x00	; 0
  ae:	41 e8       	ldi	r20, 0x81	; 129
  b0:	5f ef       	ldi	r21, 0xFF	; 255
  b2:	20 e0       	ldi	r18, 0x00	; 0
  b4:	30 e0       	ldi	r19, 0x00	; 0
  b6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  ba:	ec 01       	movw	r28, r24
		compareSetThreshold(channel2,0);	    // Keep permanently high
  bc:	c6 01       	movw	r24, r12
  be:	60 e0       	ldi	r22, 0x00	; 0
  c0:	70 e0       	ldi	r23, 0x00	; 0
  c2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel1,delay);	// pwm channel 1
  c6:	c5 01       	movw	r24, r10
  c8:	be 01       	movw	r22, r28
  ca:	00 c0       	rjmp	.+0      	; 0xcc <setSpeed+0xcc>
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
  cc:	c5 01       	movw	r24, r10
  ce:	60 e0       	ldi	r22, 0x00	; 0
  d0:	70 e0       	ldi	r23, 0x00	; 0
  d2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,0);	    // Keep permanently high
  d6:	c6 01       	movw	r24, r12
  d8:	60 e0       	ldi	r22, 0x00	; 0
  da:	70 e0       	ldi	r23, 0x00	; 0
  dc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}
}
  e0:	df 91       	pop	r29
  e2:	cf 91       	pop	r28
  e4:	1f 91       	pop	r17
  e6:	0f 91       	pop	r16
  e8:	ff 90       	pop	r15
  ea:	df 90       	pop	r13
  ec:	cf 90       	pop	r12
  ee:	bf 90       	pop	r11
  f0:	af 90       	pop	r10
  f2:	08 95       	ret

000000f4 <initPWM>:

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Return true if valid, false if there is an error
static boolean initPWM(const IOPin* pin, uint32_t deciHertz){
  f4:	6f 92       	push	r6
  f6:	7f 92       	push	r7
  f8:	8f 92       	push	r8
  fa:	9f 92       	push	r9
  fc:	af 92       	push	r10
  fe:	bf 92       	push	r11
 100:	cf 92       	push	r12
 102:	df 92       	push	r13
 104:	ef 92       	push	r14
 106:	ff 92       	push	r15
 108:	0f 93       	push	r16
 10a:	1f 93       	push	r17
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	00 d0       	rcall	.+0      	; 0x112 <initPWM+0x1e>
 112:	00 d0       	rcall	.+0      	; 0x114 <initPWM+0x20>
 114:	0f 92       	push	r0
 116:	cd b7       	in	r28, 0x3d	; 61
 118:	de b7       	in	r29, 0x3e	; 62
 11a:	3c 01       	movw	r6, r24
 11c:	6a 01       	movw	r12, r20
 11e:	7b 01       	movw	r14, r22
	const TimerCompare* channel = compareFromIOPin(pin);
 120:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 124:	4c 01       	movw	r8, r24

	if(channel==null){
 126:	00 97       	sbiw	r24, 0x00	; 0
 128:	01 f4       	brne	.+0      	; 0x12a <initPWM+0x36>
		setError(PWM_PIN_NOT_AVAILABLE);
 12a:	84 ef       	ldi	r24, 0xF4	; 244
 12c:	00 c0       	rjmp	.+0      	; 0x12e <initPWM+0x3a>
		return FALSE;
	}
	if(compareIsInUse(channel)){
 12e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 132:	88 23       	and	r24, r24
 134:	01 f0       	breq	.+0      	; 0x136 <initPWM+0x42>
		setError(PWM_PIN_IN_USE);
 136:	83 ef       	ldi	r24, 0xF3	; 243
 138:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		return FALSE;
 13c:	cc 24       	eor	r12, r12
 13e:	00 c0       	rjmp	.+0      	; 0x140 <initPWM+0x4c>
 140:	f4 01       	movw	r30, r8
 142:	32 96       	adiw	r30, 0x02	; 2
 144:	e4 91       	lpm	r30, Z
 146:	f0 e0       	ldi	r31, 0x00	; 0

	TIMER_MODE mode;
	uint16_t icr;
	uint16_t prescaler;

	const Timer* timer = compareGetTimer(channel);
 148:	8c e2       	ldi	r24, 0x2C	; 44
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	e8 9f       	mul	r30, r24
 14e:	50 01       	movw	r10, r0
 150:	e9 9f       	mul	r30, r25
 152:	b0 0c       	add	r11, r0
 154:	f8 9f       	mul	r31, r24
 156:	b0 0c       	add	r11, r0
 158:	11 24       	eor	r1, r1
 15a:	80 e0       	ldi	r24, 0x00	; 0
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	a8 0e       	add	r10, r24
 160:	b9 1e       	adc	r11, r25

	// Find the best PWM setting for 10kHz, with 128 steps
	boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 162:	c5 01       	movw	r24, r10
 164:	b7 01       	movw	r22, r14
 166:	a6 01       	movw	r20, r12
 168:	20 e8       	ldi	r18, 0x80	; 128
 16a:	30 e0       	ldi	r19, 0x00	; 0
 16c:	8e 01       	movw	r16, r28
 16e:	0f 5f       	subi	r16, 0xFF	; 255
 170:	1f 4f       	sbci	r17, 0xFF	; 255
 172:	a4 e0       	ldi	r26, 0x04	; 4
 174:	ea 2e       	mov	r14, r26
 176:	f1 2c       	mov	r15, r1
 178:	ec 0e       	add	r14, r28
 17a:	fd 1e       	adc	r15, r29
 17c:	b2 e0       	ldi	r27, 0x02	; 2
 17e:	cb 2e       	mov	r12, r27
 180:	d1 2c       	mov	r13, r1
 182:	cc 0e       	add	r12, r28
 184:	dd 1e       	adc	r13, r29
 186:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 18a:	c8 2e       	mov	r12, r24
 18c:	f5 01       	movw	r30, r10
 18e:	34 96       	adiw	r30, 0x04	; 4
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 190:	85 91       	lpm	r24, Z+
 192:	94 91       	lpm	r25, Z
 194:	fc 01       	movw	r30, r24
 196:	80 81       	ld	r24, Z
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	87 70       	andi	r24, 0x07	; 7
 19c:	90 70       	andi	r25, 0x00	; 0

	if(!valid){
 19e:	cc 20       	and	r12, r12
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <initPWM+0xae>
 1a2:	00 97       	sbiw	r24, 0x00	; 0
 1a4:	01 f0       	breq	.+0      	; 0x1a6 <initPWM+0xb2>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 1a6:	82 ef       	ldi	r24, 0xF2	; 242
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <initPWM+0xb6>
 1aa:	83 ee       	ldi	r24, 0xE3	; 227
 1ac:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <initPWM+0xbe>
 1b2:	00 97       	sbiw	r24, 0x00	; 0
 1b4:	01 f4       	brne	.+0      	; 0x1b6 <initPWM+0xc2>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <initPWM+0xc4>
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
			if(modeIsICR(mode)){
				// Set the ICR
				PORT icrPort = pgm_read_word(&timer->pgm_icr);
 1b8:	f5 01       	movw	r30, r10
 1ba:	7f 96       	adiw	r30, 0x1f	; 31
 1bc:	85 91       	lpm	r24, Z+
 1be:	94 91       	lpm	r25, Z
				_SFR_MEM16(icrPort)=icr;
 1c0:	fc 01       	movw	r30, r24
 1c2:	8c 81       	ldd	r24, Y+4	; 0x04
 1c4:	9d 81       	ldd	r25, Y+5	; 0x05
 1c6:	91 83       	std	Z+1, r25	; 0x01
 1c8:	80 83       	st	Z, r24
			}
		}

		// Make it an output pin and set high for brake
		pin_make_output(pin,TRUE);
 1ca:	c3 01       	movw	r24, r6
 1cc:	6f ef       	ldi	r22, 0xFF	; 255
 1ce:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


		// Use inverting PWM
		compareSetOutputMode(channel,CHANNEL_MODE_INVERTING);
 1d2:	c4 01       	movw	r24, r8
 1d4:	63 e0       	ldi	r22, 0x03	; 3
 1d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


		// Mark the channels as in use
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 1da:	c4 01       	movw	r24, r8
 1dc:	60 e0       	ldi	r22, 0x00	; 0
 1de:	70 e0       	ldi	r23, 0x00	; 0
 1e0:	40 e0       	ldi	r20, 0x00	; 0
 1e2:	50 e0       	ldi	r21, 0x00	; 0
 1e4:	20 e0       	ldi	r18, 0x00	; 0
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
 1ec:	6a 81       	ldd	r22, Y+2	; 0x02
 1ee:	7b 81       	ldd	r23, Y+3	; 0x03
 1f0:	c5 01       	movw	r24, r10
 1f2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}
	return valid;
}
 1f6:	8c 2d       	mov	r24, r12
 1f8:	0f 90       	pop	r0
 1fa:	0f 90       	pop	r0
 1fc:	0f 90       	pop	r0
 1fe:	0f 90       	pop	r0
 200:	0f 90       	pop	r0
 202:	df 91       	pop	r29
 204:	cf 91       	pop	r28
 206:	1f 91       	pop	r17
 208:	0f 91       	pop	r16
 20a:	ff 90       	pop	r15
 20c:	ef 90       	pop	r14
 20e:	df 90       	pop	r13
 210:	cf 90       	pop	r12
 212:	bf 90       	pop	r11
 214:	af 90       	pop	r10
 216:	9f 90       	pop	r9
 218:	8f 90       	pop	r8
 21a:	7f 90       	pop	r7
 21c:	6f 90       	pop	r6
 21e:	08 95       	ret
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
	}else{
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
 220:	c5 01       	movw	r24, r10
 222:	69 81       	ldd	r22, Y+1	; 0x01
 224:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			if(modeIsICR(mode)){
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	09 80       	ldd	r0, Y+1	; 0x01
 22e:	00 c0       	rjmp	.+0      	; 0x230 <initPWM+0x13c>
 230:	88 0f       	add	r24, r24
 232:	99 1f       	adc	r25, r25
 234:	0a 94       	dec	r0
 236:	02 f4       	brpl	.+0      	; 0x238 <initPWM+0x144>
 238:	80 70       	andi	r24, 0x00	; 0
 23a:	95 75       	andi	r25, 0x55	; 85
 23c:	00 97       	sbiw	r24, 0x00	; 0
 23e:	01 f0       	breq	.+0      	; 0x240 <initPWM+0x14c>
 240:	00 c0       	rjmp	.+0      	; 0x242 <initPWM+0x14e>
 242:	00 c0       	rjmp	.+0      	; 0x244 <setConnected>

00000244 <setConnected>:
		compareSetThreshold(channel1,0);	    // Keep permanently high
		compareSetThreshold(channel2,0);	    // Keep permanently high
	}
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
 244:	cf 92       	push	r12
 246:	df 92       	push	r13
 248:	ef 92       	push	r14
 24a:	ff 92       	push	r15
 24c:	0f 93       	push	r16
 24e:	1f 93       	push	r17
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	0f 92       	push	r0
 256:	cd b7       	in	r28, 0x3d	; 61
 258:	de b7       	in	r29, 0x3e	; 62
 25a:	6c 01       	movw	r12, r24
	SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
 25c:	fc 01       	movw	r30, r24
 25e:	84 81       	ldd	r24, Z+4	; 0x04
 260:	95 81       	ldd	r25, Z+5	; 0x05
 262:	69 83       	std	Y+1, r22	; 0x01
 264:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 268:	8c 01       	movw	r16, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
 26a:	f6 01       	movw	r30, r12
 26c:	86 81       	ldd	r24, Z+6	; 0x06
 26e:	97 81       	ldd	r25, Z+7	; 0x07
 270:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 274:	7c 01       	movw	r14, r24

	if(connected){
 276:	69 81       	ldd	r22, Y+1	; 0x01
 278:	66 23       	and	r22, r22
 27a:	01 f0       	breq	.+0      	; 0x27c <setConnected+0x38>
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 27c:	c6 01       	movw	r24, r12
 27e:	f6 01       	movw	r30, r12
 280:	62 81       	ldd	r22, Z+2	; 0x02
 282:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 286:	00 c0       	rjmp	.+0      	; 0x288 <setConnected+0x44>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 288:	f8 01       	movw	r30, r16
 28a:	32 96       	adiw	r30, 0x02	; 2
 28c:	e4 91       	lpm	r30, Z
 28e:	f0 e0       	ldi	r31, 0x00	; 0
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
 290:	8c e2       	ldi	r24, 0x2C	; 44
 292:	c8 2e       	mov	r12, r24
 294:	d1 2c       	mov	r13, r1
 296:	ec 9d       	mul	r30, r12
 298:	c0 01       	movw	r24, r0
 29a:	ed 9d       	mul	r30, r13
 29c:	90 0d       	add	r25, r0
 29e:	fc 9d       	mul	r31, r12
 2a0:	90 0d       	add	r25, r0
 2a2:	11 24       	eor	r1, r1
 2a4:	80 50       	subi	r24, 0x00	; 0
 2a6:	90 40       	sbci	r25, 0x00	; 0
 2a8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2ac:	bc 01       	movw	r22, r24
 2ae:	c8 01       	movw	r24, r16
 2b0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2b4:	f7 01       	movw	r30, r14
 2b6:	32 96       	adiw	r30, 0x02	; 2
 2b8:	e4 91       	lpm	r30, Z
 2ba:	f0 e0       	ldi	r31, 0x00	; 0
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 2bc:	ec 9d       	mul	r30, r12
 2be:	c0 01       	movw	r24, r0
 2c0:	ed 9d       	mul	r30, r13
 2c2:	90 0d       	add	r25, r0
 2c4:	fc 9d       	mul	r31, r12
 2c6:	90 0d       	add	r25, r0
 2c8:	11 24       	eor	r1, r1
 2ca:	80 50       	subi	r24, 0x00	; 0
 2cc:	90 40       	sbci	r25, 0x00	; 0
 2ce:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2d2:	bc 01       	movw	r22, r24
 2d4:	c7 01       	movw	r24, r14
 2d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

}
 2da:	0f 90       	pop	r0
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	ff 90       	pop	r15
 2e6:	ef 90       	pop	r14
 2e8:	df 90       	pop	r13
 2ea:	cf 90       	pop	r12
 2ec:	08 95       	ret

000002ee <sanyoLB1836M_Init>:
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 2ee:	4f 92       	push	r4
 2f0:	5f 92       	push	r5
 2f2:	6f 92       	push	r6
 2f4:	7f 92       	push	r7
 2f6:	8f 92       	push	r8
 2f8:	9f 92       	push	r9
 2fa:	af 92       	push	r10
 2fc:	bf 92       	push	r11
 2fe:	cf 92       	push	r12
 300:	df 92       	push	r13
 302:	ef 92       	push	r14
 304:	ff 92       	push	r15
 306:	0f 93       	push	r16
 308:	1f 93       	push	r17
 30a:	cf 93       	push	r28
 30c:	df 93       	push	r29
 30e:	5c 01       	movw	r10, r24
	uint32_t deciHertz = 10 * freq;
 310:	cb 01       	movw	r24, r22
 312:	ba 01       	movw	r22, r20
 314:	2a e0       	ldi	r18, 0x0A	; 10
 316:	30 e0       	ldi	r19, 0x00	; 0
 318:	40 e0       	ldi	r20, 0x00	; 0
 31a:	50 e0       	ldi	r21, 0x00	; 0
 31c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 320:	6b 01       	movw	r12, r22
 322:	7c 01       	movw	r14, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 324:	f5 01       	movw	r30, r10
 326:	82 81       	ldd	r24, Z+2	; 0x02
 328:	00 e0       	ldi	r16, 0x00	; 0
 32a:	10 e0       	ldi	r17, 0x00	; 0
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	2c 01       	movw	r4, r24
 330:	08 94       	sec
 332:	41 08       	sbc	r4, r1
 334:	51 08       	sbc	r5, r1
 336:	af ef       	ldi	r26, 0xFF	; 255
 338:	8a 2e       	mov	r8, r26
 33a:	af e7       	ldi	r26, 0x7F	; 127
 33c:	9a 2e       	mov	r9, r26
 33e:	88 0e       	add	r8, r24
 340:	99 1e       	adc	r9, r25


		if( initPWM(motor->pwm1, deciHertz) ){
			if(initPWM(motor->pwm2, deciHertz)){
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 342:	b0 e0       	ldi	r27, 0x00	; 0
 344:	6b 2e       	mov	r6, r27
 346:	b0 e0       	ldi	r27, 0x00	; 0
 348:	7b 2e       	mov	r7, r27
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 34a:	00 c0       	rjmp	.+0      	; 0x34c <sanyoLB1836M_Init+0x5e>
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 34c:	c4 01       	movw	r24, r8
 34e:	80 1b       	sub	r24, r16
 350:	91 0b       	sbc	r25, r17
 352:	88 0f       	add	r24, r24
 354:	99 1f       	adc	r25, r25
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		SANYO_LB1836M_MOTOR* motor = (SANYO_LB1836M_MOTOR*)pgm_read_word(&driver->motors[i]);
 356:	f5 01       	movw	r30, r10
 358:	20 81       	ld	r18, Z
 35a:	31 81       	ldd	r19, Z+1	; 0x01
 35c:	28 0f       	add	r18, r24
 35e:	39 1f       	adc	r19, r25
 360:	f9 01       	movw	r30, r18
 362:	85 91       	lpm	r24, Z+
 364:	94 91       	lpm	r25, Z
 366:	c8 2f       	mov	r28, r24
 368:	d9 2f       	mov	r29, r25


		if( initPWM(motor->pwm1, deciHertz) ){
 36a:	8c 81       	ldd	r24, Y+4	; 0x04
 36c:	9d 81       	ldd	r25, Y+5	; 0x05
 36e:	b7 01       	movw	r22, r14
 370:	a6 01       	movw	r20, r12
 372:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 376:	88 23       	and	r24, r24
 378:	01 f0       	breq	.+0      	; 0x37a <sanyoLB1836M_Init+0x8c>
			if(initPWM(motor->pwm2, deciHertz)){
 37a:	8e 81       	ldd	r24, Y+6	; 0x06
 37c:	9f 81       	ldd	r25, Y+7	; 0x07
 37e:	b7 01       	movw	r22, r14
 380:	a6 01       	movw	r20, r12
 382:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 386:	88 23       	and	r24, r24
 388:	01 f0       	breq	.+0      	; 0x38a <sanyoLB1836M_Init+0x9c>
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 38a:	79 82       	std	Y+1, r7	; 0x01
 38c:	68 82       	st	Y, r6
			}
		}

		// Start off braking
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 38e:	ce 01       	movw	r24, r28
 390:	60 e0       	ldi	r22, 0x00	; 0
 392:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
 396:	ce 01       	movw	r24, r28
 398:	6f ef       	ldi	r22, 0xFF	; 255
 39a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 39e:	0f 5f       	subi	r16, 0xFF	; 255
 3a0:	1f 4f       	sbci	r17, 0xFF	; 255
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// use the timer compare channel A (if there is more than one)
void sanyoLB1836M_Init(SANYO_LB1836M_MOTOR_DRIVER* driver, uint32_t freq){
 3a2:	c2 01       	movw	r24, r4
 3a4:	80 1b       	sub	r24, r16
 3a6:	91 0b       	sbc	r25, r17
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 3a8:	ef ef       	ldi	r30, 0xFF	; 255
 3aa:	8f 3f       	cpi	r24, 0xFF	; 255
 3ac:	9e 07       	cpc	r25, r30
 3ae:	01 f4       	brne	.+0      	; 0x3b0 <sanyoLB1836M_Init+0xc2>
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
	}
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
 3b4:	1f 91       	pop	r17
 3b6:	0f 91       	pop	r16
 3b8:	ff 90       	pop	r15
 3ba:	ef 90       	pop	r14
 3bc:	df 90       	pop	r13
 3be:	cf 90       	pop	r12
 3c0:	bf 90       	pop	r11
 3c2:	af 90       	pop	r10
 3c4:	9f 90       	pop	r9
 3c6:	8f 90       	pop	r8
 3c8:	7f 90       	pop	r7
 3ca:	6f 90       	pop	r6
 3cc:	5f 90       	pop	r5
 3ce:	4f 90       	pop	r4
 3d0:	08 95       	ret

L298.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000316  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000034a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000034a  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  0000034a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000932  00000000  00000000  0000034e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000254  00000000  00000000  00000c80  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000005d3  00000000  00000000  00000ed4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000014a7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000058  00000000  00000000  000014c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000153  00000000  00000000  0000151f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000659  00000000  00000000  00001672  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000e4  00000000  00000000  00001ccc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pin);
   a:	fc 01       	movw	r30, r24
   c:	84 81       	ldd	r24, Z+4	; 0x04
   e:	95 81       	ldd	r25, Z+5	; 0x05
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  26:	0f 90       	pop	r0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

0000002e <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2e:	cf 92       	push	r12
  30:	df 92       	push	r13
  32:	ef 92       	push	r14
  34:	ff 92       	push	r15
  36:	0f 93       	push	r16
  38:	1f 93       	push	r17
  3a:	cf 93       	push	r28
  3c:	df 93       	push	r29
  3e:	0f 92       	push	r0
  40:	cd b7       	in	r28, 0x3d	; 61
  42:	de b7       	in	r29, 0x3e	; 62
  44:	6c 01       	movw	r12, r24
	SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pin);
  46:	fc 01       	movw	r30, r24
  48:	84 81       	ldd	r24, Z+4	; 0x04
  4a:	95 81       	ldd	r25, Z+5	; 0x05
  4c:	69 83       	std	Y+1, r22	; 0x01
  4e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  52:	7c 01       	movw	r14, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  54:	fc 01       	movw	r30, r24
  56:	32 96       	adiw	r30, 0x02	; 2
  58:	e4 91       	lpm	r30, Z
  5a:	f0 e0       	ldi	r31, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
  5c:	2c e2       	ldi	r18, 0x2C	; 44
  5e:	30 e0       	ldi	r19, 0x00	; 0
  60:	e2 9f       	mul	r30, r18
  62:	c0 01       	movw	r24, r0
  64:	e3 9f       	mul	r30, r19
  66:	90 0d       	add	r25, r0
  68:	f2 9f       	mul	r31, r18
  6a:	90 0d       	add	r25, r0
  6c:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  6e:	80 50       	subi	r24, 0x00	; 0
  70:	90 40       	sbci	r25, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  76:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  78:	69 81       	ldd	r22, Y+1	; 0x01
  7a:	16 16       	cp	r1, r22
  7c:	04 f4       	brge	.+0      	; 0x7e <setSpeed+0x50>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  7e:	86 2f       	mov	r24, r22
  80:	99 27       	eor	r25, r25
  82:	87 fd       	sbrc	r24, 7
  84:	90 95       	com	r25
  86:	60 e0       	ldi	r22, 0x00	; 0
  88:	70 e0       	ldi	r23, 0x00	; 0
  8a:	4f e7       	ldi	r20, 0x7F	; 127
  8c:	50 e0       	ldi	r21, 0x00	; 0
  8e:	20 e0       	ldi	r18, 0x00	; 0
  90:	30 e0       	ldi	r19, 0x00	; 0
  92:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  96:	8c 01       	movw	r16, r24
		// Set pins low and high
		pin_low(motor->enable1);
  98:	f6 01       	movw	r30, r12
  9a:	86 81       	ldd	r24, Z+6	; 0x06
  9c:	97 81       	ldd	r25, Z+7	; 0x07
  9e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_high(motor->enable2);
  a2:	f6 01       	movw	r30, r12
  a4:	80 85       	ldd	r24, Z+8	; 0x08
  a6:	91 85       	ldd	r25, Z+9	; 0x09
  a8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  ac:	00 c0       	rjmp	.+0      	; 0xae <setSpeed+0x80>

	}else if(speed < 0){
  ae:	66 23       	and	r22, r22
  b0:	01 f0       	breq	.+0      	; 0xb2 <setSpeed+0x84>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  b2:	86 2f       	mov	r24, r22
  b4:	99 27       	eor	r25, r25
  b6:	87 fd       	sbrc	r24, 7
  b8:	90 95       	com	r25
  ba:	60 e0       	ldi	r22, 0x00	; 0
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	41 e8       	ldi	r20, 0x81	; 129
  c0:	5f ef       	ldi	r21, 0xFF	; 255
  c2:	20 e0       	ldi	r18, 0x00	; 0
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  ca:	8c 01       	movw	r16, r24
		// Set pins high and low
		pin_high(motor->enable1);
  cc:	f6 01       	movw	r30, r12
  ce:	86 81       	ldd	r24, Z+6	; 0x06
  d0:	97 81       	ldd	r25, Z+7	; 0x07
  d2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <setSpeed+0xaa>
	}else{
		// brake
		// Force output to stay high
		delay=top;
		// Set both pins low
		pin_low(motor->enable1);
  d8:	f6 01       	movw	r30, r12
  da:	86 81       	ldd	r24, Z+6	; 0x06
  dc:	97 81       	ldd	r25, Z+7	; 0x07
  de:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_low(motor->enable2);
  e2:	f6 01       	movw	r30, r12
  e4:	80 85       	ldd	r24, Z+8	; 0x08
  e6:	91 85       	ldd	r25, Z+9	; 0x09
  e8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  ec:	c7 01       	movw	r24, r14
  ee:	b8 01       	movw	r22, r16
  f0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  f4:	0f 90       	pop	r0
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	1f 91       	pop	r17
  fc:	0f 91       	pop	r16
  fe:	ff 90       	pop	r15
 100:	ef 90       	pop	r14
 102:	df 90       	pop	r13
 104:	cf 90       	pop	r12
 106:	08 95       	ret

00000108 <solarL298Init>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 108:	2f 92       	push	r2
 10a:	3f 92       	push	r3
 10c:	4f 92       	push	r4
 10e:	5f 92       	push	r5
 110:	6f 92       	push	r6
 112:	7f 92       	push	r7
 114:	8f 92       	push	r8
 116:	9f 92       	push	r9
 118:	af 92       	push	r10
 11a:	bf 92       	push	r11
 11c:	cf 92       	push	r12
 11e:	df 92       	push	r13
 120:	ef 92       	push	r14
 122:	ff 92       	push	r15
 124:	0f 93       	push	r16
 126:	1f 93       	push	r17
 128:	cf 93       	push	r28
 12a:	df 93       	push	r29
 12c:	cd b7       	in	r28, 0x3d	; 61
 12e:	de b7       	in	r29, 0x3e	; 62
 130:	2d 97       	sbiw	r28, 0x0d	; 13
 132:	0f b6       	in	r0, 0x3f	; 63
 134:	f8 94       	cli
 136:	de bf       	out	0x3e, r29	; 62
 138:	0f be       	out	0x3f, r0	; 63
 13a:	cd bf       	out	0x3d, r28	; 61
 13c:	1c 01       	movw	r2, r24
	uint32_t deciHertz = 10 * freq;
 13e:	cb 01       	movw	r24, r22
 140:	ba 01       	movw	r22, r20
 142:	2a e0       	ldi	r18, 0x0A	; 10
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	40 e0       	ldi	r20, 0x00	; 0
 148:	50 e0       	ldi	r21, 0x00	; 0
 14a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 14e:	6e 83       	std	Y+6, r22	; 0x06
 150:	7f 83       	std	Y+7, r23	; 0x07
 152:	88 87       	std	Y+8, r24	; 0x08
 154:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 156:	f1 01       	movw	r30, r2
 158:	82 81       	ldd	r24, Z+2	; 0x02
 15a:	44 24       	eor	r4, r4
 15c:	55 24       	eor	r5, r5
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	9c 01       	movw	r18, r24
 162:	21 50       	subi	r18, 0x01	; 1
 164:	30 40       	sbci	r19, 0x00	; 0
 166:	3b 87       	std	Y+11, r19	; 0x0b
 168:	2a 87       	std	Y+10, r18	; 0x0a
 16a:	fc 01       	movw	r30, r24
 16c:	e1 50       	subi	r30, 0x01	; 1
 16e:	f0 48       	sbci	r31, 0x80	; 128
 170:	fd 87       	std	Y+13, r31	; 0x0d
 172:	ec 87       	std	Y+12, r30	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 174:	00 c0       	rjmp	.+0      	; 0x176 <solarL298Init+0x6e>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 176:	8c 85       	ldd	r24, Y+12	; 0x0c
 178:	9d 85       	ldd	r25, Y+13	; 0x0d
 17a:	84 19       	sub	r24, r4
 17c:	95 09       	sbc	r25, r5
 17e:	88 0f       	add	r24, r24
 180:	99 1f       	adc	r25, r25
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		SOLAR_L298_MOTOR* motor = (SOLAR_L298_MOTOR*)pgm_read_word(&driver->motors[i]);
 182:	f1 01       	movw	r30, r2
 184:	20 81       	ld	r18, Z
 186:	31 81       	ldd	r19, Z+1	; 0x01
 188:	28 0f       	add	r18, r24
 18a:	39 1f       	adc	r19, r25
 18c:	f9 01       	movw	r30, r18
 18e:	85 91       	lpm	r24, Z+
 190:	94 91       	lpm	r25, Z
 192:	4c 01       	movw	r8, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pin);
 194:	fc 01       	movw	r30, r24
 196:	84 81       	ldd	r24, Z+4	; 0x04
 198:	95 81       	ldd	r25, Z+5	; 0x05
 19a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 19e:	3c 01       	movw	r6, r24
		if(channel==null){
 1a0:	00 97       	sbiw	r24, 0x00	; 0
 1a2:	01 f4       	brne	.+0      	; 0x1a4 <solarL298Init+0x9c>
			setError(PWM_PIN_NOT_AVAILABLE);
 1a4:	84 ef       	ldi	r24, 0xF4	; 244
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <solarL298Init+0xa0>
			continue;
		}
		if(compareIsInUse(channel)){
 1a8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1ac:	88 23       	and	r24, r24
 1ae:	01 f0       	breq	.+0      	; 0x1b0 <solarL298Init+0xa8>
			setError(PWM_PIN_IN_USE);
 1b0:	83 ef       	ldi	r24, 0xF3	; 243
 1b2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			continue;
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <solarL298Init+0xb0>
 1b8:	f3 01       	movw	r30, r6
 1ba:	32 96       	adiw	r30, 0x02	; 2
 1bc:	e4 91       	lpm	r30, Z
 1be:	f0 e0       	ldi	r31, 0x00	; 0

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 1c0:	2c e2       	ldi	r18, 0x2C	; 44
 1c2:	30 e0       	ldi	r19, 0x00	; 0
 1c4:	e2 9f       	mul	r30, r18
 1c6:	50 01       	movw	r10, r0
 1c8:	e3 9f       	mul	r30, r19
 1ca:	b0 0c       	add	r11, r0
 1cc:	f2 9f       	mul	r31, r18
 1ce:	b0 0c       	add	r11, r0
 1d0:	11 24       	eor	r1, r1
 1d2:	80 e0       	ldi	r24, 0x00	; 0
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	a8 0e       	add	r10, r24
 1d8:	b9 1e       	adc	r11, r25

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 1da:	c5 01       	movw	r24, r10
 1dc:	4e 81       	ldd	r20, Y+6	; 0x06
 1de:	5f 81       	ldd	r21, Y+7	; 0x07
 1e0:	68 85       	ldd	r22, Y+8	; 0x08
 1e2:	79 85       	ldd	r23, Y+9	; 0x09
 1e4:	20 e8       	ldi	r18, 0x80	; 128
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	8e 01       	movw	r16, r28
 1ea:	0f 5f       	subi	r16, 0xFF	; 255
 1ec:	1f 4f       	sbci	r17, 0xFF	; 255
 1ee:	a4 e0       	ldi	r26, 0x04	; 4
 1f0:	ea 2e       	mov	r14, r26
 1f2:	f1 2c       	mov	r15, r1
 1f4:	ec 0e       	add	r14, r28
 1f6:	fd 1e       	adc	r15, r29
 1f8:	b2 e0       	ldi	r27, 0x02	; 2
 1fa:	cb 2e       	mov	r12, r27
 1fc:	d1 2c       	mov	r13, r1
 1fe:	cc 0e       	add	r12, r28
 200:	dd 1e       	adc	r13, r29
 202:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 206:	f5 01       	movw	r30, r10
 208:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 20a:	88 23       	and	r24, r24
 20c:	01 f4       	brne	.+0      	; 0x20e <solarL298Init+0x106>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 20e:	85 91       	lpm	r24, Z+
 210:	94 91       	lpm	r25, Z
 212:	fc 01       	movw	r30, r24
 214:	80 81       	ld	r24, Z
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	87 70       	andi	r24, 0x07	; 7
 21a:	90 70       	andi	r25, 0x00	; 0
 21c:	00 97       	sbiw	r24, 0x00	; 0
 21e:	01 f0       	breq	.+0      	; 0x220 <solarL298Init+0x118>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 220:	82 ef       	ldi	r24, 0xF2	; 242
 222:	00 c0       	rjmp	.+0      	; 0x224 <solarL298Init+0x11c>
 224:	83 ee       	ldi	r24, 0xE3	; 227
 226:	00 c0       	rjmp	.+0      	; 0x228 <solarL298Init+0x120>
 228:	85 91       	lpm	r24, Z+
 22a:	94 91       	lpm	r25, Z
 22c:	fc 01       	movw	r30, r24
 22e:	80 81       	ld	r24, Z
 230:	90 e0       	ldi	r25, 0x00	; 0
 232:	87 70       	andi	r24, 0x07	; 7
 234:	90 70       	andi	r25, 0x00	; 0
 236:	00 97       	sbiw	r24, 0x00	; 0
 238:	01 f4       	brne	.+0      	; 0x23a <solarL298Init+0x132>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <solarL298Init+0x134>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 23c:	f5 01       	movw	r30, r10
 23e:	7f 96       	adiw	r30, 0x1f	; 31
 240:	85 91       	lpm	r24, Z+
 242:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 244:	fc 01       	movw	r30, r24
 246:	8c 81       	ldd	r24, Y+4	; 0x04
 248:	9d 81       	ldd	r25, Y+5	; 0x05
 24a:	91 83       	std	Z+1, r25	; 0x01
 24c:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 24e:	20 e0       	ldi	r18, 0x00	; 0
 250:	30 e0       	ldi	r19, 0x00	; 0
 252:	f4 01       	movw	r30, r8
 254:	31 83       	std	Z+1, r19	; 0x01
 256:	20 83       	st	Z, r18

			// Make sure the motor pin is an output pin
			pin_make_output(motor->pin, FALSE);
 258:	84 81       	ldd	r24, Z+4	; 0x04
 25a:	95 81       	ldd	r25, Z+5	; 0x05
 25c:	60 e0       	ldi	r22, 0x00	; 0
 25e:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Make sure the direction pin is set as an output pin
			pin_make_output(motor->enable1, FALSE);
 262:	f4 01       	movw	r30, r8
 264:	86 81       	ldd	r24, Z+6	; 0x06
 266:	97 81       	ldd	r25, Z+7	; 0x07
 268:	60 e0       	ldi	r22, 0x00	; 0
 26a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->enable2, FALSE);
 26e:	f4 01       	movw	r30, r8
 270:	80 85       	ldd	r24, Z+8	; 0x08
 272:	91 85       	ldd	r25, Z+9	; 0x09
 274:	60 e0       	ldi	r22, 0x00	; 0
 276:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 27a:	c3 01       	movw	r24, r6
 27c:	60 e0       	ldi	r22, 0x00	; 0
 27e:	70 e0       	ldi	r23, 0x00	; 0
 280:	40 e0       	ldi	r20, 0x00	; 0
 282:	50 e0       	ldi	r21, 0x00	; 0
 284:	20 e0       	ldi	r18, 0x00	; 0
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 28c:	6a 81       	ldd	r22, Y+2	; 0x02
 28e:	7b 81       	ldd	r23, Y+3	; 0x03
 290:	c5 01       	movw	r24, r10
 292:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 296:	c4 01       	movw	r24, r8
 298:	60 e0       	ldi	r22, 0x00	; 0
 29a:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 29e:	c4 01       	movw	r24, r8
 2a0:	6f ef       	ldi	r22, 0xFF	; 255
 2a2:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 2a6:	08 94       	sec
 2a8:	41 1c       	adc	r4, r1
 2aa:	51 1c       	adc	r5, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void solarL298Init(SOLAR_L298_MOTOR_DRIVER* driver, uint32_t freq){
 2ac:	8a 85       	ldd	r24, Y+10	; 0x0a
 2ae:	9b 85       	ldd	r25, Y+11	; 0x0b
 2b0:	84 19       	sub	r24, r4
 2b2:	95 09       	sbc	r25, r5
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 2b4:	ff ef       	ldi	r31, 0xFF	; 255
 2b6:	8f 3f       	cpi	r24, 0xFF	; 255
 2b8:	9f 07       	cpc	r25, r31
 2ba:	01 f0       	breq	.+0      	; 0x2bc <solarL298Init+0x1b4>
 2bc:	00 c0       	rjmp	.+0      	; 0x2be <solarL298Init+0x1b6>
 2be:	00 c0       	rjmp	.+0      	; 0x2c0 <solarL298Init+0x1b8>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 2c0:	c5 01       	movw	r24, r10
 2c2:	69 81       	ldd	r22, Y+1	; 0x01
 2c4:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 2c8:	81 e0       	ldi	r24, 0x01	; 1
 2ca:	90 e0       	ldi	r25, 0x00	; 0
 2cc:	09 80       	ldd	r0, Y+1	; 0x01
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <solarL298Init+0x1c8>
 2d0:	88 0f       	add	r24, r24
 2d2:	99 1f       	adc	r25, r25
 2d4:	0a 94       	dec	r0
 2d6:	02 f4       	brpl	.+0      	; 0x2d8 <solarL298Init+0x1d0>
 2d8:	80 70       	andi	r24, 0x00	; 0
 2da:	95 75       	andi	r25, 0x55	; 85
 2dc:	00 97       	sbiw	r24, 0x00	; 0
 2de:	01 f0       	breq	.+0      	; 0x2e0 <solarL298Init+0x1d8>
 2e0:	00 c0       	rjmp	.+0      	; 0x2e2 <solarL298Init+0x1da>
 2e2:	00 c0       	rjmp	.+0      	; 0x2e4 <solarL298Init+0x1dc>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 2e4:	2d 96       	adiw	r28, 0x0d	; 13
 2e6:	0f b6       	in	r0, 0x3f	; 63
 2e8:	f8 94       	cli
 2ea:	de bf       	out	0x3e, r29	; 62
 2ec:	0f be       	out	0x3f, r0	; 63
 2ee:	cd bf       	out	0x3d, r28	; 61
 2f0:	df 91       	pop	r29
 2f2:	cf 91       	pop	r28
 2f4:	1f 91       	pop	r17
 2f6:	0f 91       	pop	r16
 2f8:	ff 90       	pop	r15
 2fa:	ef 90       	pop	r14
 2fc:	df 90       	pop	r13
 2fe:	cf 90       	pop	r12
 300:	bf 90       	pop	r11
 302:	af 90       	pop	r10
 304:	9f 90       	pop	r9
 306:	8f 90       	pop	r8
 308:	7f 90       	pop	r7
 30a:	6f 90       	pop	r6
 30c:	5f 90       	pop	r5
 30e:	4f 90       	pop	r4
 310:	3f 90       	pop	r3
 312:	2f 90       	pop	r2
 314:	08 95       	ret

TB6612FNG_2pin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003d2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000406  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000406  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000406  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a74  00000000  00000000  0000040a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002a0  00000000  00000000  00000e7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000008e0  00000000  00000000  0000111e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000019fe  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000068  00000000  00000000  00001a1e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000192  00000000  00000000  00001a86  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000006cb  00000000  00000000  00001c18  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000150  00000000  00000000  000022e4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	ec 01       	movw	r28, r24
  14:	f6 2e       	mov	r15, r22
	TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
  16:	8c 81       	ldd	r24, Y+4	; 0x04
  18:	9d 81       	ldd	r25, Y+5	; 0x05
  1a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  1e:	5c 01       	movw	r10, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
  20:	8e 81       	ldd	r24, Y+6	; 0x06
  22:	9f 81       	ldd	r25, Y+7	; 0x07
  24:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  28:	6c 01       	movw	r12, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  2a:	1f 14       	cp	r1, r15
  2c:	04 f4       	brge	.+0      	; 0x2e <setSpeed+0x2e>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  2e:	fc 01       	movw	r30, r24
  30:	32 96       	adiw	r30, 0x02	; 2
  32:	e4 91       	lpm	r30, Z
  34:	f0 e0       	ldi	r31, 0x00	; 0
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0, timerGetTOP(compareGetTimer(channel2)));
  36:	2c e2       	ldi	r18, 0x2C	; 44
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	e2 9f       	mul	r30, r18
  3c:	c0 01       	movw	r24, r0
  3e:	e3 9f       	mul	r30, r19
  40:	90 0d       	add	r25, r0
  42:	f2 9f       	mul	r31, r18
  44:	90 0d       	add	r25, r0
  46:	11 24       	eor	r1, r1
  48:	80 50       	subi	r24, 0x00	; 0
  4a:	90 40       	sbci	r25, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  50:	8c 01       	movw	r16, r24
  52:	8f 2d       	mov	r24, r15
  54:	99 27       	eor	r25, r25
  56:	87 fd       	sbrc	r24, 7
  58:	90 95       	com	r25
  5a:	60 e0       	ldi	r22, 0x00	; 0
  5c:	70 e0       	ldi	r23, 0x00	; 0
  5e:	4f e7       	ldi	r20, 0x7F	; 127
  60:	50 e0       	ldi	r21, 0x00	; 0
  62:	20 e0       	ldi	r18, 0x00	; 0
  64:	30 e0       	ldi	r19, 0x00	; 0
  66:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  6a:	ec 01       	movw	r28, r24
		compareSetThreshold(channel1,0);	    // Keep permanently high
  6c:	c5 01       	movw	r24, r10
  6e:	60 e0       	ldi	r22, 0x00	; 0
  70:	70 e0       	ldi	r23, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,delay);	// pwm channel 2
  76:	c6 01       	movw	r24, r12
  78:	00 c0       	rjmp	.+0      	; 0x7a <setSpeed+0x7a>
	}else if(speed < 0){
  7a:	ff 20       	and	r15, r15
  7c:	01 f0       	breq	.+0      	; 0x7e <setSpeed+0x7e>
  7e:	f5 01       	movw	r30, r10
  80:	32 96       	adiw	r30, 0x02	; 2
  82:	e4 91       	lpm	r30, Z
  84:	f0 e0       	ldi	r31, 0x00	; 0
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , timerGetTOP(compareGetTimer(channel1)));
  86:	2c e2       	ldi	r18, 0x2C	; 44
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	e2 9f       	mul	r30, r18
  8c:	c0 01       	movw	r24, r0
  8e:	e3 9f       	mul	r30, r19
  90:	90 0d       	add	r25, r0
  92:	f2 9f       	mul	r31, r18
  94:	90 0d       	add	r25, r0
  96:	11 24       	eor	r1, r1
  98:	80 50       	subi	r24, 0x00	; 0
  9a:	90 40       	sbci	r25, 0x00	; 0
  9c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  a0:	8c 01       	movw	r16, r24
  a2:	8f 2d       	mov	r24, r15
  a4:	99 27       	eor	r25, r25
  a6:	87 fd       	sbrc	r24, 7
  a8:	90 95       	com	r25
  aa:	60 e0       	ldi	r22, 0x00	; 0
  ac:	70 e0       	ldi	r23, 0x00	; 0
  ae:	41 e8       	ldi	r20, 0x81	; 129
  b0:	5f ef       	ldi	r21, 0xFF	; 255
  b2:	20 e0       	ldi	r18, 0x00	; 0
  b4:	30 e0       	ldi	r19, 0x00	; 0
  b6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  ba:	ec 01       	movw	r28, r24
		compareSetThreshold(channel2,0);	    // Keep permanently high
  bc:	c6 01       	movw	r24, r12
  be:	60 e0       	ldi	r22, 0x00	; 0
  c0:	70 e0       	ldi	r23, 0x00	; 0
  c2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel1,delay);	// pwm channel 1
  c6:	c5 01       	movw	r24, r10
  c8:	be 01       	movw	r22, r28
  ca:	00 c0       	rjmp	.+0      	; 0xcc <setSpeed+0xcc>
	}else{
		// brake
		// Set both pins high
		compareSetThreshold(channel1,0);	    // Keep permanently high
  cc:	c5 01       	movw	r24, r10
  ce:	60 e0       	ldi	r22, 0x00	; 0
  d0:	70 e0       	ldi	r23, 0x00	; 0
  d2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		compareSetThreshold(channel2,0);	    // Keep permanently high
  d6:	c6 01       	movw	r24, r12
  d8:	60 e0       	ldi	r22, 0x00	; 0
  da:	70 e0       	ldi	r23, 0x00	; 0
  dc:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}
}
  e0:	df 91       	pop	r29
  e2:	cf 91       	pop	r28
  e4:	1f 91       	pop	r17
  e6:	0f 91       	pop	r16
  e8:	ff 90       	pop	r15
  ea:	df 90       	pop	r13
  ec:	cf 90       	pop	r12
  ee:	bf 90       	pop	r11
  f0:	af 90       	pop	r10
  f2:	08 95       	ret

000000f4 <initPWM>:
}

// Define the class
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

static boolean initPWM(const IOPin* pin, uint32_t deciHertz){
  f4:	6f 92       	push	r6
  f6:	7f 92       	push	r7
  f8:	8f 92       	push	r8
  fa:	9f 92       	push	r9
  fc:	af 92       	push	r10
  fe:	bf 92       	push	r11
 100:	cf 92       	push	r12
 102:	df 92       	push	r13
 104:	ef 92       	push	r14
 106:	ff 92       	push	r15
 108:	0f 93       	push	r16
 10a:	1f 93       	push	r17
 10c:	cf 93       	push	r28
 10e:	df 93       	push	r29
 110:	00 d0       	rcall	.+0      	; 0x112 <initPWM+0x1e>
 112:	00 d0       	rcall	.+0      	; 0x114 <initPWM+0x20>
 114:	0f 92       	push	r0
 116:	cd b7       	in	r28, 0x3d	; 61
 118:	de b7       	in	r29, 0x3e	; 62
 11a:	3c 01       	movw	r6, r24
 11c:	6a 01       	movw	r12, r20
 11e:	7b 01       	movw	r14, r22
	const TimerCompare* channel = compareFromIOPin(pin);
 120:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 124:	4c 01       	movw	r8, r24

	if(channel==null){
 126:	00 97       	sbiw	r24, 0x00	; 0
 128:	01 f4       	brne	.+0      	; 0x12a <initPWM+0x36>
		setError(PWM_PIN_NOT_AVAILABLE);
 12a:	84 ef       	ldi	r24, 0xF4	; 244
 12c:	00 c0       	rjmp	.+0      	; 0x12e <initPWM+0x3a>
		return FALSE;
	}
	if(compareIsInUse(channel)){
 12e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 132:	88 23       	and	r24, r24
 134:	01 f0       	breq	.+0      	; 0x136 <initPWM+0x42>
		setError(PWM_PIN_IN_USE);
 136:	83 ef       	ldi	r24, 0xF3	; 243
 138:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		return FALSE;
 13c:	cc 24       	eor	r12, r12
 13e:	00 c0       	rjmp	.+0      	; 0x140 <initPWM+0x4c>
 140:	f4 01       	movw	r30, r8
 142:	32 96       	adiw	r30, 0x02	; 2
 144:	e4 91       	lpm	r30, Z
 146:	f0 e0       	ldi	r31, 0x00	; 0

	TIMER_MODE mode;
	uint16_t icr;
	uint16_t prescaler;

	const Timer* timer = compareGetTimer(channel);
 148:	8c e2       	ldi	r24, 0x2C	; 44
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	e8 9f       	mul	r30, r24
 14e:	50 01       	movw	r10, r0
 150:	e9 9f       	mul	r30, r25
 152:	b0 0c       	add	r11, r0
 154:	f8 9f       	mul	r31, r24
 156:	b0 0c       	add	r11, r0
 158:	11 24       	eor	r1, r1
 15a:	80 e0       	ldi	r24, 0x00	; 0
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	a8 0e       	add	r10, r24
 160:	b9 1e       	adc	r11, r25

	// Find the best PWM setting for 10kHz, with 128 steps
	boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 162:	c5 01       	movw	r24, r10
 164:	b7 01       	movw	r22, r14
 166:	a6 01       	movw	r20, r12
 168:	20 e8       	ldi	r18, 0x80	; 128
 16a:	30 e0       	ldi	r19, 0x00	; 0
 16c:	8e 01       	movw	r16, r28
 16e:	0f 5f       	subi	r16, 0xFF	; 255
 170:	1f 4f       	sbci	r17, 0xFF	; 255
 172:	a4 e0       	ldi	r26, 0x04	; 4
 174:	ea 2e       	mov	r14, r26
 176:	f1 2c       	mov	r15, r1
 178:	ec 0e       	add	r14, r28
 17a:	fd 1e       	adc	r15, r29
 17c:	b2 e0       	ldi	r27, 0x02	; 2
 17e:	cb 2e       	mov	r12, r27
 180:	d1 2c       	mov	r13, r1
 182:	cc 0e       	add	r12, r28
 184:	dd 1e       	adc	r13, r29
 186:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 18a:	c8 2e       	mov	r12, r24
 18c:	f5 01       	movw	r30, r10
 18e:	34 96       	adiw	r30, 0x04	; 4
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 190:	85 91       	lpm	r24, Z+
 192:	94 91       	lpm	r25, Z
 194:	fc 01       	movw	r30, r24
 196:	80 81       	ld	r24, Z
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	87 70       	andi	r24, 0x07	; 7
 19c:	90 70       	andi	r25, 0x00	; 0

	if(!valid){
 19e:	cc 20       	and	r12, r12
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <initPWM+0xae>
 1a2:	00 97       	sbiw	r24, 0x00	; 0
 1a4:	01 f0       	breq	.+0      	; 0x1a6 <initPWM+0xb2>
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 1a6:	82 ef       	ldi	r24, 0xF2	; 242
 1a8:	00 c0       	rjmp	.+0      	; 0x1aa <initPWM+0xb6>
 1aa:	83 ee       	ldi	r24, 0xE3	; 227
 1ac:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <initPWM+0xbe>
 1b2:	00 97       	sbiw	r24, 0x00	; 0
 1b4:	01 f4       	brne	.+0      	; 0x1b6 <initPWM+0xc2>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <initPWM+0xc4>
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
			if(modeIsICR(mode)){
				// Set the ICR
				PORT icrPort = pgm_read_word(&timer->pgm_icr);
 1b8:	f5 01       	movw	r30, r10
 1ba:	7f 96       	adiw	r30, 0x1f	; 31
 1bc:	85 91       	lpm	r24, Z+
 1be:	94 91       	lpm	r25, Z
				_SFR_MEM16(icrPort)=icr;
 1c0:	fc 01       	movw	r30, r24
 1c2:	8c 81       	ldd	r24, Y+4	; 0x04
 1c4:	9d 81       	ldd	r25, Y+5	; 0x05
 1c6:	91 83       	std	Z+1, r25	; 0x01
 1c8:	80 83       	st	Z, r24
			}
		}

		// Make it an output pin and set high for brake
		pin_make_output(pin,TRUE);
 1ca:	c3 01       	movw	r24, r6
 1cc:	6f ef       	ldi	r22, 0xFF	; 255
 1ce:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Use inverting PWM
		compareSetOutputMode(channel,CHANNEL_MODE_INVERTING);
 1d2:	c4 01       	movw	r24, r8
 1d4:	63 e0       	ldi	r22, 0x03	; 3
 1d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Mark the channels as in use
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 1da:	c4 01       	movw	r24, r8
 1dc:	60 e0       	ldi	r22, 0x00	; 0
 1de:	70 e0       	ldi	r23, 0x00	; 0
 1e0:	40 e0       	ldi	r20, 0x00	; 0
 1e2:	50 e0       	ldi	r21, 0x00	; 0
 1e4:	20 e0       	ldi	r18, 0x00	; 0
 1e6:	30 e0       	ldi	r19, 0x00	; 0
 1e8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescaler);
 1ec:	6a 81       	ldd	r22, Y+2	; 0x02
 1ee:	7b 81       	ldd	r23, Y+3	; 0x03
 1f0:	c5 01       	movw	r24, r10
 1f2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}
	return valid;
}
 1f6:	8c 2d       	mov	r24, r12
 1f8:	0f 90       	pop	r0
 1fa:	0f 90       	pop	r0
 1fc:	0f 90       	pop	r0
 1fe:	0f 90       	pop	r0
 200:	0f 90       	pop	r0
 202:	df 91       	pop	r29
 204:	cf 91       	pop	r28
 206:	1f 91       	pop	r17
 208:	0f 91       	pop	r16
 20a:	ff 90       	pop	r15
 20c:	ef 90       	pop	r14
 20e:	df 90       	pop	r13
 210:	cf 90       	pop	r12
 212:	bf 90       	pop	r11
 214:	af 90       	pop	r10
 216:	9f 90       	pop	r9
 218:	8f 90       	pop	r8
 21a:	7f 90       	pop	r7
 21c:	6f 90       	pop	r6
 21e:	08 95       	ret
		// There is no PWM setting that is valid
		setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
	}else{
		// Lets set up the PWM
		if(!timerIsInUse(timer)){
			timerSetMode(timer,mode);
 220:	c5 01       	movw	r24, r10
 222:	69 81       	ldd	r22, Y+1	; 0x01
 224:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			if(modeIsICR(mode)){
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	09 80       	ldd	r0, Y+1	; 0x01
 22e:	00 c0       	rjmp	.+0      	; 0x230 <initPWM+0x13c>
 230:	88 0f       	add	r24, r24
 232:	99 1f       	adc	r25, r25
 234:	0a 94       	dec	r0
 236:	02 f4       	brpl	.+0      	; 0x238 <initPWM+0x144>
 238:	80 70       	andi	r24, 0x00	; 0
 23a:	95 75       	andi	r25, 0x55	; 85
 23c:	00 97       	sbiw	r24, 0x00	; 0
 23e:	01 f0       	breq	.+0      	; 0x240 <initPWM+0x14c>
 240:	00 c0       	rjmp	.+0      	; 0x242 <initPWM+0x14e>
 242:	00 c0       	rjmp	.+0      	; 0x244 <setConnected>

00000244 <setConnected>:
		compareSetThreshold(channel1,0);	    // Keep permanently high
		compareSetThreshold(channel2,0);	    // Keep permanently high
	}
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
 244:	cf 92       	push	r12
 246:	df 92       	push	r13
 248:	ef 92       	push	r14
 24a:	ff 92       	push	r15
 24c:	0f 93       	push	r16
 24e:	1f 93       	push	r17
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	0f 92       	push	r0
 256:	cd b7       	in	r28, 0x3d	; 61
 258:	de b7       	in	r29, 0x3e	; 62
 25a:	6c 01       	movw	r12, r24
	TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)actuator;
	const TimerCompare* channel1 = compareFromIOPin(motor->pwm1);
 25c:	fc 01       	movw	r30, r24
 25e:	84 81       	ldd	r24, Z+4	; 0x04
 260:	95 81       	ldd	r25, Z+5	; 0x05
 262:	69 83       	std	Y+1, r22	; 0x01
 264:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 268:	8c 01       	movw	r16, r24
	const TimerCompare* channel2 = compareFromIOPin(motor->pwm2);
 26a:	f6 01       	movw	r30, r12
 26c:	86 81       	ldd	r24, Z+6	; 0x06
 26e:	97 81       	ldd	r25, Z+7	; 0x07
 270:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 274:	7c 01       	movw	r14, r24

	if(connected){
 276:	69 81       	ldd	r22, Y+1	; 0x01
 278:	66 23       	and	r22, r22
 27a:	01 f0       	breq	.+0      	; 0x27c <setConnected+0x38>
		// connect
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 27c:	c6 01       	movw	r24, r12
 27e:	f6 01       	movw	r30, r12
 280:	62 81       	ldd	r22, Z+2	; 0x02
 282:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 286:	00 c0       	rjmp	.+0      	; 0x288 <setConnected+0x44>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 288:	f8 01       	movw	r30, r16
 28a:	32 96       	adiw	r30, 0x02	; 2
 28c:	e4 91       	lpm	r30, Z
 28e:	f0 e0       	ldi	r31, 0x00	; 0
	}else{
		// Set both outputs to low to coast - by setting duty cycle to TOP
		compareSetThreshold(channel1, timerGetTOP(compareGetTimer(channel1)));
 290:	8c e2       	ldi	r24, 0x2C	; 44
 292:	c8 2e       	mov	r12, r24
 294:	d1 2c       	mov	r13, r1
 296:	ec 9d       	mul	r30, r12
 298:	c0 01       	movw	r24, r0
 29a:	ed 9d       	mul	r30, r13
 29c:	90 0d       	add	r25, r0
 29e:	fc 9d       	mul	r31, r12
 2a0:	90 0d       	add	r25, r0
 2a2:	11 24       	eor	r1, r1
 2a4:	80 50       	subi	r24, 0x00	; 0
 2a6:	90 40       	sbci	r25, 0x00	; 0
 2a8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2ac:	bc 01       	movw	r22, r24
 2ae:	c8 01       	movw	r24, r16
 2b0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2b4:	f7 01       	movw	r30, r14
 2b6:	32 96       	adiw	r30, 0x02	; 2
 2b8:	e4 91       	lpm	r30, Z
 2ba:	f0 e0       	ldi	r31, 0x00	; 0
		compareSetThreshold(channel2, timerGetTOP(compareGetTimer(channel2)));
 2bc:	ec 9d       	mul	r30, r12
 2be:	c0 01       	movw	r24, r0
 2c0:	ed 9d       	mul	r30, r13
 2c2:	90 0d       	add	r25, r0
 2c4:	fc 9d       	mul	r31, r12
 2c6:	90 0d       	add	r25, r0
 2c8:	11 24       	eor	r1, r1
 2ca:	80 50       	subi	r24, 0x00	; 0
 2cc:	90 40       	sbci	r25, 0x00	; 0
 2ce:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2d2:	bc 01       	movw	r22, r24
 2d4:	c7 01       	movw	r24, r14
 2d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

}
 2da:	0f 90       	pop	r0
 2dc:	df 91       	pop	r29
 2de:	cf 91       	pop	r28
 2e0:	1f 91       	pop	r17
 2e2:	0f 91       	pop	r16
 2e4:	ff 90       	pop	r15
 2e6:	ef 90       	pop	r14
 2e8:	df 90       	pop	r13
 2ea:	cf 90       	pop	r12
 2ec:	08 95       	ret

000002ee <toshibaTB6612FNG_2pin_Init>:
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 2ee:	4f 92       	push	r4
 2f0:	5f 92       	push	r5
 2f2:	6f 92       	push	r6
 2f4:	7f 92       	push	r7
 2f6:	8f 92       	push	r8
 2f8:	9f 92       	push	r9
 2fa:	af 92       	push	r10
 2fc:	bf 92       	push	r11
 2fe:	cf 92       	push	r12
 300:	df 92       	push	r13
 302:	ef 92       	push	r14
 304:	ff 92       	push	r15
 306:	0f 93       	push	r16
 308:	1f 93       	push	r17
 30a:	cf 93       	push	r28
 30c:	df 93       	push	r29
 30e:	5c 01       	movw	r10, r24
	uint32_t deciHertz = 10 * freq;
 310:	cb 01       	movw	r24, r22
 312:	ba 01       	movw	r22, r20
 314:	2a e0       	ldi	r18, 0x0A	; 10
 316:	30 e0       	ldi	r19, 0x00	; 0
 318:	40 e0       	ldi	r20, 0x00	; 0
 31a:	50 e0       	ldi	r21, 0x00	; 0
 31c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 320:	6b 01       	movw	r12, r22
 322:	7c 01       	movw	r14, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 324:	f5 01       	movw	r30, r10
 326:	82 81       	ldd	r24, Z+2	; 0x02
 328:	00 e0       	ldi	r16, 0x00	; 0
 32a:	10 e0       	ldi	r17, 0x00	; 0
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 32c:	90 e0       	ldi	r25, 0x00	; 0
 32e:	2c 01       	movw	r4, r24
 330:	08 94       	sec
 332:	41 08       	sbc	r4, r1
 334:	51 08       	sbc	r5, r1
 336:	af ef       	ldi	r26, 0xFF	; 255
 338:	8a 2e       	mov	r8, r26
 33a:	af e7       	ldi	r26, 0x7F	; 127
 33c:	9a 2e       	mov	r9, r26
 33e:	88 0e       	add	r8, r24
 340:	99 1e       	adc	r9, r25


		if(initPWM(motor->pwm1,deciHertz)){
			if(initPWM(motor->pwm2, deciHertz)){
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 342:	b0 e0       	ldi	r27, 0x00	; 0
 344:	6b 2e       	mov	r6, r27
 346:	b0 e0       	ldi	r27, 0x00	; 0
 348:	7b 2e       	mov	r7, r27
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 34a:	00 c0       	rjmp	.+0      	; 0x34c <toshibaTB6612FNG_2pin_Init+0x5e>
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 34c:	c4 01       	movw	r24, r8
 34e:	80 1b       	sub	r24, r16
 350:	91 0b       	sbc	r25, r17
 352:	88 0f       	add	r24, r24
 354:	99 1f       	adc	r25, r25
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		TOSHIBA_TB6612FNG_2pin_MOTOR* motor = (TOSHIBA_TB6612FNG_2pin_MOTOR*)pgm_read_word(&driver->motors[i]);
 356:	f5 01       	movw	r30, r10
 358:	20 81       	ld	r18, Z
 35a:	31 81       	ldd	r19, Z+1	; 0x01
 35c:	28 0f       	add	r18, r24
 35e:	39 1f       	adc	r19, r25
 360:	f9 01       	movw	r30, r18
 362:	85 91       	lpm	r24, Z+
 364:	94 91       	lpm	r25, Z
 366:	c8 2f       	mov	r28, r24
 368:	d9 2f       	mov	r29, r25


		if(initPWM(motor->pwm1,deciHertz)){
 36a:	8c 81       	ldd	r24, Y+4	; 0x04
 36c:	9d 81       	ldd	r25, Y+5	; 0x05
 36e:	b7 01       	movw	r22, r14
 370:	a6 01       	movw	r20, r12
 372:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 376:	88 23       	and	r24, r24
 378:	01 f0       	breq	.+0      	; 0x37a <toshibaTB6612FNG_2pin_Init+0x8c>
			if(initPWM(motor->pwm2, deciHertz)){
 37a:	8e 81       	ldd	r24, Y+6	; 0x06
 37c:	9f 81       	ldd	r25, Y+7	; 0x07
 37e:	b7 01       	movw	r22, r14
 380:	a6 01       	movw	r20, r12
 382:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 386:	88 23       	and	r24, r24
 388:	01 f0       	breq	.+0      	; 0x38a <toshibaTB6612FNG_2pin_Init+0x9c>
				// Connect motor to driver
				motor->actuator.class = &c_motors;
 38a:	79 82       	std	Y+1, r7	; 0x01
 38c:	68 82       	st	Y, r6
			}
		}

		// Start off braking
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 38e:	ce 01       	movw	r24, r28
 390:	60 e0       	ldi	r22, 0x00	; 0
 392:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
 396:	ce 01       	movw	r24, r28
 398:	6f ef       	ldi	r22, 0xFF	; 255
 39a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 39e:	0f 5f       	subi	r16, 0xFF	; 255
 3a0:	1f 4f       	sbci	r17, 0xFF	; 255
}

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_2pin_Init(TOSHIBA_TB6612FNG_2pin_MOTOR_DRIVER* driver, uint32_t freq){
 3a2:	c2 01       	movw	r24, r4
 3a4:	80 1b       	sub	r24, r16
 3a6:	91 0b       	sbc	r25, r17
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 3a8:	ef ef       	ldi	r30, 0xFF	; 255
 3aa:	8f 3f       	cpi	r24, 0xFF	; 255
 3ac:	9e 07       	cpc	r25, r30
 3ae:	01 f4       	brne	.+0      	; 0x3b0 <toshibaTB6612FNG_2pin_Init+0xc2>
		act_setSpeed(motor,DRIVE_SPEED_BRAKE);

		// Indicate the motor is connected
		act_setConnected(motor,TRUE);
	}
}
 3b0:	df 91       	pop	r29
 3b2:	cf 91       	pop	r28
 3b4:	1f 91       	pop	r17
 3b6:	0f 91       	pop	r16
 3b8:	ff 90       	pop	r15
 3ba:	ef 90       	pop	r14
 3bc:	df 90       	pop	r13
 3be:	cf 90       	pop	r12
 3c0:	bf 90       	pop	r11
 3c2:	af 90       	pop	r10
 3c4:	9f 90       	pop	r9
 3c6:	8f 90       	pop	r8
 3c8:	7f 90       	pop	r7
 3ca:	6f 90       	pop	r6
 3cc:	5f 90       	pop	r5
 3ce:	4f 90       	pop	r4
 3d0:	08 95       	ret

TB6612FNG_3pin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000364  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000398  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000398  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000398  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   0000095a  00000000  00000000  0000039c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000261  00000000  00000000  00000cf6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000639  00000000  00000000  00000f57  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001590  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000058  00000000  00000000  000015b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000153  00000000  00000000  00001608  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000006b7  00000000  00000000  0000175b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000f0  00000000  00000000  00001e14  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#include "../../errors.h"
#include "../../iopin.h"
#include "../../timer.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	0f 92       	push	r0
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	6c 01       	movw	r12, r24
	TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  18:	fc 01       	movw	r30, r24
  1a:	84 81       	ldd	r24, Z+4	; 0x04
  1c:	95 81       	ldd	r25, Z+5	; 0x05
  1e:	69 83       	std	Y+1, r22	; 0x01
  20:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  24:	7c 01       	movw	r14, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  26:	fc 01       	movw	r30, r24
  28:	32 96       	adiw	r30, 0x02	; 2
  2a:	e4 91       	lpm	r30, Z
  2c:	f0 e0       	ldi	r31, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
  2e:	2c e2       	ldi	r18, 0x2C	; 44
  30:	30 e0       	ldi	r19, 0x00	; 0
  32:	e2 9f       	mul	r30, r18
  34:	c0 01       	movw	r24, r0
  36:	e3 9f       	mul	r30, r19
  38:	90 0d       	add	r25, r0
  3a:	f2 9f       	mul	r31, r18
  3c:	90 0d       	add	r25, r0
  3e:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  40:	80 50       	subi	r24, 0x00	; 0
  42:	90 40       	sbci	r25, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  48:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  4a:	69 81       	ldd	r22, Y+1	; 0x01
  4c:	16 16       	cp	r1, r22
  4e:	04 f4       	brge	.+0      	; 0x50 <setSpeed+0x50>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  50:	86 2f       	mov	r24, r22
  52:	99 27       	eor	r25, r25
  54:	87 fd       	sbrc	r24, 7
  56:	90 95       	com	r25
  58:	60 e0       	ldi	r22, 0x00	; 0
  5a:	70 e0       	ldi	r23, 0x00	; 0
  5c:	4f e7       	ldi	r20, 0x7F	; 127
  5e:	50 e0       	ldi	r21, 0x00	; 0
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	30 e0       	ldi	r19, 0x00	; 0
  64:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  68:	8c 01       	movw	r16, r24
		// Set pins high and low
		pin_high(motor->enable1);
  6a:	f6 01       	movw	r30, r12
  6c:	86 81       	ldd	r24, Z+6	; 0x06
  6e:	97 81       	ldd	r25, Z+7	; 0x07
  70:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable2);
  74:	f6 01       	movw	r30, r12
  76:	80 85       	ldd	r24, Z+8	; 0x08
  78:	91 85       	ldd	r25, Z+9	; 0x09
  7a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  7e:	00 c0       	rjmp	.+0      	; 0x80 <setSpeed+0x80>
	}else if(speed < 0){
  80:	66 23       	and	r22, r22
  82:	01 f0       	breq	.+0      	; 0x84 <setSpeed+0x84>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  84:	86 2f       	mov	r24, r22
  86:	99 27       	eor	r25, r25
  88:	87 fd       	sbrc	r24, 7
  8a:	90 95       	com	r25
  8c:	60 e0       	ldi	r22, 0x00	; 0
  8e:	70 e0       	ldi	r23, 0x00	; 0
  90:	41 e8       	ldi	r20, 0x81	; 129
  92:	5f ef       	ldi	r21, 0xFF	; 255
  94:	20 e0       	ldi	r18, 0x00	; 0
  96:	30 e0       	ldi	r19, 0x00	; 0
  98:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  9c:	8c 01       	movw	r16, r24
		// Set pins low and high
		pin_low(motor->enable1);
  9e:	f6 01       	movw	r30, r12
  a0:	86 81       	ldd	r24, Z+6	; 0x06
  a2:	97 81       	ldd	r25, Z+7	; 0x07
  a4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->enable2);
  a8:	f6 01       	movw	r30, r12
  aa:	80 85       	ldd	r24, Z+8	; 0x08
  ac:	91 85       	ldd	r25, Z+9	; 0x09
  ae:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <setSpeed+0xb4>
	}else{
		// brake
		// Set both pins high, and the PWM to anything
		delay = 0;
		pin_high(motor->enable1);
  b4:	f6 01       	movw	r30, r12
  b6:	86 81       	ldd	r24, Z+6	; 0x06
  b8:	97 81       	ldd	r25, Z+7	; 0x07
  ba:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->enable2);
  be:	f6 01       	movw	r30, r12
  c0:	80 85       	ldd	r24, Z+8	; 0x08
  c2:	91 85       	ldd	r25, Z+9	; 0x09
  c4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable1);
		pin_high(motor->enable2);
	}else{
		// brake
		// Set both pins high, and the PWM to anything
		delay = 0;
  c8:	00 e0       	ldi	r16, 0x00	; 0
  ca:	10 e0       	ldi	r17, 0x00	; 0
		pin_high(motor->enable1);
		pin_high(motor->enable2);
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  cc:	c7 01       	movw	r24, r14
  ce:	b8 01       	movw	r22, r16
  d0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
}
  d4:	0f 90       	pop	r0
  d6:	df 91       	pop	r29
  d8:	cf 91       	pop	r28
  da:	1f 91       	pop	r17
  dc:	0f 91       	pop	r16
  de:	ff 90       	pop	r15
  e0:	ef 90       	pop	r14
  e2:	df 90       	pop	r13
  e4:	cf 90       	pop	r12
  e6:	08 95       	ret

000000e8 <setConnected>:

static void setConnected(__ACTUATOR *actuator, boolean connected){
  e8:	0f 93       	push	r16
  ea:	1f 93       	push	r17
  ec:	cf 93       	push	r28
  ee:	df 93       	push	r29
  f0:	0f 92       	push	r0
  f2:	cd b7       	in	r28, 0x3d	; 61
  f4:	de b7       	in	r29, 0x3e	; 62
  f6:	8c 01       	movw	r16, r24
	TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  f8:	fc 01       	movw	r30, r24
  fa:	84 81       	ldd	r24, Z+4	; 0x04
  fc:	95 81       	ldd	r25, Z+5	; 0x05
  fe:	69 83       	std	Y+1, r22	; 0x01
 100:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

	if(connected){
 104:	69 81       	ldd	r22, Y+1	; 0x01
 106:	66 23       	and	r22, r22
 108:	01 f0       	breq	.+0      	; 0x10a <setConnected+0x22>
		// connect
		// turn PWM back on
		compareSetOutputMode(channel, CHANNEL_MODE_NON_INVERTING);
 10a:	62 e0       	ldi	r22, 0x02	; 2
 10c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		// restore previous speed
		setSpeed(actuator, act_getSpeed(motor));
 110:	c8 01       	movw	r24, r16
 112:	f8 01       	movw	r30, r16
 114:	62 81       	ldd	r22, Z+2	; 0x02
 116:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <setConnected+0x34>
	}else{
		// coast Set PWM output always high
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
 11c:	60 e0       	ldi	r22, 0x00	; 0
 11e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_high(motor->pwm);
 122:	f8 01       	movw	r30, r16
 124:	84 81       	ldd	r24, Z+4	; 0x04
 126:	95 81       	ldd	r25, Z+5	; 0x05
 128:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Set both input pins low
		pin_low(motor->enable1);
 12c:	f8 01       	movw	r30, r16
 12e:	86 81       	ldd	r24, Z+6	; 0x06
 130:	97 81       	ldd	r25, Z+7	; 0x07
 132:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		pin_low(motor->enable2);
 136:	f8 01       	movw	r30, r16
 138:	80 85       	ldd	r24, Z+8	; 0x08
 13a:	91 85       	ldd	r25, Z+9	; 0x09
 13c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

}
 140:	0f 90       	pop	r0
 142:	df 91       	pop	r29
 144:	cf 91       	pop	r28
 146:	1f 91       	pop	r17
 148:	0f 91       	pop	r16
 14a:	08 95       	ret

0000014c <toshibaTB6612FNG_3pin_Init>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 14c:	2f 92       	push	r2
 14e:	3f 92       	push	r3
 150:	4f 92       	push	r4
 152:	5f 92       	push	r5
 154:	6f 92       	push	r6
 156:	7f 92       	push	r7
 158:	8f 92       	push	r8
 15a:	9f 92       	push	r9
 15c:	af 92       	push	r10
 15e:	bf 92       	push	r11
 160:	cf 92       	push	r12
 162:	df 92       	push	r13
 164:	ef 92       	push	r14
 166:	ff 92       	push	r15
 168:	0f 93       	push	r16
 16a:	1f 93       	push	r17
 16c:	cf 93       	push	r28
 16e:	df 93       	push	r29
 170:	cd b7       	in	r28, 0x3d	; 61
 172:	de b7       	in	r29, 0x3e	; 62
 174:	2d 97       	sbiw	r28, 0x0d	; 13
 176:	0f b6       	in	r0, 0x3f	; 63
 178:	f8 94       	cli
 17a:	de bf       	out	0x3e, r29	; 62
 17c:	0f be       	out	0x3f, r0	; 63
 17e:	cd bf       	out	0x3d, r28	; 61
 180:	1c 01       	movw	r2, r24
	uint32_t deciHertz = 10 * freq;
 182:	cb 01       	movw	r24, r22
 184:	ba 01       	movw	r22, r20
 186:	2a e0       	ldi	r18, 0x0A	; 10
 188:	30 e0       	ldi	r19, 0x00	; 0
 18a:	40 e0       	ldi	r20, 0x00	; 0
 18c:	50 e0       	ldi	r21, 0x00	; 0
 18e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 192:	6e 83       	std	Y+6, r22	; 0x06
 194:	7f 83       	std	Y+7, r23	; 0x07
 196:	88 87       	std	Y+8, r24	; 0x08
 198:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 19a:	f1 01       	movw	r30, r2
 19c:	82 81       	ldd	r24, Z+2	; 0x02
 19e:	44 24       	eor	r4, r4
 1a0:	55 24       	eor	r5, r5
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	9c 01       	movw	r18, r24
 1a6:	21 50       	subi	r18, 0x01	; 1
 1a8:	30 40       	sbci	r19, 0x00	; 0
 1aa:	3b 87       	std	Y+11, r19	; 0x0b
 1ac:	2a 87       	std	Y+10, r18	; 0x0a
 1ae:	fc 01       	movw	r30, r24
 1b0:	e1 50       	subi	r30, 0x01	; 1
 1b2:	f0 48       	sbci	r31, 0x80	; 128
 1b4:	fd 87       	std	Y+13, r31	; 0x0d
 1b6:	ec 87       	std	Y+12, r30	; 0x0c
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <toshibaTB6612FNG_3pin_Init+0x6e>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 1ba:	8c 85       	ldd	r24, Y+12	; 0x0c
 1bc:	9d 85       	ldd	r25, Y+13	; 0x0d
 1be:	84 19       	sub	r24, r4
 1c0:	95 09       	sbc	r25, r5
 1c2:	88 0f       	add	r24, r24
 1c4:	99 1f       	adc	r25, r25
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		TOSHIBA_TB6612FNG_3pin_MOTOR* motor = (TOSHIBA_TB6612FNG_3pin_MOTOR*)pgm_read_word(&driver->motors[i]);
 1c6:	f1 01       	movw	r30, r2
 1c8:	20 81       	ld	r18, Z
 1ca:	31 81       	ldd	r19, Z+1	; 0x01
 1cc:	28 0f       	add	r18, r24
 1ce:	39 1f       	adc	r19, r25
 1d0:	f9 01       	movw	r30, r18
 1d2:	85 91       	lpm	r24, Z+
 1d4:	94 91       	lpm	r25, Z
 1d6:	4c 01       	movw	r8, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 1d8:	fc 01       	movw	r30, r24
 1da:	84 81       	ldd	r24, Z+4	; 0x04
 1dc:	95 81       	ldd	r25, Z+5	; 0x05
 1de:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1e2:	3c 01       	movw	r6, r24
		if(channel==null){
 1e4:	00 97       	sbiw	r24, 0x00	; 0
 1e6:	01 f4       	brne	.+0      	; 0x1e8 <toshibaTB6612FNG_3pin_Init+0x9c>
			setError(PWM_PIN_NOT_AVAILABLE);
 1e8:	84 ef       	ldi	r24, 0xF4	; 244
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <toshibaTB6612FNG_3pin_Init+0xa0>
			continue;
		}
		if(compareIsInUse(channel)){
 1ec:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1f0:	88 23       	and	r24, r24
 1f2:	01 f0       	breq	.+0      	; 0x1f4 <toshibaTB6612FNG_3pin_Init+0xa8>
			setError(PWM_PIN_IN_USE);
 1f4:	83 ef       	ldi	r24, 0xF3	; 243
 1f6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			continue;
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <toshibaTB6612FNG_3pin_Init+0xb0>
 1fc:	f3 01       	movw	r30, r6
 1fe:	32 96       	adiw	r30, 0x02	; 2
 200:	e4 91       	lpm	r30, Z
 202:	f0 e0       	ldi	r31, 0x00	; 0

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 204:	2c e2       	ldi	r18, 0x2C	; 44
 206:	30 e0       	ldi	r19, 0x00	; 0
 208:	e2 9f       	mul	r30, r18
 20a:	50 01       	movw	r10, r0
 20c:	e3 9f       	mul	r30, r19
 20e:	b0 0c       	add	r11, r0
 210:	f2 9f       	mul	r31, r18
 212:	b0 0c       	add	r11, r0
 214:	11 24       	eor	r1, r1
 216:	80 e0       	ldi	r24, 0x00	; 0
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	a8 0e       	add	r10, r24
 21c:	b9 1e       	adc	r11, r25

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 21e:	c5 01       	movw	r24, r10
 220:	4e 81       	ldd	r20, Y+6	; 0x06
 222:	5f 81       	ldd	r21, Y+7	; 0x07
 224:	68 85       	ldd	r22, Y+8	; 0x08
 226:	79 85       	ldd	r23, Y+9	; 0x09
 228:	20 e8       	ldi	r18, 0x80	; 128
 22a:	30 e0       	ldi	r19, 0x00	; 0
 22c:	8e 01       	movw	r16, r28
 22e:	0f 5f       	subi	r16, 0xFF	; 255
 230:	1f 4f       	sbci	r17, 0xFF	; 255
 232:	a4 e0       	ldi	r26, 0x04	; 4
 234:	ea 2e       	mov	r14, r26
 236:	f1 2c       	mov	r15, r1
 238:	ec 0e       	add	r14, r28
 23a:	fd 1e       	adc	r15, r29
 23c:	b2 e0       	ldi	r27, 0x02	; 2
 23e:	cb 2e       	mov	r12, r27
 240:	d1 2c       	mov	r13, r1
 242:	cc 0e       	add	r12, r28
 244:	dd 1e       	adc	r13, r29
 246:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 24a:	f5 01       	movw	r30, r10
 24c:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 24e:	88 23       	and	r24, r24
 250:	01 f4       	brne	.+0      	; 0x252 <toshibaTB6612FNG_3pin_Init+0x106>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 252:	85 91       	lpm	r24, Z+
 254:	94 91       	lpm	r25, Z
 256:	fc 01       	movw	r30, r24
 258:	80 81       	ld	r24, Z
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	87 70       	andi	r24, 0x07	; 7
 25e:	90 70       	andi	r25, 0x00	; 0
 260:	00 97       	sbiw	r24, 0x00	; 0
 262:	01 f0       	breq	.+0      	; 0x264 <toshibaTB6612FNG_3pin_Init+0x118>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 264:	82 ef       	ldi	r24, 0xF2	; 242
 266:	00 c0       	rjmp	.+0      	; 0x268 <toshibaTB6612FNG_3pin_Init+0x11c>
 268:	83 ee       	ldi	r24, 0xE3	; 227
 26a:	00 c0       	rjmp	.+0      	; 0x26c <toshibaTB6612FNG_3pin_Init+0x120>
 26c:	85 91       	lpm	r24, Z+
 26e:	94 91       	lpm	r25, Z
 270:	fc 01       	movw	r30, r24
 272:	80 81       	ld	r24, Z
 274:	90 e0       	ldi	r25, 0x00	; 0
 276:	87 70       	andi	r24, 0x07	; 7
 278:	90 70       	andi	r25, 0x00	; 0
 27a:	00 97       	sbiw	r24, 0x00	; 0
 27c:	01 f4       	brne	.+0      	; 0x27e <toshibaTB6612FNG_3pin_Init+0x132>
 27e:	00 c0       	rjmp	.+0      	; 0x280 <toshibaTB6612FNG_3pin_Init+0x134>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 280:	f5 01       	movw	r30, r10
 282:	7f 96       	adiw	r30, 0x1f	; 31
 284:	85 91       	lpm	r24, Z+
 286:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 288:	fc 01       	movw	r30, r24
 28a:	8c 81       	ldd	r24, Y+4	; 0x04
 28c:	9d 81       	ldd	r25, Y+5	; 0x05
 28e:	91 83       	std	Z+1, r25	; 0x01
 290:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 292:	20 e0       	ldi	r18, 0x00	; 0
 294:	30 e0       	ldi	r19, 0x00	; 0
 296:	f4 01       	movw	r30, r8
 298:	31 83       	std	Z+1, r19	; 0x01
 29a:	20 83       	st	Z, r18

			// Use non-inverting PWM
			compareSetOutputMode(channel,CHANNEL_MODE_NON_INVERTING);
 29c:	c3 01       	movw	r24, r6
 29e:	62 e0       	ldi	r22, 0x02	; 2
 2a0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Make sure the pwm pin is an output pin
			pin_make_output(motor->pwm, FALSE);
 2a4:	f4 01       	movw	r30, r8
 2a6:	84 81       	ldd	r24, Z+4	; 0x04
 2a8:	95 81       	ldd	r25, Z+5	; 0x05
 2aa:	60 e0       	ldi	r22, 0x00	; 0
 2ac:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Make sure the direction pin are set as an output pin and select 'brake'
			pin_make_output(motor->enable1, TRUE);
 2b0:	f4 01       	movw	r30, r8
 2b2:	86 81       	ldd	r24, Z+6	; 0x06
 2b4:	97 81       	ldd	r25, Z+7	; 0x07
 2b6:	6f ef       	ldi	r22, 0xFF	; 255
 2b8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			pin_make_output(motor->enable2, TRUE);
 2bc:	f4 01       	movw	r30, r8
 2be:	80 85       	ldd	r24, Z+8	; 0x08
 2c0:	91 85       	ldd	r25, Z+9	; 0x09
 2c2:	6f ef       	ldi	r22, 0xFF	; 255
 2c4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 2c8:	c3 01       	movw	r24, r6
 2ca:	60 e0       	ldi	r22, 0x00	; 0
 2cc:	70 e0       	ldi	r23, 0x00	; 0
 2ce:	40 e0       	ldi	r20, 0x00	; 0
 2d0:	50 e0       	ldi	r21, 0x00	; 0
 2d2:	20 e0       	ldi	r18, 0x00	; 0
 2d4:	30 e0       	ldi	r19, 0x00	; 0
 2d6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 2da:	6a 81       	ldd	r22, Y+2	; 0x02
 2dc:	7b 81       	ldd	r23, Y+3	; 0x03
 2de:	c5 01       	movw	r24, r10
 2e0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 2e4:	c4 01       	movw	r24, r8
 2e6:	60 e0       	ldi	r22, 0x00	; 0
 2e8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 2ec:	c4 01       	movw	r24, r8
 2ee:	6f ef       	ldi	r22, 0xFF	; 255
 2f0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 2f4:	08 94       	sec
 2f6:	41 1c       	adc	r4, r1
 2f8:	51 1c       	adc	r5, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void toshibaTB6612FNG_3pin_Init(TOSHIBA_TB6612FNG_3pin_MOTOR_DRIVER* driver, uint32_t freq){
 2fa:	8a 85       	ldd	r24, Y+10	; 0x0a
 2fc:	9b 85       	ldd	r25, Y+11	; 0x0b
 2fe:	84 19       	sub	r24, r4
 300:	95 09       	sbc	r25, r5
	uint32_t deciHertz = 10 * freq;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 302:	ff ef       	ldi	r31, 0xFF	; 255
 304:	8f 3f       	cpi	r24, 0xFF	; 255
 306:	9f 07       	cpc	r25, r31
 308:	01 f0       	breq	.+0      	; 0x30a <toshibaTB6612FNG_3pin_Init+0x1be>
 30a:	00 c0       	rjmp	.+0      	; 0x30c <toshibaTB6612FNG_3pin_Init+0x1c0>
 30c:	00 c0       	rjmp	.+0      	; 0x30e <toshibaTB6612FNG_3pin_Init+0x1c2>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 30e:	c5 01       	movw	r24, r10
 310:	69 81       	ldd	r22, Y+1	; 0x01
 312:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				if(modeIsICR(mode)){
 316:	81 e0       	ldi	r24, 0x01	; 1
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	09 80       	ldd	r0, Y+1	; 0x01
 31c:	00 c0       	rjmp	.+0      	; 0x31e <toshibaTB6612FNG_3pin_Init+0x1d2>
 31e:	88 0f       	add	r24, r24
 320:	99 1f       	adc	r25, r25
 322:	0a 94       	dec	r0
 324:	02 f4       	brpl	.+0      	; 0x326 <toshibaTB6612FNG_3pin_Init+0x1da>
 326:	80 70       	andi	r24, 0x00	; 0
 328:	95 75       	andi	r25, 0x55	; 85
 32a:	00 97       	sbiw	r24, 0x00	; 0
 32c:	01 f0       	breq	.+0      	; 0x32e <toshibaTB6612FNG_3pin_Init+0x1e2>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <toshibaTB6612FNG_3pin_Init+0x1e4>
 330:	00 c0       	rjmp	.+0      	; 0x332 <toshibaTB6612FNG_3pin_Init+0x1e6>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 332:	2d 96       	adiw	r28, 0x0d	; 13
 334:	0f b6       	in	r0, 0x3f	; 63
 336:	f8 94       	cli
 338:	de bf       	out	0x3e, r29	; 62
 33a:	0f be       	out	0x3f, r0	; 63
 33c:	cd bf       	out	0x3d, r28	; 61
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	1f 91       	pop	r17
 344:	0f 91       	pop	r16
 346:	ff 90       	pop	r15
 348:	ef 90       	pop	r14
 34a:	df 90       	pop	r13
 34c:	cf 90       	pop	r12
 34e:	bf 90       	pop	r11
 350:	af 90       	pop	r10
 352:	9f 90       	pop	r9
 354:	8f 90       	pop	r8
 356:	7f 90       	pop	r7
 358:	6f 90       	pop	r6
 35a:	5f 90       	pop	r5
 35c:	4f 90       	pop	r4
 35e:	3f 90       	pop	r3
 360:	2f 90       	pop	r2
 362:	08 95       	ret

SD21.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000154  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000188  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000188  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000188  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a52  00000000  00000000  0000018c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000233  00000000  00000000  00000bde  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000310  00000000  00000000  00000e11  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001121  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00001141  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000014c  00000000  00000000  00001159  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000004d9  00000000  00000000  000012a5  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000a8  00000000  00000000  00001780  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
 */
#include "SD21.h"
#include "../../core.h"
//#include "../../rprintf.h"

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	00 d0       	rcall	.+0      	; 0x12 <setSpeed+0x12>
  12:	0f 92       	push	r0
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	fc 01       	movw	r30, r24
	SERVO* servo = (SERVO*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
  1a:	82 81       	ldd	r24, Z+2	; 0x02
	if(servo->actuator.inverted){
  1c:	93 81       	ldd	r25, Z+3	; 0x03
  1e:	91 fd       	sbrc	r25, 1
		current *= -1;
  20:	81 95       	neg	r24
	}


	// Can only cope with 21 servos
	if(speed != current && servo->delay< 21){
  22:	68 17       	cp	r22, r24
  24:	01 f0       	breq	.+0      	; 0x26 <setSpeed+0x26>
  26:	c0 88       	ldd	r12, Z+16	; 0x10
  28:	d1 88       	ldd	r13, Z+17	; 0x11
  2a:	85 e1       	ldi	r24, 0x15	; 21
  2c:	c8 16       	cp	r12, r24
  2e:	d1 04       	cpc	r13, r1
  30:	00 f4       	brcc	.+0      	; 0x32 <setSpeed+0x32>
		uint8_t reg = (servo->delay * 3) + 1;
		uint8_t msg[3];

		struct s_servo_driver* driver = servo->driver;
		const I2C_DEVICE* i2c = &(driver->i2cInfo);
  32:	e4 80       	ldd	r14, Z+4	; 0x04
  34:	f5 80       	ldd	r15, Z+5	; 0x05
  36:	84 e0       	ldi	r24, 0x04	; 4
  38:	90 e0       	ldi	r25, 0x00	; 0
  3a:	e8 0e       	add	r14, r24
  3c:	f9 1e       	adc	r15, r25

		// Get the pulse length in us
		uint16_t pulse = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->center_us - servo->range_us , servo->center_us + servo->range_us);
  3e:	20 85       	ldd	r18, Z+8	; 0x08
  40:	31 85       	ldd	r19, Z+9	; 0x09
  42:	02 85       	ldd	r16, Z+10	; 0x0a
  44:	13 85       	ldd	r17, Z+11	; 0x0b
  46:	f9 01       	movw	r30, r18
  48:	e0 1b       	sub	r30, r16
  4a:	f1 0b       	sbc	r31, r17
  4c:	02 0f       	add	r16, r18
  4e:	13 1f       	adc	r17, r19
  50:	86 2f       	mov	r24, r22
  52:	99 27       	eor	r25, r25
  54:	87 fd       	sbrc	r24, 7
  56:	90 95       	com	r25
  58:	61 e8       	ldi	r22, 0x81	; 129
  5a:	7f ef       	ldi	r23, 0xFF	; 255
  5c:	4f e7       	ldi	r20, 0x7F	; 127
  5e:	50 e0       	ldi	r21, 0x00	; 0
  60:	9f 01       	movw	r18, r30
  62:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}


	// Can only cope with 21 servos
	if(speed != current && servo->delay< 21){
		uint8_t reg = (servo->delay * 3) + 1;
  66:	2c 2d       	mov	r18, r12
  68:	22 0f       	add	r18, r18
  6a:	2c 0d       	add	r18, r12
  6c:	2f 5f       	subi	r18, 0xFF	; 255
		const I2C_DEVICE* i2c = &(driver->i2cInfo);

		// Get the pulse length in us
		uint16_t pulse = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->center_us - servo->range_us , servo->center_us + servo->range_us);

		msg[0] = reg;						// Register
  6e:	29 83       	std	Y+1, r18	; 0x01
		msg[1] = (uint8_t)(pulse & 0xff); 	// lo
  70:	8a 83       	std	Y+2, r24	; 0x02
		msg[2] = (uint8_t)(pulse >> 8); 	// hi
  72:	9b 83       	std	Y+3, r25	; 0x03

		// The I2C address is always C2
		i2cMasterSend(i2c, sizeof(msg), msg);
  74:	c7 01       	movw	r24, r14
  76:	63 e0       	ldi	r22, 0x03	; 3
  78:	70 e0       	ldi	r23, 0x00	; 0
  7a:	ae 01       	movw	r20, r28
  7c:	4f 5f       	subi	r20, 0xFF	; 255
  7e:	5f 4f       	sbci	r21, 0xFF	; 255
  80:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
//		rprintf("%u = %u\n",servo->delay,pulse);
	}
}
  84:	0f 90       	pop	r0
  86:	0f 90       	pop	r0
  88:	0f 90       	pop	r0
  8a:	df 91       	pop	r29
  8c:	cf 91       	pop	r28
  8e:	1f 91       	pop	r17
  90:	0f 91       	pop	r16
  92:	ff 90       	pop	r15
  94:	ef 90       	pop	r14
  96:	df 90       	pop	r13
  98:	cf 90       	pop	r12
  9a:	08 95       	ret

0000009c <sd21Init>:


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  9c:	6f 92       	push	r6
  9e:	7f 92       	push	r7
  a0:	8f 92       	push	r8
  a2:	9f 92       	push	r9
  a4:	af 92       	push	r10
  a6:	bf 92       	push	r11
  a8:	cf 92       	push	r12
  aa:	df 92       	push	r13
  ac:	ef 92       	push	r14
  ae:	ff 92       	push	r15
  b0:	1f 93       	push	r17
  b2:	cf 93       	push	r28
  b4:	df 93       	push	r29
  b6:	6c 01       	movw	r12, r24
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
  b8:	fc 01       	movw	r30, r24
  ba:	12 81       	ldd	r17, Z+2	; 0x02
  bc:	11 50       	subi	r17, 0x01	; 1
  be:	ee 24       	eor	r14, r14
  c0:	ff 24       	eor	r15, r15


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  c2:	81 2e       	mov	r8, r17
  c4:	99 24       	eor	r9, r9
  c6:	87 fc       	sbrc	r8, 7
  c8:	90 94       	com	r9
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		if(servo){
			// Connect the servo to this driver
			servo->actuator.class = &c_sd21_servos;
  ca:	20 e0       	ldi	r18, 0x00	; 0
  cc:	62 2e       	mov	r6, r18
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	72 2e       	mov	r7, r18
// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <sd21Init+0x38>


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
  d4:	a4 01       	movw	r20, r8
  d6:	4e 19       	sub	r20, r14
  d8:	5f 09       	sbc	r21, r15
  da:	9a 01       	movw	r18, r20
  dc:	22 0f       	add	r18, r18
  de:	33 1f       	adc	r19, r19
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  e0:	f6 01       	movw	r30, r12
  e2:	80 81       	ld	r24, Z
  e4:	91 81       	ldd	r25, Z+1	; 0x01
  e6:	82 0f       	add	r24, r18
  e8:	93 1f       	adc	r25, r19
  ea:	fc 01       	movw	r30, r24
  ec:	a5 90       	lpm	r10, Z+
  ee:	b4 90       	lpm	r11, Z
  f0:	ca 2d       	mov	r28, r10
  f2:	db 2d       	mov	r29, r11
		if(servo){
  f4:	20 97       	sbiw	r28, 0x00	; 0
  f6:	01 f0       	breq	.+0      	; 0xf8 <sd21Init+0x5c>
			// Connect the servo to this driver
			servo->actuator.class = &c_sd21_servos;
  f8:	79 82       	std	Y+1, r7	; 0x01
  fa:	68 82       	st	Y, r6
			servo->driver = driver;
  fc:	dd 82       	std	Y+5, r13	; 0x05
  fe:	cc 82       	std	Y+4, r12	; 0x04
			servo->top = 0;
 100:	1b 8a       	std	Y+19, r1	; 0x13
 102:	1a 8a       	std	Y+18, r1	; 0x12
			servo->delay = i; // The servo number in the list
 104:	59 8b       	std	Y+17, r21	; 0x11
 106:	48 8b       	std	Y+16, r20	; 0x10
			servoSetConfig(servo,servo->center_us,servo->range_us);
 108:	68 85       	ldd	r22, Y+8	; 0x08
 10a:	79 85       	ldd	r23, Y+9	; 0x09
 10c:	4a 85       	ldd	r20, Y+10	; 0x0a
 10e:	5b 85       	ldd	r21, Y+11	; 0x0b
 110:	ce 01       	movw	r24, r28
 112:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 116:	8a 2d       	mov	r24, r10
 118:	9b 2d       	mov	r25, r11
 11a:	6f ef       	ldi	r22, 0xFF	; 255
 11c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 120:	8a 2d       	mov	r24, r10
 122:	9b 2d       	mov	r25, r11
 124:	60 e0       	ldi	r22, 0x00	; 0
 126:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 12a:	08 94       	sec
 12c:	e1 1c       	adc	r14, r1
 12e:	f1 1c       	adc	r15, r1


// Define the class
const static __ACTUATOR_DRIVER_CLASS c_sd21_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void sd21Init(SERVO_DRIVER* driver){
 130:	81 2f       	mov	r24, r17
 132:	8e 19       	sub	r24, r14
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 134:	87 ff       	sbrs	r24, 7
 136:	00 c0       	rjmp	.+0      	; 0x138 <sd21Init+0x9c>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}
	}
}
 138:	df 91       	pop	r29
 13a:	cf 91       	pop	r28
 13c:	1f 91       	pop	r17
 13e:	ff 90       	pop	r15
 140:	ef 90       	pop	r14
 142:	df 90       	pop	r13
 144:	cf 90       	pop	r12
 146:	bf 90       	pop	r11
 148:	af 90       	pop	r10
 14a:	9f 90       	pop	r9
 14c:	8f 90       	pop	r8
 14e:	7f 90       	pop	r7
 150:	6f 90       	pop	r6
 152:	08 95       	ret

AX12.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000386  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000003  00000000  00000000  000003ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003bd  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003bd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000b48  00000000  00000000  000003c1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002a9  00000000  00000000  00000f09  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000788  00000000  00000000  000011b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000193a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000038  00000000  00000000  0000195a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000019c  00000000  00000000  00001992  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000004de  00000000  00000000  00001b2e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000016c  00000000  00000000  0000200c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <xmitBlock>:
	}
}

// Callback to change the hardware to xmit or receive
// Called with interrupts disabled
static void xmitBlock(void* param, boolean xmit){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	DYNAMIXEL_AX12_DRIVER* driver = (DYNAMIXEL_AX12_DRIVER*)param;

	if(!xmit){
   a:	66 23       	and	r22, r22
   c:	01 f4       	brne	.+0      	; 0xe <xmitBlock+0xe>
		// We are entering recv mode - turn off receive hardware interrupts
		// as they are just too slow for 1,000,000 baud. We will receive the
		// characters by polling the uart hardware directly instead
		uartReceivePollingMode(driver->ax12uart,TRUE);
   e:	8b 81       	ldd	r24, Y+3	; 0x03
  10:	9c 81       	ldd	r25, Y+4	; 0x04
  12:	6f ef       	ldi	r22, 0xFF	; 255
  14:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}

	// Change the hardware state
	pin_set(driver->directionPin, xmit);
  18:	8d 81       	ldd	r24, Y+5	; 0x05
  1a:	9e 81       	ldd	r25, Y+6	; 0x06
  1c:	61 2f       	mov	r22, r17
  1e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
}
  22:	df 91       	pop	r29
  24:	cf 91       	pop	r28
  26:	1f 91       	pop	r17
  28:	08 95       	ret

0000002a <ax12Send>:

const static __ACTUATOR_DRIVER_CLASS c_ax12;



void ax12Send(const DYNAMIXEL_AX12_DRIVER* driver, uint8_t id, size_t len, uint8_t* data){
  2a:	cf 92       	push	r12
  2c:	df 92       	push	r13
  2e:	ff 92       	push	r15
  30:	0f 93       	push	r16
  32:	1f 93       	push	r17
  34:	cf 93       	push	r28
  36:	df 93       	push	r29
  38:	f6 2e       	mov	r15, r22
  3a:	8a 01       	movw	r16, r20
  3c:	69 01       	movw	r12, r18
	HW_UART* uart = driver->ax12uart;
	uartSendByte(uart, 0xff);
  3e:	fc 01       	movw	r30, r24
  40:	c3 81       	ldd	r28, Z+3	; 0x03
  42:	d4 81       	ldd	r29, Z+4	; 0x04
  44:	ce 01       	movw	r24, r28
  46:	6f ef       	ldi	r22, 0xFF	; 255
  48:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	uartSendByte(uart, 0xff);
  4c:	ce 01       	movw	r24, r28
  4e:	6f ef       	ldi	r22, 0xFF	; 255
  50:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	uint8_t chksum = uartSendByte(uart, id);
  54:	ce 01       	movw	r24, r28
  56:	6f 2d       	mov	r22, r15
  58:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  5c:	f8 2e       	mov	r15, r24
	chksum += uartSendByte(uart, len+1);
  5e:	60 2f       	mov	r22, r16
  60:	6f 5f       	subi	r22, 0xFF	; 255
  62:	ce 01       	movw	r24, r28
  64:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  68:	f8 0e       	add	r15, r24

	while(len--){
  6a:	00 c0       	rjmp	.+0      	; 0x6c <ax12Send+0x42>
		chksum += uartSendByte(uart, *data++);
  6c:	f6 01       	movw	r30, r12
  6e:	61 91       	ld	r22, Z+
  70:	6f 01       	movw	r12, r30
  72:	ce 01       	movw	r24, r28
  74:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
  78:	f8 0e       	add	r15, r24
  7a:	01 50       	subi	r16, 0x01	; 1
  7c:	10 40       	sbci	r17, 0x00	; 0
	uartSendByte(uart, 0xff);
	uartSendByte(uart, 0xff);
	uint8_t chksum = uartSendByte(uart, id);
	chksum += uartSendByte(uart, len+1);

	while(len--){
  7e:	01 15       	cp	r16, r1
  80:	11 05       	cpc	r17, r1
  82:	01 f4       	brne	.+0      	; 0x84 <ax12Send+0x5a>
		chksum += uartSendByte(uart, *data++);
	}
	uartSendByte(uart, ~chksum);
  84:	6f 2d       	mov	r22, r15
  86:	60 95       	com	r22
  88:	ce 01       	movw	r24, r28
  8a:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>

}
  8e:	df 91       	pop	r29
  90:	cf 91       	pop	r28
  92:	1f 91       	pop	r17
  94:	0f 91       	pop	r16
  96:	ff 90       	pop	r15
  98:	df 90       	pop	r13
  9a:	cf 90       	pop	r12
  9c:	08 95       	ret

0000009e <ax12Write8>:

// Send a command expecting no response
void ax12Write8(const DYNAMIXEL_AX12* servo, uint8_t cmd, uint8_t data){
  9e:	cf 93       	push	r28
  a0:	df 93       	push	r29
  a2:	00 d0       	rcall	.+0      	; 0xa4 <ax12Write8+0x6>
  a4:	0f 92       	push	r0
  a6:	cd b7       	in	r28, 0x3d	; 61
  a8:	de b7       	in	r29, 0x3e	; 62
  aa:	fc 01       	movw	r30, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  ac:	83 81       	ldd	r24, Z+3	; 0x03
  ae:	80 ff       	sbrs	r24, 0
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <ax12Write8+0x14>
	if(act_isConnected(servo)){
		uint8_t str[] = {servo->driver->writeCmd,cmd,data};
  b2:	84 81       	ldd	r24, Z+4	; 0x04
  b4:	95 81       	ldd	r25, Z+5	; 0x05
  b6:	dc 01       	movw	r26, r24
  b8:	17 96       	adiw	r26, 0x07	; 7
  ba:	2c 91       	ld	r18, X
  bc:	29 83       	std	Y+1, r18	; 0x01
  be:	6a 83       	std	Y+2, r22	; 0x02
  c0:	4b 83       	std	Y+3, r20	; 0x03
		ax12Send(servo->driver, servo->id, sizeof(str), str);
  c2:	66 81       	ldd	r22, Z+6	; 0x06
  c4:	43 e0       	ldi	r20, 0x03	; 3
  c6:	50 e0       	ldi	r21, 0x00	; 0
  c8:	9e 01       	movw	r18, r28
  ca:	2f 5f       	subi	r18, 0xFF	; 255
  cc:	3f 4f       	sbci	r19, 0xFF	; 255
  ce:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}
}
  d2:	0f 90       	pop	r0
  d4:	0f 90       	pop	r0
  d6:	0f 90       	pop	r0
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	08 95       	ret

000000de <ax12Write16>:

// Send a command expecting no response
void ax12Write16(const DYNAMIXEL_AX12* servo, uint8_t cmd, uint16_t data){
  de:	cf 93       	push	r28
  e0:	df 93       	push	r29
  e2:	00 d0       	rcall	.+0      	; 0xe4 <ax12Write16+0x6>
  e4:	00 d0       	rcall	.+0      	; 0xe6 <ax12Write16+0x8>
  e6:	cd b7       	in	r28, 0x3d	; 61
  e8:	de b7       	in	r29, 0x3e	; 62
  ea:	fc 01       	movw	r30, r24
  ec:	83 81       	ldd	r24, Z+3	; 0x03
  ee:	80 ff       	sbrs	r24, 0
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <ax12Write16+0x14>
	if(act_isConnected(servo)){
		uint8_t str[] = {servo->driver->writeCmd,cmd,data & 0xff, (data>>8) & 0xff };
  f2:	84 81       	ldd	r24, Z+4	; 0x04
  f4:	95 81       	ldd	r25, Z+5	; 0x05
  f6:	dc 01       	movw	r26, r24
  f8:	17 96       	adiw	r26, 0x07	; 7
  fa:	2c 91       	ld	r18, X
  fc:	29 83       	std	Y+1, r18	; 0x01
  fe:	6a 83       	std	Y+2, r22	; 0x02
 100:	4b 83       	std	Y+3, r20	; 0x03
 102:	5c 83       	std	Y+4, r21	; 0x04
		ax12Send(servo->driver, servo->id, sizeof(str), str);
 104:	66 81       	ldd	r22, Z+6	; 0x06
 106:	44 e0       	ldi	r20, 0x04	; 4
 108:	50 e0       	ldi	r21, 0x00	; 0
 10a:	9e 01       	movw	r18, r28
 10c:	2f 5f       	subi	r18, 0xFF	; 255
 10e:	3f 4f       	sbci	r19, 0xFF	; 255
 110:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
	}
}
 114:	0f 90       	pop	r0
 116:	0f 90       	pop	r0
 118:	0f 90       	pop	r0
 11a:	0f 90       	pop	r0
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	08 95       	ret

00000122 <setSpeed>:
	}

}

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
 122:	ff 92       	push	r15
 124:	0f 93       	push	r16
 126:	1f 93       	push	r17
 128:	cf 93       	push	r28
 12a:	df 93       	push	r29
 12c:	ec 01       	movw	r28, r24
 12e:	f6 2e       	mov	r15, r22
	DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
 130:	8a 81       	ldd	r24, Y+2	; 0x02
	if(servo->actuator.inverted){
 132:	9b 81       	ldd	r25, Y+3	; 0x03
 134:	91 fd       	sbrc	r25, 1
		current *= -1;
 136:	81 95       	neg	r24
	}


	// Ignore if it hasn't been changed
	if(speed != current){
 138:	f8 16       	cp	r15, r24
 13a:	01 f4       	brne	.+0      	; 0x13c <setSpeed+0x1a>
 13c:	00 c0       	rjmp	.+0      	; 0x13e <setSpeed+0x1c>

		// Send command to set speed
		if(servo->continuous){
 13e:	2f 81       	ldd	r18, Y+7	; 0x07
 140:	8f 2d       	mov	r24, r15
 142:	99 27       	eor	r25, r25
 144:	87 fd       	sbrc	r24, 7
 146:	90 95       	com	r25
 148:	22 23       	and	r18, r18
 14a:	01 f0       	breq	.+0      	; 0x14c <setSpeed+0x2a>
			// Interpolate the values to 0 to 1023

			uint16_t position=interpolateU(ABS(speed), DRIVE_SPEED_BRAKE, DRIVE_SPEED_MAX, 0, 0x3ff);
 14c:	97 ff       	sbrs	r25, 7
 14e:	00 c0       	rjmp	.+0      	; 0x150 <setSpeed+0x2e>
 150:	90 95       	com	r25
 152:	81 95       	neg	r24
 154:	9f 4f       	sbci	r25, 0xFF	; 255
 156:	60 e0       	ldi	r22, 0x00	; 0
 158:	70 e0       	ldi	r23, 0x00	; 0
 15a:	4f e7       	ldi	r20, 0x7F	; 127
 15c:	50 e0       	ldi	r21, 0x00	; 0
 15e:	20 e0       	ldi	r18, 0x00	; 0
 160:	30 e0       	ldi	r19, 0x00	; 0
 162:	0f ef       	ldi	r16, 0xFF	; 255
 164:	13 e0       	ldi	r17, 0x03	; 3
 166:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			if(speed<0){
 16a:	f7 fc       	sbrc	r15, 7
				position |= 0x400;
 16c:	94 60       	ori	r25, 0x04	; 4
			}
			ax12SetMOVING_SPEED(servo,position);
 16e:	00 97       	sbiw	r24, 0x00	; 0
 170:	01 f0       	breq	.+0      	; 0x172 <setSpeed+0x50>
 172:	ac 01       	movw	r20, r24
 174:	88 e0       	ldi	r24, 0x08	; 8
 176:	40 30       	cpi	r20, 0x00	; 0
 178:	58 07       	cpc	r21, r24
 17a:	00 f0       	brcs	.+0      	; 0x17c <setSpeed+0x5a>
 17c:	4f ef       	ldi	r20, 0xFF	; 255
 17e:	57 e0       	ldi	r21, 0x07	; 7
 180:	00 c0       	rjmp	.+0      	; 0x182 <setSpeed+0x60>
 182:	40 e0       	ldi	r20, 0x00	; 0
 184:	50 e0       	ldi	r21, 0x00	; 0
 186:	ce 01       	movw	r24, r28
 188:	60 e2       	ldi	r22, 0x20	; 32
 18a:	00 c0       	rjmp	.+0      	; 0x18c <setSpeed+0x6a>
		}else{
			// Interpolate the values to 0 to 1023
			uint16_t position=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, 0, 1023);
 18c:	61 e8       	ldi	r22, 0x81	; 129
 18e:	7f ef       	ldi	r23, 0xFF	; 255
 190:	4f e7       	ldi	r20, 0x7F	; 127
 192:	50 e0       	ldi	r21, 0x00	; 0
 194:	20 e0       	ldi	r18, 0x00	; 0
 196:	30 e0       	ldi	r19, 0x00	; 0
 198:	0f ef       	ldi	r16, 0xFF	; 255
 19a:	13 e0       	ldi	r17, 0x03	; 3
 19c:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetGOAL_POSITION(servo,position);
 1a0:	00 97       	sbiw	r24, 0x00	; 0
 1a2:	01 f0       	breq	.+0      	; 0x1a4 <setSpeed+0x82>
 1a4:	ac 01       	movw	r20, r24
 1a6:	84 e0       	ldi	r24, 0x04	; 4
 1a8:	40 30       	cpi	r20, 0x00	; 0
 1aa:	58 07       	cpc	r21, r24
 1ac:	00 f0       	brcs	.+0      	; 0x1ae <setSpeed+0x8c>
 1ae:	4f ef       	ldi	r20, 0xFF	; 255
 1b0:	53 e0       	ldi	r21, 0x03	; 3
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <setSpeed+0x92>
 1b4:	40 e0       	ldi	r20, 0x00	; 0
 1b6:	50 e0       	ldi	r21, 0x00	; 0
 1b8:	ce 01       	movw	r24, r28
 1ba:	6e e1       	ldi	r22, 0x1E	; 30
 1bc:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
		}
	}

}
 1c0:	df 91       	pop	r29
 1c2:	cf 91       	pop	r28
 1c4:	1f 91       	pop	r17
 1c6:	0f 91       	pop	r16
 1c8:	ff 90       	pop	r15
 1ca:	08 95       	ret

000001cc <ax12Begin>:
	// Change the hardware state
	pin_set(driver->directionPin, xmit);
}

void ax12Begin(DYNAMIXEL_AX12_DRIVER* driver){
	driver->writeCmd = ax12_REG_WRITE; // queue cmd
 1cc:	24 e0       	ldi	r18, 0x04	; 4
 1ce:	fc 01       	movw	r30, r24
 1d0:	27 83       	std	Z+7, r18	; 0x07
}
 1d2:	08 95       	ret

000001d4 <ax12End>:

void ax12End(DYNAMIXEL_AX12_DRIVER* driver){
 1d4:	cf 93       	push	r28
 1d6:	df 93       	push	r29
 1d8:	0f 92       	push	r0
 1da:	cd b7       	in	r28, 0x3d	; 61
 1dc:	de b7       	in	r29, 0x3e	; 62
	driver->writeCmd = ax12_WRITE;    // don't queue cmds
 1de:	23 e0       	ldi	r18, 0x03	; 3
 1e0:	fc 01       	movw	r30, r24
 1e2:	27 83       	std	Z+7, r18	; 0x07

	// Broadcast an ACTION cmd
	uint8_t status[] = {ax12_ACTION};
 1e4:	25 e0       	ldi	r18, 0x05	; 5
 1e6:	29 83       	std	Y+1, r18	; 0x01
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
 1e8:	6e ef       	ldi	r22, 0xFE	; 254
 1ea:	41 e0       	ldi	r20, 0x01	; 1
 1ec:	50 e0       	ldi	r21, 0x00	; 0
 1ee:	9e 01       	movw	r18, r28
 1f0:	2f 5f       	subi	r18, 0xFF	; 255
 1f2:	3f 4f       	sbci	r19, 0xFF	; 255
 1f4:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
}
 1f8:	0f 90       	pop	r0
 1fa:	df 91       	pop	r29
 1fc:	cf 91       	pop	r28
 1fe:	08 95       	ret

00000200 <ax12Init>:


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 200:	4f 92       	push	r4
 202:	5f 92       	push	r5
 204:	6f 92       	push	r6
 206:	7f 92       	push	r7
 208:	8f 92       	push	r8
 20a:	9f 92       	push	r9
 20c:	af 92       	push	r10
 20e:	bf 92       	push	r11
 210:	cf 92       	push	r12
 212:	df 92       	push	r13
 214:	ef 92       	push	r14
 216:	ff 92       	push	r15
 218:	0f 93       	push	r16
 21a:	1f 93       	push	r17
 21c:	cf 93       	push	r28
 21e:	df 93       	push	r29
 220:	00 d0       	rcall	.+0      	; 0x222 <ax12Init+0x22>
 222:	0f 92       	push	r0
 224:	cd b7       	in	r28, 0x3d	; 61
 226:	de b7       	in	r29, 0x3e	; 62
 228:	7c 01       	movw	r14, r24
 22a:	4a 01       	movw	r8, r20
 22c:	5b 01       	movw	r10, r22
	// Set the callback if there is a direction pin
	if(driver->directionPin){
 22e:	dc 01       	movw	r26, r24
 230:	15 96       	adiw	r26, 0x05	; 5
 232:	8d 91       	ld	r24, X+
 234:	9c 91       	ld	r25, X
 236:	16 97       	sbiw	r26, 0x06	; 6
 238:	00 97       	sbiw	r24, 0x00	; 0
 23a:	01 f0       	breq	.+0      	; 0x23c <ax12Init+0x3c>
		pin_make_output(driver->directionPin, FALSE);// put into receive mode
 23c:	60 e0       	ldi	r22, 0x00	; 0
 23e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
		driver->ax12uart->_uart_.xmitCallback = &xmitBlock;
 242:	d7 01       	movw	r26, r14
 244:	13 96       	adiw	r26, 0x03	; 3
 246:	ed 91       	ld	r30, X+
 248:	fc 91       	ld	r31, X
 24a:	14 97       	sbiw	r26, 0x04	; 4
 24c:	80 e0       	ldi	r24, 0x00	; 0
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	97 8b       	std	Z+23, r25	; 0x17
 252:	86 8b       	std	Z+22, r24	; 0x16
		driver->ax12uart->_uart_.callbackParam = driver;
 254:	f1 8e       	std	Z+25, r15	; 0x19
 256:	e0 8e       	std	Z+24, r14	; 0x18
 258:	00 c0       	rjmp	.+0      	; 0x25a <ax12Init+0x5a>
	}else{
		if(driver->ax12uart->_uart_.class == &c_hw_uart){
 25a:	d7 01       	movw	r26, r14
 25c:	13 96       	adiw	r26, 0x03	; 3
 25e:	ed 91       	ld	r30, X+
 260:	fc 91       	ld	r31, X
 262:	14 97       	sbiw	r26, 0x04	; 4
 264:	81 85       	ldd	r24, Z+9	; 0x09
 266:	92 85       	ldd	r25, Z+10	; 0x0a
 268:	b0 e0       	ldi	r27, 0x00	; 0
 26a:	80 30       	cpi	r24, 0x00	; 0
 26c:	9b 07       	cpc	r25, r27
 26e:	01 f4       	brne	.+0      	; 0x270 <ax12Init+0x70>
			// Its a hardware UART - so make it one wire before initialising
			driver->ax12uart->_uart_.oneWire = TRUE;
 270:	8f ef       	ldi	r24, 0xFF	; 255
 272:	85 8b       	std	Z+21, r24	; 0x15
		}
	}


	// Set the baud rate
	uartInit(driver->ax12uart, baud);
 274:	f7 01       	movw	r30, r14
 276:	83 81       	ldd	r24, Z+3	; 0x03
 278:	94 81       	ldd	r25, Z+4	; 0x04
 27a:	b5 01       	movw	r22, r10
 27c:	a4 01       	movw	r20, r8
 27e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


	// Tell all servos to only respond to READ commands
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
 282:	de 01       	movw	r26, r28
 284:	11 96       	adiw	r26, 0x01	; 1
 286:	e0 e0       	ldi	r30, 0x00	; 0
 288:	f0 e0       	ldi	r31, 0x00	; 0
 28a:	83 e0       	ldi	r24, 0x03	; 3
 28c:	01 90       	ld	r0, Z+
 28e:	0d 92       	st	X+, r0
 290:	81 50       	subi	r24, 0x01	; 1
 292:	01 f4       	brne	.+0      	; 0x294 <ax12Init+0x94>
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
 294:	c7 01       	movw	r24, r14
 296:	6e ef       	ldi	r22, 0xFE	; 254
 298:	43 e0       	ldi	r20, 0x03	; 3
 29a:	50 e0       	ldi	r21, 0x00	; 0
 29c:	9e 01       	movw	r18, r28
 29e:	2f 5f       	subi	r18, 0xFF	; 255
 2a0:	3f 4f       	sbci	r19, 0xFF	; 255
 2a2:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 2a6:	d7 01       	movw	r26, r14
 2a8:	12 96       	adiw	r26, 0x02	; 2
 2aa:	8c 91       	ld	r24, X
 2ac:	12 97       	sbiw	r26, 0x02	; 2
 2ae:	cc 24       	eor	r12, r12
 2b0:	dd 24       	eor	r13, r13
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	2c 01       	movw	r4, r24
 2b6:	08 94       	sec
 2b8:	41 08       	sbc	r4, r1
 2ba:	51 08       	sbc	r5, r1
 2bc:	6f ef       	ldi	r22, 0xFF	; 255
 2be:	86 2e       	mov	r8, r22
 2c0:	6f e7       	ldi	r22, 0x7F	; 127
 2c2:	96 2e       	mov	r9, r22
 2c4:	88 0e       	add	r8, r24
 2c6:	99 1e       	adc	r9, r25
	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);

		// Connect the servo to this driver
		servo->actuator.class = &c_ax12;
 2c8:	70 e0       	ldi	r23, 0x00	; 0
 2ca:	67 2e       	mov	r6, r23
 2cc:	70 e0       	ldi	r23, 0x00	; 0
 2ce:	77 2e       	mov	r7, r23
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <ax12Init+0xd2>
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 2d2:	c4 01       	movw	r24, r8
 2d4:	8c 19       	sub	r24, r12
 2d6:	9d 09       	sbc	r25, r13
 2d8:	88 0f       	add	r24, r24
 2da:	99 1f       	adc	r25, r25
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
 2dc:	f7 01       	movw	r30, r14
 2de:	20 81       	ld	r18, Z
 2e0:	31 81       	ldd	r19, Z+1	; 0x01
 2e2:	28 0f       	add	r18, r24
 2e4:	39 1f       	adc	r19, r25
 2e6:	f9 01       	movw	r30, r18
 2e8:	85 91       	lpm	r24, Z+
 2ea:	94 91       	lpm	r25, Z
 2ec:	8c 01       	movw	r16, r24

		// Connect the servo to this driver
		servo->actuator.class = &c_ax12;
 2ee:	dc 01       	movw	r26, r24
 2f0:	11 96       	adiw	r26, 0x01	; 1
 2f2:	7c 92       	st	X, r7
 2f4:	6e 92       	st	-X, r6
		servo->driver = driver;
 2f6:	15 96       	adiw	r26, 0x05	; 5
 2f8:	fc 92       	st	X, r15
 2fa:	ee 92       	st	-X, r14
 2fc:	14 97       	sbiw	r26, 0x04	; 4

		// Set it as connected
		act_setConnected(servo,TRUE);
 2fe:	b8 2e       	mov	r11, r24
 300:	a9 2e       	mov	r10, r25
 302:	6f ef       	ldi	r22, 0xFF	; 255
 304:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>


		if(servo->continuous){
 308:	f8 01       	movw	r30, r16
 30a:	87 81       	ldd	r24, Z+7	; 0x07
 30c:	88 23       	and	r24, r24
 30e:	01 f0       	breq	.+0      	; 0x310 <ax12Init+0x110>
			// Put into continuous rotation mode
			ax12SetCW_ANGLE_LIMIT(servo,0);
 310:	c8 01       	movw	r24, r16
 312:	66 e0       	ldi	r22, 0x06	; 6
 314:	40 e0       	ldi	r20, 0x00	; 0
 316:	50 e0       	ldi	r21, 0x00	; 0
 318:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetCCW_ANGLE_LIMIT(servo,0);
 31c:	c8 01       	movw	r24, r16
 31e:	68 e0       	ldi	r22, 0x08	; 8
 320:	40 e0       	ldi	r20, 0x00	; 0
 322:	50 e0       	ldi	r21, 0x00	; 0
 324:	00 c0       	rjmp	.+0      	; 0x326 <ax12Init+0x126>
		}else{
			// Put into servo mode
			ax12SetCW_ANGLE_LIMIT(servo,0);
 326:	c8 01       	movw	r24, r16
 328:	66 e0       	ldi	r22, 0x06	; 6
 32a:	40 e0       	ldi	r20, 0x00	; 0
 32c:	50 e0       	ldi	r21, 0x00	; 0
 32e:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
			ax12SetCCW_ANGLE_LIMIT(servo,1023);
 332:	c8 01       	movw	r24, r16
 334:	68 e0       	ldi	r22, 0x08	; 8
 336:	4f ef       	ldi	r20, 0xFF	; 255
 338:	53 e0       	ldi	r21, 0x03	; 3
 33a:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
		}

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 33e:	8b 2d       	mov	r24, r11
 340:	9a 2d       	mov	r25, r10
 342:	60 e0       	ldi	r22, 0x00	; 0
 344:	0e 94 00 00 	call	0	; 0x0 <xmitBlock>
 348:	08 94       	sec
 34a:	c1 1c       	adc	r12, r1
 34c:	d1 1c       	adc	r13, r1
	uint8_t status[] = {ax12_ACTION};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);
}


void ax12Init(DYNAMIXEL_AX12_DRIVER* driver, BAUD_RATE baud){
 34e:	c2 01       	movw	r24, r4
 350:	8c 19       	sub	r24, r12
 352:	9d 09       	sbc	r25, r13
	uint8_t status[] = {ax12_WRITE, ax12_STATUS_RTN_LEVEL,1};
	ax12Send(driver, ax12_BROADCAST_ID, sizeof(status), status);


	// Initialuse each servo
	for(int i= driver->num_servos-1;i>=0;i--){
 354:	ff ef       	ldi	r31, 0xFF	; 255
 356:	8f 3f       	cpi	r24, 0xFF	; 255
 358:	9f 07       	cpc	r25, r31
 35a:	01 f0       	breq	.+0      	; 0x35c <ax12Init+0x15c>
 35c:	00 c0       	rjmp	.+0      	; 0x35e <ax12Init+0x15e>

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
	}

}
 35e:	0f 90       	pop	r0
 360:	0f 90       	pop	r0
 362:	0f 90       	pop	r0
 364:	df 91       	pop	r29
 366:	cf 91       	pop	r28
 368:	1f 91       	pop	r17
 36a:	0f 91       	pop	r16
 36c:	ff 90       	pop	r15
 36e:	ef 90       	pop	r14
 370:	df 90       	pop	r13
 372:	cf 90       	pop	r12
 374:	bf 90       	pop	r11
 376:	af 90       	pop	r10
 378:	9f 90       	pop	r9
 37a:	8f 90       	pop	r8
 37c:	7f 90       	pop	r7
 37e:	6f 90       	pop	r6
 380:	5f 90       	pop	r5
 382:	4f 90       	pop	r4
 384:	08 95       	ret

AX12dump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000010a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000013e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000013e  2**0
                  ALLOC
  3 .progmem.data 0000005f  00000000  00000000  0000013e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   000006db  00000000  00000000  0000019d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000135  00000000  00000000  00000878  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000000dd  00000000  00000000  000009ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000a8a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000129  00000000  00000000  00000aaa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000414  00000000  00000000  00000bd3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000004c  00000000  00000000  00000fe8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12Dump>:
 */
#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12Dump(DYNAMIXEL_AX12* servo){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	ec 01       	movw	r28, r24

	uint16_t  status = ax12GetInfo(servo);
  12:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
	if(status == 0){
  16:	00 97       	sbiw	r24, 0x00	; 0
  18:	01 f0       	breq	.+0      	; 0x1a <ax12Dump+0x1a>
  1a:	00 c0       	rjmp	.+0      	; 0x1c <ax12Dump+0x1c>
		rprintf("AX12 ID%u: Pos:%d, Speed:%d, Load:%d, Volts:%u.%c, Temp:%uC, Moving:%c\n",
  1c:	ae 81       	ldd	r26, Y+6	; 0x06
  1e:	08 85       	ldd	r16, Y+8	; 0x08
  20:	11 27       	eor	r17, r17
  22:	07 fd       	sbrc	r16, 7
  24:	10 95       	com	r17
  26:	e9 84       	ldd	r14, Y+9	; 0x09
  28:	fa 84       	ldd	r15, Y+10	; 0x0a
  2a:	cb 84       	ldd	r12, Y+11	; 0x0b
  2c:	dc 84       	ldd	r13, Y+12	; 0x0c
  2e:	8d 85       	ldd	r24, Y+13	; 0x0d
  30:	6a e0       	ldi	r22, 0x0A	; 10
  32:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  36:	29 2f       	mov	r18, r25
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	20 5d       	subi	r18, 0xD0	; 208
  3c:	3f 4f       	sbci	r19, 0xFF	; 255
  3e:	9e 85       	ldd	r25, Y+14	; 0x0e
  40:	48 89       	ldd	r20, Y+16	; 0x10
  42:	44 23       	and	r20, r20
  44:	01 f0       	breq	.+0      	; 0x46 <ax12Dump+0x46>
  46:	49 e5       	ldi	r20, 0x59	; 89
  48:	50 e0       	ldi	r21, 0x00	; 0
  4a:	00 c0       	rjmp	.+0      	; 0x4c <ax12Dump+0x4c>
  4c:	4e e4       	ldi	r20, 0x4E	; 78
  4e:	50 e0       	ldi	r21, 0x00	; 0
  50:	6d b7       	in	r22, 0x3d	; 61
  52:	7e b7       	in	r23, 0x3e	; 62
  54:	63 51       	subi	r22, 0x13	; 19
  56:	70 40       	sbci	r23, 0x00	; 0
  58:	0f b6       	in	r0, 0x3f	; 63
  5a:	f8 94       	cli
  5c:	7e bf       	out	0x3e, r23	; 62
  5e:	0f be       	out	0x3f, r0	; 63
  60:	6d bf       	out	0x3d, r22	; 61
  62:	ed b7       	in	r30, 0x3d	; 61
  64:	fe b7       	in	r31, 0x3e	; 62
  66:	31 96       	adiw	r30, 0x01	; 1
  68:	61 e0       	ldi	r22, 0x01	; 1
  6a:	cd b7       	in	r28, 0x3d	; 61
  6c:	de b7       	in	r29, 0x3e	; 62
  6e:	69 83       	std	Y+1, r22	; 0x01
  70:	60 e0       	ldi	r22, 0x00	; 0
  72:	70 e0       	ldi	r23, 0x00	; 0
  74:	72 83       	std	Z+2, r23	; 0x02
  76:	61 83       	std	Z+1, r22	; 0x01
  78:	a3 83       	std	Z+3, r26	; 0x03
  7a:	14 82       	std	Z+4, r1	; 0x04
  7c:	16 83       	std	Z+6, r17	; 0x06
  7e:	05 83       	std	Z+5, r16	; 0x05
  80:	f0 86       	std	Z+8, r15	; 0x08
  82:	e7 82       	std	Z+7, r14	; 0x07
  84:	d2 86       	std	Z+10, r13	; 0x0a
  86:	c1 86       	std	Z+9, r12	; 0x09
  88:	83 87       	std	Z+11, r24	; 0x0b
  8a:	14 86       	std	Z+12, r1	; 0x0c
  8c:	36 87       	std	Z+14, r19	; 0x0e
  8e:	25 87       	std	Z+13, r18	; 0x0d
  90:	97 87       	std	Z+15, r25	; 0x0f
  92:	10 8a       	std	Z+16, r1	; 0x10
  94:	52 8b       	std	Z+18, r21	; 0x12
  96:	41 8b       	std	Z+17, r20	; 0x11
  98:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  9c:	2d b7       	in	r18, 0x3d	; 61
  9e:	3e b7       	in	r19, 0x3e	; 62
  a0:	2d 5e       	subi	r18, 0xED	; 237
  a2:	3f 4f       	sbci	r19, 0xFF	; 255
  a4:	0f b6       	in	r0, 0x3f	; 63
  a6:	f8 94       	cli
  a8:	3e bf       	out	0x3e, r19	; 62
  aa:	0f be       	out	0x3f, r0	; 63
  ac:	2d bf       	out	0x3d, r18	; 61
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <ax12Dump+0xb0>
			(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
			(uint16_t)servo->info.temperature,
			(servo->info.moving) ? 'Y' : 'N');

	}else{
		rprintf("AX12 ID%u: Status: %u\n",(uint16_t)servo->id,status);
  b0:	6d b7       	in	r22, 0x3d	; 61
  b2:	7e b7       	in	r23, 0x3e	; 62
  b4:	67 50       	subi	r22, 0x07	; 7
  b6:	70 40       	sbci	r23, 0x00	; 0
  b8:	0f b6       	in	r0, 0x3f	; 63
  ba:	f8 94       	cli
  bc:	7e bf       	out	0x3e, r23	; 62
  be:	0f be       	out	0x3f, r0	; 63
  c0:	6d bf       	out	0x3d, r22	; 61
  c2:	ed b7       	in	r30, 0x3d	; 61
  c4:	fe b7       	in	r31, 0x3e	; 62
  c6:	31 96       	adiw	r30, 0x01	; 1
  c8:	21 e0       	ldi	r18, 0x01	; 1
  ca:	ad b7       	in	r26, 0x3d	; 61
  cc:	be b7       	in	r27, 0x3e	; 62
  ce:	11 96       	adiw	r26, 0x01	; 1
  d0:	2c 93       	st	X, r18
  d2:	20 e0       	ldi	r18, 0x00	; 0
  d4:	30 e0       	ldi	r19, 0x00	; 0
  d6:	32 83       	std	Z+2, r19	; 0x02
  d8:	21 83       	std	Z+1, r18	; 0x01
  da:	2e 81       	ldd	r18, Y+6	; 0x06
  dc:	23 83       	std	Z+3, r18	; 0x03
  de:	14 82       	std	Z+4, r1	; 0x04
  e0:	96 83       	std	Z+6, r25	; 0x06
  e2:	85 83       	std	Z+5, r24	; 0x05
  e4:	0e 94 00 00 	call	0	; 0x0 <ax12Dump>
  e8:	cd b7       	in	r28, 0x3d	; 61
  ea:	de b7       	in	r29, 0x3e	; 62
  ec:	27 96       	adiw	r28, 0x07	; 7
  ee:	0f b6       	in	r0, 0x3f	; 63
  f0:	f8 94       	cli
  f2:	de bf       	out	0x3e, r29	; 62
  f4:	0f be       	out	0x3f, r0	; 63
  f6:	cd bf       	out	0x3d, r28	; 61
	}
}
  f8:	df 91       	pop	r29
  fa:	cf 91       	pop	r28
  fc:	1f 91       	pop	r17
  fe:	0f 91       	pop	r16
 100:	ff 90       	pop	r15
 102:	ef 90       	pop	r14
 104:	df 90       	pop	r13
 106:	cf 90       	pop	r12
 108:	08 95       	ret

AX12dumpAll.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000196  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001ca  2**0
                  ALLOC
  3 .progmem.data 00000066  00000000  00000000  000001ca  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000745  00000000  00000000  00000230  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000163  00000000  00000000  00000975  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000001dd  00000000  00000000  00000ad8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000cb5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00000cd5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000143  00000000  00000000  00000ced  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000442  00000000  00000000  00000e30  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000008c  00000000  00000000  00001274  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12DumpAll>:

#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	3c 01       	movw	r6, r24
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
  26:	00 d0       	rcall	.+0      	; 0x28 <ax12DumpAll+0x28>
  28:	0f 92       	push	r0
  2a:	81 e0       	ldi	r24, 0x01	; 1
  2c:	ad b7       	in	r26, 0x3d	; 61
  2e:	be b7       	in	r27, 0x3e	; 62
  30:	11 96       	adiw	r26, 0x01	; 1
  32:	8c 93       	st	X, r24
  34:	11 97       	sbiw	r26, 0x01	; 1
  36:	80 e0       	ldi	r24, 0x00	; 0
  38:	90 e0       	ldi	r25, 0x00	; 0
  3a:	13 96       	adiw	r26, 0x03	; 3
  3c:	9c 93       	st	X, r25
  3e:	8e 93       	st	-X, r24
  40:	12 97       	sbiw	r26, 0x02	; 2
  42:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
	for(int i=0; i<driver->num_servos; i++){
  46:	0f 90       	pop	r0
  48:	0f 90       	pop	r0
  4a:	0f 90       	pop	r0
  4c:	00 e0       	ldi	r16, 0x00	; 0
  4e:	10 e0       	ldi	r17, 0x00	; 0
				(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
				(uint16_t)servo->info.temperature,
				(servo->info.moving) ? 'Y' : 'N');

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
  50:	ff 24       	eor	r15, r15
  52:	f3 94       	inc	r15
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	49 2e       	mov	r4, r25
  58:	90 e0       	ldi	r25, 0x00	; 0
  5a:	59 2e       	mov	r5, r25
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
		uint16_t  status = ax12GetInfo(servo);
		if(status == 0){
			rprintf("%7u %6d %6d %5d %2u.%c %5u      %c\n",
  5c:	2a e0       	ldi	r18, 0x0A	; 10
  5e:	e2 2e       	mov	r14, r18
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	23 2e       	mov	r2, r19
  64:	30 e0       	ldi	r19, 0x00	; 0
  66:	33 2e       	mov	r3, r19
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
  68:	00 c0       	rjmp	.+0      	; 0x6a <ax12DumpAll+0x6a>

#include "AX12.h"
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
  6a:	98 01       	movw	r18, r16
  6c:	22 0f       	add	r18, r18
  6e:	33 1f       	adc	r19, r19
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
		DYNAMIXEL_AX12* servo = (DYNAMIXEL_AX12*)pgm_read_word(&driver->servos[i]);
  70:	e3 01       	movw	r28, r6
  72:	88 81       	ld	r24, Y
  74:	99 81       	ldd	r25, Y+1	; 0x01
  76:	82 0f       	add	r24, r18
  78:	93 1f       	adc	r25, r19
  7a:	fc 01       	movw	r30, r24
  7c:	85 91       	lpm	r24, Z+
  7e:	94 91       	lpm	r25, Z
  80:	c8 2f       	mov	r28, r24
  82:	d9 2f       	mov	r29, r25
		uint16_t  status = ax12GetInfo(servo);
  84:	ce 01       	movw	r24, r28
  86:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
		if(status == 0){
  8a:	00 97       	sbiw	r24, 0x00	; 0
  8c:	01 f0       	breq	.+0      	; 0x8e <ax12DumpAll+0x8e>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <ax12DumpAll+0x90>
			rprintf("%7u %6d %6d %5d %2u.%c %5u      %c\n",
  90:	ae 81       	ldd	r26, Y+6	; 0x06
  92:	c8 84       	ldd	r12, Y+8	; 0x08
  94:	dd 24       	eor	r13, r13
  96:	c7 fc       	sbrc	r12, 7
  98:	d0 94       	com	r13
  9a:	a9 84       	ldd	r10, Y+9	; 0x09
  9c:	ba 84       	ldd	r11, Y+10	; 0x0a
  9e:	8b 84       	ldd	r8, Y+11	; 0x0b
  a0:	9c 84       	ldd	r9, Y+12	; 0x0c
  a2:	8d 85       	ldd	r24, Y+13	; 0x0d
  a4:	6e 2d       	mov	r22, r14
  a6:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
  aa:	29 2f       	mov	r18, r25
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	20 5d       	subi	r18, 0xD0	; 208
  b0:	3f 4f       	sbci	r19, 0xFF	; 255
  b2:	9e 85       	ldd	r25, Y+14	; 0x0e
  b4:	48 89       	ldd	r20, Y+16	; 0x10
  b6:	44 23       	and	r20, r20
  b8:	01 f0       	breq	.+0      	; 0xba <ax12DumpAll+0xba>
  ba:	49 e5       	ldi	r20, 0x59	; 89
  bc:	50 e0       	ldi	r21, 0x00	; 0
  be:	00 c0       	rjmp	.+0      	; 0xc0 <ax12DumpAll+0xc0>
  c0:	4e e4       	ldi	r20, 0x4E	; 78
  c2:	50 e0       	ldi	r21, 0x00	; 0
  c4:	6d b7       	in	r22, 0x3d	; 61
  c6:	7e b7       	in	r23, 0x3e	; 62
  c8:	63 51       	subi	r22, 0x13	; 19
  ca:	70 40       	sbci	r23, 0x00	; 0
  cc:	0f b6       	in	r0, 0x3f	; 63
  ce:	f8 94       	cli
  d0:	7e bf       	out	0x3e, r23	; 62
  d2:	0f be       	out	0x3f, r0	; 63
  d4:	6d bf       	out	0x3d, r22	; 61
  d6:	ed b7       	in	r30, 0x3d	; 61
  d8:	fe b7       	in	r31, 0x3e	; 62
  da:	31 96       	adiw	r30, 0x01	; 1
  dc:	cd b7       	in	r28, 0x3d	; 61
  de:	de b7       	in	r29, 0x3e	; 62
  e0:	f9 82       	std	Y+1, r15	; 0x01
  e2:	32 82       	std	Z+2, r3	; 0x02
  e4:	21 82       	std	Z+1, r2	; 0x01
  e6:	a3 83       	std	Z+3, r26	; 0x03
  e8:	14 82       	std	Z+4, r1	; 0x04
  ea:	d6 82       	std	Z+6, r13	; 0x06
  ec:	c5 82       	std	Z+5, r12	; 0x05
  ee:	b0 86       	std	Z+8, r11	; 0x08
  f0:	a7 82       	std	Z+7, r10	; 0x07
  f2:	92 86       	std	Z+10, r9	; 0x0a
  f4:	81 86       	std	Z+9, r8	; 0x09
  f6:	83 87       	std	Z+11, r24	; 0x0b
  f8:	14 86       	std	Z+12, r1	; 0x0c
  fa:	36 87       	std	Z+14, r19	; 0x0e
  fc:	25 87       	std	Z+13, r18	; 0x0d
  fe:	97 87       	std	Z+15, r25	; 0x0f
 100:	10 8a       	std	Z+16, r1	; 0x10
 102:	52 8b       	std	Z+18, r21	; 0x12
 104:	41 8b       	std	Z+17, r20	; 0x11
 106:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
 10a:	ed b7       	in	r30, 0x3d	; 61
 10c:	fe b7       	in	r31, 0x3e	; 62
 10e:	73 96       	adiw	r30, 0x13	; 19
 110:	0f b6       	in	r0, 0x3f	; 63
 112:	f8 94       	cli
 114:	fe bf       	out	0x3e, r31	; 62
 116:	0f be       	out	0x3f, r0	; 63
 118:	ed bf       	out	0x3d, r30	; 61
 11a:	00 c0       	rjmp	.+0      	; 0x11c <ax12DumpAll+0x11c>
				(uint16_t)servo->info.voltage / 10, '0' + servo->info.voltage % 10,
				(uint16_t)servo->info.temperature,
				(servo->info.moving) ? 'Y' : 'N');

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
 11c:	2d b7       	in	r18, 0x3d	; 61
 11e:	3e b7       	in	r19, 0x3e	; 62
 120:	27 50       	subi	r18, 0x07	; 7
 122:	30 40       	sbci	r19, 0x00	; 0
 124:	0f b6       	in	r0, 0x3f	; 63
 126:	f8 94       	cli
 128:	3e bf       	out	0x3e, r19	; 62
 12a:	0f be       	out	0x3f, r0	; 63
 12c:	2d bf       	out	0x3d, r18	; 61
 12e:	ed b7       	in	r30, 0x3d	; 61
 130:	fe b7       	in	r31, 0x3e	; 62
 132:	31 96       	adiw	r30, 0x01	; 1
 134:	ad b7       	in	r26, 0x3d	; 61
 136:	be b7       	in	r27, 0x3e	; 62
 138:	11 96       	adiw	r26, 0x01	; 1
 13a:	fc 92       	st	X, r15
 13c:	52 82       	std	Z+2, r5	; 0x02
 13e:	41 82       	std	Z+1, r4	; 0x01
 140:	2e 81       	ldd	r18, Y+6	; 0x06
 142:	23 83       	std	Z+3, r18	; 0x03
 144:	14 82       	std	Z+4, r1	; 0x04
 146:	96 83       	std	Z+6, r25	; 0x06
 148:	85 83       	std	Z+5, r24	; 0x05
 14a:	0e 94 00 00 	call	0	; 0x0 <ax12DumpAll>
 14e:	cd b7       	in	r28, 0x3d	; 61
 150:	de b7       	in	r29, 0x3e	; 62
 152:	27 96       	adiw	r28, 0x07	; 7
 154:	0f b6       	in	r0, 0x3f	; 63
 156:	f8 94       	cli
 158:	de bf       	out	0x3e, r29	; 62
 15a:	0f be       	out	0x3f, r0	; 63
 15c:	cd bf       	out	0x3d, r28	; 61
#include "../../rprintf.h"
#include "../../core.h"

void ax12DumpAll(const DYNAMIXEL_AX12_DRIVER* driver){
	rprintf("AX12 ID Position Speed Load Volts Temp(C) Moving\n");
	for(int i=0; i<driver->num_servos; i++){
 15e:	0f 5f       	subi	r16, 0xFF	; 255
 160:	1f 4f       	sbci	r17, 0xFF	; 255
 162:	f3 01       	movw	r30, r6
 164:	82 81       	ldd	r24, Z+2	; 0x02
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	08 17       	cp	r16, r24
 16a:	19 07       	cpc	r17, r25
 16c:	04 f4       	brge	.+0      	; 0x16e <ax12DumpAll+0x16e>
 16e:	00 c0       	rjmp	.+0      	; 0x170 <ax12DumpAll+0x170>

		}else{
			rprintf("%7u Status: %u\n",(uint16_t)servo->id,status);
		}
	}
}
 170:	df 91       	pop	r29
 172:	cf 91       	pop	r28
 174:	1f 91       	pop	r17
 176:	0f 91       	pop	r16
 178:	ff 90       	pop	r15
 17a:	ef 90       	pop	r14
 17c:	df 90       	pop	r13
 17e:	cf 90       	pop	r12
 180:	bf 90       	pop	r11
 182:	af 90       	pop	r10
 184:	9f 90       	pop	r9
 186:	8f 90       	pop	r8
 188:	7f 90       	pop	r7
 18a:	6f 90       	pop	r6
 18c:	5f 90       	pop	r5
 18e:	4f 90       	pop	r4
 190:	3f 90       	pop	r3
 192:	2f 90       	pop	r2
 194:	08 95       	ret

AX12info.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000020a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000003  00000000  00000000  0000023e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000241  2**0
                  ALLOC
  3 .debug_info   0000084c  00000000  00000000  00000241  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001fb  00000000  00000000  00000a8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000369  00000000  00000000  00000c88  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000ff1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000068  00000000  00000000  00001011  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001a0  00000000  00000000  00001079  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000458  00000000  00000000  00001219  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000005c  00000000  00000000  00001674  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <ax12GetInfo>:
#include "../../core.h"

// The number of bytes to read from the ax12
#define INFO_LENGTH (ax12_LOCK - ax12_PRESENT_POSITION)

uint16_t ax12GetInfo(DYNAMIXEL_AX12* servo){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ef 92       	push	r14
   a:	ff 92       	push	r15
   c:	0f 93       	push	r16
   e:	1f 93       	push	r17
  10:	cf 93       	push	r28
  12:	df 93       	push	r29
  14:	cd b7       	in	r28, 0x3d	; 61
  16:	de b7       	in	r29, 0x3e	; 62
  18:	64 97       	sbiw	r28, 0x14	; 20
  1a:	0f b6       	in	r0, 0x3f	; 63
  1c:	f8 94       	cli
  1e:	de bf       	out	0x3e, r29	; 62
  20:	0f be       	out	0x3f, r0	; 63
  22:	cd bf       	out	0x3d, r28	; 61
  24:	6c 01       	movw	r12, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  26:	fc 01       	movw	r30, r24
  28:	83 81       	ldd	r24, Z+3	; 0x03
  2a:	80 ff       	sbrs	r24, 0
  2c:	00 c0       	rjmp	.+0      	; 0x2e <ax12GetInfo+0x2e>
	uint16_t rtn = 0;
	if(act_isConnected(servo)){
		HW_UART* uart = servo->driver->ax12uart;
  2e:	84 81       	ldd	r24, Z+4	; 0x04
  30:	95 81       	ldd	r25, Z+5	; 0x05
  32:	fc 01       	movw	r30, r24
  34:	a3 80       	ldd	r10, Z+3	; 0x03
  36:	b4 80       	ldd	r11, Z+4	; 0x04
		uint8_t str[] = {ax12_READ,			// Read
  38:	fe 01       	movw	r30, r28
  3a:	31 96       	adiw	r30, 0x01	; 1
  3c:	a0 e0       	ldi	r26, 0x00	; 0
  3e:	b0 e0       	ldi	r27, 0x00	; 0
  40:	23 e0       	ldi	r18, 0x03	; 3
  42:	0d 90       	ld	r0, X+
  44:	01 92       	st	Z+, r0
  46:	21 50       	subi	r18, 0x01	; 1
  48:	01 f4       	brne	.+0      	; 0x4a <ax12GetInfo+0x4a>
		uint8_t replyPos = 0;
		uint16_t now=0;
		boolean timeOut = FALSE;

		// Send the request
		ax12Send(servo->driver, servo->id, sizeof(str), str);
  4a:	f6 01       	movw	r30, r12
  4c:	66 81       	ldd	r22, Z+6	; 0x06
  4e:	43 e0       	ldi	r20, 0x03	; 3
  50:	50 e0       	ldi	r21, 0x00	; 0
  52:	9e 01       	movw	r18, r28
  54:	2f 5f       	subi	r18, 0xFF	; 255
  56:	3f 4f       	sbci	r19, 0xFF	; 255
  58:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>
int __uartGetByte(UART* uart);

// Is the UART busy doing something?
#define uartIsBusy(uart) __uartIsBusy(&((uart)->_uart_))
static __inline__ boolean __uartIsBusy(UART* uart){
	return (uart->readyTx) ? FALSE : TRUE;
  5c:	f5 01       	movw	r30, r10
  5e:	80 85       	ldd	r24, Z+8	; 0x08
  60:	80 ff       	sbrs	r24, 0
  62:	00 c0       	rjmp	.+0      	; 0x64 <ax12GetInfo+0x64>
		// Wait till xmit is done
		while(uartIsBusy(uart)){
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
  64:	ef b6       	in	r14, 0x3f	; 63
  66:	f8 94       	cli
//		uartFlushReceiveBuffer(uart);

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
		uint16_t now=0;
  68:	00 e0       	ldi	r16, 0x00	; 0
  6a:	10 e0       	ldi	r17, 0x00	; 0
// Doesn't use an input buffer
//		uartFlushReceiveBuffer(uart);

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
  6c:	ff 24       	eor	r15, r15
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
		while(replyPos < sizeof(reply)){
			int ch = uartPollByte(uart);
  6e:	c5 01       	movw	r24, r10
  70:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>

			if(ch != -1){
  74:	ff ef       	ldi	r31, 0xFF	; 255
  76:	8f 3f       	cpi	r24, 0xFF	; 255
  78:	9f 07       	cpc	r25, r31
  7a:	01 f0       	breq	.+0      	; 0x7c <ax12GetInfo+0x7c>
				reply[replyPos++] = (uint8_t)(ch & 0xff);
  7c:	e4 e0       	ldi	r30, 0x04	; 4
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	ec 0f       	add	r30, r28
  82:	fd 1f       	adc	r31, r29
  84:	ef 0d       	add	r30, r15
  86:	f1 1d       	adc	r31, r1
  88:	80 83       	st	Z, r24
  8a:	f3 94       	inc	r15
				now = 0;
  8c:	00 e0       	ldi	r16, 0x00	; 0
  8e:	10 e0       	ldi	r17, 0x00	; 0
  90:	00 c0       	rjmp	.+0      	; 0x92 <ax12GetInfo+0x92>
			}else if(--now == 0){					// Timeout after a while
  92:	01 50       	subi	r16, 0x01	; 1
  94:	10 40       	sbci	r17, 0x00	; 0
  96:	01 f0       	breq	.+0      	; 0x98 <ax12GetInfo+0x98>
		while(uartIsBusy(uart)){
			breathe();
		}

		CRITICAL_SECTION_START;						// At 1Mb baud we have to poll for chars or they get missed
		while(replyPos < sizeof(reply)){
  98:	20 e1       	ldi	r18, 0x10	; 16
  9a:	2f 15       	cp	r18, r15
  9c:	00 f4       	brcc	.+0      	; 0x9e <ax12GetInfo+0x9e>

		// Listen for the response
		uint8_t reply[6+INFO_LENGTH];		// 0xff,0xff,id,length,error,INFO_LENGTH bytes,checksum
		uint8_t replyPos = 0;
		uint16_t now=0;
		boolean timeOut = FALSE;
  9e:	80 e0       	ldi	r24, 0x00	; 0
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <ax12GetInfo+0xa2>

			if(ch != -1){
				reply[replyPos++] = (uint8_t)(ch & 0xff);
				now = 0;
			}else if(--now == 0){					// Timeout after a while
				timeOut = TRUE;
  a2:	8f ef       	ldi	r24, 0xFF	; 255
				break;
			}
		}
		CRITICAL_SECTION_END;
  a4:	ef be       	out	0x3f, r14	; 63

		// Check to see if we timed out
		if(timeOut){
  a6:	88 23       	and	r24, r24
  a8:	01 f0       	breq	.+0      	; 0xaa <ax12GetInfo+0xaa>
  aa:	00 c0       	rjmp	.+0      	; 0xac <ax12GetInfo+0xac>
			return AX12_RECV_TIMEOUT;
		}

		// Now validate the response
		if(reply[0]==0xff && reply[1]==0xff){
  ac:	8c 81       	ldd	r24, Y+4	; 0x04
  ae:	8f 3f       	cpi	r24, 0xFF	; 255
  b0:	01 f0       	breq	.+0      	; 0xb2 <ax12GetInfo+0xb2>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <ax12GetInfo+0xb4>
  b4:	8d 81       	ldd	r24, Y+5	; 0x05
  b6:	8f 3f       	cpi	r24, 0xFF	; 255
  b8:	01 f0       	breq	.+0      	; 0xba <ax12GetInfo+0xba>
  ba:	00 c0       	rjmp	.+0      	; 0xbc <ax12GetInfo+0xbc>
			// Got a valid header
			if(reply[2]==servo->id){
  bc:	9e 81       	ldd	r25, Y+6	; 0x06
  be:	f6 01       	movw	r30, r12
  c0:	86 81       	ldd	r24, Z+6	; 0x06
  c2:	98 17       	cp	r25, r24
  c4:	01 f0       	breq	.+0      	; 0xc6 <ax12GetInfo+0xc6>
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <ax12GetInfo+0xc8>
				// From the correct servo
				if(reply[3]==sizeof(reply)-4){
  c8:	8f 81       	ldd	r24, Y+7	; 0x07
  ca:	8d 30       	cpi	r24, 0x0D	; 13
  cc:	01 f0       	breq	.+0      	; 0xce <ax12GetInfo+0xce>
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <ax12GetInfo+0xd0>
  d0:	fe 01       	movw	r30, r28
  d2:	36 96       	adiw	r30, 0x06	; 6
  d4:	82 e0       	ldi	r24, 0x02	; 2
  d6:	90 e0       	ldi	r25, 0x00	; 0
  d8:	20 e0       	ldi	r18, 0x00	; 0
					// it is the correct length
					uint8_t chksum = 0;
					for(int i=2; i<sizeof(reply);i++){
						chksum+=reply[i];
  da:	31 91       	ld	r19, Z+
  dc:	23 0f       	add	r18, r19
			if(reply[2]==servo->id){
				// From the correct servo
				if(reply[3]==sizeof(reply)-4){
					// it is the correct length
					uint8_t chksum = 0;
					for(int i=2; i<sizeof(reply);i++){
  de:	01 96       	adiw	r24, 0x01	; 1
  e0:	81 31       	cpi	r24, 0x11	; 17
  e2:	91 05       	cpc	r25, r1
  e4:	01 f4       	brne	.+0      	; 0xe6 <ax12GetInfo+0xe6>
						chksum+=reply[i];
					}
					if(chksum==0xff){
  e6:	2f 3f       	cpi	r18, 0xFF	; 255
  e8:	01 f0       	breq	.+0      	; 0xea <ax12GetInfo+0xea>
  ea:	00 c0       	rjmp	.+0      	; 0xec <ax12GetInfo+0xec>
						// The checksum is correct
						rtn = reply[4];
  ec:	e8 84       	ldd	r14, Y+8	; 0x08
  ee:	ff 24       	eor	r15, r15
						if(rtn == 0){
  f0:	e1 14       	cp	r14, r1
  f2:	f1 04       	cpc	r15, r1
  f4:	01 f0       	breq	.+0      	; 0xf6 <ax12GetInfo+0xf6>
  f6:	00 c0       	rjmp	.+0      	; 0xf8 <ax12GetInfo+0xf8>
							// Copy data out
							uint16_t pos = reply[5] | (reply[6]<<8); // 0...1023
  f8:	3a 85       	ldd	r19, Y+10	; 0x0a
  fa:	20 e0       	ldi	r18, 0x00	; 0
  fc:	89 85       	ldd	r24, Y+9	; 0x09
  fe:	90 e0       	ldi	r25, 0x00	; 0
							servo->info.position=interpolate(pos, 0, 1023, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX);
 100:	82 2b       	or	r24, r18
 102:	93 2b       	or	r25, r19
 104:	60 e0       	ldi	r22, 0x00	; 0
 106:	70 e0       	ldi	r23, 0x00	; 0
 108:	4f ef       	ldi	r20, 0xFF	; 255
 10a:	53 e0       	ldi	r21, 0x03	; 3
 10c:	21 e8       	ldi	r18, 0x81	; 129
 10e:	3f ef       	ldi	r19, 0xFF	; 255
 110:	0f e7       	ldi	r16, 0x7F	; 127
 112:	10 e0       	ldi	r17, 0x00	; 0
 114:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>
 118:	48 2f       	mov	r20, r24
 11a:	f6 01       	movw	r30, r12
 11c:	80 87       	std	Z+8, r24	; 0x08


							servo->info.speed = reply[7] | (reply[8]<<8);
 11e:	3c 85       	ldd	r19, Y+12	; 0x0c
 120:	20 e0       	ldi	r18, 0x00	; 0
 122:	8b 85       	ldd	r24, Y+11	; 0x0b
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	82 2b       	or	r24, r18
 128:	93 2b       	or	r25, r19
 12a:	92 87       	std	Z+10, r25	; 0x0a
 12c:	81 87       	std	Z+9, r24	; 0x09
							if(servo->info.speed & 0x400){
 12e:	92 ff       	sbrs	r25, 2
 130:	00 c0       	rjmp	.+0      	; 0x132 <ax12GetInfo+0x132>
								servo->info.speed = - (servo->info.speed & 0x3ff);
 132:	93 70       	andi	r25, 0x03	; 3
 134:	90 95       	com	r25
 136:	81 95       	neg	r24
 138:	9f 4f       	sbci	r25, 0xFF	; 255
 13a:	92 87       	std	Z+10, r25	; 0x0a
 13c:	81 87       	std	Z+9, r24	; 0x09
							}

							servo->info.load = reply[9] | (reply[10]<<8);
 13e:	3e 85       	ldd	r19, Y+14	; 0x0e
 140:	20 e0       	ldi	r18, 0x00	; 0
 142:	8d 85       	ldd	r24, Y+13	; 0x0d
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	82 2b       	or	r24, r18
 148:	93 2b       	or	r25, r19
 14a:	f6 01       	movw	r30, r12
 14c:	94 87       	std	Z+12, r25	; 0x0c
 14e:	83 87       	std	Z+11, r24	; 0x0b
							if(servo->info.load & 0x400){
 150:	92 ff       	sbrs	r25, 2
 152:	00 c0       	rjmp	.+0      	; 0x154 <ax12GetInfo+0x154>
								servo->info.load = - (servo->info.load & 0x3ff);
 154:	93 70       	andi	r25, 0x03	; 3
 156:	90 95       	com	r25
 158:	81 95       	neg	r24
 15a:	9f 4f       	sbci	r25, 0xFF	; 255
 15c:	94 87       	std	Z+12, r25	; 0x0c
 15e:	83 87       	std	Z+11, r24	; 0x0b
							}

							if(servo->actuator.inverted){
 160:	f6 01       	movw	r30, r12
 162:	83 81       	ldd	r24, Z+3	; 0x03
 164:	81 ff       	sbrs	r24, 1
 166:	00 c0       	rjmp	.+0      	; 0x168 <ax12GetInfo+0x168>
								servo->info.position *= -1;
 168:	41 95       	neg	r20
 16a:	40 87       	std	Z+8, r20	; 0x08
								servo->info.load *= -1;
 16c:	83 85       	ldd	r24, Z+11	; 0x0b
 16e:	94 85       	ldd	r25, Z+12	; 0x0c
 170:	90 95       	com	r25
 172:	81 95       	neg	r24
 174:	9f 4f       	sbci	r25, 0xFF	; 255
 176:	94 87       	std	Z+12, r25	; 0x0c
 178:	83 87       	std	Z+11, r24	; 0x0b
								servo->info.speed *= -1;
 17a:	81 85       	ldd	r24, Z+9	; 0x09
 17c:	92 85       	ldd	r25, Z+10	; 0x0a
 17e:	90 95       	com	r25
 180:	81 95       	neg	r24
 182:	9f 4f       	sbci	r25, 0xFF	; 255
 184:	92 87       	std	Z+10, r25	; 0x0a
 186:	81 87       	std	Z+9, r24	; 0x09
							}
							servo->info.voltage = reply[11];
 188:	8f 85       	ldd	r24, Y+15	; 0x0f
 18a:	f6 01       	movw	r30, r12
 18c:	85 87       	std	Z+13, r24	; 0x0d
							servo->info.temperature = reply[12];
 18e:	88 89       	ldd	r24, Y+16	; 0x10
 190:	86 87       	std	Z+14, r24	; 0x0e
							servo->info.batch = (reply[13]) ? TRUE : FALSE;
 192:	89 89       	ldd	r24, Y+17	; 0x11
 194:	88 23       	and	r24, r24
 196:	01 f0       	breq	.+0      	; 0x198 <ax12GetInfo+0x198>
 198:	8f ef       	ldi	r24, 0xFF	; 255
 19a:	00 c0       	rjmp	.+0      	; 0x19c <ax12GetInfo+0x19c>
 19c:	80 e0       	ldi	r24, 0x00	; 0
 19e:	f6 01       	movw	r30, r12
 1a0:	87 87       	std	Z+15, r24	; 0x0f
							// byte14 is the reserved value
							servo->info.moving = (reply[15]) ? TRUE : FALSE;
 1a2:	8b 89       	ldd	r24, Y+19	; 0x13
 1a4:	88 23       	and	r24, r24
 1a6:	01 f0       	breq	.+0      	; 0x1a8 <ax12GetInfo+0x1a8>
 1a8:	8f ef       	ldi	r24, 0xFF	; 255
 1aa:	00 c0       	rjmp	.+0      	; 0x1ac <ax12GetInfo+0x1ac>
 1ac:	80 e0       	ldi	r24, 0x00	; 0
 1ae:	f6 01       	movw	r30, r12
 1b0:	80 8b       	std	Z+16, r24	; 0x10
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <ax12GetInfo+0x1b4>

// The number of bytes to read from the ax12
#define INFO_LENGTH (ax12_LOCK - ax12_PRESENT_POSITION)

uint16_t ax12GetInfo(DYNAMIXEL_AX12* servo){
	uint16_t rtn = 0;
 1b4:	ee 24       	eor	r14, r14
 1b6:	ff 24       	eor	r15, r15
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <ax12GetInfo+0x1ba>
		}
		CRITICAL_SECTION_END;

		// Check to see if we timed out
		if(timeOut){
			return AX12_RECV_TIMEOUT;
 1ba:	e1 2c       	mov	r14, r1
 1bc:	41 e0       	ldi	r20, 0x01	; 1
 1be:	f4 2e       	mov	r15, r20
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <ax12GetInfo+0x1c2>
				}
			}else{
				rtn = AX12_RECV_ID;
			}
		}else{
			rtn = AX12_RECV_HEADER;
 1c2:	e1 2c       	mov	r14, r1
 1c4:	34 e0       	ldi	r19, 0x04	; 4
 1c6:	f3 2e       	mov	r15, r19
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <ax12GetInfo+0x1ca>
					}
				}else{
					rtn = AX12_RECV_LEN;
				}
			}else{
				rtn = AX12_RECV_ID;
 1ca:	e1 2c       	mov	r14, r1
 1cc:	28 e0       	ldi	r18, 0x08	; 8
 1ce:	f2 2e       	mov	r15, r18
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <ax12GetInfo+0x1d2>
						}
					}else{
						rtn = AX12_RECV_CHECKSUM;
					}
				}else{
					rtn = AX12_RECV_LEN;
 1d2:	e1 2c       	mov	r14, r1
 1d4:	90 e1       	ldi	r25, 0x10	; 16
 1d6:	f9 2e       	mov	r15, r25
 1d8:	00 c0       	rjmp	.+0      	; 0x1da <ax12GetInfo+0x1da>
							servo->info.batch = (reply[13]) ? TRUE : FALSE;
							// byte14 is the reserved value
							servo->info.moving = (reply[15]) ? TRUE : FALSE;
						}
					}else{
						rtn = AX12_RECV_CHECKSUM;
 1da:	e1 2c       	mov	r14, r1
 1dc:	82 e0       	ldi	r24, 0x02	; 2
 1de:	f8 2e       	mov	r15, r24
		}else{
			rtn = AX12_RECV_HEADER;
		}
	}
	return rtn;
}
 1e0:	c7 01       	movw	r24, r14
 1e2:	64 96       	adiw	r28, 0x14	; 20
 1e4:	0f b6       	in	r0, 0x3f	; 63
 1e6:	f8 94       	cli
 1e8:	de bf       	out	0x3e, r29	; 62
 1ea:	0f be       	out	0x3f, r0	; 63
 1ec:	cd bf       	out	0x3d, r28	; 61
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	1f 91       	pop	r17
 1f4:	0f 91       	pop	r16
 1f6:	ff 90       	pop	r15
 1f8:	ef 90       	pop	r14
 1fa:	df 90       	pop	r13
 1fc:	cf 90       	pop	r12
 1fe:	bf 90       	pop	r11
 200:	af 90       	pop	r10
 202:	08 95       	ret
		// Send the request
		ax12Send(servo->driver, servo->id, sizeof(str), str);

		// Wait till xmit is done
		while(uartIsBusy(uart)){
			breathe();
 204:	0e 94 00 00 	call	0	; 0x0 <ax12GetInfo>
 208:	00 c0       	rjmp	.+0      	; 0x20a <__SREG__+0x1cb>

serialServo.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001b4  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001e8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001e8  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000001e8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a13  00000000  00000000  000001ec  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001e3  00000000  00000000  00000bff  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000311  00000000  00000000  00000de2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000010f3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00001113  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000149  00000000  00000000  0000112b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000004f4  00000000  00000000  00001274  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000a0  00000000  00000000  00001768  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
 */

#include "../servos.h"
#include "../core.h"

static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	df 92       	push	r13
   2:	ef 92       	push	r14
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	7c 01       	movw	r14, r24
  10:	d6 2e       	mov	r13, r22
	SERVO* servo = (SERVO*)actuator;

	DRIVE_SPEED current = servo->actuator.required_speed;
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	8c 91       	ld	r24, X
  18:	12 97       	sbiw	r26, 0x02	; 2
	if(servo->actuator.inverted){
  1a:	13 96       	adiw	r26, 0x03	; 3
  1c:	9c 91       	ld	r25, X
  1e:	13 97       	sbiw	r26, 0x03	; 3
  20:	91 fd       	sbrc	r25, 1
		current *= -1;
  22:	81 95       	neg	r24
	}


	if(speed != current){
  24:	d8 16       	cp	r13, r24
  26:	01 f4       	brne	.+0      	; 0x28 <setSpeed+0x28>
  28:	00 c0       	rjmp	.+0      	; 0x2a <setSpeed+0x2a>
		// Speed has changed
		UART* uart = servo->driver->specific.serial.uart;
  2a:	d7 01       	movw	r26, r14
  2c:	14 96       	adiw	r26, 0x04	; 4
  2e:	ed 91       	ld	r30, X+
  30:	fc 91       	ld	r31, X
  32:	15 97       	sbiw	r26, 0x05	; 5
  34:	c7 81       	ldd	r28, Z+7	; 0x07
  36:	d0 85       	ldd	r29, Z+8	; 0x08
		if(uart){
  38:	20 97       	sbiw	r28, 0x00	; 0
  3a:	01 f4       	brne	.+0      	; 0x3c <setSpeed+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <setSpeed+0x3e>
			SERVO_PROTOCOL protocol = servo->driver->specific.serial.protocol;
  3e:	81 85       	ldd	r24, Z+9	; 0x09
			if(protocol==MINI_SSC){
  40:	88 23       	and	r24, r24
  42:	01 f4       	brne	.+0      	; 0x44 <setSpeed+0x44>
				}else{
					// Need to interpolate
					speedByte = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, 0, 254);
				}

				_uartSendByte(uart, 0xff);
  44:	ce 01       	movw	r24, r28
  46:	6f ef       	ldi	r22, 0xFF	; 255
  48:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, servo->delay & 0x7f);
  4c:	f7 01       	movw	r30, r14
  4e:	60 89       	ldd	r22, Z+16	; 0x10
  50:	6f 77       	andi	r22, 0x7F	; 127
  52:	ce 01       	movw	r24, r28
  54:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				uint8_t speedByte;

				// Send 0xff, servo#, speed
				// where speed 0x7f=CENTER, 0x00=Left, 0xfe=Right
				if(DRIVE_SPEED_MIN == -127 && DRIVE_SPEED_MAX == 127){
					speedByte = speed + 127;
  58:	6d 2d       	mov	r22, r13
  5a:	61 58       	subi	r22, 0x81	; 129
  5c:	00 c0       	rjmp	.+0      	; 0x5e <setSpeed+0x5e>
				}

				_uartSendByte(uart, 0xff);
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
  5e:	81 30       	cpi	r24, 0x01	; 1
  60:	01 f4       	brne	.+0      	; 0x62 <setSpeed+0x62>
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
						4*(servo->center_us - servo->range_us),
  62:	d7 01       	movw	r26, r14
  64:	18 96       	adiw	r26, 0x08	; 8
  66:	8d 91       	ld	r24, X+
  68:	9c 91       	ld	r25, X
  6a:	19 97       	sbiw	r26, 0x09	; 9
  6c:	1a 96       	adiw	r26, 0x0a	; 10
  6e:	0d 91       	ld	r16, X+
  70:	1c 91       	ld	r17, X
  72:	1b 97       	sbiw	r26, 0x0b	; 11
  74:	9c 01       	movw	r18, r24
  76:	20 1b       	sub	r18, r16
  78:	31 0b       	sbc	r19, r17
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
  7a:	22 0f       	add	r18, r18
  7c:	33 1f       	adc	r19, r19
  7e:	22 0f       	add	r18, r18
  80:	33 1f       	adc	r19, r19
						4*(servo->center_us - servo->range_us),
						4*(servo->center_us + servo->range_us) );
  82:	08 0f       	add	r16, r24
  84:	19 1f       	adc	r17, r25
				_uartSendByte(uart, servo->delay & 0x7f);
				_uartSendByte(uart, speedByte);
			}else if(protocol==POLOLU_COMPACT){
				// Send 0x84, servo#, lsb, msb
				uint16_t speedWord;
				speedWord = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX,
  86:	00 0f       	add	r16, r16
  88:	11 1f       	adc	r17, r17
  8a:	00 0f       	add	r16, r16
  8c:	11 1f       	adc	r17, r17
  8e:	8d 2d       	mov	r24, r13
  90:	99 27       	eor	r25, r25
  92:	87 fd       	sbrc	r24, 7
  94:	90 95       	com	r25
  96:	61 e8       	ldi	r22, 0x81	; 129
  98:	7f ef       	ldi	r23, 0xFF	; 255
  9a:	4f e7       	ldi	r20, 0x7F	; 127
  9c:	50 e0       	ldi	r21, 0x00	; 0
  9e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  a2:	8c 01       	movw	r16, r24
						4*(servo->center_us - servo->range_us),
						4*(servo->center_us + servo->range_us) );
				_uartSendByte(uart, 0x84);
  a4:	ce 01       	movw	r24, r28
  a6:	64 e8       	ldi	r22, 0x84	; 132
  a8:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, servo->delay & 0x7f);
  ac:	f7 01       	movw	r30, r14
  ae:	60 89       	ldd	r22, Z+16	; 0x10
  b0:	6f 77       	andi	r22, 0x7F	; 127
  b2:	ce 01       	movw	r24, r28
  b4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, speedWord & 0x7f);
  b8:	60 2f       	mov	r22, r16
  ba:	6f 77       	andi	r22, 0x7F	; 127
  bc:	ce 01       	movw	r24, r28
  be:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
				_uartSendByte(uart, (speedWord>>7) & 0x7f );
  c2:	b8 01       	movw	r22, r16
  c4:	66 0f       	add	r22, r22
  c6:	67 2f       	mov	r22, r23
  c8:	66 1f       	adc	r22, r22
  ca:	77 0b       	sbc	r23, r23
  cc:	71 95       	neg	r23
  ce:	6f 77       	andi	r22, 0x7F	; 127
  d0:	ce 01       	movw	r24, r28
  d2:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			}
		}
	}
}
  d6:	df 91       	pop	r29
  d8:	cf 91       	pop	r28
  da:	1f 91       	pop	r17
  dc:	0f 91       	pop	r16
  de:	ff 90       	pop	r15
  e0:	ef 90       	pop	r14
  e2:	df 90       	pop	r13
  e4:	08 95       	ret

000000e6 <_servoSerialInit>:


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
  e6:	6f 92       	push	r6
  e8:	7f 92       	push	r7
  ea:	8f 92       	push	r8
  ec:	9f 92       	push	r9
  ee:	af 92       	push	r10
  f0:	bf 92       	push	r11
  f2:	cf 92       	push	r12
  f4:	df 92       	push	r13
  f6:	ef 92       	push	r14
  f8:	ff 92       	push	r15
  fa:	0f 93       	push	r16
  fc:	1f 93       	push	r17
  fe:	cf 93       	push	r28
 100:	df 93       	push	r29
 102:	7c 01       	movw	r14, r24
 104:	cb 01       	movw	r24, r22
 106:	ba 01       	movw	r22, r20
 108:	a9 01       	movw	r20, r18
	driver->specific.serial.uart = uart;
 10a:	f7 01       	movw	r30, r14
 10c:	90 87       	std	Z+8, r25	; 0x08
 10e:	87 83       	std	Z+7, r24	; 0x07
	driver->specific.serial.protocol = protocol;
 110:	01 87       	std	Z+9, r16	; 0x09
	// Set the baud rate
	_uartInit(uart, baud);
 112:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 116:	f7 01       	movw	r30, r14
 118:	12 81       	ldd	r17, Z+2	; 0x02
 11a:	11 50       	subi	r17, 0x01	; 1
 11c:	cc 24       	eor	r12, r12
 11e:	dd 24       	eor	r13, r13


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 120:	81 2e       	mov	r8, r17
 122:	99 24       	eor	r9, r9
 124:	87 fc       	sbrc	r8, 7
 126:	90 94       	com	r9
	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		if(servo){
			// Connect the servo to this driver
			servo->actuator.class = &c_miniSSC_servos;
 128:	a0 e0       	ldi	r26, 0x00	; 0
 12a:	6a 2e       	mov	r6, r26
 12c:	a0 e0       	ldi	r26, 0x00	; 0
 12e:	7a 2e       	mov	r7, r26
	driver->specific.serial.protocol = protocol;
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 130:	00 c0       	rjmp	.+0      	; 0x132 <_servoSerialInit+0x4c>


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 132:	a4 01       	movw	r20, r8
 134:	4c 19       	sub	r20, r12
 136:	5d 09       	sbc	r21, r13
 138:	9a 01       	movw	r18, r20
 13a:	22 0f       	add	r18, r18
 13c:	33 1f       	adc	r19, r19
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 13e:	f7 01       	movw	r30, r14
 140:	80 81       	ld	r24, Z
 142:	91 81       	ldd	r25, Z+1	; 0x01
 144:	82 0f       	add	r24, r18
 146:	93 1f       	adc	r25, r19
 148:	fc 01       	movw	r30, r24
 14a:	a5 90       	lpm	r10, Z+
 14c:	b4 90       	lpm	r11, Z
 14e:	ca 2d       	mov	r28, r10
 150:	db 2d       	mov	r29, r11
		if(servo){
 152:	20 97       	sbiw	r28, 0x00	; 0
 154:	01 f0       	breq	.+0      	; 0x156 <_servoSerialInit+0x70>
			// Connect the servo to this driver
			servo->actuator.class = &c_miniSSC_servos;
 156:	79 82       	std	Y+1, r7	; 0x01
 158:	68 82       	st	Y, r6
			servo->driver = driver;
 15a:	fd 82       	std	Y+5, r15	; 0x05
 15c:	ec 82       	std	Y+4, r14	; 0x04
			servo->top = 0;
 15e:	1b 8a       	std	Y+19, r1	; 0x13
 160:	1a 8a       	std	Y+18, r1	; 0x12
			servo->delay = i; // The servo number in the list
 162:	59 8b       	std	Y+17, r21	; 0x11
 164:	48 8b       	std	Y+16, r20	; 0x10
			servoSetConfig(servo,servo->center_us,servo->range_us);
 166:	68 85       	ldd	r22, Y+8	; 0x08
 168:	79 85       	ldd	r23, Y+9	; 0x09
 16a:	4a 85       	ldd	r20, Y+10	; 0x0a
 16c:	5b 85       	ldd	r21, Y+11	; 0x0b
 16e:	ce 01       	movw	r24, r28
 170:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 174:	8a 2d       	mov	r24, r10
 176:	9b 2d       	mov	r25, r11
 178:	6f ef       	ldi	r22, 0xFF	; 255
 17a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 17e:	8a 2d       	mov	r24, r10
 180:	9b 2d       	mov	r25, r11
 182:	60 e0       	ldi	r22, 0x00	; 0
 184:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 188:	08 94       	sec
 18a:	c1 1c       	adc	r12, r1
 18c:	d1 1c       	adc	r13, r1


// Define the class, note that you cannot connect/disconnect servos
const static __ACTUATOR_DRIVER_CLASS c_miniSSC_servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);

void _servoSerialInit(SERVO_DRIVER* driver, UART* uart, BAUD_RATE baud, SERVO_PROTOCOL protocol){
 18e:	81 2f       	mov	r24, r17
 190:	8c 19       	sub	r24, r12
	driver->specific.serial.protocol = protocol;
	// Set the baud rate
	_uartInit(uart, baud);

	// Make sure each servo is initialised
	for(int8_t i= driver->num_servos-1;i>=0;i--){
 192:	87 ff       	sbrs	r24, 7
 194:	00 c0       	rjmp	.+0      	; 0x196 <_servoSerialInit+0xb0>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}
	}
}
 196:	df 91       	pop	r29
 198:	cf 91       	pop	r28
 19a:	1f 91       	pop	r17
 19c:	0f 91       	pop	r16
 19e:	ff 90       	pop	r15
 1a0:	ef 90       	pop	r14
 1a2:	df 90       	pop	r13
 1a4:	cf 90       	pop	r12
 1a6:	bf 90       	pop	r11
 1a8:	af 90       	pop	r10
 1aa:	9f 90       	pop	r9
 1ac:	8f 90       	pop	r8
 1ae:	7f 90       	pop	r7
 1b0:	6f 90       	pop	r6
 1b2:	08 95       	ret

FATImpl.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000201c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000054  00000000  00000000  00002050  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000020a4  2**0
                  ALLOC
  3 .debug_info   00002c20  00000000  00000000  000020a4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000421  00000000  00000000  00004cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00004118  00000000  00000000  000050e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000091fd  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000308  00000000  00000000  0000921d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000006c4  00000000  00000000  00009525  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000cbd  00000000  00000000  00009be9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000864  00000000  00000000  0000a8a8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_bufferIsWritable>:
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
       0:	fc 01       	movw	r30, r24
       2:	21 81       	ldd	r18, Z+1	; 0x01
       4:	30 e0       	ldi	r19, 0x00	; 0
}
static void _bufferSetNotWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 0;
}
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
       6:	f9 01       	movw	r30, r18
       8:	ee 0f       	add	r30, r30
       a:	ff 1f       	adc	r31, r31
       c:	e2 0f       	add	r30, r18
       e:	f3 1f       	adc	r31, r19
      10:	ee 0f       	add	r30, r30
      12:	ff 1f       	adc	r31, r31
      14:	e8 0f       	add	r30, r24
      16:	f9 1f       	adc	r31, r25
      18:	87 81       	ldd	r24, Z+7	; 0x07
      1a:	81 ff       	sbrs	r24, 1
      1c:	00 c0       	rjmp	.+0      	; 0x1e <_bufferIsWritable+0x1e>
      1e:	8f ef       	ldi	r24, 0xFF	; 255
      20:	08 95       	ret
      22:	80 e0       	ldi	r24, 0x00	; 0
}
      24:	08 95       	ret

00000026 <_bufferFindUnused>:
	buffer->depth--;

	return(TRUE);
}

static BUFFER* _bufferFindUnused(const DISK* disc){
      26:	dc 01       	movw	r26, r24
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      28:	d4 96       	adiw	r26, 0x34	; 52
      2a:	ed 91       	ld	r30, X+
      2c:	fc 91       	ld	r31, X
      2e:	d5 97       	sbiw	r26, 0x35	; 53
      30:	d3 96       	adiw	r26, 0x33	; 51
      32:	3c 91       	ld	r19, X
      34:	d3 97       	sbiw	r26, 0x33	; 51
      36:	20 e0       	ldi	r18, 0x00	; 0
      38:	00 c0       	rjmp	.+0      	; 0x3a <_bufferFindUnused+0x14>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
      3a:	81 81       	ldd	r24, Z+1	; 0x01
      3c:	90 e0       	ldi	r25, 0x00	; 0

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
      3e:	dc 01       	movw	r26, r24
      40:	aa 0f       	add	r26, r26
      42:	bb 1f       	adc	r27, r27
      44:	a8 0f       	add	r26, r24
      46:	b9 1f       	adc	r27, r25
      48:	aa 0f       	add	r26, r26
      4a:	bb 1f       	adc	r27, r27
      4c:	ae 0f       	add	r26, r30
      4e:	bf 1f       	adc	r27, r31
      50:	17 96       	adiw	r26, 0x07	; 7
      52:	8c 91       	ld	r24, X
      54:	17 97       	sbiw	r26, 0x07	; 7
      56:	80 ff       	sbrs	r24, 0
      58:	00 c0       	rjmp	.+0      	; 0x5a <_bufferFindUnused+0x34>
}

static BUFFER* _bufferFindUnused(const DISK* disc){
	uint8_t bufferNum;
	BUFFER* buffer;
	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      5a:	2f 5f       	subi	r18, 0xFF	; 255
      5c:	e6 5e       	subi	r30, 0xE6	; 230
      5e:	fd 4f       	sbci	r31, 0xFD	; 253
      60:	23 17       	cp	r18, r19
      62:	01 f4       	brne	.+0      	; 0x64 <_bufferFindUnused+0x3e>
		if(!_bufferIsValid(buffer)){
			return(buffer);
		}
	}
	return(null);
      64:	e0 e0       	ldi	r30, 0x00	; 0
      66:	f0 e0       	ldi	r31, 0x00	; 0
}
      68:	cf 01       	movw	r24, r30
      6a:	08 95       	ret

0000006c <_ioFindSectorInCache>:
		}
	}
	return(null);
}

static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
      6c:	dc 01       	movw	r26, r24
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      6e:	d4 96       	adiw	r26, 0x34	; 52
      70:	ed 91       	ld	r30, X+
      72:	fc 91       	ld	r31, X
      74:	d5 97       	sbiw	r26, 0x35	; 53
      76:	d3 96       	adiw	r26, 0x33	; 51
      78:	3c 91       	ld	r19, X
      7a:	d3 97       	sbiw	r26, 0x33	; 51
      7c:	20 e0       	ldi	r18, 0x00	; 0
      7e:	00 c0       	rjmp	.+0      	; 0x80 <_ioFindSectorInCache+0x14>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
      80:	81 81       	ldd	r24, Z+1	; 0x01
      82:	90 e0       	ldi	r25, 0x00	; 0
static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		const SECTOR_BUFFER * secbuf = _bufferCurrentStackEntry(buffer);
      84:	dc 01       	movw	r26, r24
      86:	aa 0f       	add	r26, r26
      88:	bb 1f       	adc	r27, r27
      8a:	a8 0f       	add	r26, r24
      8c:	b9 1f       	adc	r27, r25
      8e:	aa 0f       	add	r26, r26
      90:	bb 1f       	adc	r27, r27
      92:	12 96       	adiw	r26, 0x02	; 2
      94:	ae 0f       	add	r26, r30
      96:	bf 1f       	adc	r27, r31
		if(secbuf->isValid && secbuf->sector==absSector){
      98:	15 96       	adiw	r26, 0x05	; 5
      9a:	8c 91       	ld	r24, X
      9c:	15 97       	sbiw	r26, 0x05	; 5
      9e:	80 ff       	sbrs	r24, 0
      a0:	00 c0       	rjmp	.+0      	; 0xa2 <_ioFindSectorInCache+0x36>
      a2:	8d 91       	ld	r24, X+
      a4:	9d 91       	ld	r25, X+
      a6:	0d 90       	ld	r0, X+
      a8:	bc 91       	ld	r27, X
      aa:	a0 2d       	mov	r26, r0
      ac:	84 17       	cp	r24, r20
      ae:	95 07       	cpc	r25, r21
      b0:	a6 07       	cpc	r26, r22
      b2:	b7 07       	cpc	r27, r23
      b4:	01 f0       	breq	.+0      	; 0xb6 <_ioFindSectorInCache+0x4a>

static BUFFER* _ioFindSectorInCache(const DISK *disc, SECTOR absSector){
	uint8_t bufferNum;
	BUFFER* buffer;

	for( bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
      b6:	2f 5f       	subi	r18, 0xFF	; 255
      b8:	e6 5e       	subi	r30, 0xE6	; 230
      ba:	fd 4f       	sbci	r31, 0xFD	; 253
      bc:	23 17       	cp	r18, r19
      be:	01 f4       	brne	.+0      	; 0xc0 <_ioFindSectorInCache+0x54>
		const SECTOR_BUFFER * secbuf = _bufferCurrentStackEntry(buffer);
		if(secbuf->isValid && secbuf->sector==absSector){
			return buffer;
		}
	}
	return(null);
      c0:	e0 e0       	ldi	r30, 0x00	; 0
      c2:	f0 e0       	ldi	r31, 0x00	; 0
}
      c4:	cf 01       	movw	r24, r30
      c6:	08 95       	ret

000000c8 <_fatGetSectorAddressFatEntry>:
/*					FAT Table Management								  */
/*------------------------------------------------------------------------*/

// Find the sector inside the FAT table which holds the given cluster
// Return value: Sector, or 0.
static SECTOR _fatGetSectorAddressFatEntry(const DISK *disk,CLUSTER cluster_addr){
      c8:	0f 93       	push	r16
      ca:	1f 93       	push	r17
      cc:	fc 01       	movw	r30, r24
	SECTOR_COUNT res;

	switch(disk->fatType){
      ce:	86 a1       	ldd	r24, Z+38	; 0x26
      d0:	80 31       	cpi	r24, 0x10	; 16
      d2:	01 f0       	breq	.+0      	; 0xd4 <_fatGetSectorAddressFatEntry+0xc>
      d4:	80 32       	cpi	r24, 0x20	; 32
      d6:	01 f0       	breq	.+0      	; 0xd8 <_fatGetSectorAddressFatEntry+0x10>
      d8:	8c 30       	cpi	r24, 0x0C	; 12
      da:	01 f4       	brne	.+0      	; 0xdc <_fatGetSectorAddressFatEntry+0x14>
		case 12:
			res=(cluster_addr * 3 / 1024);
      dc:	db 01       	movw	r26, r22
      de:	ca 01       	movw	r24, r20
      e0:	88 0f       	add	r24, r24
      e2:	99 1f       	adc	r25, r25
      e4:	aa 1f       	adc	r26, r26
      e6:	bb 1f       	adc	r27, r27
      e8:	84 0f       	add	r24, r20
      ea:	95 1f       	adc	r25, r21
      ec:	a6 1f       	adc	r26, r22
      ee:	b7 1f       	adc	r27, r23
      f0:	0a e0       	ldi	r16, 0x0A	; 10
      f2:	b6 95       	lsr	r27
      f4:	a7 95       	ror	r26
      f6:	97 95       	ror	r25
      f8:	87 95       	ror	r24
      fa:	0a 95       	dec	r16
      fc:	01 f4       	brne	.+0      	; 0xfe <_fatGetSectorAddressFatEntry+0x36>
			break;
      fe:	00 c0       	rjmp	.+0      	; 0x100 <_fatGetSectorAddressFatEntry+0x38>
		case 16:
			res=cluster_addr / 256;
     100:	bb 27       	eor	r27, r27
     102:	a7 2f       	mov	r26, r23
     104:	96 2f       	mov	r25, r22
     106:	85 2f       	mov	r24, r21
			break;
     108:	00 c0       	rjmp	.+0      	; 0x10a <_fatGetSectorAddressFatEntry+0x42>
		case 32:
			res=cluster_addr / 128;
     10a:	db 01       	movw	r26, r22
     10c:	ca 01       	movw	r24, r20
     10e:	27 e0       	ldi	r18, 0x07	; 7
     110:	b6 95       	lsr	r27
     112:	a7 95       	ror	r26
     114:	97 95       	ror	r25
     116:	87 95       	ror	r24
     118:	2a 95       	dec	r18
     11a:	01 f4       	brne	.+0      	; 0x11c <_fatGetSectorAddressFatEntry+0x54>
			break;
		default:
			return 0;
	}
	if(res >= disk->fatSectorCount){
     11c:	42 8d       	ldd	r20, Z+26	; 0x1a
     11e:	53 8d       	ldd	r21, Z+27	; 0x1b
     120:	64 8d       	ldd	r22, Z+28	; 0x1c
     122:	75 8d       	ldd	r23, Z+29	; 0x1d
     124:	84 17       	cp	r24, r20
     126:	95 07       	cpc	r25, r21
     128:	a6 07       	cpc	r26, r22
     12a:	b7 07       	cpc	r27, r23
     12c:	00 f4       	brcc	.+0      	; 0x12e <_fatGetSectorAddressFatEntry+0x66>
		return(0);
	}
	return(disk->volume.reservedSectorCount + res);
     12e:	01 89       	ldd	r16, Z+17	; 0x11
     130:	12 89       	ldd	r17, Z+18	; 0x12
     132:	20 e0       	ldi	r18, 0x00	; 0
     134:	30 e0       	ldi	r19, 0x00	; 0
     136:	08 0f       	add	r16, r24
     138:	19 1f       	adc	r17, r25
     13a:	2a 1f       	adc	r18, r26
     13c:	3b 1f       	adc	r19, r27
     13e:	00 c0       	rjmp	.+0      	; 0x140 <_fatGetSectorAddressFatEntry+0x78>
			break;
		default:
			return 0;
	}
	if(res >= disk->fatSectorCount){
		return(0);
     140:	00 e0       	ldi	r16, 0x00	; 0
     142:	10 e0       	ldi	r17, 0x00	; 0
     144:	20 e0       	ldi	r18, 0x00	; 0
     146:	30 e0       	ldi	r19, 0x00	; 0
	}
	return(disk->volume.reservedSectorCount + res);
}
     148:	b8 01       	movw	r22, r16
     14a:	c9 01       	movw	r24, r18
     14c:	1f 91       	pop	r17
     14e:	0f 91       	pop	r16
     150:	08 95       	ret

00000152 <_bufferReset>:

static uint8_t _bufferGetStackDepth(const BUFFER* buffer){
	return buffer->depth;
}

static void _bufferReset(BUFFER* buffer){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	fc 01       	movw	r30, r24
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     158:	81 81       	ldd	r24, Z+1	; 0x01
     15a:	90 e0       	ldi	r25, 0x00	; 0
	return buffer->depth;
}

static void _bufferReset(BUFFER* buffer){
	SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
	memclr(current,sizeof(SECTOR_BUFFER));
     15c:	9c 01       	movw	r18, r24
     15e:	22 0f       	add	r18, r18
     160:	33 1f       	adc	r19, r19
     162:	28 0f       	add	r18, r24
     164:	39 1f       	adc	r19, r25
     166:	22 0f       	add	r18, r18
     168:	33 1f       	adc	r19, r19
     16a:	2e 5f       	subi	r18, 0xFE	; 254
     16c:	3f 4f       	sbci	r19, 0xFF	; 255
     16e:	2e 0f       	add	r18, r30
     170:	3f 1f       	adc	r19, r31
     172:	86 e0       	ldi	r24, 0x06	; 6
     174:	e9 01       	movw	r28, r18
     176:	19 92       	st	Y+, r1
     178:	8a 95       	dec	r24
     17a:	01 f4       	brne	.+0      	; 0x17c <_bufferReset+0x2a>
	buffer->reference = 0;
     17c:	10 82       	st	Z, r1
}
     17e:	df 91       	pop	r29
     180:	cf 91       	pop	r28
     182:	08 95       	ret

00000184 <_ioFlushSector>:
	return(null);
}

// Write sector to physical device and mark as non-writeable
// if its no longer used
static boolean _ioFlushSector(const DISK *disc, BUFFER* buffer){
     184:	0f 93       	push	r16
     186:	1f 93       	push	r17
     188:	cf 93       	push	r28
     18a:	df 93       	push	r29
     18c:	8c 01       	movw	r16, r24
     18e:	eb 01       	movw	r28, r22

	// Make sure the buffer is writeable
	if(!_bufferIsWritable(buffer)){
     190:	cb 01       	movw	r24, r22
     192:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     196:	88 23       	and	r24, r24
     198:	01 f0       	breq	.+0      	; 0x19a <_ioFlushSector+0x16>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("[w%lu]",absSector);
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);
     19a:	d8 01       	movw	r26, r16
     19c:	ed 91       	ld	r30, X+
     19e:	fc 91       	ld	r31, X
     1a0:	32 96       	adiw	r30, 0x02	; 2
     1a2:	a5 91       	lpm	r26, Z+
     1a4:	b4 91       	lpm	r27, Z
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     1a6:	89 81       	ldd	r24, Y+1	; 0x01
     1a8:	90 e0       	ldi	r25, 0x00	; 0
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     1aa:	fc 01       	movw	r30, r24
     1ac:	ee 0f       	add	r30, r30
     1ae:	ff 1f       	adc	r31, r31
     1b0:	e8 0f       	add	r30, r24
     1b2:	f9 1f       	adc	r31, r25
     1b4:	ee 0f       	add	r30, r30
     1b6:	ff 1f       	adc	r31, r31
     1b8:	ec 0f       	add	r30, r28
     1ba:	fd 1f       	adc	r31, r29
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);

	return write(disc->device,absSector,dta);
     1bc:	42 81       	ldd	r20, Z+2	; 0x02
     1be:	53 81       	ldd	r21, Z+3	; 0x03
     1c0:	64 81       	ldd	r22, Z+4	; 0x04
     1c2:	75 81       	ldd	r23, Z+5	; 0x05
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     1c4:	9e 01       	movw	r18, r28
     1c6:	26 5e       	subi	r18, 0xE6	; 230
     1c8:	3f 4f       	sbci	r19, 0xFF	; 255
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);

	return write(disc->device,absSector,dta);
     1ca:	f8 01       	movw	r30, r16
     1cc:	82 81       	ldd	r24, Z+2	; 0x02
     1ce:	93 81       	ldd	r25, Z+3	; 0x03
     1d0:	fd 01       	movw	r30, r26
     1d2:	09 95       	icall
		// Trying to write readonly data
		return(FALSE);
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
     1d4:	88 23       	and	r24, r24
     1d6:	01 f0       	breq	.+0      	; 0x1d8 <_ioFlushSector+0x54>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	90 e0       	ldi	r25, 0x00	; 0
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     1dc:	fc 01       	movw	r30, r24
     1de:	ee 0f       	add	r30, r30
     1e0:	ff 1f       	adc	r31, r31
     1e2:	e8 0f       	add	r30, r24
     1e4:	f9 1f       	adc	r31, r25
     1e6:	ee 0f       	add	r30, r30
     1e8:	ff 1f       	adc	r31, r31
     1ea:	32 96       	adiw	r30, 0x02	; 2
     1ec:	ec 0f       	add	r30, r28
     1ee:	fd 1f       	adc	r31, r29
		// Write error
		return(FALSE);
	}

	// If its no longer used then no need to write it later
	if(_bufferGetUsageCount(buffer) == 0){
     1f0:	84 81       	ldd	r24, Z+4	; 0x04
     1f2:	88 23       	and	r24, r24
     1f4:	01 f4       	brne	.+0      	; 0x1f6 <_ioFlushSector+0x72>
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
}
static void _bufferSetNotWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 0;
     1f6:	85 81       	ldd	r24, Z+5	; 0x05
     1f8:	8d 7f       	andi	r24, 0xFD	; 253
     1fa:	85 83       	std	Z+5, r24	; 0x05
     1fc:	00 c0       	rjmp	.+0      	; 0x1fe <_ioFlushSector+0x7a>
	}

	// Write the sector to the physical device
	if(!(_ioWriteSector(disc,_bufferCurrentStackEntry(buffer)->sector,buffer->dta))){
		// Write error
		return(FALSE);
     1fe:	80 e0       	ldi	r24, 0x00	; 0
     200:	00 c0       	rjmp	.+0      	; 0x202 <_ioFlushSector+0x7e>
	}

	// If its no longer used then no need to write it later
	if(_bufferGetUsageCount(buffer) == 0){
     202:	8f ef       	ldi	r24, 0xFF	; 255
		_bufferSetNotWritable(buffer);
	}
	return(TRUE);
}
     204:	df 91       	pop	r29
     206:	cf 91       	pop	r28
     208:	1f 91       	pop	r17
     20a:	0f 91       	pop	r16
     20c:	08 95       	ret

0000020e <_ioPutSectorInCache>:

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){
     20e:	cf 92       	push	r12
     210:	df 92       	push	r13
     212:	ef 92       	push	r14
     214:	ff 92       	push	r15
     216:	0f 93       	push	r16
     218:	1f 93       	push	r17
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	dc 01       	movw	r26, r24
     220:	eb 01       	movw	r28, r22
     222:	69 01       	movw	r12, r18
     224:	7a 01       	movw	r14, r20
		rprintf("[r%lu]",absSector);
		rprintfInit(old);}
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);
     226:	ed 91       	ld	r30, X+
     228:	fc 91       	ld	r31, X
     22a:	11 97       	sbiw	r26, 0x01	; 1
     22c:	05 91       	lpm	r16, Z+
     22e:	14 91       	lpm	r17, Z
}

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
     230:	9b 01       	movw	r18, r22
     232:	26 5e       	subi	r18, 0xE6	; 230
     234:	3f 4f       	sbci	r19, 0xFF	; 255
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);

	return read(disc->device,absSector,dta);
     236:	12 96       	adiw	r26, 0x02	; 2
     238:	8d 91       	ld	r24, X+
     23a:	9c 91       	ld	r25, X
     23c:	13 97       	sbiw	r26, 0x03	; 3
     23e:	b7 01       	movw	r22, r14
     240:	a6 01       	movw	r20, r12
     242:	f8 01       	movw	r30, r16
     244:	09 95       	icall
}

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
     246:	88 23       	and	r24, r24
     248:	01 f0       	breq	.+0      	; 0x24a <_ioPutSectorInCache+0x3c>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     24a:	89 81       	ldd	r24, Y+1	; 0x01
     24c:	90 e0       	ldi	r25, 0x00	; 0
}

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
     24e:	fc 01       	movw	r30, r24
     250:	ee 0f       	add	r30, r30
     252:	ff 1f       	adc	r31, r31
     254:	e8 0f       	add	r30, r24
     256:	f9 1f       	adc	r31, r25
     258:	ee 0f       	add	r30, r30
     25a:	ff 1f       	adc	r31, r31
     25c:	32 96       	adiw	r30, 0x02	; 2
     25e:	ec 0f       	add	r30, r28
     260:	fd 1f       	adc	r31, r29
     262:	85 81       	ldd	r24, Z+5	; 0x05
     264:	81 60       	ori	r24, 0x01	; 1
     266:	85 83       	std	Z+5, r24	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     268:	89 81       	ldd	r24, Y+1	; 0x01
     26a:	90 e0       	ldi	r25, 0x00	; 0

	// Indicate the buffer is 'in-use'
	_bufferSetValid(buffer);

	// And remember its sector address
	_bufferCurrentStackEntry(buffer)->sector = absSector;
     26c:	fc 01       	movw	r30, r24
     26e:	ee 0f       	add	r30, r30
     270:	ff 1f       	adc	r31, r31
     272:	e8 0f       	add	r30, r24
     274:	f9 1f       	adc	r31, r25
     276:	ee 0f       	add	r30, r30
     278:	ff 1f       	adc	r31, r31
     27a:	ec 0f       	add	r30, r28
     27c:	fd 1f       	adc	r31, r29
     27e:	c2 82       	std	Z+2, r12	; 0x02
     280:	d3 82       	std	Z+3, r13	; 0x03
     282:	e4 82       	std	Z+4, r14	; 0x04
     284:	f5 82       	std	Z+5, r15	; 0x05
     286:	8f ef       	ldi	r24, 0xFF	; 255
     288:	00 c0       	rjmp	.+0      	; 0x28a <_ioPutSectorInCache+0x7c>

static boolean _ioPutSectorInCache(const DISK* disc, BUFFER* buffer, SECTOR absSector){

	// Read the data from the physical device
	if(!(_ioReadSector(disc,absSector,buffer->dta))){
		return(FALSE);
     28a:	80 e0       	ldi	r24, 0x00	; 0

	// And remember its sector address
	_bufferCurrentStackEntry(buffer)->sector = absSector;

	return(TRUE);
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	1f 91       	pop	r17
     292:	0f 91       	pop	r16
     294:	ff 90       	pop	r15
     296:	ef 90       	pop	r14
     298:	df 90       	pop	r13
     29a:	cf 90       	pop	r12
     29c:	08 95       	ret

0000029e <_ioGetSector>:
// and return its address.
// Each call should have its own matching releaseSector command
// disc 		- The disc
// absSector	- The absolute sector on the entire disc
// mode			- The mode in which the sector will be used
static void* _ioGetSector(const DISK* disc,SECTOR absSector, uint8_t mode){
     29e:	2f 92       	push	r2
     2a0:	3f 92       	push	r3
     2a2:	4f 92       	push	r4
     2a4:	5f 92       	push	r5
     2a6:	6f 92       	push	r6
     2a8:	7f 92       	push	r7
     2aa:	8f 92       	push	r8
     2ac:	9f 92       	push	r9
     2ae:	af 92       	push	r10
     2b0:	bf 92       	push	r11
     2b2:	cf 92       	push	r12
     2b4:	df 92       	push	r13
     2b6:	ef 92       	push	r14
     2b8:	ff 92       	push	r15
     2ba:	0f 93       	push	r16
     2bc:	1f 93       	push	r17
     2be:	cf 93       	push	r28
     2c0:	df 93       	push	r29
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ioGetSector+0x26>
     2c4:	0f 92       	push	r0
     2c6:	cd b7       	in	r28, 0x3d	; 61
     2c8:	de b7       	in	r29, 0x3e	; 62
     2ca:	4c 01       	movw	r8, r24
     2cc:	2a 01       	movw	r4, r20
     2ce:	3b 01       	movw	r6, r22
     2d0:	29 83       	std	Y+1, r18	; 0x01
	BUFFER* buffer;

	// Find the buffer containing the sector
	buffer = _ioFindSectorInCache(disc,absSector);
     2d2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     2d6:	9b 83       	std	Y+3, r25	; 0x03
     2d8:	8a 83       	std	Y+2, r24	; 0x02

	if(buffer){
     2da:	00 97       	sbiw	r24, 0x00	; 0
     2dc:	01 f0       	breq	.+0      	; 0x2de <_ioGetSector+0x40>
     2de:	00 c0       	rjmp	.+0      	; 0x2e0 <_ioGetSector+0x42>
		// Its already in memory
		goto inRAM;
	}

	// Find an unused buffer or flush the most recently used
	buffer = _bufferFindUnused(disc);
     2e0:	c4 01       	movw	r24, r8
     2e2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     2e6:	9b 83       	std	Y+3, r25	; 0x03
     2e8:	8a 83       	std	Y+2, r24	; 0x02
	if(!buffer){
     2ea:	00 97       	sbiw	r24, 0x00	; 0
     2ec:	01 f0       	breq	.+0      	; 0x2ee <_ioGetSector+0x50>
     2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <_ioGetSector+0x52>
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     2f0:	f4 01       	movw	r30, r8
     2f2:	a4 a8       	ldd	r10, Z+52	; 0x34
     2f4:	b5 a8       	ldd	r11, Z+53	; 0x35
     2f6:	15 01       	movw	r2, r10
}


// Find the least recently used buffer - giving preference to any read only entries
static BUFFER* _ioFindLeastRecentlyUsedBuffer(const DISK* disc){
	BUFFER* rtn=null;
     2f8:	ff 24       	eor	r15, r15
     2fa:	ee 24       	eor	r14, r14
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     2fc:	dd 24       	eor	r13, r13

// Find the least recently used buffer - giving preference to any read only entries
static BUFFER* _ioFindLeastRecentlyUsedBuffer(const DISK* disc){
	BUFFER* rtn=null;
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
     2fe:	0f ef       	ldi	r16, 0xFF	; 255


// Find the least recently used buffer - giving preference to any read only entries
static BUFFER* _ioFindLeastRecentlyUsedBuffer(const DISK* disc){
	BUFFER* rtn=null;
	boolean foundAReadOnly=FALSE;
     300:	10 e0       	ldi	r17, 0x00	; 0
     302:	00 c0       	rjmp	.+0      	; 0x304 <_ioGetSector+0x66>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     304:	f1 01       	movw	r30, r2
     306:	81 81       	ldd	r24, Z+1	; 0x01
     308:	90 e0       	ldi	r25, 0x00	; 0
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     30a:	fc 01       	movw	r30, r24
     30c:	ee 0f       	add	r30, r30
     30e:	ff 1f       	adc	r31, r31
     310:	e8 0f       	add	r30, r24
     312:	f9 1f       	adc	r31, r25
     314:	ee 0f       	add	r30, r30
     316:	ff 1f       	adc	r31, r31
     318:	e2 0d       	add	r30, r2
     31a:	f3 1d       	adc	r31, r3
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
		if(_bufferGetUsageCount(buffer)==0){
     31c:	86 81       	ldd	r24, Z+6	; 0x06
     31e:	88 23       	and	r24, r24
     320:	01 f4       	brne	.+0      	; 0x322 <_ioGetSector+0x84>
			// Nothing uses the data in this buffer

			if(!_bufferIsWritable(buffer)){
     322:	c1 01       	movw	r24, r2
     324:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     328:	88 23       	and	r24, r24
     32a:	01 f4       	brne	.+0      	; 0x32c <_ioGetSector+0x8e>
				// This is a readonly buffer
				if(!foundAReadOnly || _bufferGetReferenceCount(buffer)<=refCount ){
     32c:	11 23       	and	r17, r17
     32e:	01 f0       	breq	.+0      	; 0x330 <_ioGetSector+0x92>
     330:	f1 01       	movw	r30, r2
     332:	80 81       	ld	r24, Z
     334:	08 17       	cp	r16, r24
     336:	00 f0       	brcs	.+0      	; 0x338 <_ioGetSector+0x9a>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     338:	f1 01       	movw	r30, r2
     33a:	00 81       	ld	r16, Z
			if(!_bufferIsWritable(buffer)){
				// This is a readonly buffer
				if(!foundAReadOnly || _bufferGetReferenceCount(buffer)<=refCount ){
					// This is the best so far
					foundAReadOnly=TRUE;
					rtn=buffer;
     33c:	f2 2c       	mov	r15, r2
     33e:	e3 2c       	mov	r14, r3
     340:	00 c0       	rjmp	.+0      	; 0x342 <_ioGetSector+0xa4>
					refCount=_bufferGetReferenceCount(buffer);
				}
			}else{
				// This is a writable buffer
				if(!foundAReadOnly && _bufferGetReferenceCount(buffer)<=refCount){
     342:	11 23       	and	r17, r17
     344:	01 f4       	brne	.+0      	; 0x346 <_ioGetSector+0xa8>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     346:	f1 01       	movw	r30, r2
     348:	80 81       	ld	r24, Z
					rtn=buffer;
					refCount=_bufferGetReferenceCount(buffer);
				}
			}else{
				// This is a writable buffer
				if(!foundAReadOnly && _bufferGetReferenceCount(buffer)<=refCount){
     34a:	08 17       	cp	r16, r24
     34c:	00 f0       	brcs	.+0      	; 0x34e <_ioGetSector+0xb0>
     34e:	08 2f       	mov	r16, r24
					// This is the best writable buffer
					rtn=buffer;
     350:	f2 2c       	mov	r15, r2
     352:	e3 2c       	mov	r14, r3
     354:	00 c0       	rjmp	.+0      	; 0x356 <_ioGetSector+0xb8>
					rtn=buffer;
					refCount=_bufferGetReferenceCount(buffer);
				}
			}else{
				// This is a writable buffer
				if(!foundAReadOnly && _bufferGetReferenceCount(buffer)<=refCount){
     356:	1f ef       	ldi	r17, 0xFF	; 255
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     358:	d3 94       	inc	r13
     35a:	8a e1       	ldi	r24, 0x1A	; 26
     35c:	92 e0       	ldi	r25, 0x02	; 2
     35e:	28 0e       	add	r2, r24
     360:	39 1e       	adc	r3, r25
     362:	f4 01       	movw	r30, r8
     364:	c3 a8       	ldd	r12, Z+51	; 0x33
     366:	dc 14       	cp	r13, r12
     368:	00 f0       	brcs	.+0      	; 0x36a <_ioGetSector+0xcc>
     36a:	fa 82       	std	Y+2, r15	; 0x02
     36c:	eb 82       	std	Y+3, r14	; 0x03
		// All buffers are in use

		// Find the least recently used buffer which has no references to it
		buffer = _ioFindLeastRecentlyUsedBuffer(disc);

		if(buffer && _bufferIsWritable(buffer)){
     36e:	8a 81       	ldd	r24, Y+2	; 0x02
     370:	9b 81       	ldd	r25, Y+3	; 0x03
     372:	00 97       	sbiw	r24, 0x00	; 0
     374:	01 f0       	breq	.+0      	; 0x376 <_ioGetSector+0xd8>
     376:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     37a:	88 23       	and	r24, r24
     37c:	01 f0       	breq	.+0      	; 0x37e <_ioGetSector+0xe0>
			// Write it to the physical device
			_ioFlushSector(disc,buffer);
     37e:	c4 01       	movw	r24, r8
     380:	6a 81       	ldd	r22, Y+2	; 0x02
     382:	7b 81       	ldd	r23, Y+3	; 0x03
     384:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	boolean foundAReadOnly=FALSE;
	uint8_t refCount=MAX_U08;
	BUFFER* buffer;
	uint8_t bufferNum;

	for(bufferNum=0, buffer=disc->buffers;bufferNum<disc->numbuf;bufferNum++,buffer++){
     388:	fa 82       	std	Y+2, r15	; 0x02
     38a:	eb 82       	std	Y+3, r14	; 0x03
		}
	}

	if(buffer){
		// Mark buffer as unused
		_bufferReset(buffer);
     38c:	8a 81       	ldd	r24, Y+2	; 0x02
     38e:	9b 81       	ldd	r25, Y+3	; 0x03
     390:	00 c0       	rjmp	.+0      	; 0x392 <_ioGetSector+0xf4>
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     392:	f5 01       	movw	r30, r10
     394:	01 81       	ldd	r16, Z+1	; 0x01
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		uint8_t stackDepth = _bufferGetStackDepth(buffer);
		if( stackDepth < MAX_STACK_DEPTH){
     396:	04 30       	cpi	r16, 0x04	; 4
     398:	00 f4       	brcc	.+0      	; 0x39a <_ioGetSector+0xfc>
			// Calc the score for this buffer
			uint8_t points = 0;

			// Give it a 50% score if writable so that read only
			// buffers will always be selected in preference
			if(_bufferIsWritable(buffer)){
     39a:	c5 01       	movw	r24, r10
     39c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     3a0:	88 23       	and	r24, r24
     3a2:	01 f4       	brne	.+0      	; 0x3a4 <_ioGetSector+0x106>

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
		uint8_t stackDepth = _bufferGetStackDepth(buffer);
		if( stackDepth < MAX_STACK_DEPTH){
			// Calc the score for this buffer
			uint8_t points = 0;
     3a4:	20 e0       	ldi	r18, 0x00	; 0
     3a6:	00 c0       	rjmp	.+0      	; 0x3a8 <_ioGetSector+0x10a>

			// Give it a 50% score if writable so that read only
			// buffers will always be selected in preference
			if(_bufferIsWritable(buffer)){
				points+=0x7F;
     3a8:	2f e7       	ldi	r18, 0x7F	; 127
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
	memclr(nav,sizeof(CLUSTER_NAV));
	nav->startCluster = nav->currentCluster=cluster_addr;
}
     3aa:	f5 01       	movw	r30, r10
     3ac:	80 81       	ld	r24, Z
			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     3ae:	8e 9d       	mul	r24, r14
     3b0:	c0 01       	movw	r24, r0
     3b2:	11 24       	eor	r1, r1
     3b4:	b1 01       	movw	r22, r2
     3b6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				points+=0x7F;
			}

			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);
     3ba:	0d 9d       	mul	r16, r13
     3bc:	c0 01       	movw	r24, r0
     3be:	11 24       	eor	r1, r1
     3c0:	96 95       	lsr	r25
     3c2:	87 95       	ror	r24
     3c4:	96 95       	lsr	r25
     3c6:	87 95       	ror	r24
     3c8:	86 0f       	add	r24, r22

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     3ca:	82 0f       	add	r24, r18

			// Keep the smallest score
			if(points<leastPoint){
     3cc:	8f 15       	cp	r24, r15
     3ce:	00 f4       	brcc	.+0      	; 0x3d0 <_ioGetSector+0x132>
				leastPoint=points;
				rtn=buffer;
     3d0:	bb 82       	std	Y+3, r11	; 0x03
     3d2:	aa 82       	std	Y+2, r10	; 0x02

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;

			// Keep the smallest score
			if(points<leastPoint){
     3d4:	f8 2e       	mov	r15, r24
	uint8_t leastPoint=MAX_U08;
	uint8_t bufferNum;
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
     3d6:	1f 5f       	subi	r17, 0xFF	; 255
     3d8:	8a e1       	ldi	r24, 0x1A	; 26
     3da:	92 e0       	ldi	r25, 0x02	; 2
     3dc:	a8 0e       	add	r10, r24
     3de:	b9 1e       	adc	r11, r25
     3e0:	00 c0       	rjmp	.+0      	; 0x3e2 <_ioGetSector+0x144>
     3e2:	10 e0       	ldi	r17, 0x00	; 0
	}
	return(rtn);
}

static BUFFER* _ioFindStackableBuffer(const DISK* disc){
	uint8_t leastPoint=MAX_U08;
     3e4:	ff 24       	eor	r15, r15
     3e6:	fa 94       	dec	r15
			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);

			// Give it 0% to 20% depending on how many time it has been read from
			points += ((uint16_t)(_bufferGetReferenceCount(buffer)*0x33))/0xFF;
     3e8:	83 e3       	ldi	r24, 0x33	; 51
     3ea:	e8 2e       	mov	r14, r24
     3ec:	9f ef       	ldi	r25, 0xFF	; 255
     3ee:	29 2e       	mov	r2, r25
     3f0:	31 2c       	mov	r3, r1
				points+=0x7F;
			}

			// Give it 0% to 30% depending on how many stack entries there are
			// This will cause 'stack full' entries to get a worse score than others
			points += ((uint16_t)(stackDepth*0x4D))/(MAX_STACK_DEPTH);
     3f2:	2d e4       	ldi	r18, 0x4D	; 77
     3f4:	d2 2e       	mov	r13, r18
	uint8_t leastPoint=MAX_U08;
	uint8_t bufferNum;
	BUFFER* rtn=null;
	BUFFER* buffer;

	for(bufferNum=0,buffer=disc->buffers; bufferNum<disc->numbuf; bufferNum++,buffer++){
     3f6:	1c 15       	cp	r17, r12
     3f8:	00 f0       	brcs	.+0      	; 0x3fa <_ioGetSector+0x15c>
		goto readIt;
	}

	// All buffers are currently used and referenced by code
	buffer=_ioFindStackableBuffer(disc);
	if(buffer){
     3fa:	ea 81       	ldd	r30, Y+2	; 0x02
     3fc:	fb 81       	ldd	r31, Y+3	; 0x03
     3fe:	30 97       	sbiw	r30, 0x00	; 0
     400:	01 f4       	brne	.+0      	; 0x402 <_ioGetSector+0x164>
     402:	00 c0       	rjmp	.+0      	; 0x404 <_ioGetSector+0x166>
		if(_bufferIsWritable(buffer)){
     404:	cf 01       	movw	r24, r30
     406:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     40a:	88 23       	and	r24, r24
     40c:	01 f0       	breq	.+0      	; 0x40e <_ioGetSector+0x170>
			_ioFlushSector(disc,buffer);
     40e:	c4 01       	movw	r24, r8
     410:	6a 81       	ldd	r22, Y+2	; 0x02
     412:	7b 81       	ldd	r23, Y+3	; 0x03
     414:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	memclr(current,sizeof(SECTOR_BUFFER));
	buffer->reference = 0;
}

static boolean _bufferPush(BUFFER* buffer){
	if(buffer->depth >= MAX_STACK_DEPTH){
     418:	ea 81       	ldd	r30, Y+2	; 0x02
     41a:	fb 81       	ldd	r31, Y+3	; 0x03
     41c:	81 81       	ldd	r24, Z+1	; 0x01
     41e:	84 30       	cpi	r24, 0x04	; 4
     420:	00 f0       	brcs	.+0      	; 0x422 <_ioGetSector+0x184>
     422:	00 c0       	rjmp	.+0      	; 0x424 <_ioGetSector+0x186>
		// The iteration number is invalid
		return(FALSE);
	}

	// Increment the stack position and reset the current data
	buffer->depth++;
     424:	8f 5f       	subi	r24, 0xFF	; 255
     426:	81 83       	std	Z+1, r24	; 0x01
	_bufferReset(buffer);
     428:	cf 01       	movw	r24, r30
     42a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		if(!_bufferPush(buffer)){
			return null;
		}
readIt:
		// Read from physical device into buffer
		if(! _ioPutSectorInCache(disc, buffer,absSector) ){
     42e:	c4 01       	movw	r24, r8
     430:	6a 81       	ldd	r22, Y+2	; 0x02
     432:	7b 81       	ldd	r23, Y+3	; 0x03
     434:	a3 01       	movw	r20, r6
     436:	92 01       	movw	r18, r4
     438:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     43c:	88 23       	and	r24, r24
     43e:	01 f0       	breq	.+0      	; 0x440 <_ioGetSector+0x1a2>
			return null;
		}
inRAM:
		// Mark as writable if required
		if(iomgr_isReqRw(mode)){
     440:	f9 81       	ldd	r31, Y+1	; 0x01
     442:	f1 ff       	sbrs	r31, 1
     444:	00 c0       	rjmp	.+0      	; 0x446 <_ioGetSector+0x1a8>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     446:	ea 81       	ldd	r30, Y+2	; 0x02
     448:	fb 81       	ldd	r31, Y+3	; 0x03
     44a:	81 81       	ldd	r24, Z+1	; 0x01
     44c:	90 e0       	ldi	r25, 0x00	; 0
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
     44e:	fc 01       	movw	r30, r24
     450:	ee 0f       	add	r30, r30
     452:	ff 1f       	adc	r31, r31
     454:	e8 0f       	add	r30, r24
     456:	f9 1f       	adc	r31, r25
     458:	ee 0f       	add	r30, r30
     45a:	ff 1f       	adc	r31, r31
     45c:	32 96       	adiw	r30, 0x02	; 2
     45e:	8a 81       	ldd	r24, Y+2	; 0x02
     460:	9b 81       	ldd	r25, Y+3	; 0x03
     462:	e8 0f       	add	r30, r24
     464:	f9 1f       	adc	r31, r25
     466:	85 81       	ldd	r24, Z+5	; 0x05
     468:	82 60       	ori	r24, 0x02	; 2
     46a:	85 83       	std	Z+5, r24	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     46c:	ea 81       	ldd	r30, Y+2	; 0x02
     46e:	fb 81       	ldd	r31, Y+3	; 0x03
     470:	81 81       	ldd	r24, Z+1	; 0x01
     472:	90 e0       	ldi	r25, 0x00	; 0
		if(iomgr_isReqRw(mode)){
			_bufferSetWritable(buffer);
		}

		// Increment usage count
		SECTOR_BUFFER* sb = _bufferCurrentStackEntry(buffer);
     474:	fc 01       	movw	r30, r24
     476:	ee 0f       	add	r30, r30
     478:	ff 1f       	adc	r31, r31
     47a:	e8 0f       	add	r30, r24
     47c:	f9 1f       	adc	r31, r25
     47e:	ee 0f       	add	r30, r30
     480:	ff 1f       	adc	r31, r31
     482:	32 96       	adiw	r30, 0x02	; 2
     484:	8a 81       	ldd	r24, Y+2	; 0x02
     486:	9b 81       	ldd	r25, Y+3	; 0x03
     488:	e8 0f       	add	r30, r24
     48a:	f9 1f       	adc	r31, r25
		if(++(sb->usage) == 0){
     48c:	84 81       	ldd	r24, Z+4	; 0x04
     48e:	98 2f       	mov	r25, r24
     490:	9f 5f       	subi	r25, 0xFF	; 255
     492:	94 83       	std	Z+4, r25	; 0x04
     494:	99 23       	and	r25, r25
     496:	01 f4       	brne	.+0      	; 0x498 <_ioGetSector+0x1fa>
			(sb->usage)--;
     498:	84 83       	std	Z+4, r24	; 0x04
		}


		// increment ref count
		if(++(buffer->reference) == 0){
     49a:	ea 81       	ldd	r30, Y+2	; 0x02
     49c:	fb 81       	ldd	r31, Y+3	; 0x03
     49e:	80 81       	ld	r24, Z
     4a0:	98 2f       	mov	r25, r24
     4a2:	9f 5f       	subi	r25, 0xFF	; 255
     4a4:	90 83       	st	Z, r25
     4a6:	99 23       	and	r25, r25
     4a8:	01 f4       	brne	.+0      	; 0x4aa <_ioGetSector+0x20c>
			(buffer->reference)--;
     4aa:	80 83       	st	Z, r24
		}


		// Return address of sector in RAM
		return(buffer->dta);
     4ac:	8a 81       	ldd	r24, Y+2	; 0x02
     4ae:	9b 81       	ldd	r25, Y+3	; 0x03
     4b0:	4a 96       	adiw	r24, 0x1a	; 26
     4b2:	00 c0       	rjmp	.+0      	; 0x4b4 <_ioGetSector+0x216>
			return null;
		}
readIt:
		// Read from physical device into buffer
		if(! _ioPutSectorInCache(disc, buffer,absSector) ){
			return null;
     4b4:	80 e0       	ldi	r24, 0x00	; 0
     4b6:	90 e0       	ldi	r25, 0x00	; 0
		return(buffer->dta);
	}

	// No memory available
	return null;
}
     4b8:	0f 90       	pop	r0
     4ba:	0f 90       	pop	r0
     4bc:	0f 90       	pop	r0
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	1f 91       	pop	r17
     4c4:	0f 91       	pop	r16
     4c6:	ff 90       	pop	r15
     4c8:	ef 90       	pop	r14
     4ca:	df 90       	pop	r13
     4cc:	cf 90       	pop	r12
     4ce:	bf 90       	pop	r11
     4d0:	af 90       	pop	r10
     4d2:	9f 90       	pop	r9
     4d4:	8f 90       	pop	r8
     4d6:	7f 90       	pop	r7
     4d8:	6f 90       	pop	r6
     4da:	5f 90       	pop	r5
     4dc:	4f 90       	pop	r4
     4de:	3f 90       	pop	r3
     4e0:	2f 90       	pop	r2
     4e2:	08 95       	ret

000004e4 <_fileValidateChar.part.6>:
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
		return (c-'a'+'A');

    if(c=='-' || c=='_' || c=='~' || (c>='0' && c<='9') || (c>='A' && c<='Z')){
     4e4:	8d 32       	cpi	r24, 0x2D	; 45
     4e6:	01 f0       	breq	.+0      	; 0x4e8 <_fileValidateChar.part.6+0x4>
     4e8:	8f 35       	cpi	r24, 0x5F	; 95
     4ea:	01 f0       	breq	.+0      	; 0x4ec <_fileValidateChar.part.6+0x8>
     4ec:	8e 37       	cpi	r24, 0x7E	; 126
     4ee:	01 f0       	breq	.+0      	; 0x4f0 <_fileValidateChar.part.6+0xc>
     4f0:	98 2f       	mov	r25, r24
     4f2:	90 53       	subi	r25, 0x30	; 48
     4f4:	9a 30       	cpi	r25, 0x0A	; 10
     4f6:	00 f0       	brcs	.+0      	; 0x4f8 <_fileValidateChar.part.6+0x14>
     4f8:	91 51       	subi	r25, 0x11	; 17
     4fa:	9a 31       	cpi	r25, 0x1A	; 26
     4fc:	00 f0       	brcs	.+0      	; 0x4fe <_fileValidateChar.part.6+0x1a>
    	return c;
    }

	return('_');
     4fe:	8f e5       	ldi	r24, 0x5F	; 95
}
     500:	08 95       	ret

00000502 <_fileUserToFatName>:

// Convert a filename into how it would appear on disk
// Returns the string following the filenane
static const char* _fileUserToFatName(const char* filename,char* fatfilename){
     502:	af 92       	push	r10
     504:	bf 92       	push	r11
     506:	cf 92       	push	r12
     508:	df 92       	push	r13
     50a:	ef 92       	push	r14
     50c:	ff 92       	push	r15
     50e:	0f 93       	push	r16
     510:	1f 93       	push	r17
     512:	cf 93       	push	r28
     514:	df 93       	push	r29
     516:	0f 92       	push	r0
     518:	cd b7       	in	r28, 0x3d	; 61
     51a:	de b7       	in	r29, 0x3e	; 62
     51c:	7c 01       	movw	r14, r24
     51e:	8b 01       	movw	r16, r22
	boolean inXtn=FALSE; // are we doing the file extension
	boolean valid=FALSE; // is the file valid

	// Zap the filename
	memset(fatfilename,' ',11);
     520:	cb 01       	movw	r24, r22
     522:	60 e2       	ldi	r22, 0x20	; 32
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	4b e0       	ldi	r20, 0x0B	; 11
     528:	50 e0       	ldi	r21, 0x00	; 0
     52a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

	uint8_t c=0;		// offset to write into the filename

	if(*filename == '.'){
     52e:	f7 01       	movw	r30, r14
     530:	80 81       	ld	r24, Z
     532:	8e 32       	cpi	r24, 0x2E	; 46
     534:	01 f0       	breq	.+0      	; 0x536 <_fileUserToFatName+0x34>
     536:	dd 24       	eor	r13, r13
     538:	cc 24       	eor	r12, r12
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	00 c0       	rjmp	.+0      	; 0x53e <_fileUserToFatName+0x3c>
		// Check for '.' or '..'
		fatfilename[0]='.';
     53e:	f8 01       	movw	r30, r16
     540:	80 83       	st	Z, r24
		valid=TRUE;
		if(*(filename+1) == '.'){
     542:	f7 01       	movw	r30, r14
     544:	81 81       	ldd	r24, Z+1	; 0x01
     546:	8e 32       	cpi	r24, 0x2E	; 46
     548:	01 f4       	brne	.+0      	; 0x54a <_fileUserToFatName+0x48>
			fatfilename[1]='.';
     54a:	f8 01       	movw	r30, r16
     54c:	81 83       	std	Z+1, r24	; 0x01
			filename+=2;
     54e:	d7 01       	movw	r26, r14
     550:	12 96       	adiw	r26, 0x02	; 2
     552:	00 c0       	rjmp	.+0      	; 0x554 <_fileUserToFatName+0x52>
		}else{
			filename++;
     554:	d7 01       	movw	r26, r14
     556:	11 96       	adiw	r26, 0x01	; 1
     558:	00 c0       	rjmp	.+0      	; 0x55a <_fileUserToFatName+0x58>
		}
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
			if(*filename=='.' && !inXtn){
     55a:	8e 32       	cpi	r24, 0x2E	; 46
     55c:	01 f4       	brne	.+0      	; 0x55e <_fileUserToFatName+0x5c>
     55e:	99 23       	and	r25, r25
     560:	01 f0       	breq	.+0      	; 0x562 <_fileUserToFatName+0x60>
     562:	00 c0       	rjmp	.+0      	; 0x564 <_fileUserToFatName+0x62>
				// If we've found the first dot then move to extension
				inXtn=TRUE;
				c=8;
			}else{
				if(inXtn){
     564:	99 23       	and	r25, r25
     566:	01 f0       	breq	.+0      	; 0x568 <_fileUserToFatName+0x66>
					if(c<=10){
     568:	fa e0       	ldi	r31, 0x0A	; 10
     56a:	fd 15       	cp	r31, r13
     56c:	00 f0       	brcs	.+0      	; 0x56e <_fileUserToFatName+0x6c>
						fatfilename[c]=_fileValidateChar(*filename);
     56e:	58 01       	movw	r10, r16
     570:	ad 0c       	add	r10, r13
     572:	b1 1c       	adc	r11, r1

// Convert a character into a valid uppercase character for a filename
// Invalid characters are changed to an '_'
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
     574:	98 2f       	mov	r25, r24
     576:	91 56       	subi	r25, 0x61	; 97
     578:	9a 31       	cpi	r25, 0x1A	; 26
     57a:	00 f4       	brcc	.+0      	; 0x57c <_fileUserToFatName+0x7a>
		return (c-'a'+'A');
     57c:	80 52       	subi	r24, 0x20	; 32
     57e:	00 c0       	rjmp	.+0      	; 0x580 <_fileUserToFatName+0x7e>
     580:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				inXtn=TRUE;
				c=8;
			}else{
				if(inXtn){
					if(c<=10){
						fatfilename[c]=_fileValidateChar(*filename);
     584:	f5 01       	movw	r30, r10
     586:	80 83       	st	Z, r24
						c++;
     588:	d3 94       	inc	r13
     58a:	00 c0       	rjmp	.+0      	; 0x58c <_fileUserToFatName+0x8a>
					}
				}else{
					if(c<=7){
     58c:	f7 e0       	ldi	r31, 0x07	; 7
     58e:	fd 15       	cp	r31, r13
     590:	00 f0       	brcs	.+0      	; 0x592 <_fileUserToFatName+0x90>
						fatfilename[c]=_fileValidateChar(*filename);
     592:	58 01       	movw	r10, r16
     594:	ad 0c       	add	r10, r13
     596:	b1 1c       	adc	r11, r1

// Convert a character into a valid uppercase character for a filename
// Invalid characters are changed to an '_'
static char _fileValidateChar(char c){
    // Convert to uppercase
    if( c>='a' && c<='z' )
     598:	28 2f       	mov	r18, r24
     59a:	21 56       	subi	r18, 0x61	; 97
     59c:	2a 31       	cpi	r18, 0x1A	; 26
     59e:	00 f4       	brcc	.+0      	; 0x5a0 <_fileUserToFatName+0x9e>
		return (c-'a'+'A');
     5a0:	80 52       	subi	r24, 0x20	; 32
     5a2:	00 c0       	rjmp	.+0      	; 0x5a4 <_fileUserToFatName+0xa2>
     5a4:	99 83       	std	Y+1, r25	; 0x01
     5a6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     5aa:	99 81       	ldd	r25, Y+1	; 0x01
						fatfilename[c]=_fileValidateChar(*filename);
						c++;
					}
				}else{
					if(c<=7){
						fatfilename[c]=_fileValidateChar(*filename);
     5ac:	f5 01       	movw	r30, r10
     5ae:	80 83       	st	Z, r24
						c++;
     5b0:	d3 94       	inc	r13
						valid=TRUE;
     5b2:	cc 24       	eor	r12, r12
     5b4:	ca 94       	dec	r12
     5b6:	00 c0       	rjmp	.+0      	; 0x5b8 <_fileUserToFatName+0xb6>
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
			if(*filename=='.' && !inXtn){
				// If we've found the first dot then move to extension
				inXtn=TRUE;
				c=8;
     5b8:	68 e0       	ldi	r22, 0x08	; 8
     5ba:	d6 2e       	mov	r13, r22
			}else{
				if(inXtn){
					if(c<=10){
     5bc:	9f ef       	ldi	r25, 0xFF	; 255
						c++;
					}
				}else{
					if(c<=7){
						fatfilename[c]=_fileValidateChar(*filename);
						c++;
     5be:	d7 01       	movw	r26, r14
			filename+=2;
		}else{
			filename++;
		}
	}else{
		while(*filename && *filename != ' ' && *filename != '/'){
     5c0:	f7 01       	movw	r30, r14
     5c2:	81 91       	ld	r24, Z+
     5c4:	7f 01       	movw	r14, r30
     5c6:	88 23       	and	r24, r24
     5c8:	01 f0       	breq	.+0      	; 0x5ca <_fileUserToFatName+0xc8>
     5ca:	80 32       	cpi	r24, 0x20	; 32
     5cc:	01 f0       	breq	.+0      	; 0x5ce <_fileUserToFatName+0xcc>
     5ce:	8f 32       	cpi	r24, 0x2F	; 47
     5d0:	01 f4       	brne	.+0      	; 0x5d2 <_fileUserToFatName+0xd0>
			}
			filename++;
		}
	}

	if(valid){
     5d2:	cc 20       	and	r12, r12
     5d4:	01 f0       	breq	.+0      	; 0x5d6 <_fileUserToFatName+0xd4>
		if(*filename=='\0'){
     5d6:	8c 91       	ld	r24, X
     5d8:	88 23       	and	r24, r24
     5da:	01 f0       	breq	.+0      	; 0x5dc <_fileUserToFatName+0xda>
			return(filename);
		}else{
			return(filename+1);
     5dc:	11 96       	adiw	r26, 0x01	; 1
     5de:	00 c0       	rjmp	.+0      	; 0x5e0 <_fileUserToFatName+0xde>
		}
	}else{
		return(0);
     5e0:	a0 e0       	ldi	r26, 0x00	; 0
     5e2:	b0 e0       	ldi	r27, 0x00	; 0
	}
}
     5e4:	cd 01       	movw	r24, r26
     5e6:	0f 90       	pop	r0
     5e8:	df 91       	pop	r29
     5ea:	cf 91       	pop	r28
     5ec:	1f 91       	pop	r17
     5ee:	0f 91       	pop	r16
     5f0:	ff 90       	pop	r15
     5f2:	ef 90       	pop	r14
     5f4:	df 90       	pop	r13
     5f6:	cf 90       	pop	r12
     5f8:	bf 90       	pop	r11
     5fa:	af 90       	pop	r10
     5fc:	08 95       	ret

000005fe <_dirFindInSector>:
	return(0);
}

// This function searches for a given fatfilename in a buffer.
// Return value: Returns 0 on not found, and the firstcluster when the name is found.
static CLUSTER _dirFindInSector(const DIR_ENTRY *fileEntry,const char *fatname, DIR_POSITION *loc, uint8_t mode){
     5fe:	cf 92       	push	r12
     600:	df 92       	push	r13
     602:	ff 92       	push	r15
     604:	0f 93       	push	r16
     606:	1f 93       	push	r17
     608:	cf 93       	push	r28
     60a:	df 93       	push	r29
     60c:	ec 01       	movw	r28, r24
     60e:	6b 01       	movw	r12, r22
     610:	8a 01       	movw	r16, r20
	switch(mode){
     612:	22 23       	and	r18, r18
     614:	01 f0       	breq	.+0      	; 0x616 <_dirFindInSector+0x18>
     616:	21 30       	cpi	r18, 0x01	; 1
     618:	01 f0       	breq	.+0      	; 0x61a <_dirFindInSector+0x1c>
     61a:	00 c0       	rjmp	.+0      	; 0x61c <_dirFindInSector+0x1e>
     61c:	00 c0       	rjmp	.+0      	; 0x61e <_dirFindInSector+0x20>
     61e:	ff 24       	eor	r15, r15
// Return: 0 if not found, else the starting cluster for the file data
static CLUSTER _dirFindFileInSector(const DIR_ENTRY *fileEntry,const  char *fatname, DIR_POSITION *loc){

	for(uint8_t c=0; c<16; c++,fileEntry++){
		/* Check if the entry is for short filenames */
		if( (fileEntry->attribute.bits & 0x0F) != 0x0F ){
     620:	8b 85       	ldd	r24, Y+11	; 0x0b
     622:	8f 70       	andi	r24, 0x0F	; 15
     624:	8f 30       	cpi	r24, 0x0F	; 15
     626:	01 f0       	breq	.+0      	; 0x628 <_dirFindInSector+0x2a>
			if( memcmp((const char*)fileEntry->filename,fatname,sizeof(fileEntry->filename)) == 0 ){
     628:	ce 01       	movw	r24, r28
     62a:	b6 01       	movw	r22, r12
     62c:	4b e0       	ldi	r20, 0x0B	; 11
     62e:	50 e0       	ldi	r21, 0x00	; 0
     630:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     634:	00 97       	sbiw	r24, 0x00	; 0
     636:	01 f4       	brne	.+0      	; 0x638 <_dirFindInSector+0x3a>
				/* The entry has been found, return the location in the dir */
				if(loc){
     638:	01 15       	cp	r16, r1
     63a:	11 05       	cpc	r17, r1
     63c:	01 f0       	breq	.+0      	; 0x63e <_dirFindInSector+0x40>
					loc->entryInSector = c;
     63e:	f8 01       	movw	r30, r16
     640:	f4 82       	std	Z+4, r15	; 0x04
					loc->attrib = fileEntry->attribute;
     642:	8b 85       	ldd	r24, Y+11	; 0x0b
     644:	85 83       	std	Z+5, r24	; 0x05
				}

				CLUSTER firstCluster=(((CLUSTER )fileEntry->firstClusterHigh)<<16)+ fileEntry->firstClusterLow;
     646:	0c 89       	ldd	r16, Y+20	; 0x14
     648:	1d 89       	ldd	r17, Y+21	; 0x15
     64a:	20 e0       	ldi	r18, 0x00	; 0
     64c:	30 e0       	ldi	r19, 0x00	; 0
     64e:	98 01       	movw	r18, r16
     650:	11 27       	eor	r17, r17
     652:	00 27       	eor	r16, r16
     654:	8a 8d       	ldd	r24, Y+26	; 0x1a
     656:	9b 8d       	ldd	r25, Y+27	; 0x1b
     658:	a0 e0       	ldi	r26, 0x00	; 0
     65a:	b0 e0       	ldi	r27, 0x00	; 0
     65c:	08 0f       	add	r16, r24
     65e:	19 1f       	adc	r17, r25
     660:	2a 1f       	adc	r18, r26
     662:	3b 1f       	adc	r19, r27

				if(firstCluster==0){
     664:	01 15       	cp	r16, r1
     666:	11 05       	cpc	r17, r1
     668:	21 05       	cpc	r18, r1
     66a:	31 05       	cpc	r19, r1
     66c:	01 f4       	brne	.+0      	; 0x66e <_dirFindInSector+0x70>
     66e:	00 c0       	rjmp	.+0      	; 0x670 <_dirFindInSector+0x72>

// Attempt to locate a given filename in a director sector
// Return: 0 if not found, else the starting cluster for the file data
static CLUSTER _dirFindFileInSector(const DIR_ENTRY *fileEntry,const  char *fatname, DIR_POSITION *loc){

	for(uint8_t c=0; c<16; c++,fileEntry++){
     670:	f3 94       	inc	r15
     672:	a0 96       	adiw	r28, 0x20	; 32
     674:	f0 e1       	ldi	r31, 0x10	; 16
     676:	ff 16       	cp	r15, r31
     678:	01 f4       	brne	.+0      	; 0x67a <_dirFindInSector+0x7c>
     67a:	00 c0       	rjmp	.+0      	; 0x67c <_dirFindInSector+0x7e>
}

// This function searches for a given fatfilename in a buffer.
// Return value: Returns 0 on not found, and the firstcluster when the name is found.
static CLUSTER _dirFindInSector(const DIR_ENTRY *fileEntry,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	switch(mode){
     67c:	80 e0       	ldi	r24, 0x00	; 0
// This function searches for a free entry in a given directory sector buffer.
// It will put the offset into the loc->Offset field, given that loc is not 0.
// Return value: TRUE when it found a free spot, FALSE if it hasn't.
static uint32_t _dirFindFreeEntryinRAM(const DIR_ENTRY *fileEntry, DIR_POSITION *loc){
	for(uint8_t c=0;c<16;c++,fileEntry++){
		if( (fileEntry->attribute.bits & 0x0F) != 0x0F ){	// If its not a long filename entry
     67e:	9b 85       	ldd	r25, Y+11	; 0x0b
     680:	9f 70       	andi	r25, 0x0F	; 15
     682:	9f 30       	cpi	r25, 0x0F	; 15
     684:	01 f0       	breq	.+0      	; 0x686 <_dirFindInSector+0x88>
			if(fileEntry->filename[0] == 0x00 ||		// And is unused or
     686:	98 81       	ld	r25, Y
     688:	99 23       	and	r25, r25
     68a:	01 f0       	breq	.+0      	; 0x68c <_dirFindInSector+0x8e>
     68c:	95 3e       	cpi	r25, 0xE5	; 229
     68e:	01 f4       	brne	.+0      	; 0x690 <_dirFindInSector+0x92>
			   fileEntry->filename[0] == 0xE5 ){		// The file is deleted
				if(loc){
     690:	01 15       	cp	r16, r1
     692:	11 05       	cpc	r17, r1
     694:	01 f0       	breq	.+0      	; 0x696 <_dirFindInSector+0x98>
					loc->entryInSector=c;
     696:	f8 01       	movw	r30, r16
     698:	84 83       	std	Z+4, r24	; 0x04
     69a:	00 c0       	rjmp	.+0      	; 0x69c <_dirFindInSector+0x9e>

// This function searches for a free entry in a given directory sector buffer.
// It will put the offset into the loc->Offset field, given that loc is not 0.
// Return value: TRUE when it found a free spot, FALSE if it hasn't.
static uint32_t _dirFindFreeEntryinRAM(const DIR_ENTRY *fileEntry, DIR_POSITION *loc){
	for(uint8_t c=0;c<16;c++,fileEntry++){
     69c:	8f 5f       	subi	r24, 0xFF	; 255
     69e:	a0 96       	adiw	r28, 0x20	; 32
     6a0:	80 31       	cpi	r24, 0x10	; 16
     6a2:	01 f4       	brne	.+0      	; 0x6a4 <_dirFindInSector+0xa6>
		case DIRFIND_FILE:
			return(_dirFindFileInSector(fileEntry,fatname,loc));
		case DIRFIND_FREE:
			return(_dirFindFreeEntryinRAM(fileEntry,loc));
	}
	return(0);
     6a4:	00 e0       	ldi	r16, 0x00	; 0
     6a6:	10 e0       	ldi	r17, 0x00	; 0
     6a8:	20 e0       	ldi	r18, 0x00	; 0
     6aa:	30 e0       	ldi	r19, 0x00	; 0
     6ac:	00 c0       	rjmp	.+0      	; 0x6ae <_dirFindInSector+0xb0>
			if(fileEntry->filename[0] == 0x00 ||		// And is unused or
			   fileEntry->filename[0] == 0xE5 ){		// The file is deleted
				if(loc){
					loc->entryInSector=c;
				}
				return(1);								// We can use it
     6ae:	01 e0       	ldi	r16, 0x01	; 1
     6b0:	10 e0       	ldi	r17, 0x00	; 0
     6b2:	20 e0       	ldi	r18, 0x00	; 0
     6b4:	30 e0       	ldi	r19, 0x00	; 0
			return(_dirFindFileInSector(fileEntry,fatname,loc));
		case DIRFIND_FREE:
			return(_dirFindFreeEntryinRAM(fileEntry,loc));
	}
	return(0);
}
     6b6:	b8 01       	movw	r22, r16
     6b8:	c9 01       	movw	r24, r18
     6ba:	df 91       	pop	r29
     6bc:	cf 91       	pop	r28
     6be:	1f 91       	pop	r17
     6c0:	0f 91       	pop	r16
     6c2:	ff 90       	pop	r15
     6c4:	df 90       	pop	r13
     6c6:	cf 90       	pop	r12
     6c8:	08 95       	ret

000006ca <_diskClusterToSector>:
	disc->initialised = rtn;
	return rtn;
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
     6ca:	8f 92       	push	r8
     6cc:	9f 92       	push	r9
     6ce:	af 92       	push	r10
     6d0:	bf 92       	push	r11
     6d2:	cf 92       	push	r12
     6d4:	df 92       	push	r13
     6d6:	ef 92       	push	r14
     6d8:	ff 92       	push	r15
     6da:	0f 93       	push	r16
     6dc:	1f 93       	push	r17
     6de:	cf 93       	push	r28
     6e0:	df 93       	push	r29
     6e2:	ec 01       	movw	r28, r24
     6e4:	4a 01       	movw	r8, r20
     6e6:	5b 01       	movw	r10, r22
	SECTOR base=
		disk->volume.reservedSectorCount+
		disk->fatSectorCount * disk->volume.numberOfFats;
     6e8:	6b 89       	ldd	r22, Y+19	; 0x13
     6ea:	70 e0       	ldi	r23, 0x00	; 0
     6ec:	80 e0       	ldi	r24, 0x00	; 0
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	2a 8d       	ldd	r18, Y+26	; 0x1a
     6f2:	3b 8d       	ldd	r19, Y+27	; 0x1b
     6f4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6f6:	5d 8d       	ldd	r21, Y+29	; 0x1d
     6f8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     6fc:	6b 01       	movw	r12, r22
     6fe:	7c 01       	movw	r14, r24
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
	SECTOR base=
		disk->volume.reservedSectorCount+
     700:	89 89       	ldd	r24, Y+17	; 0x11
     702:	9a 89       	ldd	r25, Y+18	; 0x12
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e0       	ldi	r27, 0x00	; 0
	return rtn;
}

// Return the starting sector for a given cluster
SECTOR _diskClusterToSector(const DISK* disk,CLUSTER cluster){
	SECTOR base=
     708:	c8 0e       	add	r12, r24
     70a:	d9 1e       	adc	r13, r25
     70c:	ea 1e       	adc	r14, r26
     70e:	fb 1e       	adc	r15, r27
		disk->volume.reservedSectorCount+
		disk->fatSectorCount * disk->volume.numberOfFats;

	if(disk->fatType!=32)	{
     710:	8e a1       	ldd	r24, Y+38	; 0x26
     712:	80 32       	cpi	r24, 0x20	; 32
     714:	01 f0       	breq	.+0      	; 0x716 <_diskClusterToSector+0x4c>
		base += disk->volume.rootDirEntryCount/16;
     716:	8c 89       	ldd	r24, Y+20	; 0x14
     718:	9d 89       	ldd	r25, Y+21	; 0x15
     71a:	e4 e0       	ldi	r30, 0x04	; 4
     71c:	96 95       	lsr	r25
     71e:	87 95       	ror	r24
     720:	ea 95       	dec	r30
     722:	01 f4       	brne	.+0      	; 0x724 <_diskClusterToSector+0x5a>
     724:	a0 e0       	ldi	r26, 0x00	; 0
     726:	b0 e0       	ldi	r27, 0x00	; 0
     728:	c8 0e       	add	r12, r24
     72a:	d9 1e       	adc	r13, r25
     72c:	ea 1e       	adc	r14, r26
     72e:	fb 1e       	adc	r15, r27
	}

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
     730:	c5 01       	movw	r24, r10
     732:	b4 01       	movw	r22, r8
     734:	62 50       	subi	r22, 0x02	; 2
     736:	70 40       	sbci	r23, 0x00	; 0
     738:	80 40       	sbci	r24, 0x00	; 0
     73a:	90 40       	sbci	r25, 0x00	; 0
     73c:	28 89       	ldd	r18, Y+16	; 0x10
     73e:	30 e0       	ldi	r19, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     748:	8b 01       	movw	r16, r22
     74a:	9c 01       	movw	r18, r24
     74c:	0c 0d       	add	r16, r12
     74e:	1d 1d       	adc	r17, r13
     750:	2e 1d       	adc	r18, r14
     752:	3f 1d       	adc	r19, r15
}
     754:	b8 01       	movw	r22, r16
     756:	c9 01       	movw	r24, r18
     758:	df 91       	pop	r29
     75a:	cf 91       	pop	r28
     75c:	1f 91       	pop	r17
     75e:	0f 91       	pop	r16
     760:	ff 90       	pop	r15
     762:	ef 90       	pop	r14
     764:	df 90       	pop	r13
     766:	cf 90       	pop	r12
     768:	bf 90       	pop	r11
     76a:	af 90       	pop	r10
     76c:	9f 90       	pop	r9
     76e:	8f 90       	pop	r8
     770:	08 95       	ret

00000772 <diskFlush>:
static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
}

// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
     772:	6f 92       	push	r6
     774:	7f 92       	push	r7
     776:	8f 92       	push	r8
     778:	9f 92       	push	r9
     77a:	af 92       	push	r10
     77c:	bf 92       	push	r11
     77e:	cf 92       	push	r12
     780:	df 92       	push	r13
     782:	ef 92       	push	r14
     784:	ff 92       	push	r15
     786:	0f 93       	push	r16
     788:	1f 93       	push	r17
     78a:	cf 93       	push	r28
     78c:	df 93       	push	r29
     78e:	8c 01       	movw	r16, r24
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
}

static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
     790:	fc 01       	movw	r30, r24
     792:	86 80       	ldd	r8, Z+6	; 0x06
     794:	97 80       	ldd	r9, Z+7	; 0x07
     796:	a0 84       	ldd	r10, Z+8	; 0x08
     798:	b1 84       	ldd	r11, Z+9	; 0x09
     79a:	c6 8c       	ldd	r12, Z+30	; 0x1e
     79c:	d7 8c       	ldd	r13, Z+31	; 0x1f
     79e:	e0 a0       	ldd	r14, Z+32	; 0x20
     7a0:	f1 a0       	ldd	r15, Z+33	; 0x21
     7a2:	c8 0c       	add	r12, r8
     7a4:	d9 1c       	adc	r13, r9
     7a6:	ea 1c       	adc	r14, r10
     7a8:	fb 1c       	adc	r15, r11

static boolean _ioFlushRange(const DISK* disk,SECTOR address_low, SECTOR address_high){
	boolean rtn = TRUE;

	// Swap the high/low values if needed
	if(address_low>address_high){
     7aa:	c8 14       	cp	r12, r8
     7ac:	d9 04       	cpc	r13, r9
     7ae:	ea 04       	cpc	r14, r10
     7b0:	fb 04       	cpc	r15, r11
     7b2:	00 f0       	brcs	.+0      	; 0x7b4 <diskFlush+0x42>
     7b4:	3c 2d       	mov	r19, r12
     7b6:	2d 2d       	mov	r18, r13
     7b8:	9e 2d       	mov	r25, r14
     7ba:	8f 2d       	mov	r24, r15
     7bc:	75 01       	movw	r14, r10
     7be:	64 01       	movw	r12, r8
     7c0:	83 2e       	mov	r8, r19
     7c2:	92 2e       	mov	r9, r18
     7c4:	a9 2e       	mov	r10, r25
     7c6:	b8 2e       	mov	r11, r24
		address_low=address_high;
		address_high=swap;
	}


	BUFFER* buffer = disk->buffers;
     7c8:	f8 01       	movw	r30, r16
     7ca:	c4 a9       	ldd	r28, Z+52	; 0x34
     7cc:	d5 a9       	ldd	r29, Z+53	; 0x35
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
     7ce:	77 24       	eor	r7, r7
	// Cache is full so write the sector directly from user ram to the physical device
	return _ioWriteSector(disk,address,buf);
}

static boolean _ioFlushRange(const DISK* disk,SECTOR address_low, SECTOR address_high){
	boolean rtn = TRUE;
     7d0:	66 24       	eor	r6, r6
     7d2:	6a 94       	dec	r6
     7d4:	00 c0       	rjmp	.+0      	; 0x7d6 <diskFlush+0x64>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     7d6:	89 81       	ldd	r24, Y+1	; 0x01
     7d8:	90 e0       	ldi	r25, 0x00	; 0
	}


	BUFFER* buffer = disk->buffers;
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
		SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
     7da:	fc 01       	movw	r30, r24
     7dc:	ee 0f       	add	r30, r30
     7de:	ff 1f       	adc	r31, r31
     7e0:	e8 0f       	add	r30, r24
     7e2:	f9 1f       	adc	r31, r25
     7e4:	ee 0f       	add	r30, r30
     7e6:	ff 1f       	adc	r31, r31
		if((current->sector >= address_low) && (current->sector <= address_high) && (_bufferIsWritable(buffer))){
     7e8:	ec 0f       	add	r30, r28
     7ea:	fd 1f       	adc	r31, r29
     7ec:	82 81       	ldd	r24, Z+2	; 0x02
     7ee:	93 81       	ldd	r25, Z+3	; 0x03
     7f0:	a4 81       	ldd	r26, Z+4	; 0x04
     7f2:	b5 81       	ldd	r27, Z+5	; 0x05
     7f4:	8c 15       	cp	r24, r12
     7f6:	9d 05       	cpc	r25, r13
     7f8:	ae 05       	cpc	r26, r14
     7fa:	bf 05       	cpc	r27, r15
     7fc:	00 f0       	brcs	.+0      	; 0x7fe <diskFlush+0x8c>
     7fe:	88 16       	cp	r8, r24
     800:	99 06       	cpc	r9, r25
     802:	aa 06       	cpc	r10, r26
     804:	bb 06       	cpc	r11, r27
     806:	00 f0       	brcs	.+0      	; 0x808 <diskFlush+0x96>
     808:	ce 01       	movw	r24, r28
     80a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     80e:	88 23       	and	r24, r24
     810:	01 f0       	breq	.+0      	; 0x812 <diskFlush+0xa0>
			// Flush to the physical device
			rtn &= _ioFlushSector(disk,buffer);
     812:	c8 01       	movw	r24, r16
     814:	be 01       	movw	r22, r28
     816:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     81a:	68 22       	and	r6, r24
		address_high=swap;
	}


	BUFFER* buffer = disk->buffers;
	for( uint8_t b = 0; b<disk->numbuf; b++,buffer++){
     81c:	73 94       	inc	r7
     81e:	c6 5e       	subi	r28, 0xE6	; 230
     820:	dd 4f       	sbci	r29, 0xFD	; 253
     822:	f8 01       	movw	r30, r16
     824:	83 a9       	ldd	r24, Z+51	; 0x33
     826:	78 16       	cp	r7, r24
     828:	00 f0       	brcs	.+0      	; 0x82a <diskFlush+0xb8>
}

// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}
     82a:	86 2d       	mov	r24, r6
     82c:	df 91       	pop	r29
     82e:	cf 91       	pop	r28
     830:	1f 91       	pop	r17
     832:	0f 91       	pop	r16
     834:	ff 90       	pop	r15
     836:	ef 90       	pop	r14
     838:	df 90       	pop	r13
     83a:	cf 90       	pop	r12
     83c:	bf 90       	pop	r11
     83e:	af 90       	pop	r10
     840:	9f 90       	pop	r9
     842:	8f 90       	pop	r8
     844:	7f 90       	pop	r7
     846:	6f 90       	pop	r6
     848:	08 95       	ret

0000084a <_ioReleaseSector>:
	// No memory available
	return null;
}

// Indicate that a given sector buffer is no longer required
void _ioReleaseSector(const DISK* disc,const void* buf){
     84a:	0f 93       	push	r16
     84c:	1f 93       	push	r17
     84e:	cf 93       	push	r28
     850:	df 93       	push	r29
     852:	8c 01       	movw	r16, r24


static BUFFER* _ioGetBuffer(const DISK* disc, const void* buf){
	uint8_t i;
	BUFFER* buffer;
	for(i=0,buffer=disc->buffers; i<disc->numbuf; i++,buffer++){
     854:	fc 01       	movw	r30, r24
     856:	c4 a9       	ldd	r28, Z+52	; 0x34
     858:	d5 a9       	ldd	r29, Z+53	; 0x35
     85a:	33 a9       	ldd	r19, Z+51	; 0x33
     85c:	20 e0       	ldi	r18, 0x00	; 0
     85e:	00 c0       	rjmp	.+0      	; 0x860 <_ioReleaseSector+0x16>
		if(buf == buffer->dta){
     860:	ce 01       	movw	r24, r28
     862:	4a 96       	adiw	r24, 0x1a	; 26
     864:	68 17       	cp	r22, r24
     866:	79 07       	cpc	r23, r25
     868:	01 f0       	breq	.+0      	; 0x86a <_ioReleaseSector+0x20>


static BUFFER* _ioGetBuffer(const DISK* disc, const void* buf){
	uint8_t i;
	BUFFER* buffer;
	for(i=0,buffer=disc->buffers; i<disc->numbuf; i++,buffer++){
     86a:	2f 5f       	subi	r18, 0xFF	; 255
     86c:	c6 5e       	subi	r28, 0xE6	; 230
     86e:	dd 4f       	sbci	r29, 0xFD	; 253
     870:	23 17       	cp	r18, r19
     872:	01 f4       	brne	.+0      	; 0x874 <_ioReleaseSector+0x2a>
		if(buf == buffer->dta){
			return buffer;
		}
	}
	return(null);
     874:	c0 e0       	ldi	r28, 0x00	; 0
     876:	d0 e0       	ldi	r29, 0x00	; 0
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	90 e0       	ldi	r25, 0x00	; 0

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
}
static void _bufferDecrementUsageCount(BUFFER* buffer){
	SECTOR_BUFFER* sb = _bufferCurrentStackEntry(buffer);
     87c:	fc 01       	movw	r30, r24
     87e:	ee 0f       	add	r30, r30
     880:	ff 1f       	adc	r31, r31
     882:	e8 0f       	add	r30, r24
     884:	f9 1f       	adc	r31, r25
     886:	ee 0f       	add	r30, r30
     888:	ff 1f       	adc	r31, r31
     88a:	32 96       	adiw	r30, 0x02	; 2
     88c:	ec 0f       	add	r30, r28
     88e:	fd 1f       	adc	r31, r29
	if(sb->usage != 0){
     890:	84 81       	ldd	r24, Z+4	; 0x04
     892:	88 23       	and	r24, r24
     894:	01 f0       	breq	.+0      	; 0x896 <_ioReleaseSector+0x4c>
		sb->usage--;
     896:	81 50       	subi	r24, 0x01	; 1
     898:	84 83       	std	Z+4, r24	; 0x04
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     89a:	29 81       	ldd	r18, Y+1	; 0x01
     89c:	82 2f       	mov	r24, r18
     89e:	90 e0       	ldi	r25, 0x00	; 0
static boolean _bufferIsWritable(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isWritable) ? TRUE : FALSE;
}

static uint8_t _bufferGetUsageCount(BUFFER* buffer){
	return _bufferCurrentStackEntry(buffer)->usage;
     8a0:	fc 01       	movw	r30, r24
     8a2:	ee 0f       	add	r30, r30
     8a4:	ff 1f       	adc	r31, r31
     8a6:	e8 0f       	add	r30, r24
     8a8:	f9 1f       	adc	r31, r25
     8aa:	ee 0f       	add	r30, r30
     8ac:	ff 1f       	adc	r31, r31
     8ae:	ec 0f       	add	r30, r28
     8b0:	fd 1f       	adc	r31, r29
	BUFFER* buffer = _ioGetBuffer(disc,buf);

	// Decrement the usage count
	_bufferDecrementUsageCount(buffer);

	if(_bufferGetUsageCount(buffer)==0 && buffer->depth!=0){
     8b2:	86 81       	ldd	r24, Z+6	; 0x06
     8b4:	88 23       	and	r24, r24
     8b6:	01 f4       	brne	.+0      	; 0x8b8 <_ioReleaseSector+0x6e>
     8b8:	22 23       	and	r18, r18
     8ba:	01 f0       	breq	.+0      	; 0x8bc <_ioReleaseSector+0x72>
		// buffer is no longer used - so restore previous

		// Write sector to physical device
		if(_bufferIsWritable(buffer)){
     8bc:	ce 01       	movw	r24, r28
     8be:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     8c2:	88 23       	and	r24, r24
     8c4:	01 f0       	breq	.+0      	; 0x8c6 <_ioReleaseSector+0x7c>
			_ioFlushSector(disc,buffer);
     8c6:	c8 01       	movw	r24, r16
     8c8:	be 01       	movw	r22, r28
     8ca:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	return(TRUE);
}

static boolean _bufferPop(BUFFER* buffer){
	// Make sure there is something on the stack
	if(buffer->depth==0 || buffer->depth>MAX_STACK_DEPTH){
     8ce:	89 81       	ldd	r24, Y+1	; 0x01
     8d0:	81 50       	subi	r24, 0x01	; 1
     8d2:	84 30       	cpi	r24, 0x04	; 4
     8d4:	00 f4       	brcc	.+0      	; 0x8d6 <_ioReleaseSector+0x8c>
		return(FALSE);
	}

	// Decrement the stack pointer
	buffer->depth--;
     8d6:	89 83       	std	Y+1, r24	; 0x01
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
     8d8:	89 81       	ldd	r24, Y+1	; 0x01
     8da:	90 e0       	ldi	r25, 0x00	; 0

		// pop data from the stack
		_bufferPop(buffer);

		// re-read the data for the buffer from the physical device
		_ioPutSectorInCache(disc, buffer, _bufferCurrentStackEntry(buffer)->sector);
     8dc:	fc 01       	movw	r30, r24
     8de:	ee 0f       	add	r30, r30
     8e0:	ff 1f       	adc	r31, r31
     8e2:	e8 0f       	add	r30, r24
     8e4:	f9 1f       	adc	r31, r25
     8e6:	ee 0f       	add	r30, r30
     8e8:	ff 1f       	adc	r31, r31
     8ea:	ec 0f       	add	r30, r28
     8ec:	fd 1f       	adc	r31, r29
     8ee:	22 81       	ldd	r18, Z+2	; 0x02
     8f0:	33 81       	ldd	r19, Z+3	; 0x03
     8f2:	44 81       	ldd	r20, Z+4	; 0x04
     8f4:	55 81       	ldd	r21, Z+5	; 0x05
     8f6:	c8 01       	movw	r24, r16
     8f8:	be 01       	movw	r22, r28
     8fa:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	}
}
     8fe:	df 91       	pop	r29
     900:	cf 91       	pop	r28
     902:	1f 91       	pop	r17
     904:	0f 91       	pop	r16
     906:	08 95       	ret

00000908 <_partitionGetSector>:
/*------------------------------------------------------------------------*/
/*					Partition Management								  */
/*------------------------------------------------------------------------*/

// Read a sector from inside a partition
void* _partitionGetSector(const DISK* disk, SECTOR partSector, uint8_t mode){
     908:	0f 93       	push	r16
     90a:	1f 93       	push	r17
     90c:	e2 2f       	mov	r30, r18
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
     90e:	dc 01       	movw	r26, r24
     910:	16 96       	adiw	r26, 0x06	; 6
     912:	0d 91       	ld	r16, X+
     914:	1d 91       	ld	r17, X+
     916:	2d 91       	ld	r18, X+
     918:	3c 91       	ld	r19, X
     91a:	19 97       	sbiw	r26, 0x09	; 9
     91c:	40 0f       	add	r20, r16
     91e:	51 1f       	adc	r21, r17
     920:	62 1f       	adc	r22, r18
     922:	73 1f       	adc	r23, r19
     924:	2e 2f       	mov	r18, r30
     926:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
}
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	08 95       	ret

00000930 <_fatGetNextClusterAddressInRAM>:
	}
	return(disk->volume.reservedSectorCount + res);
}

// Look in a FAT table sector to find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddressInRAM(const DISK *disk,CLUSTER cluster_addr, uint8_t* buf){
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	cf 93       	push	r28
     93e:	df 93       	push	r29
     940:	ec 01       	movw	r28, r24
     942:	6a 01       	movw	r12, r20
     944:	7b 01       	movw	r14, r22
	uint16_t offset;
	CLUSTER nextcluster=0;
	uint8_t hb,lb;

	switch(disk->fatType){
     946:	8e a1       	ldd	r24, Y+38	; 0x26
     948:	80 31       	cpi	r24, 0x10	; 16
     94a:	01 f4       	brne	.+0      	; 0x94c <_fatGetNextClusterAddressInRAM+0x1c>
     94c:	00 c0       	rjmp	.+0      	; 0x94e <_fatGetNextClusterAddressInRAM+0x1e>
     94e:	80 32       	cpi	r24, 0x20	; 32
     950:	01 f4       	brne	.+0      	; 0x952 <_fatGetNextClusterAddressInRAM+0x22>
     952:	00 c0       	rjmp	.+0      	; 0x954 <_fatGetNextClusterAddressInRAM+0x24>
     954:	8c 30       	cpi	r24, 0x0C	; 12
     956:	01 f0       	breq	.+0      	; 0x958 <_fatGetNextClusterAddressInRAM+0x28>
     958:	00 c0       	rjmp	.+0      	; 0x95a <_fatGetNextClusterAddressInRAM+0x2a>
		case 12:
			offset = ((cluster_addr % 1024) * 3 / 2) % 512;
     95a:	53 70       	andi	r21, 0x03	; 3
     95c:	60 70       	andi	r22, 0x00	; 0
     95e:	70 70       	andi	r23, 0x00	; 0
     960:	db 01       	movw	r26, r22
     962:	ca 01       	movw	r24, r20
     964:	88 0f       	add	r24, r24
     966:	99 1f       	adc	r25, r25
     968:	aa 1f       	adc	r26, r26
     96a:	bb 1f       	adc	r27, r27
     96c:	84 0f       	add	r24, r20
     96e:	95 1f       	adc	r25, r21
     970:	a6 1f       	adc	r26, r22
     972:	b7 1f       	adc	r27, r23
     974:	b6 95       	lsr	r27
     976:	a7 95       	ror	r26
     978:	97 95       	ror	r25
     97a:	87 95       	ror	r24
     97c:	91 70       	andi	r25, 0x01	; 1
			hb = buf[offset];
     97e:	f9 01       	movw	r30, r18
     980:	e8 0f       	add	r30, r24
     982:	f9 1f       	adc	r31, r25
     984:	10 81       	ld	r17, Z
			if(offset == 511){
     986:	21 e0       	ldi	r18, 0x01	; 1
     988:	8f 3f       	cpi	r24, 0xFF	; 255
     98a:	92 07       	cpc	r25, r18
     98c:	01 f4       	brne	.+0      	; 0x98e <_fatGetNextClusterAddressInRAM+0x5e>
				// Next byte is in the next sector
				uint8_t* buf2=_partitionGetSector(disk,_fatGetSectorAddressFatEntry(disk,cluster_addr)+1,BUFFER_MODE_READONLY);
     98e:	ce 01       	movw	r24, r28
     990:	b7 01       	movw	r22, r14
     992:	a6 01       	movw	r20, r12
     994:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     998:	ab 01       	movw	r20, r22
     99a:	bc 01       	movw	r22, r24
     99c:	4f 5f       	subi	r20, 0xFF	; 255
     99e:	5f 4f       	sbci	r21, 0xFF	; 255
     9a0:	6f 4f       	sbci	r22, 0xFF	; 255
     9a2:	7f 4f       	sbci	r23, 0xFF	; 255
     9a4:	ce 01       	movw	r24, r28
     9a6:	21 e0       	ldi	r18, 0x01	; 1
     9a8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     9ac:	bc 01       	movw	r22, r24
				lb = buf2[0];
     9ae:	fc 01       	movw	r30, r24
     9b0:	00 81       	ld	r16, Z

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
     9b2:	ce 01       	movw	r24, r28
     9b4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     9b8:	00 c0       	rjmp	.+0      	; 0x9ba <_fatGetNextClusterAddressInRAM+0x8a>
				partition_releaseSector(disk,buf2);
			}else{
				lb = buf[offset + 1];
     9ba:	01 81       	ldd	r16, Z+1	; 0x01
     9bc:	80 2f       	mov	r24, r16
     9be:	90 e0       	ldi	r25, 0x00	; 0
			}
			if(cluster_addr % 2 == 0){
     9c0:	c0 fc       	sbrc	r12, 0
     9c2:	00 c0       	rjmp	.+0      	; 0x9c4 <_fatGetNextClusterAddressInRAM+0x94>
				nextcluster = ( ((lb&0x0F)<<8) + (hb) );
     9c4:	8f 70       	andi	r24, 0x0F	; 15
     9c6:	90 70       	andi	r25, 0x00	; 0
     9c8:	98 2f       	mov	r25, r24
     9ca:	88 27       	eor	r24, r24
     9cc:	00 c0       	rjmp	.+0      	; 0x9ce <_fatGetNextClusterAddressInRAM+0x9e>
			}else{
				nextcluster = ( (lb<<4) + (hb>>4) );
     9ce:	c4 e0       	ldi	r28, 0x04	; 4
     9d0:	88 0f       	add	r24, r24
     9d2:	99 1f       	adc	r25, r25
     9d4:	ca 95       	dec	r28
     9d6:	01 f4       	brne	.+0      	; 0x9d8 <_fatGetNextClusterAddressInRAM+0xa8>
     9d8:	12 95       	swap	r17
     9da:	1f 70       	andi	r17, 0x0F	; 15
     9dc:	81 0f       	add	r24, r17
     9de:	91 1d       	adc	r25, r1
     9e0:	8c 01       	movw	r16, r24
     9e2:	22 27       	eor	r18, r18
     9e4:	17 fd       	sbrc	r17, 7
     9e6:	20 95       	com	r18
     9e8:	32 2f       	mov	r19, r18
     9ea:	00 c0       	rjmp	.+0      	; 0x9ec <_fatGetNextClusterAddressInRAM+0xbc>
			}
			break;
		case 16:
			offset=cluster_addr % 256;
     9ec:	fa 01       	movw	r30, r20
     9ee:	f0 70       	andi	r31, 0x00	; 0
			nextcluster = *((uint16_t*)buf + offset);
     9f0:	ee 0f       	add	r30, r30
     9f2:	ff 1f       	adc	r31, r31
     9f4:	e2 0f       	add	r30, r18
     9f6:	f3 1f       	adc	r31, r19
     9f8:	00 81       	ld	r16, Z
     9fa:	11 81       	ldd	r17, Z+1	; 0x01
     9fc:	20 e0       	ldi	r18, 0x00	; 0
     9fe:	30 e0       	ldi	r19, 0x00	; 0
			break;
     a00:	00 c0       	rjmp	.+0      	; 0xa02 <_fatGetNextClusterAddressInRAM+0xd2>
		case 32:
			offset=cluster_addr % 128;
     a02:	fa 01       	movw	r30, r20
     a04:	ef 77       	andi	r30, 0x7F	; 127
     a06:	f0 70       	andi	r31, 0x00	; 0
			nextcluster = *((uint32_t*)buf + offset);
     a08:	ee 0f       	add	r30, r30
     a0a:	ff 1f       	adc	r31, r31
     a0c:	ee 0f       	add	r30, r30
     a0e:	ff 1f       	adc	r31, r31
     a10:	e2 0f       	add	r30, r18
     a12:	f3 1f       	adc	r31, r19
     a14:	00 81       	ld	r16, Z
     a16:	11 81       	ldd	r17, Z+1	; 0x01
     a18:	22 81       	ldd	r18, Z+2	; 0x02
     a1a:	33 81       	ldd	r19, Z+3	; 0x03
			break;
     a1c:	00 c0       	rjmp	.+0      	; 0xa1e <_fatGetNextClusterAddressInRAM+0xee>
}

// Look in a FAT table sector to find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddressInRAM(const DISK *disk,CLUSTER cluster_addr, uint8_t* buf){
	uint16_t offset;
	CLUSTER nextcluster=0;
     a1e:	00 e0       	ldi	r16, 0x00	; 0
     a20:	10 e0       	ldi	r17, 0x00	; 0
     a22:	20 e0       	ldi	r18, 0x00	; 0
     a24:	30 e0       	ldi	r19, 0x00	; 0
			offset=cluster_addr % 128;
			nextcluster = *((uint32_t*)buf + offset);
			break;
	}
	return(nextcluster);
}
     a26:	b8 01       	movw	r22, r16
     a28:	c9 01       	movw	r24, r18
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	1f 91       	pop	r17
     a30:	0f 91       	pop	r16
     a32:	ff 90       	pop	r15
     a34:	ef 90       	pop	r14
     a36:	df 90       	pop	r13
     a38:	cf 90       	pop	r12
     a3a:	08 95       	ret

00000a3c <_fatGetNextClusterChain.part.9>:


// Scan one sector of the FAT table to find the number of contiguous clusters
// Return value: TRUE on success, or FALSE when end of chain has been hit in which
//				case the chain has the LastCluster field set
static boolean _fatGetNextClusterChain(const DISK *disk, CLUSTER_NAV *chain){
     a3c:	2f 92       	push	r2
     a3e:	3f 92       	push	r3
     a40:	4f 92       	push	r4
     a42:	5f 92       	push	r5
     a44:	6f 92       	push	r6
     a46:	7f 92       	push	r7
     a48:	8f 92       	push	r8
     a4a:	9f 92       	push	r9
     a4c:	af 92       	push	r10
     a4e:	bf 92       	push	r11
     a50:	cf 92       	push	r12
     a52:	df 92       	push	r13
     a54:	ef 92       	push	r14
     a56:	ff 92       	push	r15
     a58:	0f 93       	push	r16
     a5a:	1f 93       	push	r17
     a5c:	cf 93       	push	r28
     a5e:	df 93       	push	r29
     a60:	8c 01       	movw	r16, r24
     a62:	eb 01       	movw	r28, r22

	if(chain->currentCluster==0){
		return(FALSE);
	}

	SECTOR sect=_fatGetSectorAddressFatEntry(disk,chain->currentCluster);
     a64:	48 85       	ldd	r20, Y+8	; 0x08
     a66:	59 85       	ldd	r21, Y+9	; 0x09
     a68:	6a 85       	ldd	r22, Y+10	; 0x0a
     a6a:	7b 85       	ldd	r23, Y+11	; 0x0b
     a6c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     a70:	2b 01       	movw	r4, r22
     a72:	3c 01       	movw	r6, r24

	// Read the FAT
	void* buf=_partitionGetSector(disk,sect,BUFFER_MODE_READONLY);
     a74:	c8 01       	movw	r24, r16
     a76:	b3 01       	movw	r22, r6
     a78:	a2 01       	movw	r20, r4
     a7a:	21 e0       	ldi	r18, 0x01	; 1
     a7c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     a80:	1c 01       	movw	r2, r24


	CLUSTER dc=_fatGetNextClusterAddressInRAM(disk,chain->currentCluster,buf);
     a82:	48 85       	ldd	r20, Y+8	; 0x08
     a84:	59 85       	ldd	r21, Y+9	; 0x09
     a86:	6a 85       	ldd	r22, Y+10	; 0x0a
     a88:	7b 85       	ldd	r23, Y+11	; 0x0b
     a8a:	c8 01       	movw	r24, r16
     a8c:	91 01       	movw	r18, r2
     a8e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     a92:	6b 01       	movw	r12, r22
     a94:	7c 01       	movw	r14, r24
}


// Return true if the cluster number represents the end of a cluster chain
static boolean _fatIsEndMarker(const DISK* disk, CLUSTER cluster){
	switch(disk->fatType){
     a96:	f8 01       	movw	r30, r16
     a98:	86 a1       	ldd	r24, Z+38	; 0x26
     a9a:	80 31       	cpi	r24, 0x10	; 16
     a9c:	01 f0       	breq	.+0      	; 0xa9e <_fatGetNextClusterChain.part.9+0x62>
     a9e:	80 32       	cpi	r24, 0x20	; 32
     aa0:	01 f0       	breq	.+0      	; 0xaa2 <_fatGetNextClusterChain.part.9+0x66>
     aa2:	8c 30       	cpi	r24, 0x0C	; 12
     aa4:	01 f0       	breq	.+0      	; 0xaa6 <_fatGetNextClusterChain.part.9+0x6a>
     aa6:	00 c0       	rjmp	.+0      	; 0xaa8 <_fatGetNextClusterChain.part.9+0x6c>
		case 12:
			if(cluster < 0xFF8){
     aa8:	f8 ef       	ldi	r31, 0xF8	; 248
     aaa:	cf 16       	cp	r12, r31
     aac:	ff e0       	ldi	r31, 0x0F	; 15
     aae:	df 06       	cpc	r13, r31
     ab0:	f0 e0       	ldi	r31, 0x00	; 0
     ab2:	ef 06       	cpc	r14, r31
     ab4:	f0 e0       	ldi	r31, 0x00	; 0
     ab6:	ff 06       	cpc	r15, r31
     ab8:	00 f0       	brcs	.+0      	; 0xaba <_fatGetNextClusterChain.part.9+0x7e>
     aba:	00 c0       	rjmp	.+0      	; 0xabc <_fatGetNextClusterChain.part.9+0x80>
				return(FALSE);
			}
			break;
		case 16:
			if(cluster < 0xFFF8){
     abc:	28 ef       	ldi	r18, 0xF8	; 248
     abe:	c2 16       	cp	r12, r18
     ac0:	2f ef       	ldi	r18, 0xFF	; 255
     ac2:	d2 06       	cpc	r13, r18
     ac4:	20 e0       	ldi	r18, 0x00	; 0
     ac6:	e2 06       	cpc	r14, r18
     ac8:	20 e0       	ldi	r18, 0x00	; 0
     aca:	f2 06       	cpc	r15, r18
     acc:	00 f0       	brcs	.+0      	; 0xace <_fatGetNextClusterChain.part.9+0x92>
     ace:	00 c0       	rjmp	.+0      	; 0xad0 <_fatGetNextClusterChain.part.9+0x94>
				return(FALSE);
			}
			break;
		case 32:
			if((cluster & 0x0FFFFFFF) < 0xFFFFFF8){
     ad0:	d7 01       	movw	r26, r14
     ad2:	c6 01       	movw	r24, r12
     ad4:	bf 70       	andi	r27, 0x0F	; 15
     ad6:	88 3f       	cpi	r24, 0xF8	; 248
     ad8:	ef ef       	ldi	r30, 0xFF	; 255
     ada:	9e 07       	cpc	r25, r30
     adc:	ef ef       	ldi	r30, 0xFF	; 255
     ade:	ae 07       	cpc	r26, r30
     ae0:	ef e0       	ldi	r30, 0x0F	; 15
     ae2:	be 07       	cpc	r27, r30
     ae4:	00 f0       	brcs	.+0      	; 0xae6 <_fatGetNextClusterChain.part.9+0xaa>
     ae6:	00 c0       	rjmp	.+0      	; 0xae8 <_fatGetNextClusterChain.part.9+0xac>
		chain->endCluster=chain->currentCluster;			// Set the last cluster
		partition_releaseSector(disk,buf);					// Release the FAT
		return(FALSE);										// Return END
	}

	chain->currentCluster=dc;								// Move to next cluster
     ae8:	c8 86       	std	Y+8, r12	; 0x08
     aea:	d9 86       	std	Y+9, r13	; 0x09
     aec:	ea 86       	std	Y+10, r14	; 0x0a
     aee:	fb 86       	std	Y+11, r15	; 0x0b
	chain->relativeCluster++;								// We have moved forward one
     af0:	8c 81       	ldd	r24, Y+4	; 0x04
     af2:	9d 81       	ldd	r25, Y+5	; 0x05
     af4:	ae 81       	ldd	r26, Y+6	; 0x06
     af6:	bf 81       	ldd	r27, Y+7	; 0x07
     af8:	01 96       	adiw	r24, 0x01	; 1
     afa:	a1 1d       	adc	r26, r1
     afc:	b1 1d       	adc	r27, r1
     afe:	8c 83       	std	Y+4, r24	; 0x04
     b00:	9d 83       	std	Y+5, r25	; 0x05
     b02:	ae 83       	std	Y+6, r26	; 0x06
     b04:	bf 83       	std	Y+7, r27	; 0x07

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
     b06:	b7 01       	movw	r22, r14
     b08:	a6 01       	movw	r20, r12
     b0a:	41 50       	subi	r20, 0x01	; 1
     b0c:	50 40       	sbci	r21, 0x00	; 0
     b0e:	60 40       	sbci	r22, 0x00	; 0
     b10:	70 40       	sbci	r23, 0x00	; 0
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
     b12:	88 24       	eor	r8, r8
     b14:	99 24       	eor	r9, r9
     b16:	54 01       	movw	r10, r8
     b18:	00 c0       	rjmp	.+0      	; 0xb1a <_fatGetNextClusterChain.part.9+0xde>
	while(next-1==last &&									// While we are in the same FAT sector
		  _fatGetSectorAddressFatEntry(disk,next)==sect){

		last=next;											// last cluster = next cluster
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
     b1a:	c8 01       	movw	r24, r16
     b1c:	b7 01       	movw	r22, r14
     b1e:	a6 01       	movw	r20, r12
     b20:	91 01       	movw	r18, r2
     b22:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     b26:	9b 01       	movw	r18, r22
		contiguous++;										// One more cluster in the chain
     b28:	08 94       	sec
     b2a:	81 1c       	adc	r8, r1
     b2c:	91 1c       	adc	r9, r1
     b2e:	a1 1c       	adc	r10, r1
     b30:	b1 1c       	adc	r11, r1
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
		  _fatGetSectorAddressFatEntry(disk,next)==sect){

		last=next;											// last cluster = next cluster
     b32:	b7 01       	movw	r22, r14
     b34:	a6 01       	movw	r20, r12
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
     b36:	69 01       	movw	r12, r18
     b38:	7c 01       	movw	r14, r24
	chain->relativeCluster++;								// We have moved forward one

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
     b3a:	d7 01       	movw	r26, r14
     b3c:	c6 01       	movw	r24, r12
     b3e:	01 97       	sbiw	r24, 0x01	; 1
     b40:	a1 09       	sbc	r26, r1
     b42:	b1 09       	sbc	r27, r1
     b44:	84 17       	cp	r24, r20
     b46:	95 07       	cpc	r25, r21
     b48:	a6 07       	cpc	r26, r22
     b4a:	b7 07       	cpc	r27, r23
     b4c:	01 f4       	brne	.+0      	; 0xb4e <_fatGetNextClusterChain.part.9+0x112>
		  _fatGetSectorAddressFatEntry(disk,next)==sect){
     b4e:	c8 01       	movw	r24, r16
     b50:	b7 01       	movw	r22, r14
     b52:	a6 01       	movw	r20, r12
     b54:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     b58:	dc 01       	movw	r26, r24
     b5a:	cb 01       	movw	r24, r22
	chain->relativeCluster++;								// We have moved forward one

	CLUSTER last=chain->currentCluster-1;					// Set up variables to ..
	CLUSTER next=last+1;									// allow the while to succeed
	CLUSTER_COUNT contiguous=0;
	while(next-1==last &&									// While we are in the same FAT sector
     b5c:	84 15       	cp	r24, r4
     b5e:	95 05       	cpc	r25, r5
     b60:	a6 05       	cpc	r26, r6
     b62:	b7 05       	cpc	r27, r7
     b64:	01 f0       	breq	.+0      	; 0xb66 <_fatGetNextClusterChain.part.9+0x12a>
		last=next;											// last cluster = next cluster
		next=_fatGetNextClusterAddressInRAM(disk,last,buf); // find next cluster
		contiguous++;										// One more cluster in the chain
	}

	chain->contiguousCount= (contiguous==0) ? 0 : contiguous-1;// Set the number of clusters in chain
     b66:	81 14       	cp	r8, r1
     b68:	91 04       	cpc	r9, r1
     b6a:	a1 04       	cpc	r10, r1
     b6c:	b1 04       	cpc	r11, r1
     b6e:	01 f0       	breq	.+0      	; 0xb70 <_fatGetNextClusterChain.part.9+0x134>
     b70:	08 94       	sec
     b72:	81 08       	sbc	r8, r1
     b74:	91 08       	sbc	r9, r1
     b76:	a1 08       	sbc	r10, r1
     b78:	b1 08       	sbc	r11, r1
     b7a:	00 c0       	rjmp	.+0      	; 0xb7c <_fatGetNextClusterChain.part.9+0x140>
     b7c:	88 24       	eor	r8, r8
     b7e:	99 24       	eor	r9, r9
     b80:	54 01       	movw	r10, r8
     b82:	88 82       	st	Y, r8
     b84:	99 82       	std	Y+1, r9	; 0x01
     b86:	aa 82       	std	Y+2, r10	; 0x02
     b88:	bb 82       	std	Y+3, r11	; 0x03
     b8a:	c8 01       	movw	r24, r16
     b8c:	b1 01       	movw	r22, r2
     b8e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		rprintf("NextChain: Rel=%lu, Actual=%lu, Contig=%lu\n",chain->relativeCluster,chain->currentCluster,chain->contiguousCount);
		rprintfInit(old);}
#endif


	return(TRUE);
     b92:	8f ef       	ldi	r24, 0xFF	; 255
}
     b94:	df 91       	pop	r29
     b96:	cf 91       	pop	r28
     b98:	1f 91       	pop	r17
     b9a:	0f 91       	pop	r16
     b9c:	ff 90       	pop	r15
     b9e:	ef 90       	pop	r14
     ba0:	df 90       	pop	r13
     ba2:	cf 90       	pop	r12
     ba4:	bf 90       	pop	r11
     ba6:	af 90       	pop	r10
     ba8:	9f 90       	pop	r9
     baa:	8f 90       	pop	r8
     bac:	7f 90       	pop	r7
     bae:	6f 90       	pop	r6
     bb0:	5f 90       	pop	r5
     bb2:	4f 90       	pop	r4
     bb4:	3f 90       	pop	r3
     bb6:	2f 90       	pop	r2
     bb8:	08 95       	ret
	void* buf=_partitionGetSector(disk,sect,BUFFER_MODE_READONLY);


	CLUSTER dc=_fatGetNextClusterAddressInRAM(disk,chain->currentCluster,buf);
	if(_fatIsEndMarker(disk,dc)){							// If its the end of the file?
		chain->endCluster=chain->currentCluster;			// Set the last cluster
     bba:	88 85       	ldd	r24, Y+8	; 0x08
     bbc:	99 85       	ldd	r25, Y+9	; 0x09
     bbe:	aa 85       	ldd	r26, Y+10	; 0x0a
     bc0:	bb 85       	ldd	r27, Y+11	; 0x0b
     bc2:	88 8b       	std	Y+16, r24	; 0x10
     bc4:	99 8b       	std	Y+17, r25	; 0x11
     bc6:	aa 8b       	std	Y+18, r26	; 0x12
     bc8:	bb 8b       	std	Y+19, r27	; 0x13
     bca:	c8 01       	movw	r24, r16
     bcc:	b1 01       	movw	r22, r2
     bce:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		partition_releaseSector(disk,buf);					// Release the FAT
		return(FALSE);										// Return END
     bd2:	80 e0       	ldi	r24, 0x00	; 0
     bd4:	00 c0       	rjmp	.+0      	; 0xbd6 <_navGetLastCluster>

00000bd6 <_navGetLastCluster>:
/*------------------------------------------------------------------------*/
/*					Cluster Navigation Management  						  */
/*------------------------------------------------------------------------*/

// Find the last cluster in a cluster chain and store it in the cache
static CLUSTER _navGetLastCluster(const DISK* disk,CLUSTER_NAV *nav){
     bd6:	0f 93       	push	r16
     bd8:	1f 93       	push	r17
     bda:	cf 93       	push	r28
     bdc:	df 93       	push	r29
     bde:	8c 01       	movw	r16, r24
     be0:	eb 01       	movw	r28, r22
	// If not initialised then go to start of file
	if(nav->currentCluster==0){
     be2:	88 85       	ldd	r24, Y+8	; 0x08
     be4:	99 85       	ldd	r25, Y+9	; 0x09
     be6:	aa 85       	ldd	r26, Y+10	; 0x0a
     be8:	bb 85       	ldd	r27, Y+11	; 0x0b
     bea:	00 97       	sbiw	r24, 0x00	; 0
     bec:	a1 05       	cpc	r26, r1
     bee:	b1 05       	cpc	r27, r1
     bf0:	01 f4       	brne	.+0      	; 0xbf2 <_navGetLastCluster+0x1c>
		nav->currentCluster=nav->startCluster;
     bf2:	8c 85       	ldd	r24, Y+12	; 0x0c
     bf4:	9d 85       	ldd	r25, Y+13	; 0x0d
     bf6:	ae 85       	ldd	r26, Y+14	; 0x0e
     bf8:	bf 85       	ldd	r27, Y+15	; 0x0f
     bfa:	88 87       	std	Y+8, r24	; 0x08
     bfc:	99 87       	std	Y+9, r25	; 0x09
     bfe:	aa 87       	std	Y+10, r26	; 0x0a
     c00:	bb 87       	std	Y+11, r27	; 0x0b
		nav->relativeCluster=0;
     c02:	1c 82       	std	Y+4, r1	; 0x04
     c04:	1d 82       	std	Y+5, r1	; 0x05
     c06:	1e 82       	std	Y+6, r1	; 0x06
     c08:	1f 82       	std	Y+7, r1	; 0x07
	}

	// If we haven't found the last cluster yet then find it now
	if(nav->endCluster==0){
     c0a:	88 89       	ldd	r24, Y+16	; 0x10
     c0c:	99 89       	ldd	r25, Y+17	; 0x11
     c0e:	aa 89       	ldd	r26, Y+18	; 0x12
     c10:	bb 89       	ldd	r27, Y+19	; 0x13
     c12:	00 97       	sbiw	r24, 0x00	; 0
     c14:	a1 05       	cpc	r26, r1
     c16:	b1 05       	cpc	r27, r1
     c18:	01 f0       	breq	.+0      	; 0xc1a <_navGetLastCluster+0x44>
     c1a:	00 c0       	rjmp	.+0      	; 0xc1c <_navGetLastCluster+0x46>
		while(_fatGetNextClusterChain(disk, nav)){
			nav->relativeCluster+=nav->contiguousCount;
     c1c:	48 81       	ld	r20, Y
     c1e:	59 81       	ldd	r21, Y+1	; 0x01
     c20:	6a 81       	ldd	r22, Y+2	; 0x02
     c22:	7b 81       	ldd	r23, Y+3	; 0x03
     c24:	8c 81       	ldd	r24, Y+4	; 0x04
     c26:	9d 81       	ldd	r25, Y+5	; 0x05
     c28:	ae 81       	ldd	r26, Y+6	; 0x06
     c2a:	bf 81       	ldd	r27, Y+7	; 0x07
     c2c:	84 0f       	add	r24, r20
     c2e:	95 1f       	adc	r25, r21
     c30:	a6 1f       	adc	r26, r22
     c32:	b7 1f       	adc	r27, r23
     c34:	8c 83       	std	Y+4, r24	; 0x04
     c36:	9d 83       	std	Y+5, r25	; 0x05
     c38:	ae 83       	std	Y+6, r26	; 0x06
     c3a:	bf 83       	std	Y+7, r27	; 0x07
			nav->currentCluster+=nav->contiguousCount;
     c3c:	88 85       	ldd	r24, Y+8	; 0x08
     c3e:	99 85       	ldd	r25, Y+9	; 0x09
     c40:	aa 85       	ldd	r26, Y+10	; 0x0a
     c42:	bb 85       	ldd	r27, Y+11	; 0x0b
     c44:	84 0f       	add	r24, r20
     c46:	95 1f       	adc	r25, r21
     c48:	a6 1f       	adc	r26, r22
     c4a:	b7 1f       	adc	r27, r23
     c4c:	88 87       	std	Y+8, r24	; 0x08
     c4e:	99 87       	std	Y+9, r25	; 0x09
     c50:	aa 87       	std	Y+10, r26	; 0x0a
     c52:	bb 87       	std	Y+11, r27	; 0x0b
			nav->contiguousCount=0;
     c54:	18 82       	st	Y, r1
     c56:	19 82       	std	Y+1, r1	; 0x01
     c58:	1a 82       	std	Y+2, r1	; 0x02
     c5a:	1b 82       	std	Y+3, r1	; 0x03
// Scan one sector of the FAT table to find the number of contiguous clusters
// Return value: TRUE on success, or FALSE when end of chain has been hit in which
//				case the chain has the LastCluster field set
static boolean _fatGetNextClusterChain(const DISK *disk, CLUSTER_NAV *chain){

	if(chain->currentCluster==0){
     c5c:	88 85       	ldd	r24, Y+8	; 0x08
     c5e:	99 85       	ldd	r25, Y+9	; 0x09
     c60:	aa 85       	ldd	r26, Y+10	; 0x0a
     c62:	bb 85       	ldd	r27, Y+11	; 0x0b
     c64:	00 97       	sbiw	r24, 0x00	; 0
     c66:	a1 05       	cpc	r26, r1
     c68:	b1 05       	cpc	r27, r1
     c6a:	01 f0       	breq	.+0      	; 0xc6c <_navGetLastCluster+0x96>
     c6c:	c8 01       	movw	r24, r16
     c6e:	be 01       	movw	r22, r28
     c70:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		nav->relativeCluster=0;
	}

	// If we haven't found the last cluster yet then find it now
	if(nav->endCluster==0){
		while(_fatGetNextClusterChain(disk, nav)){
     c74:	88 23       	and	r24, r24
     c76:	01 f4       	brne	.+0      	; 0xc78 <_navGetLastCluster+0xa2>
			nav->relativeCluster+=nav->contiguousCount;
			nav->currentCluster+=nav->contiguousCount;
			nav->contiguousCount=0;
		}
	}
	return(nav->endCluster);
     c78:	68 89       	ldd	r22, Y+16	; 0x10
     c7a:	79 89       	ldd	r23, Y+17	; 0x11
}
     c7c:	8a 89       	ldd	r24, Y+18	; 0x12
     c7e:	9b 89       	ldd	r25, Y+19	; 0x13
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	1f 91       	pop	r17
     c86:	0f 91       	pop	r16
     c88:	08 95       	ret

00000c8a <diskFreeSpace>:
// Flush the file system to disk. This must be done for removing any drives
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}

uint32_t diskFreeSpace(const DISK* disk){
     c8a:	2f 92       	push	r2
     c8c:	3f 92       	push	r3
     c8e:	4f 92       	push	r4
     c90:	5f 92       	push	r5
     c92:	6f 92       	push	r6
     c94:	7f 92       	push	r7
     c96:	8f 92       	push	r8
     c98:	9f 92       	push	r9
     c9a:	af 92       	push	r10
     c9c:	bf 92       	push	r11
     c9e:	cf 92       	push	r12
     ca0:	df 92       	push	r13
     ca2:	ef 92       	push	r14
     ca4:	ff 92       	push	r15
     ca6:	0f 93       	push	r16
     ca8:	1f 93       	push	r17
     caa:	cf 93       	push	r28
     cac:	df 93       	push	r29
     cae:	00 d0       	rcall	.+0      	; 0xcb0 <diskFreeSpace+0x26>
     cb0:	00 d0       	rcall	.+0      	; 0xcb2 <diskFreeSpace+0x28>
     cb2:	cd b7       	in	r28, 0x3d	; 61
     cb4:	de b7       	in	r29, 0x3e	; 62
     cb6:	1c 01       	movw	r2, r24
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;
     cb8:	dc 01       	movw	r26, r24
     cba:	50 96       	adiw	r26, 0x10	; 16
     cbc:	8c 91       	ld	r24, X
     cbe:	50 97       	sbiw	r26, 0x10	; 16

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     cc0:	88 24       	eor	r8, r8
     cc2:	99 24       	eor	r9, r9
     cc4:	54 01       	movw	r10, r8
boolean diskFlush(const DISK *disk){
	return(_partitionFlushRange(disk,0,disk->sectorCount));
}

uint32_t diskFreeSpace(const DISK* disk){
	SECTOR_COUNT free=0;
     cc6:	44 24       	eor	r4, r4
     cc8:	55 24       	eor	r5, r5
     cca:	32 01       	movw	r6, r4
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
		next=_fatGetNextClusterAddress(disk,cluster);
		if(next == 0){
			free += secPerClust;
     ccc:	28 2f       	mov	r18, r24
     cce:	30 e0       	ldi	r19, 0x00	; 0
     cd0:	40 e0       	ldi	r20, 0x00	; 0
     cd2:	50 e0       	ldi	r21, 0x00	; 0
     cd4:	29 83       	std	Y+1, r18	; 0x01
     cd6:	3a 83       	std	Y+2, r19	; 0x02
     cd8:	4b 83       	std	Y+3, r20	; 0x03
     cda:	5c 83       	std	Y+4, r21	; 0x04
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     cdc:	00 c0       	rjmp	.+0      	; 0xcde <diskFreeSpace+0x54>

// Given a cluster - find the next cluster in the chain
static CLUSTER _fatGetNextClusterAddress(const DISK* disk,CLUSTER cluster){
	uint32_t nextcluster=0;

	SECTOR sector=_fatGetSectorAddressFatEntry(disk,cluster);
     cde:	c1 01       	movw	r24, r2
     ce0:	b5 01       	movw	r22, r10
     ce2:	a4 01       	movw	r20, r8
     ce4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     ce8:	8b 01       	movw	r16, r22
     cea:	9c 01       	movw	r18, r24
	if( (disk->fatSectorCount > (sector - disk->volume.reservedSectorCount)) && sector!=0 ){
     cec:	d1 01       	movw	r26, r2
     cee:	51 96       	adiw	r26, 0x11	; 17
     cf0:	8d 91       	ld	r24, X+
     cf2:	9c 91       	ld	r25, X
     cf4:	52 97       	sbiw	r26, 0x12	; 18
     cf6:	a0 e0       	ldi	r26, 0x00	; 0
     cf8:	b0 e0       	ldi	r27, 0x00	; 0
     cfa:	b9 01       	movw	r22, r18
     cfc:	a8 01       	movw	r20, r16
     cfe:	48 1b       	sub	r20, r24
     d00:	59 0b       	sbc	r21, r25
     d02:	6a 0b       	sbc	r22, r26
     d04:	7b 0b       	sbc	r23, r27
     d06:	db 01       	movw	r26, r22
     d08:	ca 01       	movw	r24, r20
     d0a:	f1 01       	movw	r30, r2
     d0c:	42 8d       	ldd	r20, Z+26	; 0x1a
     d0e:	53 8d       	ldd	r21, Z+27	; 0x1b
     d10:	64 8d       	ldd	r22, Z+28	; 0x1c
     d12:	75 8d       	ldd	r23, Z+29	; 0x1d
     d14:	84 17       	cp	r24, r20
     d16:	95 07       	cpc	r25, r21
     d18:	a6 07       	cpc	r26, r22
     d1a:	b7 07       	cpc	r27, r23
     d1c:	00 f4       	brcc	.+0      	; 0xd1e <diskFreeSpace+0x94>
     d1e:	01 15       	cp	r16, r1
     d20:	11 05       	cpc	r17, r1
     d22:	21 05       	cpc	r18, r1
     d24:	31 05       	cpc	r19, r1
     d26:	01 f0       	breq	.+0      	; 0xd28 <diskFreeSpace+0x9e>
		void* buf=_partitionGetSector(disk,sector,BUFFER_MODE_READONLY);
     d28:	c1 01       	movw	r24, r2
     d2a:	b9 01       	movw	r22, r18
     d2c:	a8 01       	movw	r20, r16
     d2e:	21 e0       	ldi	r18, 0x01	; 1
     d30:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     d34:	8c 01       	movw	r16, r24
		nextcluster = _fatGetNextClusterAddressInRAM(disk, cluster, buf);
     d36:	c1 01       	movw	r24, r2
     d38:	b5 01       	movw	r22, r10
     d3a:	a4 01       	movw	r20, r8
     d3c:	98 01       	movw	r18, r16
     d3e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     d42:	6b 01       	movw	r12, r22
     d44:	7c 01       	movw	r14, r24
     d46:	c1 01       	movw	r24, r2
     d48:	b8 01       	movw	r22, r16
     d4a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
		next=_fatGetNextClusterAddress(disk,cluster);
		if(next == 0){
     d4e:	c1 14       	cp	r12, r1
     d50:	d1 04       	cpc	r13, r1
     d52:	e1 04       	cpc	r14, r1
     d54:	f1 04       	cpc	r15, r1
     d56:	01 f4       	brne	.+0      	; 0xd58 <diskFreeSpace+0xce>
			free += secPerClust;
     d58:	29 81       	ldd	r18, Y+1	; 0x01
     d5a:	3a 81       	ldd	r19, Y+2	; 0x02
     d5c:	4b 81       	ldd	r20, Y+3	; 0x03
     d5e:	5c 81       	ldd	r21, Y+4	; 0x04
     d60:	42 0e       	add	r4, r18
     d62:	53 1e       	adc	r5, r19
     d64:	64 1e       	adc	r6, r20
     d66:	75 1e       	adc	r7, r21
	SECTOR_COUNT free=0;
	CLUSTER cluster;
	CLUSTER next;
	uint8_t secPerClust = disk->volume.sectorsPerCluster;

	for(cluster = 0; cluster < disk->dataClusterCount; cluster++){
     d68:	08 94       	sec
     d6a:	81 1c       	adc	r8, r1
     d6c:	91 1c       	adc	r9, r1
     d6e:	a1 1c       	adc	r10, r1
     d70:	b1 1c       	adc	r11, r1
     d72:	f1 01       	movw	r30, r2
     d74:	82 a1       	ldd	r24, Z+34	; 0x22
     d76:	93 a1       	ldd	r25, Z+35	; 0x23
     d78:	a4 a1       	ldd	r26, Z+36	; 0x24
     d7a:	b5 a1       	ldd	r27, Z+37	; 0x25
     d7c:	88 16       	cp	r8, r24
     d7e:	99 06       	cpc	r9, r25
     d80:	aa 06       	cpc	r10, r26
     d82:	bb 06       	cpc	r11, r27
     d84:	00 f4       	brcc	.+0      	; 0xd86 <diskFreeSpace+0xfc>
     d86:	00 c0       	rjmp	.+0      	; 0xd88 <diskFreeSpace+0xfe>
		if(next == 0){
			free += secPerClust;
		}
	}

	return (free >> 1);
     d88:	76 94       	lsr	r7
     d8a:	67 94       	ror	r6
     d8c:	57 94       	ror	r5
     d8e:	47 94       	ror	r4
}
     d90:	b2 01       	movw	r22, r4
     d92:	c3 01       	movw	r24, r6
     d94:	0f 90       	pop	r0
     d96:	0f 90       	pop	r0
     d98:	0f 90       	pop	r0
     d9a:	0f 90       	pop	r0
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	1f 91       	pop	r17
     da2:	0f 91       	pop	r16
     da4:	ff 90       	pop	r15
     da6:	ef 90       	pop	r14
     da8:	df 90       	pop	r13
     daa:	cf 90       	pop	r12
     dac:	bf 90       	pop	r11
     dae:	af 90       	pop	r10
     db0:	9f 90       	pop	r9
     db2:	8f 90       	pop	r8
     db4:	7f 90       	pop	r7
     db6:	6f 90       	pop	r6
     db8:	5f 90       	pop	r5
     dba:	4f 90       	pop	r4
     dbc:	3f 90       	pop	r3
     dbe:	2f 90       	pop	r2
     dc0:	08 95       	ret

00000dc2 <diskInit>:
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     dc2:	4f 92       	push	r4
     dc4:	5f 92       	push	r5
     dc6:	6f 92       	push	r6
     dc8:	7f 92       	push	r7
     dca:	8f 92       	push	r8
     dcc:	9f 92       	push	r9
     dce:	af 92       	push	r10
     dd0:	bf 92       	push	r11
     dd2:	cf 92       	push	r12
     dd4:	df 92       	push	r13
     dd6:	ef 92       	push	r14
     dd8:	ff 92       	push	r15
     dda:	0f 93       	push	r16
     ddc:	1f 93       	push	r17
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	00 d0       	rcall	.+0      	; 0xde4 <diskInit+0x22>
     de4:	00 d0       	rcall	.+0      	; 0xde6 <diskInit+0x24>
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
     dea:	7c 01       	movw	r14, r24
     dec:	86 2f       	mov	r24, r22
	boolean rtn = FALSE;

	disc->sclass = class;
     dee:	d7 01       	movw	r26, r14
     df0:	11 96       	adiw	r26, 0x01	; 1
     df2:	5c 93       	st	X, r21
     df4:	4e 93       	st	-X, r20
	disc->device = device;
     df6:	13 96       	adiw	r26, 0x03	; 3
     df8:	3c 93       	st	X, r19
     dfa:	2e 93       	st	-X, r18
     dfc:	12 97       	sbiw	r26, 0x02	; 2
	disc->partitionType = 0;
     dfe:	15 96       	adiw	r26, 0x05	; 5
     e00:	1c 92       	st	X, r1
     e02:	15 97       	sbiw	r26, 0x05	; 5

	// Allocate memory for the buffers
	if(disc->buffers==null){
     e04:	d4 96       	adiw	r26, 0x34	; 52
     e06:	2d 91       	ld	r18, X+
     e08:	3c 91       	ld	r19, X
     e0a:	d5 97       	sbiw	r26, 0x35	; 53
     e0c:	21 15       	cp	r18, r1
     e0e:	31 05       	cpc	r19, r1
     e10:	01 f4       	brne	.+0      	; 0xe12 <diskInit+0x50>
		disc->numbuf = numBuffers;
     e12:	d3 96       	adiw	r26, 0x33	; 51
     e14:	6c 93       	st	X, r22
		disc->buffers = calloc(numBuffers,sizeof(BUFFER));
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	6a e1       	ldi	r22, 0x1A	; 26
     e1a:	72 e0       	ldi	r23, 0x02	; 2
     e1c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     e20:	f7 01       	movw	r30, r14
     e22:	84 ab       	std	Z+52, r24	; 0x34
     e24:	95 ab       	std	Z+53, r25	; 0x35
	}

	// Load the master boot record
	uint8_t* buf=_ioGetSector(disc, 0, BUFFER_MODE_READONLY);
     e26:	c7 01       	movw	r24, r14
     e28:	40 e0       	ldi	r20, 0x00	; 0
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	60 e0       	ldi	r22, 0x00	; 0
     e2e:	70 e0       	ldi	r23, 0x00	; 0
     e30:	21 e0       	ldi	r18, 0x01	; 1
     e32:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     e36:	8c 01       	movw	r16, r24

	if(buf){
     e38:	00 97       	sbiw	r24, 0x00	; 0
     e3a:	01 f4       	brne	.+0      	; 0xe3c <diskInit+0x7a>
     e3c:	00 c0       	rjmp	.+0      	; 0xe3e <diskInit+0x7c>
     e3e:	9c 01       	movw	r18, r24
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e40:	ac 01       	movw	r20, r24
     e42:	40 54       	subi	r20, 0x40	; 64
     e44:	50 40       	sbci	r21, 0x00	; 0
	boolean rtn = FALSE;
     e46:	90 e0       	ldi	r25, 0x00	; 0
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e48:	f9 01       	movw	r30, r18
     e4a:	ee 50       	subi	r30, 0x0E	; 14
     e4c:	fe 4f       	sbci	r31, 0xFE	; 254
	if(buf){
		// Find the active partition
		PartitionEntry* partitions = (PartitionEntry*)(&buf[0x1BE]);
		for(int p=3; p>=0; p--){
			PartitionEntry* partition = &partitions[p];
			uint8_t type = partition->type;
     e4e:	80 81       	ld	r24, Z
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
     e50:	81 30       	cpi	r24, 0x01	; 1
     e52:	01 f0       	breq	.+0      	; 0xe54 <diskInit+0x92>
     e54:	84 30       	cpi	r24, 0x04	; 4
     e56:	01 f0       	breq	.+0      	; 0xe58 <diskInit+0x96>
     e58:	86 30       	cpi	r24, 0x06	; 6
     e5a:	01 f0       	breq	.+0      	; 0xe5c <diskInit+0x9a>
     e5c:	8b 30       	cpi	r24, 0x0B	; 11
     e5e:	01 f0       	breq	.+0      	; 0xe60 <diskInit+0x9e>
     e60:	8c 35       	cpi	r24, 0x5C	; 92
     e62:	01 f0       	breq	.+0      	; 0xe64 <diskInit+0xa2>
     e64:	8e 35       	cpi	r24, 0x5E	; 94
     e66:	01 f4       	brne	.+0      	; 0xe68 <diskInit+0xa6>
				// This is a recognised partition type
				disc->partitionType = type;
     e68:	d7 01       	movw	r26, r14
     e6a:	15 96       	adiw	r26, 0x05	; 5
     e6c:	8c 93       	st	X, r24
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e6e:	f9 01       	movw	r30, r18
     e70:	ea 50       	subi	r30, 0x0A	; 10
     e72:	fe 4f       	sbci	r31, 0xFE	; 254
			PartitionEntry* partition = &partitions[p];
			uint8_t type = partition->type;
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
				// This is a recognised partition type
				disc->partitionType = type;
				disc->partitionStartSector = partition->LBA_begin;
     e74:	80 81       	ld	r24, Z
     e76:	91 81       	ldd	r25, Z+1	; 0x01
     e78:	a2 81       	ldd	r26, Z+2	; 0x02
     e7a:	b3 81       	ldd	r27, Z+3	; 0x03
     e7c:	f7 01       	movw	r30, r14
     e7e:	86 83       	std	Z+6, r24	; 0x06
     e80:	97 83       	std	Z+7, r25	; 0x07
     e82:	a0 87       	std	Z+8, r26	; 0x08
     e84:	b1 87       	std	Z+9, r27	; 0x09
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
     e86:	f9 01       	movw	r30, r18
     e88:	e6 50       	subi	r30, 0x06	; 6
     e8a:	fe 4f       	sbci	r31, 0xFE	; 254
			uint8_t type = partition->type;
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
				// This is a recognised partition type
				disc->partitionType = type;
				disc->partitionStartSector = partition->LBA_begin;
				disc->partitionNumSectors = partition->numSectors;
     e8c:	80 81       	ld	r24, Z
     e8e:	91 81       	ldd	r25, Z+1	; 0x01
     e90:	a2 81       	ldd	r26, Z+2	; 0x02
     e92:	b3 81       	ldd	r27, Z+3	; 0x03
     e94:	f7 01       	movw	r30, r14
     e96:	82 87       	std	Z+10, r24	; 0x0a
     e98:	93 87       	std	Z+11, r25	; 0x0b
     e9a:	a4 87       	std	Z+12, r26	; 0x0c
     e9c:	b5 87       	std	Z+13, r27	; 0x0d
				rtn = TRUE;
     e9e:	9f ef       	ldi	r25, 0xFF	; 255
			uint8_t type = partition->type;
			if(type == PT_FAT12  || type == PT_FAT16A || type == PT_FAT16  ||  type == PT_FAT32  || type == PT_FAT32A || type == PT_FAT16B){
				// This is a recognised partition type
				disc->partitionType = type;
				disc->partitionStartSector = partition->LBA_begin;
				disc->partitionNumSectors = partition->numSectors;
     ea0:	20 51       	subi	r18, 0x10	; 16
     ea2:	30 40       	sbci	r19, 0x00	; 0
	uint8_t* buf=_ioGetSector(disc, 0, BUFFER_MODE_READONLY);

	if(buf){
		// Find the active partition
		PartitionEntry* partitions = (PartitionEntry*)(&buf[0x1BE]);
		for(int p=3; p>=0; p--){
     ea4:	24 17       	cp	r18, r20
     ea6:	35 07       	cpc	r19, r21
     ea8:	01 f4       	brne	.+0      	; 0xeaa <diskInit+0xe8>
				disc->partitionStartSector = partition->LBA_begin;
				disc->partitionNumSectors = partition->numSectors;
				rtn = TRUE;
			}
		}
		if(!rtn){
     eaa:	99 23       	and	r25, r25
     eac:	01 f4       	brne	.+0      	; 0xeae <diskInit+0xec>
			// No partition - so assume whole disk is FAT32
			const STORAGE_CLASS* class = disc->sclass;
     eae:	d7 01       	movw	r26, r14
     eb0:	ed 91       	ld	r30, X+
     eb2:	fc 91       	ld	r31, X
     eb4:	11 97       	sbiw	r26, 0x01	; 1

			disc->partitionType = PT_FAT32;
     eb6:	8b e0       	ldi	r24, 0x0B	; 11
     eb8:	15 96       	adiw	r26, 0x05	; 5
     eba:	8c 93       	st	X, r24
     ebc:	15 97       	sbiw	r26, 0x05	; 5
			disc->partitionStartSector = 0;
     ebe:	16 96       	adiw	r26, 0x06	; 6
     ec0:	1d 92       	st	X+, r1
     ec2:	1d 92       	st	X+, r1
     ec4:	1d 92       	st	X+, r1
     ec6:	1c 92       	st	X, r1
     ec8:	19 97       	sbiw	r26, 0x09	; 9

			SECTOR_COUNT (*getTotalSectors)(void*) = (SECTOR_COUNT (*)(void*))pgm_read_word(&class->getTotalSectors);
     eca:	34 96       	adiw	r30, 0x04	; 4
     ecc:	65 91       	lpm	r22, Z+
     ece:	74 91       	lpm	r23, Z
			disc->partitionNumSectors = getTotalSectors(disc->device);
     ed0:	12 96       	adiw	r26, 0x02	; 2
     ed2:	8d 91       	ld	r24, X+
     ed4:	9c 91       	ld	r25, X
     ed6:	13 97       	sbiw	r26, 0x03	; 3
     ed8:	fb 01       	movw	r30, r22
     eda:	09 95       	icall
     edc:	dc 01       	movw	r26, r24
     ede:	cb 01       	movw	r24, r22
     ee0:	f7 01       	movw	r30, r14
     ee2:	82 87       	std	Z+10, r24	; 0x0a
     ee4:	93 87       	std	Z+11, r25	; 0x0b
     ee6:	a4 87       	std	Z+12, r26	; 0x0c
     ee8:	b5 87       	std	Z+13, r27	; 0x0d
			rtn = TRUE;
		}
		// release the sector
		_ioReleaseSector(disc,buf);
     eea:	c7 01       	movw	r24, r14
     eec:	b8 01       	movw	r22, r16
     eee:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	return(TRUE);
}

static boolean _fatInit(DISK* disk){

	void* buf=_partitionGetSector(disk,0,BUFFER_MODE_READONLY); /* Load Volume label */
     ef2:	c7 01       	movw	r24, r14
     ef4:	40 e0       	ldi	r20, 0x00	; 0
     ef6:	50 e0       	ldi	r21, 0x00	; 0
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	70 e0       	ldi	r23, 0x00	; 0
     efc:	21 e0       	ldi	r18, 0x01	; 1
     efe:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
     f02:	6c 01       	movw	r12, r24
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     f04:	dc 01       	movw	r26, r24
     f06:	1b 96       	adiw	r26, 0x0b	; 11
     f08:	8d 91       	ld	r24, X+
     f0a:	9c 91       	ld	r25, X
     f0c:	1c 97       	sbiw	r26, 0x0c	; 12

	// Load the volume info
	disk->volume.bytesPerSector=get_uint16(buf,0x0B);
     f0e:	f7 01       	movw	r30, r14
     f10:	97 87       	std	Z+15, r25	; 0x0f
     f12:	86 87       	std	Z+14, r24	; 0x0e
	disk->volume.sectorsPerCluster=*((char*)(buf+0x0D));
     f14:	1d 96       	adiw	r26, 0x0d	; 13
     f16:	8c 91       	ld	r24, X
     f18:	1d 97       	sbiw	r26, 0x0d	; 13
     f1a:	80 8b       	std	Z+16, r24	; 0x10
     f1c:	1e 96       	adiw	r26, 0x0e	; 14
     f1e:	8d 91       	ld	r24, X+
     f20:	9c 91       	ld	r25, X
     f22:	1f 97       	sbiw	r26, 0x0f	; 15
	disk->volume.reservedSectorCount=get_uint16(buf,0x0E);
     f24:	92 8b       	std	Z+18, r25	; 0x12
     f26:	81 8b       	std	Z+17, r24	; 0x11
	disk->volume.numberOfFats=*((char*)(buf+0x10));
     f28:	50 96       	adiw	r26, 0x10	; 16
     f2a:	8c 91       	ld	r24, X
     f2c:	50 97       	sbiw	r26, 0x10	; 16
     f2e:	83 8b       	std	Z+19, r24	; 0x13
     f30:	51 96       	adiw	r26, 0x11	; 17
     f32:	8d 91       	ld	r24, X+
     f34:	9c 91       	ld	r25, X
     f36:	52 97       	sbiw	r26, 0x12	; 18
	disk->volume.rootDirEntryCount=get_uint16(buf,0x11);
     f38:	95 8b       	std	Z+21, r25	; 0x15
     f3a:	84 8b       	std	Z+20, r24	; 0x14
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     f3c:	9c 96       	adiw	r26, 0x2c	; 44
     f3e:	8d 91       	ld	r24, X+
     f40:	9d 91       	ld	r25, X+
     f42:	0d 90       	ld	r0, X+
     f44:	bc 91       	ld	r27, X
     f46:	a0 2d       	mov	r26, r0
	disk->volume.rootDirCluster=get_uint32(buf,0x2C);
     f48:	86 8b       	std	Z+22, r24	; 0x16
     f4a:	97 8b       	std	Z+23, r25	; 0x17
     f4c:	a0 8f       	std	Z+24, r26	; 0x18
     f4e:	b1 8f       	std	Z+25, r27	; 0x19
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     f50:	d6 01       	movw	r26, r12
     f52:	56 96       	adiw	r26, 0x16	; 22
     f54:	0d 91       	ld	r16, X+
     f56:	1c 91       	ld	r17, X
     f58:	57 97       	sbiw	r26, 0x17	; 23
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     f5a:	94 96       	adiw	r26, 0x24	; 36
     f5c:	8d 90       	ld	r8, X+
     f5e:	9d 90       	ld	r9, X+
     f60:	ad 90       	ld	r10, X+
     f62:	bc 90       	ld	r11, X
     f64:	97 97       	sbiw	r26, 0x27	; 39
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     f66:	53 96       	adiw	r26, 0x13	; 19
     f68:	4d 90       	ld	r4, X+
     f6a:	5c 90       	ld	r5, X
     f6c:	54 97       	sbiw	r26, 0x14	; 20
}
static __inline__ uint32_t get_uint32(const void* buf,size_t offset){
	return(*((const uint32_t*)(  ((const uint8_t*)buf) + offset)));
     f6e:	90 96       	adiw	r26, 0x20	; 32
     f70:	2d 91       	ld	r18, X+
     f72:	3d 91       	ld	r19, X+
     f74:	4d 91       	ld	r20, X+
     f76:	5c 91       	ld	r21, X
     f78:	93 97       	sbiw	r26, 0x23	; 35
     f7a:	29 83       	std	Y+1, r18	; 0x01
     f7c:	3a 83       	std	Y+2, r19	; 0x02
     f7e:	4b 83       	std	Y+3, r20	; 0x03
     f80:	5c 83       	std	Y+4, r21	; 0x04
     f82:	c7 01       	movw	r24, r14
     f84:	b6 01       	movw	r22, r12
     f86:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
typedef int (*Reader)(void);
#define MAKE_READER(name) int name(void)


static __inline__ uint16_t get_uint16(const void* buf,size_t offset){
	return(*((const uint16_t*)(  ((const uint8_t*)buf) + offset)) );
     f8a:	f6 01       	movw	r30, r12
     f8c:	e2 50       	subi	r30, 0x02	; 2
     f8e:	fe 4f       	sbci	r31, 0xFE	; 254
	uint32_t SectorCount32=get_uint32(buf,0x20);

	partition_releaseSector(disk,buf);

	// Check we have a valid FAT marker
	if( get_uint16(buf,0x1FE) != 0xAA55 ){
     f90:	80 81       	ld	r24, Z
     f92:	91 81       	ldd	r25, Z+1	; 0x01
     f94:	ba ea       	ldi	r27, 0xAA	; 170
     f96:	85 35       	cpi	r24, 0x55	; 85
     f98:	9b 07       	cpc	r25, r27
     f9a:	01 f0       	breq	.+0      	; 0xf9c <diskInit+0x1da>
     f9c:	00 c0       	rjmp	.+0      	; 0xf9e <diskInit+0x1dc>
		return FALSE;
	}


	/* Can only handle 512 byte sectors */
	if(disk->volume.bytesPerSector!=512)
     f9e:	f7 01       	movw	r30, r14
     fa0:	86 85       	ldd	r24, Z+14	; 0x0e
     fa2:	97 85       	ldd	r25, Z+15	; 0x0f
     fa4:	f2 e0       	ldi	r31, 0x02	; 2
     fa6:	80 30       	cpi	r24, 0x00	; 0
     fa8:	9f 07       	cpc	r25, r31
     faa:	01 f0       	breq	.+0      	; 0xfac <diskInit+0x1ea>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <diskInit+0x1ec>
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
     fae:	d7 01       	movw	r26, r14
     fb0:	50 96       	adiw	r26, 0x10	; 16
     fb2:	cc 90       	ld	r12, X
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
     fb4:	21 e0       	ldi	r18, 0x01	; 1
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	b0 e1       	ldi	r27, 0x10	; 16
     fba:	cb 16       	cp	r12, r27
     fbc:	01 f0       	breq	.+0      	; 0xfbe <diskInit+0x1fc>
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	30 e0       	ldi	r19, 0x00	; 0

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
     fc2:	81 e0       	ldi	r24, 0x01	; 1
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	e8 e0       	ldi	r30, 0x08	; 8
     fc8:	ce 16       	cp	r12, r30
     fca:	01 f0       	breq	.+0      	; 0xfcc <diskInit+0x20a>
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	90 e0       	ldi	r25, 0x00	; 0
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
     fd0:	28 2b       	or	r18, r24
     fd2:	39 2b       	or	r19, r25
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
	     (disk->volume.sectorsPerCluster == 32) |
     fd4:	81 e0       	ldi	r24, 0x01	; 1
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	f0 e2       	ldi	r31, 0x20	; 32
     fda:	cf 16       	cp	r12, r31
     fdc:	01 f0       	breq	.+0      	; 0xfde <diskInit+0x21c>
     fde:	80 e0       	ldi	r24, 0x00	; 0
     fe0:	90 e0       	ldi	r25, 0x00	; 0

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
     fe2:	28 2b       	or	r18, r24
     fe4:	39 2b       	or	r19, r25
	     (disk->volume.sectorsPerCluster == 16) |
	     (disk->volume.sectorsPerCluster == 32) |
	     (disk->volume.sectorsPerCluster == 64) ))
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	40 e4       	ldi	r20, 0x40	; 64
     fec:	c4 16       	cp	r12, r20
     fee:	01 f0       	breq	.+0      	; 0xff0 <diskInit+0x22e>
     ff0:	80 e0       	ldi	r24, 0x00	; 0
     ff2:	90 e0       	ldi	r25, 0x00	; 0
	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
     ff4:	28 2b       	or	r18, r24
     ff6:	39 2b       	or	r19, r25
	/* Can only handle 512 byte sectors */
	if(disk->volume.bytesPerSector!=512)
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
     ff8:	8c 2d       	mov	r24, r12
     ffa:	81 50       	subi	r24, 0x01	; 1
     ffc:	91 e0       	ldi	r25, 0x01	; 1
     ffe:	82 30       	cpi	r24, 0x02	; 2
    1000:	00 f0       	brcs	.+0      	; 0x1002 <diskInit+0x240>
    1002:	90 e0       	ldi	r25, 0x00	; 0
	     (disk->volume.sectorsPerCluster == 2 ) |
	     (disk->volume.sectorsPerCluster == 4 ) |
    1004:	81 e0       	ldi	r24, 0x01	; 1
    1006:	54 e0       	ldi	r21, 0x04	; 4
    1008:	c5 12       	cpse	r12, r21
    100a:	80 e0       	ldi	r24, 0x00	; 0
	if(disk->volume.bytesPerSector!=512)
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
	     (disk->volume.sectorsPerCluster == 2 ) |
    100c:	89 2b       	or	r24, r25
    100e:	90 e0       	ldi	r25, 0x00	; 0
	     (disk->volume.sectorsPerCluster == 4 ) |
	     (disk->volume.sectorsPerCluster == 8 ) |
	     (disk->volume.sectorsPerCluster == 16) |
	     (disk->volume.sectorsPerCluster == 32) |
    1010:	82 2b       	or	r24, r18
    1012:	93 2b       	or	r25, r19
	/* Can only handle 512 byte sectors */
	if(disk->volume.bytesPerSector!=512)
		return FALSE;

	/* Sectors per cluster must be a power of 2 */
	if(!((disk->volume.sectorsPerCluster == 1 ) |
    1014:	00 97       	sbiw	r24, 0x00	; 0
    1016:	01 f4       	brne	.+0      	; 0x1018 <diskInit+0x256>
    1018:	00 c0       	rjmp	.+0      	; 0x101a <diskInit+0x258>
	     (disk->volume.sectorsPerCluster == 32) |
	     (disk->volume.sectorsPerCluster == 64) ))
		return FALSE;

	/* There should be at least 1 reserved sector */
	if(disk->volume.reservedSectorCount==0)
    101a:	d7 01       	movw	r26, r14
    101c:	51 96       	adiw	r26, 0x11	; 17
    101e:	2d 91       	ld	r18, X+
    1020:	3c 91       	ld	r19, X
    1022:	52 97       	sbiw	r26, 0x12	; 18
    1024:	21 15       	cp	r18, r1
    1026:	31 05       	cpc	r19, r1
    1028:	01 f4       	brne	.+0      	; 0x102a <diskInit+0x268>
    102a:	00 c0       	rjmp	.+0      	; 0x102c <diskInit+0x26a>
		return FALSE;

	/* Find the number of sectors per FAT */
	disk->fatSectorCount = (FatSectorCount16 != 0) ? FatSectorCount16 : FatSectorCount32;
    102c:	01 15       	cp	r16, r1
    102e:	11 05       	cpc	r17, r1
    1030:	01 f0       	breq	.+0      	; 0x1032 <diskInit+0x270>
    1032:	48 01       	movw	r8, r16
    1034:	aa 24       	eor	r10, r10
    1036:	bb 24       	eor	r11, r11
    1038:	f7 01       	movw	r30, r14
    103a:	82 8e       	std	Z+26, r8	; 0x1a
    103c:	93 8e       	std	Z+27, r9	; 0x1b
    103e:	a4 8e       	std	Z+28, r10	; 0x1c
    1040:	b5 8e       	std	Z+29, r11	; 0x1d
	if(disk->fatSectorCount > disk->partitionNumSectors){
    1042:	82 85       	ldd	r24, Z+10	; 0x0a
    1044:	93 85       	ldd	r25, Z+11	; 0x0b
    1046:	a4 85       	ldd	r26, Z+12	; 0x0c
    1048:	b5 85       	ldd	r27, Z+13	; 0x0d
    104a:	88 15       	cp	r24, r8
    104c:	99 05       	cpc	r25, r9
    104e:	aa 05       	cpc	r26, r10
    1050:	bb 05       	cpc	r27, r11
    1052:	00 f4       	brcc	.+0      	; 0x1054 <diskInit+0x292>
    1054:	00 c0       	rjmp	.+0      	; 0x1056 <diskInit+0x294>
		return FALSE;
	}

	// Get the sector count
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;
    1056:	41 14       	cp	r4, r1
    1058:	51 04       	cpc	r5, r1
    105a:	01 f0       	breq	.+0      	; 0x105c <diskInit+0x29a>
    105c:	c2 01       	movw	r24, r4
    105e:	a0 e0       	ldi	r26, 0x00	; 0
    1060:	b0 e0       	ldi	r27, 0x00	; 0
    1062:	89 83       	std	Y+1, r24	; 0x01
    1064:	9a 83       	std	Y+2, r25	; 0x02
    1066:	ab 83       	std	Y+3, r26	; 0x03
    1068:	bc 83       	std	Y+4, r27	; 0x04
    106a:	89 81       	ldd	r24, Y+1	; 0x01
    106c:	9a 81       	ldd	r25, Y+2	; 0x02
    106e:	ab 81       	ldd	r26, Y+3	; 0x03
    1070:	bc 81       	ldd	r27, Y+4	; 0x04
    1072:	f7 01       	movw	r30, r14
    1074:	86 8f       	std	Z+30, r24	; 0x1e
    1076:	97 8f       	std	Z+31, r25	; 0x1f
    1078:	a0 a3       	std	Z+32, r26	; 0x20
    107a:	b1 a3       	std	Z+33, r27	; 0x21

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
				 (disk->volume.bytesPerSector - 1)) /
				 disk->volume.bytesPerSector;
	SECTOR dataSectorCount = disk->sectorCount - (
			disk->volume.reservedSectorCount +
    107c:	29 01       	movw	r4, r18
    107e:	66 24       	eor	r6, r6
    1080:	77 24       	eor	r7, r7
			(disk->volume.numberOfFats * disk->fatSectorCount) +
    1082:	23 89       	ldd	r18, Z+19	; 0x13
    1084:	30 e0       	ldi	r19, 0x00	; 0
    1086:	40 e0       	ldi	r20, 0x00	; 0
    1088:	50 e0       	ldi	r21, 0x00	; 0
    108a:	c5 01       	movw	r24, r10
    108c:	b4 01       	movw	r22, r8
    108e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1092:	4b 01       	movw	r8, r22
    1094:	5c 01       	movw	r10, r24
	}

	// Get the sector count
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
    1096:	d7 01       	movw	r26, r14
    1098:	54 96       	adiw	r26, 0x14	; 20
    109a:	8d 91       	ld	r24, X+
    109c:	9c 91       	ld	r25, X
    109e:	55 97       	sbiw	r26, 0x15	; 21
    10a0:	e5 e0       	ldi	r30, 0x05	; 5
    10a2:	88 0f       	add	r24, r24
    10a4:	99 1f       	adc	r25, r25
    10a6:	ea 95       	dec	r30
    10a8:	01 f4       	brne	.+0      	; 0x10aa <diskInit+0x2e8>
    10aa:	81 50       	subi	r24, 0x01	; 1
    10ac:	9e 4f       	sbci	r25, 0xFE	; 254
				 (disk->volume.bytesPerSector - 1)) /
    10ae:	89 2f       	mov	r24, r25
    10b0:	99 27       	eor	r25, r25
    10b2:	86 95       	lsr	r24
	}

	// Get the sector count
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
    10b4:	a0 e0       	ldi	r26, 0x00	; 0
    10b6:	b0 e0       	ldi	r27, 0x00	; 0
static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode);

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
    10b8:	84 0d       	add	r24, r4
    10ba:	95 1d       	adc	r25, r5
    10bc:	a6 1d       	adc	r26, r6
    10be:	b7 1d       	adc	r27, r7
    10c0:	88 0d       	add	r24, r8
    10c2:	99 1d       	adc	r25, r9
    10c4:	aa 1d       	adc	r26, r10
    10c6:	bb 1d       	adc	r27, r11
	disk->sectorCount = (SectorCount16!=0) ? SectorCount16 : SectorCount32;

	SECTOR rootDirSectors=((disk->volume.rootDirEntryCount*32) +
				 (disk->volume.bytesPerSector - 1)) /
				 disk->volume.bytesPerSector;
	SECTOR dataSectorCount = disk->sectorCount - (
    10c8:	29 81       	ldd	r18, Y+1	; 0x01
    10ca:	3a 81       	ldd	r19, Y+2	; 0x02
    10cc:	4b 81       	ldd	r20, Y+3	; 0x03
    10ce:	5c 81       	ldd	r21, Y+4	; 0x04
    10d0:	28 1b       	sub	r18, r24
    10d2:	39 0b       	sbc	r19, r25
    10d4:	4a 0b       	sbc	r20, r26
    10d6:	5b 0b       	sbc	r21, r27
    10d8:	ca 01       	movw	r24, r20
    10da:	b9 01       	movw	r22, r18
			disk->volume.reservedSectorCount +
			(disk->volume.numberOfFats * disk->fatSectorCount) +
			rootDirSectors);

	disk->dataClusterCount = dataSectorCount / disk->volume.sectorsPerCluster;
    10dc:	2c 2d       	mov	r18, r12
    10de:	30 e0       	ldi	r19, 0x00	; 0
    10e0:	40 e0       	ldi	r20, 0x00	; 0
    10e2:	50 e0       	ldi	r21, 0x00	; 0
    10e4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    10e8:	89 01       	movw	r16, r18
    10ea:	9a 01       	movw	r18, r20
    10ec:	d7 01       	movw	r26, r14
    10ee:	92 96       	adiw	r26, 0x22	; 34
    10f0:	0d 93       	st	X+, r16
    10f2:	1d 93       	st	X+, r17
    10f4:	2d 93       	st	X+, r18
    10f6:	3c 93       	st	X, r19
    10f8:	95 97       	sbiw	r26, 0x25	; 37

	// Calculate the type of FAT
	if(disk->dataClusterCount < 4085){			// 2^12 - 11
    10fa:	05 3f       	cpi	r16, 0xF5	; 245
    10fc:	bf e0       	ldi	r27, 0x0F	; 15
    10fe:	1b 07       	cpc	r17, r27
    1100:	b0 e0       	ldi	r27, 0x00	; 0
    1102:	2b 07       	cpc	r18, r27
    1104:	b0 e0       	ldi	r27, 0x00	; 0
    1106:	3b 07       	cpc	r19, r27
    1108:	00 f4       	brcc	.+0      	; 0x110a <diskInit+0x348>
		disk->fatType=12;
    110a:	8c e0       	ldi	r24, 0x0C	; 12
    110c:	00 c0       	rjmp	.+0      	; 0x110e <diskInit+0x34c>
		disk->volume.rootDirCluster=0;
	}else if(disk->dataClusterCount < 65525){	// 2^16 - 11
    110e:	05 3f       	cpi	r16, 0xF5	; 245
    1110:	bf ef       	ldi	r27, 0xFF	; 255
    1112:	1b 07       	cpc	r17, r27
    1114:	b0 e0       	ldi	r27, 0x00	; 0
    1116:	2b 07       	cpc	r18, r27
    1118:	b0 e0       	ldi	r27, 0x00	; 0
    111a:	3b 07       	cpc	r19, r27
    111c:	00 f4       	brcc	.+0      	; 0x111e <diskInit+0x35c>
		disk->fatType=16;
    111e:	80 e1       	ldi	r24, 0x10	; 16
    1120:	f7 01       	movw	r30, r14
    1122:	86 a3       	std	Z+38, r24	; 0x26
		disk->volume.rootDirCluster=0;
    1124:	16 8a       	std	Z+22, r1	; 0x16
    1126:	17 8a       	std	Z+23, r1	; 0x17
    1128:	10 8e       	std	Z+24, r1	; 0x18
    112a:	11 8e       	std	Z+25, r1	; 0x19
    112c:	00 c0       	rjmp	.+0      	; 0x112e <diskInit+0x36c>
	}else{
		disk->fatType=32;
    112e:	80 e2       	ldi	r24, 0x20	; 32
    1130:	f7 01       	movw	r30, r14
    1132:	86 a3       	std	Z+38, r24	; 0x26
	}

	// Find the first sector for the root directory
	disk->firstSectorRootDir = disk->volume.reservedSectorCount +
    1134:	84 0c       	add	r8, r4
    1136:	95 1c       	adc	r9, r5
    1138:	a6 1c       	adc	r10, r6
    113a:	b7 1c       	adc	r11, r7
    113c:	d7 01       	movw	r26, r14
    113e:	97 96       	adiw	r26, 0x27	; 39
    1140:	8d 92       	st	X+, r8
    1142:	9d 92       	st	X+, r9
    1144:	ad 92       	st	X+, r10
    1146:	bc 92       	st	X, r11
    1148:	9a 97       	sbiw	r26, 0x2a	; 42
	                         (disk->volume.numberOfFats * disk->fatSectorCount);
	if(disk->fatType==32){
    114a:	96 96       	adiw	r26, 0x26	; 38
    114c:	8c 91       	ld	r24, X
    114e:	96 97       	sbiw	r26, 0x26	; 38
    1150:	80 32       	cpi	r24, 0x20	; 32
    1152:	01 f4       	brne	.+0      	; 0x1154 <diskInit+0x392>
		disk->firstSectorRootDir += (disk->volume.rootDirCluster-2) * disk->volume.sectorsPerCluster;
    1154:	56 96       	adiw	r26, 0x16	; 22
    1156:	4d 90       	ld	r4, X+
    1158:	5d 90       	ld	r5, X+
    115a:	6d 90       	ld	r6, X+
    115c:	7c 90       	ld	r7, X
    115e:	59 97       	sbiw	r26, 0x19	; 25
    1160:	50 96       	adiw	r26, 0x10	; 16
    1162:	6c 91       	ld	r22, X
    1164:	70 e0       	ldi	r23, 0x00	; 0
    1166:	80 e0       	ldi	r24, 0x00	; 0
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	a3 01       	movw	r20, r6
    116c:	92 01       	movw	r18, r4
    116e:	22 50       	subi	r18, 0x02	; 2
    1170:	30 40       	sbci	r19, 0x00	; 0
    1172:	40 40       	sbci	r20, 0x00	; 0
    1174:	50 40       	sbci	r21, 0x00	; 0
    1176:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    117a:	dc 01       	movw	r26, r24
    117c:	cb 01       	movw	r24, r22
    117e:	88 0d       	add	r24, r8
    1180:	99 1d       	adc	r25, r9
    1182:	aa 1d       	adc	r26, r10
    1184:	bb 1d       	adc	r27, r11
    1186:	f7 01       	movw	r30, r14
    1188:	87 a3       	std	Z+39, r24	; 0x27
    118a:	90 a7       	std	Z+40, r25	; 0x28
    118c:	a1 a7       	std	Z+41, r26	; 0x29
    118e:	b2 a7       	std	Z+42, r27	; 0x2a
    1190:	00 c0       	rjmp	.+0      	; 0x1192 <diskInit+0x3d0>

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    1192:	91 e0       	ldi	r25, 0x01	; 1
    1194:	49 2e       	mov	r4, r25
    1196:	51 2c       	mov	r5, r1
    1198:	61 2c       	mov	r6, r1
    119a:	71 2c       	mov	r7, r1
	if(disk->fatType==32){
		disk->firstSectorRootDir += (disk->volume.rootDirCluster-2) * disk->volume.sectorsPerCluster;
	}

	// Initialise the current directory as root
	disk->firstClusterCurrentDir = _diskGetFirstClusterRootDir(disk);
    119c:	d7 01       	movw	r26, r14
    119e:	9b 96       	adiw	r26, 0x2b	; 43
    11a0:	4d 92       	st	X+, r4
    11a2:	5d 92       	st	X+, r5
    11a4:	6d 92       	st	X+, r6
    11a6:	7c 92       	st	X, r7
    11a8:	9e 97       	sbiw	r26, 0x2e	; 46
		rprintf("Root@%lu\n",disk->firstSectorRootDir);
		rprintf("Sec/Cluster=%u\n",disk->volume.sectorsPerCluster);
		rprintfInit(old);}
#endif

	return(TRUE);
    11aa:	8f ef       	ldi	r24, 0xFF	; 255
    11ac:	00 c0       	rjmp	.+0      	; 0x11ae <diskInit+0x3ec>

/*------------------------------------------------------------------------*/
/*					Disc												  */
/*------------------------------------------------------------------------*/
boolean diskInit(DISK *disc, uint8_t numBuffers, const STORAGE_CLASS* class, void* device){
	boolean rtn = FALSE;
    11ae:	80 e0       	ldi	r24, 0x00	; 0
		_ioReleaseSector(disc,buf);

		// Initialise the file system
		rtn &= _fatInit(disc);
	}
	disc->initialised = rtn;
    11b0:	f7 01       	movw	r30, r14
    11b2:	84 83       	std	Z+4, r24	; 0x04
	return rtn;
}
    11b4:	0f 90       	pop	r0
    11b6:	0f 90       	pop	r0
    11b8:	0f 90       	pop	r0
    11ba:	0f 90       	pop	r0
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	1f 91       	pop	r17
    11c2:	0f 91       	pop	r16
    11c4:	ff 90       	pop	r15
    11c6:	ef 90       	pop	r14
    11c8:	df 90       	pop	r13
    11ca:	cf 90       	pop	r12
    11cc:	bf 90       	pop	r11
    11ce:	af 90       	pop	r10
    11d0:	9f 90       	pop	r9
    11d2:	8f 90       	pop	r8
    11d4:	7f 90       	pop	r7
    11d6:	6f 90       	pop	r6
    11d8:	5f 90       	pop	r5
    11da:	4f 90       	pop	r4
    11dc:	08 95       	ret

000011de <_partitionDirectSectorRead>:
// Read a sector from inside a partition
void* _partitionGetSector(const DISK* disk, SECTOR partSector, uint8_t mode){
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
}

boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
    11de:	af 92       	push	r10
    11e0:	bf 92       	push	r11
    11e2:	cf 92       	push	r12
    11e4:	df 92       	push	r13
    11e6:	ef 92       	push	r14
    11e8:	ff 92       	push	r15
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
    11f2:	8c 01       	movw	r16, r24
    11f4:	6a 01       	movw	r12, r20
    11f6:	7b 01       	movw	r14, r22
    11f8:	b2 2e       	mov	r11, r18
    11fa:	a3 2e       	mov	r10, r19
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
    11fc:	fc 01       	movw	r30, r24
    11fe:	86 81       	ldd	r24, Z+6	; 0x06
    1200:	97 81       	ldd	r25, Z+7	; 0x07
    1202:	a0 85       	ldd	r26, Z+8	; 0x08
    1204:	b1 85       	ldd	r27, Z+9	; 0x09
    1206:	c8 0e       	add	r12, r24
    1208:	d9 1e       	adc	r13, r25
    120a:	ea 1e       	adc	r14, r26
    120c:	fb 1e       	adc	r15, r27
// Return TRUE if done or FALSE if error
static boolean _ioDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	BUFFER* buffer;

	// See if its already in the cache
	buffer=_ioFindSectorInCache(disk,address);
    120e:	c8 01       	movw	r24, r16
    1210:	b7 01       	movw	r22, r14
    1212:	a6 01       	movw	r20, r12
    1214:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1218:	ec 01       	movw	r28, r24
	if(!buffer){
    121a:	00 97       	sbiw	r24, 0x00	; 0
    121c:	01 f4       	brne	.+0      	; 0x121e <_partitionDirectSectorRead+0x40>
		// Try to find an unused cache area
		buffer=_bufferFindUnused(disk);
    121e:	c8 01       	movw	r24, r16
    1220:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1224:	ec 01       	movw	r28, r24
		if(buffer){
    1226:	00 97       	sbiw	r24, 0x00	; 0
    1228:	01 f0       	breq	.+0      	; 0x122a <_partitionDirectSectorRead+0x4c>
			// Read the sector into the cache
			if(!_ioPutSectorInCache(disk,buffer,address)){
    122a:	c8 01       	movw	r24, r16
    122c:	be 01       	movw	r22, r28
    122e:	a7 01       	movw	r20, r14
    1230:	96 01       	movw	r18, r12
    1232:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1236:	88 23       	and	r24, r24
    1238:	01 f0       	breq	.+0      	; 0x123a <_partitionDirectSectorRead+0x5c>
		}
	}

	if(buffer){
		// If its now in the cache then copy out the data
		memcpy(buf,buffer->dta,512);
    123a:	eb 2d       	mov	r30, r11
    123c:	fa 2d       	mov	r31, r10
    123e:	6a 96       	adiw	r28, 0x1a	; 26
    1240:	80 e0       	ldi	r24, 0x00	; 0
    1242:	92 e0       	ldi	r25, 0x02	; 2
    1244:	09 90       	ld	r0, Y+
    1246:	01 92       	st	Z+, r0
    1248:	01 97       	sbiw	r24, 0x01	; 1
    124a:	01 f4       	brne	.+0      	; 0x124c <_partitionDirectSectorRead+0x6e>
    124c:	00 c0       	rjmp	.+0      	; 0x124e <_partitionDirectSectorRead+0x70>
	}else{
		// Read it straight into user memory
		if(!_ioReadSector(disk,address,buf)){
			return(FALSE);
    124e:	80 e0       	ldi	r24, 0x00	; 0
	return(_ioGetSector(disk,partSector + disk->partitionStartSector,mode));
}

boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	ff 90       	pop	r15
    125a:	ef 90       	pop	r14
    125c:	df 90       	pop	r13
    125e:	cf 90       	pop	r12
    1260:	bf 90       	pop	r11
    1262:	af 90       	pop	r10
    1264:	08 95       	ret
		rprintf("[r%lu]",absSector);
		rprintfInit(old);}
#endif


	boolean (*read)(void*,SECTOR,void*) = (boolean (*)(void*,SECTOR,void*))pgm_read_word(&class->read);
    1266:	d8 01       	movw	r26, r16
    1268:	ed 91       	ld	r30, X+
    126a:	fc 91       	ld	r31, X
    126c:	a5 91       	lpm	r26, Z+
    126e:	b4 91       	lpm	r27, Z

	return read(disc->device,absSector,dta);
    1270:	f8 01       	movw	r30, r16
    1272:	82 81       	ldd	r24, Z+2	; 0x02
    1274:	93 81       	ldd	r25, Z+3	; 0x03
    1276:	b7 01       	movw	r22, r14
    1278:	a6 01       	movw	r20, r12
    127a:	2b 2d       	mov	r18, r11
    127c:	3a 2d       	mov	r19, r10
    127e:	fd 01       	movw	r30, r26
    1280:	09 95       	icall
	if(buffer){
		// If its now in the cache then copy out the data
		memcpy(buf,buffer->dta,512);
	}else{
		// Read it straight into user memory
		if(!_ioReadSector(disk,address,buf)){
    1282:	88 23       	and	r24, r24
    1284:	01 f0       	breq	.+0      	; 0x1286 <_partitionDirectSectorRead+0xa8>
			return(FALSE);
		}
	}

	return(TRUE);
    1286:	8f ef       	ldi	r24, 0xFF	; 255
    1288:	00 c0       	rjmp	.+0      	; 0x128a <_partitionDirectSectorWrite>

0000128a <_partitionDirectSectorWrite>:
}

boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
    128a:	af 92       	push	r10
    128c:	bf 92       	push	r11
    128e:	cf 92       	push	r12
    1290:	df 92       	push	r13
    1292:	ef 92       	push	r14
    1294:	ff 92       	push	r15
    1296:	0f 93       	push	r16
    1298:	1f 93       	push	r17
    129a:	cf 93       	push	r28
    129c:	df 93       	push	r29
    129e:	00 d0       	rcall	.+0      	; 0x12a0 <_partitionDirectSectorWrite+0x16>
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	5c 01       	movw	r10, r24
    12a6:	6a 01       	movw	r12, r20
    12a8:	7b 01       	movw	r14, r22
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
    12aa:	fc 01       	movw	r30, r24
    12ac:	86 81       	ldd	r24, Z+6	; 0x06
    12ae:	97 81       	ldd	r25, Z+7	; 0x07
    12b0:	a0 85       	ldd	r26, Z+8	; 0x08
    12b2:	b1 85       	ldd	r27, Z+9	; 0x09
    12b4:	c8 0e       	add	r12, r24
    12b6:	d9 1e       	adc	r13, r25
    12b8:	ea 1e       	adc	r14, r26
    12ba:	fb 1e       	adc	r15, r27

static boolean _ioDirectSectorWrite(const DISK* disk,SECTOR address, const void* buf){
	BUFFER* buffer;

	// If it exists in the cache
	buffer=_ioFindSectorInCache(disk,address);
    12bc:	c5 01       	movw	r24, r10
    12be:	b7 01       	movw	r22, r14
    12c0:	a6 01       	movw	r20, r12
    12c2:	29 83       	std	Y+1, r18	; 0x01
    12c4:	3a 83       	std	Y+2, r19	; 0x02
    12c6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    12ca:	dc 01       	movw	r26, r24
	if(buffer){
    12cc:	29 81       	ldd	r18, Y+1	; 0x01
    12ce:	3a 81       	ldd	r19, Y+2	; 0x02
    12d0:	00 97       	sbiw	r24, 0x00	; 0
    12d2:	01 f0       	breq	.+0      	; 0x12d4 <_partitionDirectSectorWrite+0x4a>
		// copy it to the cache
		memcpy(buffer->dta,buf,512);
    12d4:	bc 01       	movw	r22, r24
    12d6:	66 5e       	subi	r22, 0xE6	; 230
    12d8:	7f 4f       	sbci	r23, 0xFF	; 255
    12da:	a9 01       	movw	r20, r18
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	92 e0       	ldi	r25, 0x02	; 2
    12e0:	fa 01       	movw	r30, r20
    12e2:	01 90       	ld	r0, Z+
    12e4:	af 01       	movw	r20, r30
    12e6:	fb 01       	movw	r30, r22
    12e8:	01 92       	st	Z+, r0
    12ea:	bf 01       	movw	r22, r30
    12ec:	01 97       	sbiw	r24, 0x01	; 1
    12ee:	01 f4       	brne	.+0      	; 0x12f0 <_partitionDirectSectorWrite+0x66>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    12f0:	11 96       	adiw	r26, 0x01	; 1
    12f2:	8c 91       	ld	r24, X
    12f4:	11 97       	sbiw	r26, 0x01	; 1
    12f6:	90 e0       	ldi	r25, 0x00	; 0
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
    12f8:	fc 01       	movw	r30, r24
    12fa:	ee 0f       	add	r30, r30
    12fc:	ff 1f       	adc	r31, r31
    12fe:	e8 0f       	add	r30, r24
    1300:	f9 1f       	adc	r31, r25
    1302:	ee 0f       	add	r30, r30
    1304:	ff 1f       	adc	r31, r31
    1306:	32 96       	adiw	r30, 0x02	; 2
    1308:	ea 0f       	add	r30, r26
    130a:	fb 1f       	adc	r31, r27
    130c:	85 81       	ldd	r24, Z+5	; 0x05
    130e:	82 60       	ori	r24, 0x02	; 2
    1310:	00 c0       	rjmp	.+0      	; 0x1312 <_partitionDirectSectorWrite+0x88>
		_bufferSetWritable(buffer);
		return(TRUE);
	}

	// Try to find an available cache buffer entry
	buffer=_bufferFindUnused(disk);
    1312:	c5 01       	movw	r24, r10
    1314:	29 83       	std	Y+1, r18	; 0x01
    1316:	3a 83       	std	Y+2, r19	; 0x02
    1318:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    131c:	8c 01       	movw	r16, r24
	if(buffer){
    131e:	29 81       	ldd	r18, Y+1	; 0x01
    1320:	3a 81       	ldd	r19, Y+2	; 0x02
    1322:	00 97       	sbiw	r24, 0x00	; 0
    1324:	01 f4       	brne	.+0      	; 0x1326 <_partitionDirectSectorWrite+0x9c>
    1326:	00 c0       	rjmp	.+0      	; 0x1328 <_partitionDirectSectorWrite+0x9e>
		// copy it into the cache
		memcpy(buffer->dta,buf,512);
    1328:	fc 01       	movw	r30, r24
    132a:	7a 96       	adiw	r30, 0x1a	; 26
    132c:	d9 01       	movw	r26, r18
    132e:	80 e0       	ldi	r24, 0x00	; 0
    1330:	92 e0       	ldi	r25, 0x02	; 2
    1332:	0d 90       	ld	r0, X+
    1334:	01 92       	st	Z+, r0
    1336:	01 97       	sbiw	r24, 0x01	; 1
    1338:	01 f4       	brne	.+0      	; 0x133a <_partitionDirectSectorWrite+0xb0>
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    133a:	d8 01       	movw	r26, r16
    133c:	11 96       	adiw	r26, 0x01	; 1
    133e:	8c 91       	ld	r24, X
    1340:	90 e0       	ldi	r25, 0x00	; 0
	// Try to find an available cache buffer entry
	buffer=_bufferFindUnused(disk);
	if(buffer){
		// copy it into the cache
		memcpy(buffer->dta,buf,512);
		SECTOR_BUFFER* current = _bufferCurrentStackEntry(buffer);
    1342:	5c 01       	movw	r10, r24
    1344:	aa 0c       	add	r10, r10
    1346:	bb 1c       	adc	r11, r11
    1348:	a8 0e       	add	r10, r24
    134a:	b9 1e       	adc	r11, r25
    134c:	aa 0c       	add	r10, r10
    134e:	bb 1c       	adc	r11, r11
    1350:	e2 e0       	ldi	r30, 0x02	; 2
    1352:	f0 e0       	ldi	r31, 0x00	; 0
    1354:	ae 0e       	add	r10, r30
    1356:	bf 1e       	adc	r11, r31
    1358:	a0 0e       	add	r10, r16
    135a:	b1 1e       	adc	r11, r17
		// Set cache entry to indicate it needs writing
		_bufferReset(buffer);
    135c:	c8 01       	movw	r24, r16
    135e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		current->sector = address;
    1362:	d5 01       	movw	r26, r10
    1364:	cd 92       	st	X+, r12
    1366:	dd 92       	st	X+, r13
    1368:	ed 92       	st	X+, r14
    136a:	fc 92       	st	X, r15
    136c:	13 97       	sbiw	r26, 0x03	; 3
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    136e:	f8 01       	movw	r30, r16
    1370:	81 81       	ldd	r24, Z+1	; 0x01
    1372:	90 e0       	ldi	r25, 0x00	; 0
}
static boolean _bufferIsValid(BUFFER* buf){
	return(_bufferCurrentStackEntry(buf)->isValid) ? TRUE : FALSE;
}
static void _bufferSetWritable(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isWritable = 1;
    1374:	fc 01       	movw	r30, r24
    1376:	ee 0f       	add	r30, r30
    1378:	ff 1f       	adc	r31, r31
    137a:	e8 0f       	add	r30, r24
    137c:	f9 1f       	adc	r31, r25
    137e:	ee 0f       	add	r30, r30
    1380:	ff 1f       	adc	r31, r31
    1382:	32 96       	adiw	r30, 0x02	; 2
    1384:	e0 0f       	add	r30, r16
    1386:	f1 1f       	adc	r31, r17
    1388:	85 81       	ldd	r24, Z+5	; 0x05
    138a:	82 60       	ori	r24, 0x02	; 2
    138c:	85 83       	std	Z+5, r24	; 0x05
/*------------------------------------------------------------------------*/
/*					Buffer Management									  */
/*------------------------------------------------------------------------*/

static SECTOR_BUFFER* _bufferCurrentStackEntry(BUFFER* buf){
	return &buf->stack[ buf->depth ];
    138e:	d8 01       	movw	r26, r16
    1390:	11 96       	adiw	r26, 0x01	; 1
    1392:	8c 91       	ld	r24, X
    1394:	11 97       	sbiw	r26, 0x01	; 1
    1396:	90 e0       	ldi	r25, 0x00	; 0
}

static void _bufferSetValid(BUFFER* buf){
	_bufferCurrentStackEntry(buf)->isValid = 1;
    1398:	fc 01       	movw	r30, r24
    139a:	ee 0f       	add	r30, r30
    139c:	ff 1f       	adc	r31, r31
    139e:	e8 0f       	add	r30, r24
    13a0:	f9 1f       	adc	r31, r25
    13a2:	ee 0f       	add	r30, r30
    13a4:	ff 1f       	adc	r31, r31
    13a6:	32 96       	adiw	r30, 0x02	; 2
    13a8:	e0 0f       	add	r30, r16
    13aa:	f1 1f       	adc	r31, r17
    13ac:	85 81       	ldd	r24, Z+5	; 0x05
    13ae:	81 60       	ori	r24, 0x01	; 1
    13b0:	85 83       	std	Z+5, r24	; 0x05
		// Set cache entry to indicate it needs writing
		_bufferReset(buffer);
		current->sector = address;
		_bufferSetWritable(buffer);
		_bufferSetValid(buffer);				// indicate buffer is in use
		return(TRUE);
    13b2:	8f ef       	ldi	r24, 0xFF	; 255
    13b4:	00 c0       	rjmp	.+0      	; 0x13b6 <_partitionDirectSectorWrite+0x12c>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("[w%lu]",absSector);
		rprintfInit(old);}
#endif

	boolean (*write)(void*,SECTOR,const void*) = (boolean (*)(void*,SECTOR,const void*))pgm_read_word(&class->write);
    13b6:	d5 01       	movw	r26, r10
    13b8:	ed 91       	ld	r30, X+
    13ba:	fc 91       	ld	r31, X
    13bc:	32 96       	adiw	r30, 0x02	; 2
    13be:	a5 91       	lpm	r26, Z+
    13c0:	b4 91       	lpm	r27, Z

	return write(disc->device,absSector,dta);
    13c2:	f5 01       	movw	r30, r10
    13c4:	82 81       	ldd	r24, Z+2	; 0x02
    13c6:	93 81       	ldd	r25, Z+3	; 0x03
    13c8:	b7 01       	movw	r22, r14
    13ca:	a6 01       	movw	r20, r12
    13cc:	fd 01       	movw	r30, r26
    13ce:	09 95       	icall
boolean _partitionDirectSectorRead(const DISK *disk,SECTOR address, void* buf){
	return(_ioDirectSectorRead(disk,address + disk->partitionStartSector,buf));
}
boolean _partitionDirectSectorWrite(const DISK *disk,SECTOR address, const void* buf){
	return(_ioDirectSectorWrite(disk,address + disk->partitionStartSector,buf));
}
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	1f 91       	pop	r17
    13da:	0f 91       	pop	r16
    13dc:	ff 90       	pop	r15
    13de:	ef 90       	pop	r14
    13e0:	df 90       	pop	r13
    13e2:	cf 90       	pop	r12
    13e4:	bf 90       	pop	r11
    13e6:	af 90       	pop	r10
    13e8:	08 95       	ret

000013ea <_partitionClearCluster>:
static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
    13ea:	af 92       	push	r10
    13ec:	bf 92       	push	r11
    13ee:	cf 92       	push	r12
    13f0:	df 92       	push	r13
    13f2:	ef 92       	push	r14
    13f4:	ff 92       	push	r15
    13f6:	1f 93       	push	r17
    13f8:	cf 93       	push	r28
    13fa:	df 93       	push	r29
    13fc:	ec 01       	movw	r28, r24
	SECTOR sector = _diskClusterToSector(disk,cluster);
    13fe:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1402:	16 2f       	mov	r17, r22
    1404:	c6 2e       	mov	r12, r22
    1406:	d7 2e       	mov	r13, r23
    1408:	7c 01       	movw	r14, r24
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
		memclr(buf,512);
    140a:	a1 2c       	mov	r10, r1
    140c:	82 e0       	ldi	r24, 0x02	; 2
    140e:	b8 2e       	mov	r11, r24
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    1410:	00 c0       	rjmp	.+0      	; 0x1412 <_partitionClearCluster+0x28>
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
    1412:	ce 01       	movw	r24, r28
    1414:	b7 01       	movw	r22, r14
    1416:	a6 01       	movw	r20, r12
    1418:	22 e0       	ldi	r18, 0x02	; 2
    141a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    141e:	bc 01       	movw	r22, r24
		memclr(buf,512);
    1420:	dc 01       	movw	r26, r24
    1422:	c5 01       	movw	r24, r10
    1424:	1d 92       	st	X+, r1
    1426:	01 97       	sbiw	r24, 0x01	; 1
    1428:	01 f4       	brne	.+0      	; 0x142a <_partitionClearCluster+0x40>
    142a:	ce 01       	movw	r24, r28
    142c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    1430:	08 94       	sec
    1432:	c1 1c       	adc	r12, r1
    1434:	d1 1c       	adc	r13, r1
    1436:	e1 1c       	adc	r14, r1
    1438:	f1 1c       	adc	r15, r1
static boolean _partitionFlushRange(const DISK* disk,SECTOR addr_l, SECTOR addr_h){
	return( _ioFlushRange(disk,addr_l+ disk->partitionStartSector,addr_h+ disk->partitionStartSector));
}

// Clear the contents of a sector
void _partitionClearCluster(const DISK* disk,CLUSTER cluster){
    143a:	9c 2d       	mov	r25, r12
    143c:	91 1b       	sub	r25, r17
	SECTOR sector = _diskClusterToSector(disk,cluster);
	for(uint8_t c=0; c < (disk->volume.sectorsPerCluster); c++,sector++){
    143e:	88 89       	ldd	r24, Y+16	; 0x10
    1440:	98 17       	cp	r25, r24
    1442:	00 f0       	brcs	.+0      	; 0x1444 <_partitionClearCluster+0x5a>
		void* buf = _partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
		memclr(buf,512);
		partition_releaseSector(disk,buf);
	}
}
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	1f 91       	pop	r17
    144a:	ff 90       	pop	r15
    144c:	ef 90       	pop	r14
    144e:	df 90       	pop	r13
    1450:	cf 90       	pop	r12
    1452:	bf 90       	pop	r11
    1454:	af 90       	pop	r10
    1456:	08 95       	ret

00001458 <_fatGiveEndMarker>:
	return(TRUE);
}

// Return the cluster number that represent the end of chain marker

CLUSTER _fatGiveEndMarker(const DISK* disk){
    1458:	0f 93       	push	r16
    145a:	1f 93       	push	r17
	switch(disk->fatType){
    145c:	dc 01       	movw	r26, r24
    145e:	96 96       	adiw	r26, 0x26	; 38
    1460:	ec 91       	ld	r30, X
    1462:	96 97       	sbiw	r26, 0x26	; 38
    1464:	ec 50       	subi	r30, 0x0C	; 12
    1466:	e5 31       	cpi	r30, 0x15	; 21
    1468:	00 f4       	brcc	.+0      	; 0x146a <_fatGiveEndMarker+0x12>
    146a:	f0 e0       	ldi	r31, 0x00	; 0
    146c:	ee 0f       	add	r30, r30
    146e:	ff 1f       	adc	r31, r31
    1470:	ee 0f       	add	r30, r30
    1472:	ff 1f       	adc	r31, r31
    1474:	e0 50       	subi	r30, 0x00	; 0
    1476:	f0 40       	sbci	r31, 0x00	; 0
    1478:	00 81       	ld	r16, Z
    147a:	11 81       	ldd	r17, Z+1	; 0x01
    147c:	22 81       	ldd	r18, Z+2	; 0x02
    147e:	33 81       	ldd	r19, Z+3	; 0x03
    1480:	00 c0       	rjmp	.+0      	; 0x1482 <_fatGiveEndMarker+0x2a>
    1482:	00 e0       	ldi	r16, 0x00	; 0
    1484:	10 e0       	ldi	r17, 0x00	; 0
    1486:	20 e0       	ldi	r18, 0x00	; 0
    1488:	30 e0       	ldi	r19, 0x00	; 0
			return(CLUSTER)0xFFFFUL;
		case 32:
			return(CLUSTER)0x0FFFFFFFUL;
	}
	return(CLUSTER)0UL;
}
    148a:	b8 01       	movw	r22, r16
    148c:	c9 01       	movw	r24, r18
    148e:	1f 91       	pop	r17
    1490:	0f 91       	pop	r16
    1492:	08 95       	ret

00001494 <_fatNavigateTo>:
	return(TRUE);
}

// Attempt to find the given relative cluster starting at the current CLUSTER_NAV entry
// Return value: TRUE on success and FALSE if its not part of the cluster chain
boolean _fatNavigateTo(const DISK *disk, CLUSTER_NAV *nav,CLUSTER_COUNT relativeCluster){
    1494:	af 92       	push	r10
    1496:	bf 92       	push	r11
    1498:	cf 92       	push	r12
    149a:	df 92       	push	r13
    149c:	ef 92       	push	r14
    149e:	ff 92       	push	r15
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	5c 01       	movw	r10, r24
    14aa:	eb 01       	movw	r28, r22
    14ac:	69 01       	movw	r12, r18
    14ae:	7a 01       	movw	r14, r20

	// If we've gone backwards then start from the beginning
	if(relativeCluster<nav->relativeCluster || nav->currentCluster==0){
    14b0:	8c 81       	ldd	r24, Y+4	; 0x04
    14b2:	9d 81       	ldd	r25, Y+5	; 0x05
    14b4:	ae 81       	ldd	r26, Y+6	; 0x06
    14b6:	bf 81       	ldd	r27, Y+7	; 0x07
    14b8:	28 17       	cp	r18, r24
    14ba:	39 07       	cpc	r19, r25
    14bc:	4a 07       	cpc	r20, r26
    14be:	5b 07       	cpc	r21, r27
    14c0:	00 f0       	brcs	.+0      	; 0x14c2 <_fatNavigateTo+0x2e>
    14c2:	88 85       	ldd	r24, Y+8	; 0x08
    14c4:	99 85       	ldd	r25, Y+9	; 0x09
    14c6:	aa 85       	ldd	r26, Y+10	; 0x0a
    14c8:	bb 85       	ldd	r27, Y+11	; 0x0b
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	a1 05       	cpc	r26, r1
    14ce:	b1 05       	cpc	r27, r1
    14d0:	01 f4       	brne	.+0      	; 0x14d2 <_fatNavigateTo+0x3e>
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav From start\n");
		rprintfInit(old);}
#endif

		nav->relativeCluster=0;
    14d2:	1c 82       	std	Y+4, r1	; 0x04
    14d4:	1d 82       	std	Y+5, r1	; 0x05
    14d6:	1e 82       	std	Y+6, r1	; 0x06
    14d8:	1f 82       	std	Y+7, r1	; 0x07
		nav->currentCluster=nav->startCluster;
    14da:	8c 85       	ldd	r24, Y+12	; 0x0c
    14dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    14de:	ae 85       	ldd	r26, Y+14	; 0x0e
    14e0:	bf 85       	ldd	r27, Y+15	; 0x0f
    14e2:	88 87       	std	Y+8, r24	; 0x08
    14e4:	99 87       	std	Y+9, r25	; 0x09
    14e6:	aa 87       	std	Y+10, r26	; 0x0a
    14e8:	bb 87       	std	Y+11, r27	; 0x0b
		nav->contiguousCount=0;
    14ea:	18 82       	st	Y, r1
    14ec:	19 82       	std	Y+1, r1	; 0x01
    14ee:	1a 82       	std	Y+2, r1	; 0x02
    14f0:	1b 82       	std	Y+3, r1	; 0x03
	}

	if(nav->relativeCluster==relativeCluster){
    14f2:	8c 81       	ldd	r24, Y+4	; 0x04
    14f4:	9d 81       	ldd	r25, Y+5	; 0x05
    14f6:	ae 81       	ldd	r26, Y+6	; 0x06
    14f8:	bf 81       	ldd	r27, Y+7	; 0x07
    14fa:	8c 15       	cp	r24, r12
    14fc:	9d 05       	cpc	r25, r13
    14fe:	ae 05       	cpc	r26, r14
    1500:	bf 05       	cpc	r27, r15
    1502:	01 f4       	brne	.+0      	; 0x1504 <_fatNavigateTo+0x70>
    1504:	00 c0       	rjmp	.+0      	; 0x1506 <_fatNavigateTo+0x72>
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav find %lu, seek %lu, @%lu\n",nav->relativeCluster,relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif

		if(nav->contiguousCount!=0){
    1506:	88 81       	ld	r24, Y
    1508:	99 81       	ldd	r25, Y+1	; 0x01
    150a:	aa 81       	ldd	r26, Y+2	; 0x02
    150c:	bb 81       	ldd	r27, Y+3	; 0x03
    150e:	08 85       	ldd	r16, Y+8	; 0x08
    1510:	19 85       	ldd	r17, Y+9	; 0x09
    1512:	2a 85       	ldd	r18, Y+10	; 0x0a
    1514:	3b 85       	ldd	r19, Y+11	; 0x0b
    1516:	00 97       	sbiw	r24, 0x00	; 0
    1518:	a1 05       	cpc	r26, r1
    151a:	b1 05       	cpc	r27, r1
    151c:	01 f0       	breq	.+0      	; 0x151e <_fatNavigateTo+0x8a>
			// We already know the next one is contiguous
			nav->contiguousCount--;
    151e:	01 97       	sbiw	r24, 0x01	; 1
    1520:	a1 09       	sbc	r26, r1
    1522:	b1 09       	sbc	r27, r1
    1524:	88 83       	st	Y, r24
    1526:	99 83       	std	Y+1, r25	; 0x01
    1528:	aa 83       	std	Y+2, r26	; 0x02
    152a:	bb 83       	std	Y+3, r27	; 0x03
			nav->relativeCluster++;
    152c:	4f 5f       	subi	r20, 0xFF	; 255
    152e:	5f 4f       	sbci	r21, 0xFF	; 255
    1530:	6f 4f       	sbci	r22, 0xFF	; 255
    1532:	7f 4f       	sbci	r23, 0xFF	; 255
    1534:	4c 83       	std	Y+4, r20	; 0x04
    1536:	5d 83       	std	Y+5, r21	; 0x05
    1538:	6e 83       	std	Y+6, r22	; 0x06
    153a:	7f 83       	std	Y+7, r23	; 0x07
			nav->currentCluster++;
    153c:	0f 5f       	subi	r16, 0xFF	; 255
    153e:	1f 4f       	sbci	r17, 0xFF	; 255
    1540:	2f 4f       	sbci	r18, 0xFF	; 255
    1542:	3f 4f       	sbci	r19, 0xFF	; 255
    1544:	08 87       	std	Y+8, r16	; 0x08
    1546:	19 87       	std	Y+9, r17	; 0x09
    1548:	2a 87       	std	Y+10, r18	; 0x0a
    154a:	3b 87       	std	Y+11, r19	; 0x0b
    154c:	00 c0       	rjmp	.+0      	; 0x154e <_fatNavigateTo+0xba>
// Scan one sector of the FAT table to find the number of contiguous clusters
// Return value: TRUE on success, or FALSE when end of chain has been hit in which
//				case the chain has the LastCluster field set
static boolean _fatGetNextClusterChain(const DISK *disk, CLUSTER_NAV *chain){

	if(chain->currentCluster==0){
    154e:	01 15       	cp	r16, r1
    1550:	11 05       	cpc	r17, r1
    1552:	21 05       	cpc	r18, r1
    1554:	31 05       	cpc	r19, r1
    1556:	01 f0       	breq	.+0      	; 0x1558 <_fatNavigateTo+0xc4>
    1558:	c5 01       	movw	r24, r10
    155a:	be 01       	movw	r22, r28
    155c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			nav->contiguousCount--;
			nav->relativeCluster++;
			nav->currentCluster++;
		}else{
			// Get the next cluster chain
			if( !_fatGetNextClusterChain(disk,nav)){
    1560:	88 23       	and	r24, r24
    1562:	01 f0       	breq	.+0      	; 0x1564 <_fatNavigateTo+0xd0>

	if(nav->relativeCluster==relativeCluster){
		return TRUE;
	}

	while(nav->relativeCluster!=relativeCluster){
    1564:	4c 81       	ldd	r20, Y+4	; 0x04
    1566:	5d 81       	ldd	r21, Y+5	; 0x05
    1568:	6e 81       	ldd	r22, Y+6	; 0x06
    156a:	7f 81       	ldd	r23, Y+7	; 0x07
    156c:	4c 15       	cp	r20, r12
    156e:	5d 05       	cpc	r21, r13
    1570:	6e 05       	cpc	r22, r14
    1572:	7f 05       	cpc	r23, r15
    1574:	01 f4       	brne	.+0      	; 0x1576 <_fatNavigateTo+0xe2>
		nav->currentCluster=nav->startCluster;
		nav->contiguousCount=0;
	}

	if(nav->relativeCluster==relativeCluster){
		return TRUE;
    1576:	8f ef       	ldi	r24, 0xFF	; 255
    1578:	00 c0       	rjmp	.+0      	; 0x157a <_fatNavigateTo+0xe6>
#ifdef FAT_DEBUG
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav end %lu, seek %lu, @%lu\n",nav->relativeCluster,relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif
				return(FALSE);
    157a:	80 e0       	ldi	r24, 0x00	; 0
		{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Nav @%lu => %lu\n",nav->relativeCluster,nav->currentCluster);
		rprintfInit(old);}
#endif
	return(TRUE);
}
    157c:	df 91       	pop	r29
    157e:	cf 91       	pop	r28
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	ff 90       	pop	r15
    1586:	ef 90       	pop	r14
    1588:	df 90       	pop	r13
    158a:	cf 90       	pop	r12
    158c:	bf 90       	pop	r11
    158e:	af 90       	pop	r10
    1590:	08 95       	ret

00001592 <_fatSetNextClusterAddress>:
// Update the FAT to indicate that cluster_addr is followed by next_cluster_addr
void _fatSetNextClusterAddress(const DISK* disk,CLUSTER cluster_addr,CLUSTER next_cluster_addr){
    1592:	4f 92       	push	r4
    1594:	5f 92       	push	r5
    1596:	6f 92       	push	r6
    1598:	7f 92       	push	r7
    159a:	8f 92       	push	r8
    159c:	9f 92       	push	r9
    159e:	af 92       	push	r10
    15a0:	bf 92       	push	r11
    15a2:	cf 92       	push	r12
    15a4:	df 92       	push	r13
    15a6:	ef 92       	push	r14
    15a8:	ff 92       	push	r15
    15aa:	0f 93       	push	r16
    15ac:	1f 93       	push	r17
    15ae:	cf 93       	push	r28
    15b0:	df 93       	push	r29
    15b2:	ec 01       	movw	r28, r24
    15b4:	4a 01       	movw	r8, r20
    15b6:	5b 01       	movw	r10, r22
    15b8:	28 01       	movw	r4, r16
    15ba:	39 01       	movw	r6, r18
	SECTOR sector=_fatGetSectorAddressFatEntry(disk,cluster_addr);
    15bc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    15c0:	8b 01       	movw	r16, r22
    15c2:	9c 01       	movw	r18, r24

	if(( disk->fatSectorCount <= (sector - disk->volume.reservedSectorCount )||(sector==0))){
    15c4:	89 89       	ldd	r24, Y+17	; 0x11
    15c6:	9a 89       	ldd	r25, Y+18	; 0x12
    15c8:	a0 e0       	ldi	r26, 0x00	; 0
    15ca:	b0 e0       	ldi	r27, 0x00	; 0
    15cc:	b9 01       	movw	r22, r18
    15ce:	a8 01       	movw	r20, r16
    15d0:	48 1b       	sub	r20, r24
    15d2:	59 0b       	sbc	r21, r25
    15d4:	6a 0b       	sbc	r22, r26
    15d6:	7b 0b       	sbc	r23, r27
    15d8:	db 01       	movw	r26, r22
    15da:	ca 01       	movw	r24, r20
    15dc:	4a 8d       	ldd	r20, Y+26	; 0x1a
    15de:	5b 8d       	ldd	r21, Y+27	; 0x1b
    15e0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    15e2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    15e4:	84 17       	cp	r24, r20
    15e6:	95 07       	cpc	r25, r21
    15e8:	a6 07       	cpc	r26, r22
    15ea:	b7 07       	cpc	r27, r23
    15ec:	00 f0       	brcs	.+0      	; 0x15ee <_fatSetNextClusterAddress+0x5c>
    15ee:	00 c0       	rjmp	.+0      	; 0x15f0 <_fatSetNextClusterAddress+0x5e>
    15f0:	01 15       	cp	r16, r1
    15f2:	11 05       	cpc	r17, r1
    15f4:	21 05       	cpc	r18, r1
    15f6:	31 05       	cpc	r19, r1
    15f8:	01 f4       	brne	.+0      	; 0x15fa <_fatSetNextClusterAddress+0x68>
    15fa:	00 c0       	rjmp	.+0      	; 0x15fc <_fatSetNextClusterAddress+0x6a>
	    return;
	}

	uint8_t* buf=_partitionGetSector(disk,sector,BUFFER_MODE_READWRITE);
    15fc:	ce 01       	movw	r24, r28
    15fe:	b9 01       	movw	r22, r18
    1600:	a8 01       	movw	r20, r16
    1602:	22 e0       	ldi	r18, 0x02	; 2
    1604:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1608:	8c 01       	movw	r16, r24
	size_t offset;

	switch(disk->fatType){
    160a:	8e a1       	ldd	r24, Y+38	; 0x26
    160c:	80 31       	cpi	r24, 0x10	; 16
    160e:	01 f4       	brne	.+0      	; 0x1610 <_fatSetNextClusterAddress+0x7e>
    1610:	00 c0       	rjmp	.+0      	; 0x1612 <_fatSetNextClusterAddress+0x80>
    1612:	80 32       	cpi	r24, 0x20	; 32
    1614:	01 f4       	brne	.+0      	; 0x1616 <_fatSetNextClusterAddress+0x84>
    1616:	00 c0       	rjmp	.+0      	; 0x1618 <_fatSetNextClusterAddress+0x86>
    1618:	8c 30       	cpi	r24, 0x0C	; 12
    161a:	01 f0       	breq	.+0      	; 0x161c <_fatSetNextClusterAddress+0x8a>
    161c:	00 c0       	rjmp	.+0      	; 0x161e <_fatSetNextClusterAddress+0x8c>
		case 12:
			offset = ((cluster_addr%1024)*3/2)%512;
    161e:	b5 01       	movw	r22, r10
    1620:	a4 01       	movw	r20, r8
    1622:	53 70       	andi	r21, 0x03	; 3
    1624:	60 70       	andi	r22, 0x00	; 0
    1626:	70 70       	andi	r23, 0x00	; 0
    1628:	db 01       	movw	r26, r22
    162a:	ca 01       	movw	r24, r20
    162c:	88 0f       	add	r24, r24
    162e:	99 1f       	adc	r25, r25
    1630:	aa 1f       	adc	r26, r26
    1632:	bb 1f       	adc	r27, r27
    1634:	84 0f       	add	r24, r20
    1636:	95 1f       	adc	r25, r21
    1638:	a6 1f       	adc	r26, r22
    163a:	b7 1f       	adc	r27, r23
    163c:	b6 95       	lsr	r27
    163e:	a7 95       	ror	r26
    1640:	97 95       	ror	r25
    1642:	87 95       	ror	r24
    1644:	91 70       	andi	r25, 0x01	; 1
    1646:	a1 e0       	ldi	r26, 0x01	; 1
    1648:	ca 2e       	mov	r12, r26
    164a:	d1 2c       	mov	r13, r1
    164c:	e1 2c       	mov	r14, r1
    164e:	f1 2c       	mov	r15, r1
    1650:	c8 20       	and	r12, r8
    1652:	d9 20       	and	r13, r9
    1654:	ea 20       	and	r14, r10
    1656:	fb 20       	and	r15, r11
    1658:	f8 01       	movw	r30, r16
			if(offset == 511){
    165a:	51 e0       	ldi	r21, 0x01	; 1
    165c:	8f 3f       	cpi	r24, 0xFF	; 255
    165e:	95 07       	cpc	r25, r21
    1660:	01 f4       	brne	.+0      	; 0x1662 <_fatSetNextClusterAddress+0xd0>
    1662:	e1 50       	subi	r30, 0x01	; 1
    1664:	fe 4f       	sbci	r31, 0xFE	; 254
				if(cluster_addr%2==0){
    1666:	c1 14       	cp	r12, r1
    1668:	d1 04       	cpc	r13, r1
    166a:	e1 04       	cpc	r14, r1
    166c:	f1 04       	cpc	r15, r1
    166e:	01 f4       	brne	.+0      	; 0x1670 <_fatSetNextClusterAddress+0xde>
					buf[offset] = next_cluster_addr & 0xFF;
    1670:	40 82       	st	Z, r4
    1672:	00 c0       	rjmp	.+0      	; 0x1674 <_fatSetNextClusterAddress+0xe2>
				}else{
					buf[offset] = (buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
    1674:	80 81       	ld	r24, Z
    1676:	8f 70       	andi	r24, 0x0F	; 15
    1678:	94 2d       	mov	r25, r4
    167a:	92 95       	swap	r25
    167c:	90 7f       	andi	r25, 0xF0	; 240
    167e:	89 0f       	add	r24, r25
    1680:	80 83       	st	Z, r24
				}
				// Read second sector
				uint8_t* buf2=_partitionGetSector(disk,_fatGetSectorAddressFatEntry(disk,cluster_addr)+1,BUFFER_MODE_READWRITE);
    1682:	ce 01       	movw	r24, r28
    1684:	b5 01       	movw	r22, r10
    1686:	a4 01       	movw	r20, r8
    1688:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    168c:	ab 01       	movw	r20, r22
    168e:	bc 01       	movw	r22, r24
    1690:	4f 5f       	subi	r20, 0xFF	; 255
    1692:	5f 4f       	sbci	r21, 0xFF	; 255
    1694:	6f 4f       	sbci	r22, 0xFF	; 255
    1696:	7f 4f       	sbci	r23, 0xFF	; 255
    1698:	ce 01       	movw	r24, r28
    169a:	22 e0       	ldi	r18, 0x02	; 2
    169c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    16a0:	fc 01       	movw	r30, r24
				if(cluster_addr%2==0){
    16a2:	c1 14       	cp	r12, r1
    16a4:	d1 04       	cpc	r13, r1
    16a6:	e1 04       	cpc	r14, r1
    16a8:	f1 04       	cpc	r15, r1
    16aa:	01 f4       	brne	.+0      	; 0x16ac <_fatSetNextClusterAddress+0x11a>
					buf2[0]=(buf2[0]&0xF0)+((next_cluster_addr>>8)&0xF);
    16ac:	80 81       	ld	r24, Z
    16ae:	80 7f       	andi	r24, 0xF0	; 240
    16b0:	95 2d       	mov	r25, r5
    16b2:	9f 70       	andi	r25, 0x0F	; 15
    16b4:	89 0f       	add	r24, r25
    16b6:	80 83       	st	Z, r24
    16b8:	00 c0       	rjmp	.+0      	; 0x16ba <_fatSetNextClusterAddress+0x128>
				}else{
					buf2[0]=(next_cluster_addr>>4)&0xFF;
    16ba:	54 e0       	ldi	r21, 0x04	; 4
    16bc:	76 94       	lsr	r7
    16be:	67 94       	ror	r6
    16c0:	57 94       	ror	r5
    16c2:	47 94       	ror	r4
    16c4:	5a 95       	dec	r21
    16c6:	01 f4       	brne	.+0      	; 0x16c8 <_fatSetNextClusterAddress+0x136>
    16c8:	40 82       	st	Z, r4
    16ca:	ce 01       	movw	r24, r28
    16cc:	bf 01       	movw	r22, r30
    16ce:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    16d2:	00 c0       	rjmp	.+0      	; 0x16d4 <_fatSetNextClusterAddress+0x142>
    16d4:	e8 0f       	add	r30, r24
    16d6:	f9 1f       	adc	r31, r25
				}
				// Write second sector
				partition_releaseSector(disk,buf2);
			}else{
				if(cluster_addr%2==0){
    16d8:	c1 14       	cp	r12, r1
    16da:	d1 04       	cpc	r13, r1
    16dc:	e1 04       	cpc	r14, r1
    16de:	f1 04       	cpc	r15, r1
    16e0:	01 f4       	brne	.+0      	; 0x16e2 <_fatSetNextClusterAddress+0x150>
					buf[offset]=next_cluster_addr&0xFF;
    16e2:	40 82       	st	Z, r4
					buf[offset+1]=(buf[offset+1]&0xF0)+((next_cluster_addr>>8)&0xF);
    16e4:	fc 01       	movw	r30, r24
    16e6:	31 96       	adiw	r30, 0x01	; 1
    16e8:	e0 0f       	add	r30, r16
    16ea:	f1 1f       	adc	r31, r17
    16ec:	80 81       	ld	r24, Z
    16ee:	80 7f       	andi	r24, 0xF0	; 240
    16f0:	95 2d       	mov	r25, r5
    16f2:	9f 70       	andi	r25, 0x0F	; 15
    16f4:	89 0f       	add	r24, r25
    16f6:	80 83       	st	Z, r24
    16f8:	00 c0       	rjmp	.+0      	; 0x16fa <_fatSetNextClusterAddress+0x168>
				}else{
					buf[offset]=(buf[offset]&0xF)+((next_cluster_addr<<4)&0xF0);
    16fa:	80 81       	ld	r24, Z
    16fc:	8f 70       	andi	r24, 0x0F	; 15
    16fe:	94 2d       	mov	r25, r4
    1700:	92 95       	swap	r25
    1702:	90 7f       	andi	r25, 0xF0	; 240
    1704:	89 0f       	add	r24, r25
    1706:	80 83       	st	Z, r24
					buf[offset+1]=(next_cluster_addr>>4)&0xFF;
    1708:	44 e0       	ldi	r20, 0x04	; 4
    170a:	76 94       	lsr	r7
    170c:	67 94       	ror	r6
    170e:	57 94       	ror	r5
    1710:	47 94       	ror	r4
    1712:	4a 95       	dec	r20
    1714:	01 f4       	brne	.+0      	; 0x1716 <_fatSetNextClusterAddress+0x184>
    1716:	41 82       	std	Z+1, r4	; 0x01
    1718:	00 c0       	rjmp	.+0      	; 0x171a <_fatSetNextClusterAddress+0x188>
				}
			}
			break;
		case 16:
			offset=cluster_addr%256;
    171a:	f4 01       	movw	r30, r8
    171c:	f0 70       	andi	r31, 0x00	; 0
			*((uint16_t*)buf+offset)=next_cluster_addr;
    171e:	ee 0f       	add	r30, r30
    1720:	ff 1f       	adc	r31, r31
    1722:	e0 0f       	add	r30, r16
    1724:	f1 1f       	adc	r31, r17
    1726:	51 82       	std	Z+1, r5	; 0x01
    1728:	40 82       	st	Z, r4
			break;
    172a:	00 c0       	rjmp	.+0      	; 0x172c <_fatSetNextClusterAddress+0x19a>
		case 32:
			offset=cluster_addr%128;
    172c:	f4 01       	movw	r30, r8
    172e:	ef 77       	andi	r30, 0x7F	; 127
    1730:	f0 70       	andi	r31, 0x00	; 0
			*((uint32_t*)buf+offset)=next_cluster_addr;
    1732:	ee 0f       	add	r30, r30
    1734:	ff 1f       	adc	r31, r31
    1736:	ee 0f       	add	r30, r30
    1738:	ff 1f       	adc	r31, r31
    173a:	e0 0f       	add	r30, r16
    173c:	f1 1f       	adc	r31, r17
    173e:	40 82       	st	Z, r4
    1740:	51 82       	std	Z+1, r5	; 0x01
    1742:	62 82       	std	Z+2, r6	; 0x02
    1744:	73 82       	std	Z+3, r7	; 0x03
    1746:	ce 01       	movw	r24, r28
    1748:	b8 01       	movw	r22, r16
    174a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			break;
	}
	partition_releaseSector(disk,buf);
}
    174e:	df 91       	pop	r29
    1750:	cf 91       	pop	r28
    1752:	1f 91       	pop	r17
    1754:	0f 91       	pop	r16
    1756:	ff 90       	pop	r15
    1758:	ef 90       	pop	r14
    175a:	df 90       	pop	r13
    175c:	cf 90       	pop	r12
    175e:	bf 90       	pop	r11
    1760:	af 90       	pop	r10
    1762:	9f 90       	pop	r9
    1764:	8f 90       	pop	r8
    1766:	7f 90       	pop	r7
    1768:	6f 90       	pop	r6
    176a:	5f 90       	pop	r5
    176c:	4f 90       	pop	r4
    176e:	08 95       	ret

00001770 <_fatGetFreeCluster>:

// Find a free cluster on the disk
// Return the cluster or 0 if the disk is full
CLUSTER _fatGetFreeCluster(DISK* disk){
    1770:	2f 92       	push	r2
    1772:	3f 92       	push	r3
    1774:	4f 92       	push	r4
    1776:	5f 92       	push	r5
    1778:	6f 92       	push	r6
    177a:	7f 92       	push	r7
    177c:	8f 92       	push	r8
    177e:	9f 92       	push	r9
    1780:	af 92       	push	r10
    1782:	bf 92       	push	r11
    1784:	cf 92       	push	r12
    1786:	df 92       	push	r13
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	cf 93       	push	r28
    1792:	df 93       	push	r29
    1794:	00 d0       	rcall	.+0      	; 0x1796 <_fatGetFreeCluster+0x26>
    1796:	00 d0       	rcall	.+0      	; 0x1798 <_fatGetFreeCluster+0x28>
    1798:	cd b7       	in	r28, 0x3d	; 61
    179a:	de b7       	in	r29, 0x3e	; 62
    179c:	1c 01       	movw	r2, r24
	CLUSTER start = disk->freeClusterHint;
    179e:	dc 01       	movw	r26, r24
    17a0:	9f 96       	adiw	r26, 0x2f	; 47
    17a2:	8d 90       	ld	r8, X+
    17a4:	9d 90       	ld	r9, X+
    17a6:	ad 90       	ld	r10, X+
    17a8:	bc 90       	ld	r11, X
    17aa:	d2 97       	sbiw	r26, 0x32	; 50
	if(start < 2 || start > disk->dataClusterCount){
    17ac:	b2 e0       	ldi	r27, 0x02	; 2
    17ae:	8b 16       	cp	r8, r27
    17b0:	91 04       	cpc	r9, r1
    17b2:	a1 04       	cpc	r10, r1
    17b4:	b1 04       	cpc	r11, r1
    17b6:	00 f0       	brcs	.+0      	; 0x17b8 <_fatGetFreeCluster+0x48>
    17b8:	fc 01       	movw	r30, r24
    17ba:	82 a1       	ldd	r24, Z+34	; 0x22
    17bc:	93 a1       	ldd	r25, Z+35	; 0x23
    17be:	a4 a1       	ldd	r26, Z+36	; 0x24
    17c0:	b5 a1       	ldd	r27, Z+37	; 0x25
    17c2:	88 15       	cp	r24, r8
    17c4:	99 05       	cpc	r25, r9
    17c6:	aa 05       	cpc	r26, r10
    17c8:	bb 05       	cpc	r27, r11
    17ca:	00 f4       	brcc	.+0      	; 0x17cc <_fatGetFreeCluster+0x5c>
		start = 2;
    17cc:	12 e0       	ldi	r17, 0x02	; 2
    17ce:	81 2e       	mov	r8, r17
    17d0:	91 2c       	mov	r9, r1
    17d2:	a1 2c       	mov	r10, r1
    17d4:	b1 2c       	mov	r11, r1
#endif


	SECTOR fatSector=0;
	void*  fatBuf=null;
	CLUSTER current = start;
    17d6:	75 01       	movw	r14, r10
    17d8:	64 01       	movw	r12, r8
		rprintfInit(old);}
#endif


	SECTOR fatSector=0;
	void*  fatBuf=null;
    17da:	00 e0       	ldi	r16, 0x00	; 0
    17dc:	10 e0       	ldi	r17, 0x00	; 0
		rprintf("Start Get Free Cluster\n");
		rprintfInit(old);}
#endif


	SECTOR fatSector=0;
    17de:	19 82       	std	Y+1, r1	; 0x01
    17e0:	1a 82       	std	Y+2, r1	; 0x02
    17e2:	1b 82       	std	Y+3, r1	; 0x03
    17e4:	1c 82       	std	Y+4, r1	; 0x04
	void*  fatBuf=null;
	CLUSTER current = start;
	CLUSTER rtn = 0;
	while(rtn==0){
		SECTOR sector=_fatGetSectorAddressFatEntry(disk,current);
    17e6:	c1 01       	movw	r24, r2
    17e8:	b7 01       	movw	r22, r14
    17ea:	a6 01       	movw	r20, r12
    17ec:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    17f0:	2b 01       	movw	r4, r22
    17f2:	3c 01       	movw	r6, r24

		if(sector != fatSector ){
    17f4:	89 81       	ldd	r24, Y+1	; 0x01
    17f6:	9a 81       	ldd	r25, Y+2	; 0x02
    17f8:	ab 81       	ldd	r26, Y+3	; 0x03
    17fa:	bc 81       	ldd	r27, Y+4	; 0x04
    17fc:	48 16       	cp	r4, r24
    17fe:	59 06       	cpc	r5, r25
    1800:	6a 06       	cpc	r6, r26
    1802:	7b 06       	cpc	r7, r27
    1804:	01 f0       	breq	.+0      	; 0x1806 <_fatGetFreeCluster+0x96>
			// Release any existing sector
			if(fatBuf){
    1806:	01 15       	cp	r16, r1
    1808:	11 05       	cpc	r17, r1
    180a:	01 f0       	breq	.+0      	; 0x180c <_fatGetFreeCluster+0x9c>
    180c:	c1 01       	movw	r24, r2
    180e:	b8 01       	movw	r22, r16
    1810:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
				partition_releaseSector(disk,fatBuf);
				fatBuf = null;
			}
			// Read the new sector
			fatSector = sector;
			fatBuf = _partitionGetSector(disk,fatSector,BUFFER_MODE_READONLY);
    1814:	c1 01       	movw	r24, r2
    1816:	b3 01       	movw	r22, r6
    1818:	a2 01       	movw	r20, r4
    181a:	21 e0       	ldi	r18, 0x01	; 1
    181c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1820:	8c 01       	movw	r16, r24
    1822:	49 82       	std	Y+1, r4	; 0x01
    1824:	5a 82       	std	Y+2, r5	; 0x02
    1826:	6b 82       	std	Y+3, r6	; 0x03
    1828:	7c 82       	std	Y+4, r7	; 0x04
		}

		CLUSTER next = _fatGetNextClusterAddressInRAM(disk,current,fatBuf);
    182a:	c1 01       	movw	r24, r2
    182c:	b7 01       	movw	r22, r14
    182e:	a6 01       	movw	r20, r12
    1830:	98 01       	movw	r18, r16
    1832:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1836:	dc 01       	movw	r26, r24
    1838:	cb 01       	movw	r24, r22
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("Cluster %lu, next=%lu\n",current,next);
		rprintfInit(old);}
#endif

		if( next == 0){
    183a:	00 97       	sbiw	r24, 0x00	; 0
    183c:	a1 05       	cpc	r26, r1
    183e:	b1 05       	cpc	r27, r1
    1840:	01 f0       	breq	.+0      	; 0x1842 <_fatGetFreeCluster+0xd2>
			rtn = current;
		}else{
			// try the next one and wrap around if reqd
			if(++current > disk->dataClusterCount){
    1842:	08 94       	sec
    1844:	c1 1c       	adc	r12, r1
    1846:	d1 1c       	adc	r13, r1
    1848:	e1 1c       	adc	r14, r1
    184a:	f1 1c       	adc	r15, r1
    184c:	f1 01       	movw	r30, r2
    184e:	82 a1       	ldd	r24, Z+34	; 0x22
    1850:	93 a1       	ldd	r25, Z+35	; 0x23
    1852:	a4 a1       	ldd	r26, Z+36	; 0x24
    1854:	b5 a1       	ldd	r27, Z+37	; 0x25
    1856:	8c 15       	cp	r24, r12
    1858:	9d 05       	cpc	r25, r13
    185a:	ae 05       	cpc	r26, r14
    185c:	bf 05       	cpc	r27, r15
    185e:	00 f4       	brcc	.+0      	; 0x1860 <_fatGetFreeCluster+0xf0>
				current = 2;
    1860:	b2 e0       	ldi	r27, 0x02	; 2
    1862:	cb 2e       	mov	r12, r27
    1864:	d1 2c       	mov	r13, r1
    1866:	e1 2c       	mov	r14, r1
    1868:	f1 2c       	mov	r15, r1
			}

			// If we are back at the start then exit - everthing is full
			if(current==start){
    186a:	c8 14       	cp	r12, r8
    186c:	d9 04       	cpc	r13, r9
    186e:	ea 04       	cpc	r14, r10
    1870:	fb 04       	cpc	r15, r11
    1872:	01 f0       	breq	.+0      	; 0x1874 <_fatGetFreeCluster+0x104>
    1874:	00 c0       	rjmp	.+0      	; 0x1876 <_fatGetFreeCluster+0x106>
    1876:	00 c0       	rjmp	.+0      	; 0x1878 <_fatGetFreeCluster+0x108>

	SECTOR fatSector=0;
	void*  fatBuf=null;
	CLUSTER current = start;
	CLUSTER rtn = 0;
	while(rtn==0){
    1878:	c1 14       	cp	r12, r1
    187a:	d1 04       	cpc	r13, r1
    187c:	e1 04       	cpc	r14, r1
    187e:	f1 04       	cpc	r15, r1
    1880:	01 f4       	brne	.+0      	; 0x1882 <_fatGetFreeCluster+0x112>
    1882:	00 c0       	rjmp	.+0      	; 0x1884 <_fatGetFreeCluster+0x114>
    1884:	00 c0       	rjmp	.+0      	; 0x1886 <_fatGetFreeCluster+0x116>
			if(++current > disk->dataClusterCount){
				current = 2;
			}

			// If we are back at the start then exit - everthing is full
			if(current==start){
    1886:	cc 24       	eor	r12, r12
    1888:	dd 24       	eor	r13, r13
    188a:	76 01       	movw	r14, r12
			}
		}
	}

	// Release the current buffer
	if(fatBuf){
    188c:	01 15       	cp	r16, r1
    188e:	11 05       	cpc	r17, r1
    1890:	01 f0       	breq	.+0      	; 0x1892 <_fatGetFreeCluster+0x122>
    1892:	c1 01       	movw	r24, r2
    1894:	b8 01       	movw	r22, r16
    1896:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		partition_releaseSector(disk,fatBuf);
	}
	disk->freeClusterHint = rtn;
    189a:	d1 01       	movw	r26, r2
    189c:	9f 96       	adiw	r26, 0x2f	; 47
    189e:	cd 92       	st	X+, r12
    18a0:	dd 92       	st	X+, r13
    18a2:	ed 92       	st	X+, r14
    18a4:	fc 92       	st	X, r15
    18a6:	d2 97       	sbiw	r26, 0x32	; 50
		rprintf("End Get Free Cluster=%lu\n",rtn);
		rprintfInit(old);}
#endif

	return rtn;
}
    18a8:	b6 01       	movw	r22, r12
    18aa:	c7 01       	movw	r24, r14
    18ac:	0f 90       	pop	r0
    18ae:	0f 90       	pop	r0
    18b0:	0f 90       	pop	r0
    18b2:	0f 90       	pop	r0
    18b4:	df 91       	pop	r29
    18b6:	cf 91       	pop	r28
    18b8:	1f 91       	pop	r17
    18ba:	0f 91       	pop	r16
    18bc:	ff 90       	pop	r15
    18be:	ef 90       	pop	r14
    18c0:	df 90       	pop	r13
    18c2:	cf 90       	pop	r12
    18c4:	bf 90       	pop	r11
    18c6:	af 90       	pop	r10
    18c8:	9f 90       	pop	r9
    18ca:	8f 90       	pop	r8
    18cc:	7f 90       	pop	r7
    18ce:	6f 90       	pop	r6
    18d0:	5f 90       	pop	r5
    18d2:	4f 90       	pop	r4
    18d4:	3f 90       	pop	r3
    18d6:	2f 90       	pop	r2
    18d8:	08 95       	ret

000018da <_fatExtend>:

// Append 'num_clusters' to the end of the cluster chain
// Return TRUE on success, FALSE if the FAT is full
boolean _fatExtend(DISK* disk,CLUSTER_NAV *nav,CLUSTER_COUNT num_clusters){
    18da:	2f 92       	push	r2
    18dc:	3f 92       	push	r3
    18de:	4f 92       	push	r4
    18e0:	5f 92       	push	r5
    18e2:	6f 92       	push	r6
    18e4:	7f 92       	push	r7
    18e6:	8f 92       	push	r8
    18e8:	9f 92       	push	r9
    18ea:	af 92       	push	r10
    18ec:	bf 92       	push	r11
    18ee:	cf 92       	push	r12
    18f0:	df 92       	push	r13
    18f2:	ef 92       	push	r14
    18f4:	ff 92       	push	r15
    18f6:	0f 93       	push	r16
    18f8:	1f 93       	push	r17
    18fa:	cf 93       	push	r28
    18fc:	df 93       	push	r29
    18fe:	00 d0       	rcall	.+0      	; 0x1900 <_fatExtend+0x26>
    1900:	00 d0       	rcall	.+0      	; 0x1902 <_fatExtend+0x28>
    1902:	00 d0       	rcall	.+0      	; 0x1904 <_fatExtend+0x2a>
    1904:	cd b7       	in	r28, 0x3d	; 61
    1906:	de b7       	in	r29, 0x3e	; 62
    1908:	9e 83       	std	Y+6, r25	; 0x06
    190a:	8d 83       	std	Y+5, r24	; 0x05
    190c:	7b 01       	movw	r14, r22
    190e:	29 83       	std	Y+1, r18	; 0x01
    1910:	3a 83       	std	Y+2, r19	; 0x02
    1912:	4b 83       	std	Y+3, r20	; 0x03
    1914:	5c 83       	std	Y+4, r21	; 0x04
	CLUSTER numRemaining=num_clusters;

	// Check we have a valid start cluster
	if(nav->startCluster<2){
    1916:	fb 01       	movw	r30, r22
    1918:	84 85       	ldd	r24, Z+12	; 0x0c
    191a:	95 85       	ldd	r25, Z+13	; 0x0d
    191c:	a6 85       	ldd	r26, Z+14	; 0x0e
    191e:	b7 85       	ldd	r27, Z+15	; 0x0f
    1920:	82 30       	cpi	r24, 0x02	; 2
    1922:	91 05       	cpc	r25, r1
    1924:	a1 05       	cpc	r26, r1
    1926:	b1 05       	cpc	r27, r1
    1928:	00 f4       	brcc	.+0      	; 0x192a <_fatExtend+0x50>
    192a:	00 c0       	rjmp	.+0      	; 0x192c <_fatExtend+0x52>
		return(FALSE);
	}

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
    192c:	8d 81       	ldd	r24, Y+5	; 0x05
    192e:	9e 81       	ldd	r25, Y+6	; 0x06
    1930:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1934:	d6 2e       	mov	r13, r22
    1936:	c7 2e       	mov	r12, r23
    1938:	38 2e       	mov	r3, r24
    193a:	29 2e       	mov	r2, r25
	disk->freeClusterHint = lastCluster;
    193c:	ad 81       	ldd	r26, Y+5	; 0x05
    193e:	be 81       	ldd	r27, Y+6	; 0x06
    1940:	9f 96       	adiw	r26, 0x2f	; 47
    1942:	6c 93       	st	X, r22
    1944:	9f 97       	sbiw	r26, 0x2f	; 47
    1946:	d0 96       	adiw	r26, 0x30	; 48
    1948:	7c 93       	st	X, r23
    194a:	d0 97       	sbiw	r26, 0x30	; 48
    194c:	d1 96       	adiw	r26, 0x31	; 49
    194e:	8c 93       	st	X, r24
    1950:	d1 97       	sbiw	r26, 0x31	; 49
    1952:	d2 96       	adiw	r26, 0x32	; 50
    1954:	9c 93       	st	X, r25
    1956:	d2 97       	sbiw	r26, 0x32	; 50
}

// Append 'num_clusters' to the end of the cluster chain
// Return TRUE on success, FALSE if the FAT is full
boolean _fatExtend(DISK* disk,CLUSTER_NAV *nav,CLUSTER_COUNT num_clusters){
	CLUSTER numRemaining=num_clusters;
    1958:	49 80       	ldd	r4, Y+1	; 0x01
    195a:	5a 80       	ldd	r5, Y+2	; 0x02
    195c:	6b 80       	ldd	r6, Y+3	; 0x03
    195e:	7c 80       	ldd	r7, Y+4	; 0x04

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
	disk->freeClusterHint = lastCluster;


	while(numRemaining > 0){
    1960:	00 c0       	rjmp	.+0      	; 0x1962 <_fatExtend+0x88>
		rprintf("\nStart extend: First Cl=%lu, End Cl=%lu\n",nav->startCluster,lastCluster);
		rprintfInit(old);}
#endif

		// Find the next free cluster
		CLUSTER currentCluster = _fatGetFreeCluster(disk);
    1962:	8d 81       	ldd	r24, Y+5	; 0x05
    1964:	9e 81       	ldd	r25, Y+6	; 0x06
    1966:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    196a:	4b 01       	movw	r8, r22
    196c:	5c 01       	movw	r10, r24

		if(currentCluster==0){
			// The disk is full
			_fatSetNextClusterAddress(disk,lastCluster,_fatGiveEndMarker(disk));
    196e:	8d 81       	ldd	r24, Y+5	; 0x05
    1970:	9e 81       	ldd	r25, Y+6	; 0x06
#endif

		// Find the next free cluster
		CLUSTER currentCluster = _fatGetFreeCluster(disk);

		if(currentCluster==0){
    1972:	81 14       	cp	r8, r1
    1974:	91 04       	cpc	r9, r1
    1976:	a1 04       	cpc	r10, r1
    1978:	b1 04       	cpc	r11, r1
    197a:	01 f4       	brne	.+0      	; 0x197c <_fatExtend+0xa2>
			// The disk is full
			_fatSetNextClusterAddress(disk,lastCluster,_fatGiveEndMarker(disk));
    197c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1980:	8b 01       	movw	r16, r22
    1982:	9c 01       	movw	r18, r24
    1984:	8d 81       	ldd	r24, Y+5	; 0x05
    1986:	9e 81       	ldd	r25, Y+6	; 0x06
    1988:	4d 2d       	mov	r20, r13
    198a:	5c 2d       	mov	r21, r12
    198c:	63 2d       	mov	r22, r3
    198e:	72 2d       	mov	r23, r2
    1990:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			nav->endCluster=lastCluster;
    1994:	f7 01       	movw	r30, r14
    1996:	d0 8a       	std	Z+16, r13	; 0x10
    1998:	c1 8a       	std	Z+17, r12	; 0x11
    199a:	32 8a       	std	Z+18, r3	; 0x12
    199c:	23 8a       	std	Z+19, r2	; 0x13
			// Return TRUE if we have added at least one cluster
			return(num_clusters == numRemaining) ? FALSE : TRUE;
    199e:	29 81       	ldd	r18, Y+1	; 0x01
    19a0:	3a 81       	ldd	r19, Y+2	; 0x02
    19a2:	4b 81       	ldd	r20, Y+3	; 0x03
    19a4:	5c 81       	ldd	r21, Y+4	; 0x04
    19a6:	24 15       	cp	r18, r4
    19a8:	35 05       	cpc	r19, r5
    19aa:	46 05       	cpc	r20, r6
    19ac:	57 05       	cpc	r21, r7
    19ae:	01 f0       	breq	.+0      	; 0x19b0 <_fatExtend+0xd6>
    19b0:	00 c0       	rjmp	.+0      	; 0x19b2 <_fatExtend+0xd8>
    19b2:	00 c0       	rjmp	.+0      	; 0x19b4 <_fatExtend+0xda>
		}

		// This cluster is available - so link it in
		_fatSetNextClusterAddress(disk,lastCluster,currentCluster);
    19b4:	4d 2d       	mov	r20, r13
    19b6:	5c 2d       	mov	r21, r12
    19b8:	63 2d       	mov	r22, r3
    19ba:	72 2d       	mov	r23, r2
    19bc:	95 01       	movw	r18, r10
    19be:	84 01       	movw	r16, r8
    19c0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

		// One less to do
		numRemaining--;
    19c4:	08 94       	sec
    19c6:	41 08       	sbc	r4, r1
    19c8:	51 08       	sbc	r5, r1
    19ca:	61 08       	sbc	r6, r1
    19cc:	71 08       	sbc	r7, r1
		lastCluster=currentCluster;

		// If all done then mark end of chain
		if(numRemaining==0){
    19ce:	41 14       	cp	r4, r1
    19d0:	51 04       	cpc	r5, r1
    19d2:	61 04       	cpc	r6, r1
    19d4:	71 04       	cpc	r7, r1
    19d6:	01 f4       	brne	.+0      	; 0x19d8 <_fatExtend+0xfe>
			_fatSetNextClusterAddress(disk,lastCluster,_fatGiveEndMarker(disk));
    19d8:	8d 81       	ldd	r24, Y+5	; 0x05
    19da:	9e 81       	ldd	r25, Y+6	; 0x06
    19dc:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    19e0:	8b 01       	movw	r16, r22
    19e2:	9c 01       	movw	r18, r24
    19e4:	8d 81       	ldd	r24, Y+5	; 0x05
    19e6:	9e 81       	ldd	r25, Y+6	; 0x06
    19e8:	b5 01       	movw	r22, r10
    19ea:	a4 01       	movw	r20, r8
    19ec:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
			nav->endCluster=lastCluster;
    19f0:	d7 01       	movw	r26, r14
    19f2:	50 96       	adiw	r26, 0x10	; 16
    19f4:	8d 92       	st	X+, r8
    19f6:	9d 92       	st	X+, r9
    19f8:	ad 92       	st	X+, r10
    19fa:	bc 92       	st	X, r11
    19fc:	53 97       	sbiw	r26, 0x13	; 19
    19fe:	d8 2c       	mov	r13, r8
    1a00:	c9 2c       	mov	r12, r9
    1a02:	3a 2c       	mov	r3, r10
    1a04:	2b 2c       	mov	r2, r11

	CLUSTER lastCluster=_navGetLastCluster(disk,nav);
	disk->freeClusterHint = lastCluster;


	while(numRemaining > 0){
    1a06:	41 14       	cp	r4, r1
    1a08:	51 04       	cpc	r5, r1
    1a0a:	61 04       	cpc	r6, r1
    1a0c:	71 04       	cpc	r7, r1
    1a0e:	01 f0       	breq	.+0      	; 0x1a10 <_fatExtend+0x136>
    1a10:	00 c0       	rjmp	.+0      	; 0x1a12 <_fatExtend+0x138>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("End extend: First Cl=%lu, End Cl=%lu, Current=%lu\n",nav->startCluster,lastCluster,nav->currentCluster);
		rprintfInit(old);}
#endif

	if(nav->totalClusters){
    1a12:	f7 01       	movw	r30, r14
    1a14:	84 89       	ldd	r24, Z+20	; 0x14
    1a16:	95 89       	ldd	r25, Z+21	; 0x15
    1a18:	a6 89       	ldd	r26, Z+22	; 0x16
    1a1a:	b7 89       	ldd	r27, Z+23	; 0x17
    1a1c:	00 97       	sbiw	r24, 0x00	; 0
    1a1e:	a1 05       	cpc	r26, r1
    1a20:	b1 05       	cpc	r27, r1
    1a22:	01 f0       	breq	.+0      	; 0x1a24 <_fatExtend+0x14a>
		nav->totalClusters+=num_clusters;
    1a24:	29 81       	ldd	r18, Y+1	; 0x01
    1a26:	3a 81       	ldd	r19, Y+2	; 0x02
    1a28:	4b 81       	ldd	r20, Y+3	; 0x03
    1a2a:	5c 81       	ldd	r21, Y+4	; 0x04
    1a2c:	82 0f       	add	r24, r18
    1a2e:	93 1f       	adc	r25, r19
    1a30:	a4 1f       	adc	r26, r20
    1a32:	b5 1f       	adc	r27, r21
    1a34:	84 8b       	std	Z+20, r24	; 0x14
    1a36:	95 8b       	std	Z+21, r25	; 0x15
    1a38:	a6 8b       	std	Z+22, r26	; 0x16
    1a3a:	b7 8b       	std	Z+23, r27	; 0x17
    1a3c:	00 c0       	rjmp	.+0      	; 0x1a3e <_fatExtend+0x164>
boolean _fatExtend(DISK* disk,CLUSTER_NAV *nav,CLUSTER_COUNT num_clusters){
	CLUSTER numRemaining=num_clusters;

	// Check we have a valid start cluster
	if(nav->startCluster<2){
		return(FALSE);
    1a3e:	80 e0       	ldi	r24, 0x00	; 0
    1a40:	00 c0       	rjmp	.+0      	; 0x1a42 <_fatExtend+0x168>
#endif

	if(nav->totalClusters){
		nav->totalClusters+=num_clusters;
	}
	return(TRUE);
    1a42:	8f ef       	ldi	r24, 0xFF	; 255
}
    1a44:	26 96       	adiw	r28, 0x06	; 6
    1a46:	0f b6       	in	r0, 0x3f	; 63
    1a48:	f8 94       	cli
    1a4a:	de bf       	out	0x3e, r29	; 62
    1a4c:	0f be       	out	0x3f, r0	; 63
    1a4e:	cd bf       	out	0x3d, r28	; 61
    1a50:	df 91       	pop	r29
    1a52:	cf 91       	pop	r28
    1a54:	1f 91       	pop	r17
    1a56:	0f 91       	pop	r16
    1a58:	ff 90       	pop	r15
    1a5a:	ef 90       	pop	r14
    1a5c:	df 90       	pop	r13
    1a5e:	cf 90       	pop	r12
    1a60:	bf 90       	pop	r11
    1a62:	af 90       	pop	r10
    1a64:	9f 90       	pop	r9
    1a66:	8f 90       	pop	r8
    1a68:	7f 90       	pop	r7
    1a6a:	6f 90       	pop	r6
    1a6c:	5f 90       	pop	r5
    1a6e:	4f 90       	pop	r4
    1a70:	3f 90       	pop	r3
    1a72:	2f 90       	pop	r2
    1a74:	08 95       	ret

00001a76 <_dirGetFatFileName>:

// This function will take a full directory path, and strip off all leading
// dirs and characters, leaving you with the MS-DOS notation of the actual filename.
// Return value: TRUE on success, FALSE on not being able to produce a filename

boolean _dirGetFatFileName(const char* filename, char* fatfilename){
    1a76:	ff 92       	push	r15
    1a78:	0f 93       	push	r16
    1a7a:	1f 93       	push	r17
    1a7c:	cf 93       	push	r28
    1a7e:	df 93       	push	r29
    1a80:	cd b7       	in	r28, 0x3d	; 61
    1a82:	de b7       	in	r29, 0x3e	; 62
    1a84:	2b 97       	sbiw	r28, 0x0b	; 11
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	f8 94       	cli
    1a8a:	de bf       	out	0x3e, r29	; 62
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	cd bf       	out	0x3d, r28	; 61
    1a90:	f6 2e       	mov	r15, r22
    1a92:	07 2f       	mov	r16, r23
	char ffnamec[11];
	const char *next;
	char nn=0;

	memclr(ffnamec,11);
    1a94:	2b e0       	ldi	r18, 0x0B	; 11
    1a96:	fe 01       	movw	r30, r28
    1a98:	31 96       	adiw	r30, 0x01	; 1
    1a9a:	df 01       	movw	r26, r30
    1a9c:	32 2f       	mov	r19, r18
    1a9e:	1d 92       	st	X+, r1
    1aa0:	3a 95       	dec	r19
    1aa2:	01 f4       	brne	.+0      	; 0x1aa4 <_dirGetFatFileName+0x2e>
	memclr(fatfilename,11);
    1aa4:	e6 2f       	mov	r30, r22
    1aa6:	f7 2f       	mov	r31, r23
    1aa8:	df 01       	movw	r26, r30
    1aaa:	1d 92       	st	X+, r1
    1aac:	2a 95       	dec	r18
    1aae:	01 f4       	brne	.+0      	; 0x1ab0 <_dirGetFatFileName+0x3a>
	next = filename;

	if(*filename=='/'){
    1ab0:	fc 01       	movw	r30, r24
    1ab2:	20 81       	ld	r18, Z
    1ab4:	2f 32       	cpi	r18, 0x2F	; 47
    1ab6:	01 f4       	brne	.+0      	; 0x1ab8 <_dirGetFatFileName+0x42>
		next++;
    1ab8:	01 96       	adiw	r24, 0x01	; 1
	const char *next;
	char nn=0;

	memclr(ffnamec,11);
	memclr(fatfilename,11);
	next = filename;
    1aba:	10 e0       	ldi	r17, 0x00	; 0
    1abc:	00 c0       	rjmp	.+0      	; 0x1abe <_dirGetFatFileName+0x48>
		next++;
	}

	while((next=_fileUserToFatName(next,ffnamec))){
//		memCpy(ffnamec,fatfilename,11);
		memcpy(fatfilename,ffnamec,11);
    1abe:	ef 2d       	mov	r30, r15
    1ac0:	f0 2f       	mov	r31, r16
    1ac2:	de 01       	movw	r26, r28
    1ac4:	11 96       	adiw	r26, 0x01	; 1
    1ac6:	2b e0       	ldi	r18, 0x0B	; 11
    1ac8:	0d 90       	ld	r0, X+
    1aca:	01 92       	st	Z+, r0
    1acc:	21 50       	subi	r18, 0x01	; 1
    1ace:	01 f4       	brne	.+0      	; 0x1ad0 <_dirGetFatFileName+0x5a>
		nn++;
    1ad0:	1f 5f       	subi	r17, 0xFF	; 255

	if(*filename=='/'){
		next++;
	}

	while((next=_fileUserToFatName(next,ffnamec))){
    1ad2:	be 01       	movw	r22, r28
    1ad4:	6f 5f       	subi	r22, 0xFF	; 255
    1ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1adc:	00 97       	sbiw	r24, 0x00	; 0
    1ade:	01 f4       	brne	.+0      	; 0x1ae0 <_dirGetFatFileName+0x6a>
//		memCpy(ffnamec,fatfilename,11);
		memcpy(fatfilename,ffnamec,11);
		nn++;
	}
	return (nn) ? TRUE : FALSE;
    1ae0:	11 23       	and	r17, r17
    1ae2:	01 f0       	breq	.+0      	; 0x1ae4 <_dirGetFatFileName+0x6e>
    1ae4:	8f ef       	ldi	r24, 0xFF	; 255
    1ae6:	00 c0       	rjmp	.+0      	; 0x1ae8 <_dirGetFatFileName+0x72>
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
}
    1aea:	2b 96       	adiw	r28, 0x0b	; 11
    1aec:	0f b6       	in	r0, 0x3f	; 63
    1aee:	f8 94       	cli
    1af0:	de bf       	out	0x3e, r29	; 62
    1af2:	0f be       	out	0x3f, r0	; 63
    1af4:	cd bf       	out	0x3d, r28	; 61
    1af6:	df 91       	pop	r29
    1af8:	cf 91       	pop	r28
    1afa:	1f 91       	pop	r17
    1afc:	0f 91       	pop	r16
    1afe:	ff 90       	pop	r15
    1b00:	08 95       	ret

00001b02 <_dirCreateDirectoryEntry>:
	_partitionClearCluster(disk,lastc);
	return(TRUE);
}

// Write a directory entry
void _dirCreateDirectoryEntry(const DISK* disk,const DIR_ENTRY *filerec,const DIR_POSITION *loc){
    1b02:	ef 92       	push	r14
    1b04:	ff 92       	push	r15
    1b06:	0f 93       	push	r16
    1b08:	1f 93       	push	r17
    1b0a:	cf 93       	push	r28
    1b0c:	df 93       	push	r29
    1b0e:	8c 01       	movw	r16, r24
    1b10:	f6 2e       	mov	r15, r22
    1b12:	e7 2e       	mov	r14, r23
    1b14:	ea 01       	movw	r28, r20
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
    1b16:	48 81       	ld	r20, Y
    1b18:	59 81       	ldd	r21, Y+1	; 0x01
    1b1a:	6a 81       	ldd	r22, Y+2	; 0x02
    1b1c:	7b 81       	ldd	r23, Y+3	; 0x03
    1b1e:	22 e0       	ldi	r18, 0x02	; 2
    1b20:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1b24:	bc 01       	movw	r22, r24
	memcpy(&dir[loc->entryInSector],filerec,sizeof(*filerec));
    1b26:	ec 81       	ldd	r30, Y+4	; 0x04
    1b28:	f0 e0       	ldi	r31, 0x00	; 0
    1b2a:	25 e0       	ldi	r18, 0x05	; 5
    1b2c:	ee 0f       	add	r30, r30
    1b2e:	ff 1f       	adc	r31, r31
    1b30:	2a 95       	dec	r18
    1b32:	01 f4       	brne	.+0      	; 0x1b34 <_dirCreateDirectoryEntry+0x32>
    1b34:	e8 0f       	add	r30, r24
    1b36:	f9 1f       	adc	r31, r25
    1b38:	af 2d       	mov	r26, r15
    1b3a:	be 2d       	mov	r27, r14
    1b3c:	80 e2       	ldi	r24, 0x20	; 32
    1b3e:	0d 90       	ld	r0, X+
    1b40:	01 92       	st	Z+, r0
    1b42:	81 50       	subi	r24, 0x01	; 1
    1b44:	01 f4       	brne	.+0      	; 0x1b46 <_dirCreateDirectoryEntry+0x44>
    1b46:	c8 01       	movw	r24, r16
    1b48:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	partition_releaseSector(disk,dir);
}
    1b4c:	df 91       	pop	r29
    1b4e:	cf 91       	pop	r28
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	ff 90       	pop	r15
    1b56:	ef 90       	pop	r14
    1b58:	08 95       	ret

00001b5a <_dirSetFirstClusterInDirEntry>:

	return(FALSE);
}

// Update the disk directory with the start cluster
void _dirSetFirstClusterInDirEntry(DIR_ENTRY *rec,CLUSTER cluster_addr){
    1b5a:	fc 01       	movw	r30, r24
	rec->firstClusterHigh=cluster_addr>>16;
    1b5c:	75 8b       	std	Z+21, r23	; 0x15
    1b5e:	64 8b       	std	Z+20, r22	; 0x14
	rec->firstClusterLow=cluster_addr&0xFFFF;
    1b60:	53 8f       	std	Z+27, r21	; 0x1b
    1b62:	42 8f       	std	Z+26, r20	; 0x1a
}
    1b64:	08 95       	ret

00001b66 <_navInitClusterChain>:
		}
	}
	return(nav->endCluster);
}

void _navInitClusterChain(CLUSTER_NAV *nav,CLUSTER cluster_addr){
    1b66:	fc 01       	movw	r30, r24
	memclr(nav,sizeof(CLUSTER_NAV));
    1b68:	88 e1       	ldi	r24, 0x18	; 24
    1b6a:	df 01       	movw	r26, r30
    1b6c:	1d 92       	st	X+, r1
    1b6e:	8a 95       	dec	r24
    1b70:	01 f4       	brne	.+0      	; 0x1b72 <_navInitClusterChain+0xc>
	nav->startCluster = nav->currentCluster=cluster_addr;
    1b72:	40 87       	std	Z+8, r20	; 0x08
    1b74:	51 87       	std	Z+9, r21	; 0x09
    1b76:	62 87       	std	Z+10, r22	; 0x0a
    1b78:	73 87       	std	Z+11, r23	; 0x0b
    1b7a:	44 87       	std	Z+12, r20	; 0x0c
    1b7c:	55 87       	std	Z+13, r21	; 0x0d
    1b7e:	66 87       	std	Z+14, r22	; 0x0e
    1b80:	77 87       	std	Z+15, r23	; 0x0f
}
    1b82:	08 95       	ret

00001b84 <_dirFindinDir>:

// This function will search for an existing (fatname) or free directory entry
// in a directory, following the clusterchains.
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinDir(const DISK* disk, const char* fatname,CLUSTER firstcluster, DIR_POSITION *loc, uint8_t mode){
    1b84:	2f 92       	push	r2
    1b86:	3f 92       	push	r3
    1b88:	4f 92       	push	r4
    1b8a:	5f 92       	push	r5
    1b8c:	6f 92       	push	r6
    1b8e:	7f 92       	push	r7
    1b90:	8f 92       	push	r8
    1b92:	9f 92       	push	r9
    1b94:	af 92       	push	r10
    1b96:	bf 92       	push	r11
    1b98:	cf 92       	push	r12
    1b9a:	df 92       	push	r13
    1b9c:	ef 92       	push	r14
    1b9e:	ff 92       	push	r15
    1ba0:	0f 93       	push	r16
    1ba2:	1f 93       	push	r17
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	cd b7       	in	r28, 0x3d	; 61
    1baa:	de b7       	in	r29, 0x3e	; 62
    1bac:	a4 97       	sbiw	r28, 0x24	; 36
    1bae:	0f b6       	in	r0, 0x3f	; 63
    1bb0:	f8 94       	cli
    1bb2:	de bf       	out	0x3e, r29	; 62
    1bb4:	0f be       	out	0x3f, r0	; 63
    1bb6:	cd bf       	out	0x3d, r28	; 61
    1bb8:	1c 01       	movw	r2, r24
    1bba:	7e 8f       	std	Y+30, r23	; 0x1e
    1bbc:	6d 8f       	std	Y+29, r22	; 0x1d
    1bbe:	49 01       	movw	r8, r18
    1bc0:	5a 01       	movw	r10, r20
    1bc2:	1a 8f       	std	Y+26, r17	; 0x1a
    1bc4:	09 8f       	std	Y+25, r16	; 0x19
    1bc6:	ef 8e       	std	Y+31, r14	; 0x1f
	CLUSTER_COUNT c=0;
	CLUSTER cluster;
	CLUSTER_NAV nav;

	_navInitClusterChain(&nav,firstcluster);
    1bc8:	8e 01       	movw	r16, r28
    1bca:	0f 5f       	subi	r16, 0xFF	; 255
    1bcc:	1f 4f       	sbci	r17, 0xFF	; 255
    1bce:	c8 01       	movw	r24, r16
    1bd0:	ba 01       	movw	r22, r20
    1bd2:	a9 01       	movw	r20, r18
    1bd4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>

	if(firstcluster <= 1){
    1bd8:	82 e0       	ldi	r24, 0x02	; 2
    1bda:	88 16       	cp	r8, r24
    1bdc:	91 04       	cpc	r9, r1
    1bde:	a1 04       	cpc	r10, r1
    1be0:	b1 04       	cpc	r11, r1
    1be2:	00 f0       	brcs	.+0      	; 0x1be4 <_dirFindinDir+0x60>
    1be4:	00 c0       	rjmp	.+0      	; 0x1be6 <_dirFindinDir+0x62>
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.
static CLUSTER _dirFindinRootArea(const DISK *disk,const char* fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	// FAT32 doesn't have a root area
	if((disk->fatType != 12) && (disk->fatType != 16))
    1be6:	d1 01       	movw	r26, r2
    1be8:	96 96       	adiw	r26, 0x26	; 38
    1bea:	8c 91       	ld	r24, X
    1bec:	96 97       	sbiw	r26, 0x26	; 38
    1bee:	8c 30       	cpi	r24, 0x0C	; 12
    1bf0:	01 f0       	breq	.+0      	; 0x1bf2 <_dirFindinDir+0x6e>
    1bf2:	80 31       	cpi	r24, 0x10	; 16
    1bf4:	01 f0       	breq	.+0      	; 0x1bf6 <_dirFindinDir+0x72>
    1bf6:	00 c0       	rjmp	.+0      	; 0x1bf8 <_dirFindinDir+0x74>
		return(0);

	// Find the end sector of the root area
	SECTOR last = disk->firstSectorRootDir + disk->volume.rootDirEntryCount/32;
    1bf8:	f1 01       	movw	r30, r2
    1bfa:	47 a0       	ldd	r4, Z+39	; 0x27
    1bfc:	50 a4       	ldd	r5, Z+40	; 0x28
    1bfe:	61 a4       	ldd	r6, Z+41	; 0x29
    1c00:	72 a4       	ldd	r7, Z+42	; 0x2a
    1c02:	c4 88       	ldd	r12, Z+20	; 0x14
    1c04:	d5 88       	ldd	r13, Z+21	; 0x15
    1c06:	35 e0       	ldi	r19, 0x05	; 5
    1c08:	d6 94       	lsr	r13
    1c0a:	c7 94       	ror	r12
    1c0c:	3a 95       	dec	r19
    1c0e:	01 f4       	brne	.+0      	; 0x1c10 <_dirFindinDir+0x8c>
    1c10:	ee 24       	eor	r14, r14
    1c12:	ff 24       	eor	r15, r15
    1c14:	c4 0c       	add	r12, r4
    1c16:	d5 1c       	adc	r13, r5
    1c18:	e6 1c       	adc	r14, r6
    1c1a:	f7 1c       	adc	r15, r7
    1c1c:	00 c0       	rjmp	.+0      	; 0x1c1e <_dirFindinDir+0x9a>

	for(SECTOR c=disk->firstSectorRootDir; c<last; c++){
		void* buf= _partitionGetSector(disk,c,BUFFER_MODE_READONLY);
    1c1e:	c1 01       	movw	r24, r2
    1c20:	b3 01       	movw	r22, r6
    1c22:	a2 01       	movw	r20, r4
    1c24:	21 e0       	ldi	r18, 0x01	; 1
    1c26:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c2a:	8c 01       	movw	r16, r24
		if((fclus=_dirFindInSector(buf,fatname,loc,mode))){
    1c2c:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1c2e:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1c30:	49 8d       	ldd	r20, Y+25	; 0x19
    1c32:	5a 8d       	ldd	r21, Y+26	; 0x1a
    1c34:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1c36:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c3a:	4b 01       	movw	r8, r22
    1c3c:	5c 01       	movw	r10, r24
    1c3e:	61 15       	cp	r22, r1
    1c40:	71 05       	cpc	r23, r1
    1c42:	81 05       	cpc	r24, r1
    1c44:	91 05       	cpc	r25, r1
    1c46:	01 f0       	breq	.+0      	; 0x1c48 <_dirFindinDir+0xc4>
			if(loc){
    1c48:	89 8d       	ldd	r24, Y+25	; 0x19
    1c4a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c4c:	00 97       	sbiw	r24, 0x00	; 0
    1c4e:	01 f0       	breq	.+0      	; 0x1c50 <_dirFindinDir+0xcc>
				loc->sector=c;
    1c50:	dc 01       	movw	r26, r24
    1c52:	4d 92       	st	X+, r4
    1c54:	5d 92       	st	X+, r5
    1c56:	6d 92       	st	X+, r6
    1c58:	7c 92       	st	X, r7
    1c5a:	13 97       	sbiw	r26, 0x03	; 3
    1c5c:	c1 01       	movw	r24, r2
    1c5e:	b8 01       	movw	r22, r16
    1c60:	00 c0       	rjmp	.+0      	; 0x1c62 <_dirFindinDir+0xde>
    1c62:	c1 01       	movw	r24, r2
    1c64:	b8 01       	movw	r22, r16
    1c66:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
		return(0);

	// Find the end sector of the root area
	SECTOR last = disk->firstSectorRootDir + disk->volume.rootDirEntryCount/32;

	for(SECTOR c=disk->firstSectorRootDir; c<last; c++){
    1c6a:	08 94       	sec
    1c6c:	41 1c       	adc	r4, r1
    1c6e:	51 1c       	adc	r5, r1
    1c70:	61 1c       	adc	r6, r1
    1c72:	71 1c       	adc	r7, r1
    1c74:	4c 14       	cp	r4, r12
    1c76:	5d 04       	cpc	r5, r13
    1c78:	6e 04       	cpc	r6, r14
    1c7a:	7f 04       	cpc	r7, r15
    1c7c:	00 f0       	brcs	.+0      	; 0x1c7e <_dirFindinDir+0xfa>
    1c7e:	00 c0       	rjmp	.+0      	; 0x1c80 <_dirFindinDir+0xfc>
	if(firstcluster <= 1){
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
		if((cluster=_dirFindinCluster(disk,nav.currentCluster,fatname,loc,mode))){
    1c80:	49 84       	ldd	r4, Y+9	; 0x09
    1c82:	5a 84       	ldd	r5, Y+10	; 0x0a
    1c84:	6b 84       	ldd	r6, Y+11	; 0x0b
    1c86:	7c 84       	ldd	r7, Y+12	; 0x0c
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
    1c88:	dd 24       	eor	r13, r13
    1c8a:	00 c0       	rjmp	.+0      	; 0x1c8c <_dirFindinDir+0x108>
		DIR_ENTRY* buf = _partitionGetSector(disk,_diskClusterToSector(disk,cluster)+c,BUFFER_MODE_READONLY);
    1c8c:	c1 01       	movw	r24, r2
    1c8e:	b3 01       	movw	r22, r6
    1c90:	a2 01       	movw	r20, r4
    1c92:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1c96:	ab 01       	movw	r20, r22
    1c98:	bc 01       	movw	r22, r24
    1c9a:	ed 2c       	mov	r14, r13
    1c9c:	ff 24       	eor	r15, r15
    1c9e:	00 e0       	ldi	r16, 0x00	; 0
    1ca0:	10 e0       	ldi	r17, 0x00	; 0
    1ca2:	4e 0d       	add	r20, r14
    1ca4:	5f 1d       	adc	r21, r15
    1ca6:	60 1f       	adc	r22, r16
    1ca8:	71 1f       	adc	r23, r17
    1caa:	c1 01       	movw	r24, r2
    1cac:	21 e0       	ldi	r18, 0x01	; 1
    1cae:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1cb2:	9c 8f       	std	Y+28, r25	; 0x1c
    1cb4:	8b 8f       	std	Y+27, r24	; 0x1b
		if((fclus=_dirFindInSector(buf,fatname,loc,mode))){
    1cb6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    1cb8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    1cba:	49 8d       	ldd	r20, Y+25	; 0x19
    1cbc:	5a 8d       	ldd	r21, Y+26	; 0x1a
    1cbe:	2f 8d       	ldd	r18, Y+31	; 0x1f
    1cc0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1cc4:	4b 01       	movw	r8, r22
    1cc6:	5c 01       	movw	r10, r24
    1cc8:	61 15       	cp	r22, r1
    1cca:	71 05       	cpc	r23, r1
    1ccc:	81 05       	cpc	r24, r1
    1cce:	91 05       	cpc	r25, r1
    1cd0:	01 f0       	breq	.+0      	; 0x1cd2 <_dirFindinDir+0x14e>
			if(loc){
    1cd2:	e9 8d       	ldd	r30, Y+25	; 0x19
    1cd4:	fa 8d       	ldd	r31, Y+26	; 0x1a
    1cd6:	30 97       	sbiw	r30, 0x00	; 0
    1cd8:	01 f0       	breq	.+0      	; 0x1cda <_dirFindinDir+0x156>
				loc->sector = _diskClusterToSector(disk,cluster) + c;
    1cda:	c1 01       	movw	r24, r2
    1cdc:	b3 01       	movw	r22, r6
    1cde:	a2 01       	movw	r20, r4
    1ce0:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1ce4:	dc 01       	movw	r26, r24
    1ce6:	cb 01       	movw	r24, r22
    1ce8:	8e 0d       	add	r24, r14
    1cea:	9f 1d       	adc	r25, r15
    1cec:	a0 1f       	adc	r26, r16
    1cee:	b1 1f       	adc	r27, r17
    1cf0:	e9 8d       	ldd	r30, Y+25	; 0x19
    1cf2:	fa 8d       	ldd	r31, Y+26	; 0x1a
    1cf4:	80 83       	st	Z, r24
    1cf6:	91 83       	std	Z+1, r25	; 0x01
    1cf8:	a2 83       	std	Z+2, r26	; 0x02
    1cfa:	b3 83       	std	Z+3, r27	; 0x03
    1cfc:	c1 01       	movw	r24, r2
    1cfe:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1d00:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1d02:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1d06:	00 c0       	rjmp	.+0      	; 0x1d08 <_dirFindinDir+0x184>
    1d08:	c1 01       	movw	r24, r2
    1d0a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1d0c:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1d0e:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
// Return value: 0 on failure, firstcluster on finding file, and 1 on finding free spot.

static CLUSTER _dirFindinCluster(const DISK *disk,CLUSTER cluster,const char *fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	for(uint8_t c=0; c<disk->volume.sectorsPerCluster; c++){
    1d12:	d3 94       	inc	r13
    1d14:	d1 01       	movw	r26, r2
    1d16:	50 96       	adiw	r26, 0x10	; 16
    1d18:	8c 91       	ld	r24, X
    1d1a:	50 97       	sbiw	r26, 0x10	; 16
    1d1c:	d8 16       	cp	r13, r24
    1d1e:	00 f4       	brcc	.+0      	; 0x1d20 <_dirFindinDir+0x19c>
    1d20:	00 c0       	rjmp	.+0      	; 0x1d22 <_dirFindinDir+0x19e>

	if(firstcluster <= 1){
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
    1d22:	28 a1       	ldd	r18, Y+32	; 0x20
    1d24:	39 a1       	ldd	r19, Y+33	; 0x21
    1d26:	4a a1       	ldd	r20, Y+34	; 0x22
    1d28:	5b a1       	ldd	r21, Y+35	; 0x23
    1d2a:	00 c0       	rjmp	.+0      	; 0x1d2c <_dirFindinDir+0x1a8>
	CLUSTER cluster;
	CLUSTER_NAV nav;

	_navInitClusterChain(&nav,firstcluster);

	if(firstcluster <= 1){
    1d2c:	20 e0       	ldi	r18, 0x00	; 0
    1d2e:	30 e0       	ldi	r19, 0x00	; 0
    1d30:	40 e0       	ldi	r20, 0x00	; 0
    1d32:	50 e0       	ldi	r21, 0x00	; 0
		return(_dirFindinRootArea(disk,fatname,loc,mode));
	}

	while( _fatNavigateTo(disk,&nav,c++) ){
    1d34:	0c a3       	std	Y+36, r16	; 0x24
    1d36:	c1 2e       	mov	r12, r17
    1d38:	da 01       	movw	r26, r20
    1d3a:	c9 01       	movw	r24, r18
    1d3c:	01 96       	adiw	r24, 0x01	; 1
    1d3e:	a1 1d       	adc	r26, r1
    1d40:	b1 1d       	adc	r27, r1
    1d42:	88 a3       	std	Y+32, r24	; 0x20
    1d44:	99 a3       	std	Y+33, r25	; 0x21
    1d46:	aa a3       	std	Y+34, r26	; 0x22
    1d48:	bb a3       	std	Y+35, r27	; 0x23
    1d4a:	c1 01       	movw	r24, r2
    1d4c:	6c a1       	ldd	r22, Y+36	; 0x24
    1d4e:	7c 2d       	mov	r23, r12
    1d50:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1d54:	88 23       	and	r24, r24
    1d56:	01 f0       	breq	.+0      	; 0x1d58 <_dirFindinDir+0x1d4>
    1d58:	00 c0       	rjmp	.+0      	; 0x1d5a <_dirFindinDir+0x1d6>
static CLUSTER _dirFindinRootArea(const DISK *disk,const char* fatname, DIR_POSITION *loc, uint8_t mode){
	CLUSTER fclus;

	// FAT32 doesn't have a root area
	if((disk->fatType != 12) && (disk->fatType != 16))
		return(0);
    1d5a:	88 24       	eor	r8, r8
    1d5c:	99 24       	eor	r9, r9
    1d5e:	54 01       	movw	r10, r8
		if((cluster=_dirFindinCluster(disk,nav.currentCluster,fatname,loc,mode))){
			return(cluster);
		}
	}
	return(0);
}
    1d60:	b4 01       	movw	r22, r8
    1d62:	c5 01       	movw	r24, r10
    1d64:	a4 96       	adiw	r28, 0x24	; 36
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	f8 94       	cli
    1d6a:	de bf       	out	0x3e, r29	; 62
    1d6c:	0f be       	out	0x3f, r0	; 63
    1d6e:	cd bf       	out	0x3d, r28	; 61
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
    1d74:	1f 91       	pop	r17
    1d76:	0f 91       	pop	r16
    1d78:	ff 90       	pop	r15
    1d7a:	ef 90       	pop	r14
    1d7c:	df 90       	pop	r13
    1d7e:	cf 90       	pop	r12
    1d80:	bf 90       	pop	r11
    1d82:	af 90       	pop	r10
    1d84:	9f 90       	pop	r9
    1d86:	8f 90       	pop	r8
    1d88:	7f 90       	pop	r7
    1d8a:	6f 90       	pop	r6
    1d8c:	5f 90       	pop	r5
    1d8e:	4f 90       	pop	r4
    1d90:	3f 90       	pop	r3
    1d92:	2f 90       	pop	r2
    1d94:	08 95       	ret

00001d96 <_fileFindFile>:
// Try to locate a file with the given name
// Return value: Returns 0 when nothing was found, 1 when the thing found (and loc is filled in)
// was a file and 2 if the thing found was a directory. Also returns lstDir set to the cluster
// of the directory

int8_t _fileFindFile(const DISK* disk,const char* filename,DIR_POSITION *loc,CLUSTER *lastDir){
    1d96:	2f 92       	push	r2
    1d98:	3f 92       	push	r3
    1d9a:	5f 92       	push	r5
    1d9c:	6f 92       	push	r6
    1d9e:	7f 92       	push	r7
    1da0:	8f 92       	push	r8
    1da2:	9f 92       	push	r9
    1da4:	af 92       	push	r10
    1da6:	bf 92       	push	r11
    1da8:	cf 92       	push	r12
    1daa:	df 92       	push	r13
    1dac:	ef 92       	push	r14
    1dae:	ff 92       	push	r15
    1db0:	0f 93       	push	r16
    1db2:	1f 93       	push	r17
    1db4:	cf 93       	push	r28
    1db6:	df 93       	push	r29
    1db8:	cd b7       	in	r28, 0x3d	; 61
    1dba:	de b7       	in	r29, 0x3e	; 62
    1dbc:	2d 97       	sbiw	r28, 0x0d	; 13
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	de bf       	out	0x3e, r29	; 62
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cd bf       	out	0x3d, r28	; 61
    1dc8:	1c 01       	movw	r2, r24
    1dca:	cb 01       	movw	r24, r22
    1dcc:	5d 87       	std	Y+13, r21	; 0x0d
    1dce:	4c 87       	std	Y+12, r20	; 0x0c
    1dd0:	69 01       	movw	r12, r18
	CLUSTER tmpclus;
	char ffname[11];
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
    1dd2:	fb 01       	movw	r30, r22
    1dd4:	20 81       	ld	r18, Z

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    1dd6:	f1 01       	movw	r30, r2
	CLUSTER tmpclus;
	char ffname[11];
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
    1dd8:	2f 32       	cpi	r18, 0x2F	; 47
    1dda:	01 f4       	brne	.+0      	; 0x1ddc <_fileFindFile+0x46>

	return( base + (cluster-2) * disk->volume.sectorsPerCluster );
}

static CLUSTER _diskGetFirstClusterRootDir(const DISK *disk){
	return(disk->fatType == 32) ? disk->volume.rootDirCluster : 1;
    1ddc:	26 a1       	ldd	r18, Z+38	; 0x26
    1dde:	20 32       	cpi	r18, 0x20	; 32
    1de0:	01 f4       	brne	.+0      	; 0x1de2 <_fileFindFile+0x4c>
    1de2:	86 88       	ldd	r8, Z+22	; 0x16
    1de4:	97 88       	ldd	r9, Z+23	; 0x17
    1de6:	a0 8c       	ldd	r10, Z+24	; 0x18
    1de8:	b1 8c       	ldd	r11, Z+25	; 0x19
    1dea:	00 c0       	rjmp	.+0      	; 0x1dec <_fileFindFile+0x56>
    1dec:	41 e0       	ldi	r20, 0x01	; 1
    1dee:	84 2e       	mov	r8, r20
    1df0:	91 2c       	mov	r9, r1
    1df2:	a1 2c       	mov	r10, r1
    1df4:	b1 2c       	mov	r11, r1
	boolean filefound=FALSE;

	if(*filename=='/'){
		fccd = _diskGetFirstClusterRootDir(disk);		// current directory = root
		filename++;
		if(lastDir){
    1df6:	c1 14       	cp	r12, r1
    1df8:	d1 04       	cpc	r13, r1
    1dfa:	01 f0       	breq	.+0      	; 0x1dfc <_fileFindFile+0x66>
			*lastDir=fccd;
    1dfc:	f6 01       	movw	r30, r12
    1dfe:	80 82       	st	Z, r8
    1e00:	91 82       	std	Z+1, r9	; 0x01
    1e02:	a2 82       	std	Z+2, r10	; 0x02
    1e04:	b3 82       	std	Z+3, r11	; 0x03
		}
		if(*filename=='\0'){
    1e06:	fc 01       	movw	r30, r24
    1e08:	21 81       	ldd	r18, Z+1	; 0x01
    1e0a:	22 23       	and	r18, r18
    1e0c:	01 f4       	brne	.+0      	; 0x1e0e <_fileFindFile+0x78>
    1e0e:	00 c0       	rjmp	.+0      	; 0x1e10 <_fileFindFile+0x7a>
	const char *next;
	boolean filefound=FALSE;

	if(*filename=='/'){
		fccd = _diskGetFirstClusterRootDir(disk);		// current directory = root
		filename++;
    1e10:	01 96       	adiw	r24, 0x01	; 1
    1e12:	00 c0       	rjmp	.+0      	; 0x1e14 <_fileFindFile+0x7e>
		}
		if(*filename=='\0'){
			return(2);								// The filename is a directory
		}
	}else{
		fccd = disk->firstClusterCurrentDir;		// current directory = current directory
    1e14:	83 a4       	ldd	r8, Z+43	; 0x2b
    1e16:	94 a4       	ldd	r9, Z+44	; 0x2c
    1e18:	a5 a4       	ldd	r10, Z+45	; 0x2d
    1e1a:	b6 a4       	ldd	r11, Z+46	; 0x2e
		if(lastDir){
    1e1c:	c1 14       	cp	r12, r1
    1e1e:	d1 04       	cpc	r13, r1
    1e20:	01 f0       	breq	.+0      	; 0x1e22 <_fileFindFile+0x8c>
			*lastDir=fccd;
    1e22:	f6 01       	movw	r30, r12
    1e24:	80 82       	st	Z, r8
    1e26:	91 82       	std	Z+1, r9	; 0x01
    1e28:	a2 82       	std	Z+2, r10	; 0x02
    1e2a:	b3 82       	std	Z+3, r11	; 0x03
			fccd = tmpclus;
			filename = next;
			if(lastDir){
				*lastDir=fccd;
			}
			if(filefound){
    1e2c:	ff 24       	eor	r15, r15
    1e2e:	55 24       	eor	r5, r5
    1e30:	00 c0       	rjmp	.+0      	; 0x1e32 <_fileFindFile+0x9c>
	// Iterator
	uint8_t it=0;

	while((next=_fileUserToFatName(filename,ffname))!=0){

		if((tmpclus=_dirFindinDir(disk,ffname,fccd,loc,DIRFIND_FILE))==0){
    1e32:	c1 01       	movw	r24, r2
    1e34:	be 01       	movw	r22, r28
    1e36:	6f 5f       	subi	r22, 0xFF	; 255
    1e38:	7f 4f       	sbci	r23, 0xFF	; 255
    1e3a:	a5 01       	movw	r20, r10
    1e3c:	94 01       	movw	r18, r8
    1e3e:	0c 85       	ldd	r16, Y+12	; 0x0c
    1e40:	1d 85       	ldd	r17, Y+13	; 0x0d
    1e42:	ee 24       	eor	r14, r14
    1e44:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1e48:	dc 01       	movw	r26, r24
    1e4a:	cb 01       	movw	r24, r22
    1e4c:	00 97       	sbiw	r24, 0x00	; 0
    1e4e:	a1 05       	cpc	r26, r1
    1e50:	b1 05       	cpc	r27, r1
    1e52:	01 f4       	brne	.+0      	; 0x1e54 <_fileFindFile+0xbe>
			/* We didn't find what we wanted */
			/* We should check, to see if there is more after it, so that
			 * we can invalidate lastDir
			 */
			if((_fileUserToFatName(next,ffname))!=0){
    1e54:	c3 01       	movw	r24, r6
    1e56:	be 01       	movw	r22, r28
    1e58:	6f 5f       	subi	r22, 0xFF	; 255
    1e5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e5c:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1e60:	00 97       	sbiw	r24, 0x00	; 0
    1e62:	01 f4       	brne	.+0      	; 0x1e64 <_fileFindFile+0xce>
    1e64:	00 c0       	rjmp	.+0      	; 0x1e66 <_fileFindFile+0xd0>
				}
			}
			return(0);
		}

		it++;
    1e66:	f3 94       	inc	r15

		if(loc->attrib.flags.isDirectory){
    1e68:	ec 85       	ldd	r30, Y+12	; 0x0c
    1e6a:	fd 85       	ldd	r31, Y+13	; 0x0d
    1e6c:	25 81       	ldd	r18, Z+5	; 0x05
    1e6e:	24 ff       	sbrs	r18, 4
    1e70:	00 c0       	rjmp	.+0      	; 0x1e72 <_fileFindFile+0xdc>
			fccd = tmpclus;
			filename = next;
			if(lastDir){
    1e72:	c1 14       	cp	r12, r1
    1e74:	d1 04       	cpc	r13, r1
    1e76:	01 f0       	breq	.+0      	; 0x1e78 <_fileFindFile+0xe2>
				*lastDir=fccd;
    1e78:	f6 01       	movw	r30, r12
    1e7a:	80 83       	st	Z, r24
    1e7c:	91 83       	std	Z+1, r25	; 0x01
    1e7e:	a2 83       	std	Z+2, r26	; 0x02
    1e80:	b3 83       	std	Z+3, r27	; 0x03
			}
			if(filefound){
    1e82:	55 20       	and	r5, r5
    1e84:	01 f0       	breq	.+0      	; 0x1e86 <_fileFindFile+0xf0>
				*lastDir=0;
    1e86:	f6 01       	movw	r30, r12
    1e88:	10 82       	st	Z, r1
    1e8a:	11 82       	std	Z+1, r1	; 0x01
    1e8c:	12 82       	std	Z+2, r1	; 0x02
    1e8e:	13 82       	std	Z+3, r1	; 0x03
    1e90:	00 c0       	rjmp	.+0      	; 0x1e92 <_fileFindFile+0xfc>
			}
		}else{
			filefound=TRUE;
			if((_fileUserToFatName(next,ffname))!=0){
    1e92:	c3 01       	movw	r24, r6
    1e94:	be 01       	movw	r22, r28
    1e96:	6f 5f       	subi	r22, 0xFF	; 255
    1e98:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9a:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1e9e:	00 97       	sbiw	r24, 0x00	; 0
    1ea0:	01 f0       	breq	.+0      	; 0x1ea2 <_fileFindFile+0x10c>
				if(lastDir){
    1ea2:	c1 14       	cp	r12, r1
    1ea4:	d1 04       	cpc	r13, r1
    1ea6:	01 f0       	breq	.+0      	; 0x1ea8 <_fileFindFile+0x112>
					*lastDir=0;
    1ea8:	f6 01       	movw	r30, r12
    1eaa:	10 82       	st	Z, r1
    1eac:	11 82       	std	Z+1, r1	; 0x01
    1eae:	12 82       	std	Z+2, r1	; 0x02
    1eb0:	13 82       	std	Z+3, r1	; 0x03
    1eb2:	00 c0       	rjmp	.+0      	; 0x1eb4 <_fileFindFile+0x11e>
			fccd = tmpclus;
			filename = next;
			if(lastDir){
				*lastDir=fccd;
			}
			if(filefound){
    1eb4:	4c 01       	movw	r8, r24
    1eb6:	5d 01       	movw	r10, r26
    1eb8:	00 c0       	rjmp	.+0      	; 0x1eba <_fileFindFile+0x124>
				*lastDir=0;
			}
		}else{
			filefound=TRUE;
    1eba:	55 24       	eor	r5, r5
    1ebc:	5a 94       	dec	r5
			if((_fileUserToFatName(next,ffname))!=0){
				if(lastDir){
					*lastDir=0;
    1ebe:	c3 01       	movw	r24, r6


	// Iterator
	uint8_t it=0;

	while((next=_fileUserToFatName(filename,ffname))!=0){
    1ec0:	be 01       	movw	r22, r28
    1ec2:	6f 5f       	subi	r22, 0xFF	; 255
    1ec4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1eca:	3c 01       	movw	r6, r24
    1ecc:	00 97       	sbiw	r24, 0x00	; 0
    1ece:	01 f0       	breq	.+0      	; 0x1ed0 <_fileFindFile+0x13a>
    1ed0:	00 c0       	rjmp	.+0      	; 0x1ed2 <_fileFindFile+0x13c>
				filename=next;
			}
		}
	}

	if(it==0){
    1ed2:	ff 20       	and	r15, r15
    1ed4:	01 f0       	breq	.+0      	; 0x1ed6 <_fileFindFile+0x140>
		return(0);
	}

	if(loc->attrib.flags.isDirectory || !filefound){
    1ed6:	ec 85       	ldd	r30, Y+12	; 0x0c
    1ed8:	fd 85       	ldd	r31, Y+13	; 0x0d
    1eda:	85 81       	ldd	r24, Z+5	; 0x05
    1edc:	84 fd       	sbrc	r24, 4
    1ede:	00 c0       	rjmp	.+0      	; 0x1ee0 <_fileFindFile+0x14a>
    1ee0:	55 20       	and	r5, r5
    1ee2:	01 f0       	breq	.+0      	; 0x1ee4 <_fileFindFile+0x14e>
    1ee4:	00 c0       	rjmp	.+0      	; 0x1ee6 <_fileFindFile+0x150>
			}
		}
	}

	if(it==0){
		return(0);
    1ee6:	80 e0       	ldi	r24, 0x00	; 0
    1ee8:	00 c0       	rjmp	.+0      	; 0x1eea <_fileFindFile+0x154>
	}

	if(loc->attrib.flags.isDirectory || !filefound){
		return(2);
    1eea:	82 e0       	ldi	r24, 0x02	; 2
    1eec:	00 c0       	rjmp	.+0      	; 0x1eee <_fileFindFile+0x158>
	}
	return(1);
    1eee:	81 e0       	ldi	r24, 0x01	; 1
}
    1ef0:	2d 96       	adiw	r28, 0x0d	; 13
    1ef2:	0f b6       	in	r0, 0x3f	; 63
    1ef4:	f8 94       	cli
    1ef6:	de bf       	out	0x3e, r29	; 62
    1ef8:	0f be       	out	0x3f, r0	; 63
    1efa:	cd bf       	out	0x3d, r28	; 61
    1efc:	df 91       	pop	r29
    1efe:	cf 91       	pop	r28
    1f00:	1f 91       	pop	r17
    1f02:	0f 91       	pop	r16
    1f04:	ff 90       	pop	r15
    1f06:	ef 90       	pop	r14
    1f08:	df 90       	pop	r13
    1f0a:	cf 90       	pop	r12
    1f0c:	bf 90       	pop	r11
    1f0e:	af 90       	pop	r10
    1f10:	9f 90       	pop	r9
    1f12:	8f 90       	pop	r8
    1f14:	7f 90       	pop	r7
    1f16:	6f 90       	pop	r6
    1f18:	5f 90       	pop	r5
    1f1a:	3f 90       	pop	r3
    1f1c:	2f 90       	pop	r2
    1f1e:	08 95       	ret

00001f20 <_dirFindFreeFile>:
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
	memcpy(&dir[loc->entryInSector],filerec,sizeof(*filerec));
	partition_releaseSector(disk,dir);
}

boolean _dirFindFreeFile(DISK* disk,const char* filename,DIR_POSITION *loc){
    1f20:	af 92       	push	r10
    1f22:	bf 92       	push	r11
    1f24:	cf 92       	push	r12
    1f26:	df 92       	push	r13
    1f28:	ef 92       	push	r14
    1f2a:	0f 93       	push	r16
    1f2c:	1f 93       	push	r17
    1f2e:	cf 93       	push	r28
    1f30:	df 93       	push	r29
    1f32:	cd b7       	in	r28, 0x3d	; 61
    1f34:	de b7       	in	r29, 0x3e	; 62
    1f36:	a7 97       	sbiw	r28, 0x27	; 39
    1f38:	0f b6       	in	r0, 0x3f	; 63
    1f3a:	f8 94       	cli
    1f3c:	de bf       	out	0x3e, r29	; 62
    1f3e:	0f be       	out	0x3f, r0	; 63
    1f40:	cd bf       	out	0x3d, r28	; 61
    1f42:	6c 01       	movw	r12, r24
    1f44:	8b 01       	movw	r16, r22
    1f46:	5a 01       	movw	r10, r20
	CLUSTER targetdir=0;
    1f48:	19 82       	std	Y+1, r1	; 0x01
    1f4a:	1a 82       	std	Y+2, r1	; 0x02
    1f4c:	1b 82       	std	Y+3, r1	; 0x03
    1f4e:	1c 82       	std	Y+4, r1	; 0x04
	char ffname[11];

	if(_fileFindFile(disk,filename,loc,&targetdir)){
    1f50:	9e 01       	movw	r18, r28
    1f52:	2f 5f       	subi	r18, 0xFF	; 255
    1f54:	3f 4f       	sbci	r19, 0xFF	; 255
    1f56:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f5a:	88 23       	and	r24, r24
    1f5c:	01 f0       	breq	.+0      	; 0x1f5e <_dirFindFreeFile+0x3e>
    1f5e:	00 c0       	rjmp	.+0      	; 0x1f60 <_dirFindFreeFile+0x40>
		// The file already exists
		return(FALSE);
	}

	// Parse for a valid filename
	if(!_dirGetFatFileName(filename,ffname)){
    1f60:	c8 01       	movw	r24, r16
    1f62:	be 01       	movw	r22, r28
    1f64:	6b 5f       	subi	r22, 0xFB	; 251
    1f66:	7f 4f       	sbci	r23, 0xFF	; 255
    1f68:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f6c:	88 23       	and	r24, r24
    1f6e:	01 f4       	brne	.+0      	; 0x1f70 <_dirFindFreeFile+0x50>
    1f70:	00 c0       	rjmp	.+0      	; 0x1f72 <_dirFindFreeFile+0x52>
		return(FALSE);
	}

	if(_dirFindinDir(disk,ffname,targetdir,loc,DIRFIND_FREE)){
    1f72:	29 81       	ldd	r18, Y+1	; 0x01
    1f74:	3a 81       	ldd	r19, Y+2	; 0x02
    1f76:	4b 81       	ldd	r20, Y+3	; 0x03
    1f78:	5c 81       	ldd	r21, Y+4	; 0x04
    1f7a:	c6 01       	movw	r24, r12
    1f7c:	be 01       	movw	r22, r28
    1f7e:	6b 5f       	subi	r22, 0xFB	; 251
    1f80:	7f 4f       	sbci	r23, 0xFF	; 255
    1f82:	85 01       	movw	r16, r10
    1f84:	ee 24       	eor	r14, r14
    1f86:	e3 94       	inc	r14
    1f88:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1f8c:	dc 01       	movw	r26, r24
    1f8e:	cb 01       	movw	r24, r22
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	a1 05       	cpc	r26, r1
    1f94:	b1 05       	cpc	r27, r1
    1f96:	01 f4       	brne	.+0      	; 0x1f98 <_dirFindFreeFile+0x78>
// cluster. (or clusters)
// Return value: TRUE on success, FALSE on fail

static boolean _dirAddCluster(DISK* disk,CLUSTER firstCluster){
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav,firstCluster);
    1f98:	49 81       	ldd	r20, Y+1	; 0x01
    1f9a:	5a 81       	ldd	r21, Y+2	; 0x02
    1f9c:	6b 81       	ldd	r22, Y+3	; 0x03
    1f9e:	7c 81       	ldd	r23, Y+4	; 0x04
    1fa0:	ce 01       	movw	r24, r28
    1fa2:	40 96       	adiw	r24, 0x10	; 16
    1fa4:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	if(!_fatExtend(disk,&nav,1)){
    1fa8:	c6 01       	movw	r24, r12
    1faa:	be 01       	movw	r22, r28
    1fac:	60 5f       	subi	r22, 0xF0	; 240
    1fae:	7f 4f       	sbci	r23, 0xFF	; 255
    1fb0:	21 e0       	ldi	r18, 0x01	; 1
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	40 e0       	ldi	r20, 0x00	; 0
    1fb6:	50 e0       	ldi	r21, 0x00	; 0
    1fb8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1fbc:	88 23       	and	r24, r24
    1fbe:	01 f0       	breq	.+0      	; 0x1fc0 <_dirFindFreeFile+0xa0>
		return(FALSE);
	}
	CLUSTER lastc = _navGetLastCluster(disk,&nav);
    1fc0:	c6 01       	movw	r24, r12
    1fc2:	be 01       	movw	r22, r28
    1fc4:	60 5f       	subi	r22, 0xF0	; 240
    1fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc8:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1fcc:	ab 01       	movw	r20, r22
    1fce:	bc 01       	movw	r22, r24
	_partitionClearCluster(disk,lastc);
    1fd0:	c6 01       	movw	r24, r12
    1fd2:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
	}else{
		// Try to increase the directory size
		if(!_dirAddCluster(disk,targetdir)){
			return(FALSE);
		}else{
			if(_dirFindinDir(disk,ffname,targetdir,loc,DIRFIND_FREE)){
    1fd6:	29 81       	ldd	r18, Y+1	; 0x01
    1fd8:	3a 81       	ldd	r19, Y+2	; 0x02
    1fda:	4b 81       	ldd	r20, Y+3	; 0x03
    1fdc:	5c 81       	ldd	r21, Y+4	; 0x04
    1fde:	c6 01       	movw	r24, r12
    1fe0:	be 01       	movw	r22, r28
    1fe2:	6b 5f       	subi	r22, 0xFB	; 251
    1fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fe6:	0e 94 00 00 	call	0	; 0x0 <_bufferIsWritable>
    1fea:	dc 01       	movw	r26, r24
    1fec:	cb 01       	movw	r24, r22
    1fee:	00 97       	sbiw	r24, 0x00	; 0
    1ff0:	a1 05       	cpc	r26, r1
    1ff2:	b1 05       	cpc	r27, r1
    1ff4:	01 f0       	breq	.+0      	; 0x1ff6 <_dirFindFreeFile+0xd6>
	if(!_dirGetFatFileName(filename,ffname)){
		return(FALSE);
	}

	if(_dirFindinDir(disk,ffname,targetdir,loc,DIRFIND_FREE)){
		return(TRUE);
    1ff6:	8f ef       	ldi	r24, 0xFF	; 255
    1ff8:	00 c0       	rjmp	.+0      	; 0x1ffa <_dirFindFreeFile+0xda>
				return(TRUE);
			}
		}
	}

	return(FALSE);
    1ffa:	80 e0       	ldi	r24, 0x00	; 0
}
    1ffc:	a7 96       	adiw	r28, 0x27	; 39
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	cd bf       	out	0x3d, r28	; 61
    2008:	df 91       	pop	r29
    200a:	cf 91       	pop	r28
    200c:	1f 91       	pop	r17
    200e:	0f 91       	pop	r16
    2010:	ef 90       	pop	r14
    2012:	df 90       	pop	r13
    2014:	cf 90       	pop	r12
    2016:	bf 90       	pop	r11
    2018:	af 90       	pop	r10
    201a:	08 95       	ret

FATdelfile.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000146  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000017a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000017a  2**0
                  ALLOC
  3 .debug_info   00000768  00000000  00000000  0000017a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001d2  00000000  00000000  000008e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002c4  00000000  00000000  00000ab4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000d78  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000ed  00000000  00000000  00000d98  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004fd  00000000  00000000  00000e85  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000078  00000000  00000000  00001384  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <fileDelete>:



// Return value: TRUE if deleted

boolean fileDelete(DISK * disk,const char* filename){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	cd b7       	in	r28, 0x3d	; 61
  22:	de b7       	in	r29, 0x3e	; 62
  24:	6e 97       	sbiw	r28, 0x1e	; 30
  26:	0f b6       	in	r0, 0x3f	; 63
  28:	f8 94       	cli
  2a:	de bf       	out	0x3e, r29	; 62
  2c:	0f be       	out	0x3f, r0	; 63
  2e:	cd bf       	out	0x3d, r28	; 61
  30:	3c 01       	movw	r6, r24
	boolean rtn = FALSE;
	DIR_POSITION loc;

	if((_fileFindFile(disk,filename,&loc,0))==1){
  32:	ae 01       	movw	r20, r28
  34:	4f 5f       	subi	r20, 0xFF	; 255
  36:	5f 4f       	sbci	r21, 0xFF	; 255
  38:	20 e0       	ldi	r18, 0x00	; 0
  3a:	30 e0       	ldi	r19, 0x00	; 0
  3c:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
  40:	81 30       	cpi	r24, 0x01	; 1
  42:	01 f0       	breq	.+0      	; 0x44 <fileDelete+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <fileDelete+0x46>
		if(loc.attrib.flags.isReadOnly){
  46:	8e 81       	ldd	r24, Y+6	; 0x06
  48:	80 fd       	sbrc	r24, 0
  4a:	00 c0       	rjmp	.+0      	; 0x4c <fileDelete+0x4c>
			return FALSE;
		}
		CLUSTER firstCluster;

		// Read the directory sector
		DIR_ENTRY* buf=_partitionGetSector(disk,loc.sector,BUFFER_MODE_READWRITE);
  4c:	49 81       	ldd	r20, Y+1	; 0x01
  4e:	5a 81       	ldd	r21, Y+2	; 0x02
  50:	6b 81       	ldd	r22, Y+3	; 0x03
  52:	7c 81       	ldd	r23, Y+4	; 0x04
  54:	c3 01       	movw	r24, r6
  56:	22 e0       	ldi	r18, 0x02	; 2
  58:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
  5c:	bc 01       	movw	r22, r24
		DIR_ENTRY* dir = &buf[loc.entryInSector];
  5e:	ed 81       	ldd	r30, Y+5	; 0x05
  60:	f0 e0       	ldi	r31, 0x00	; 0
  62:	25 e0       	ldi	r18, 0x05	; 5
  64:	ee 0f       	add	r30, r30
  66:	ff 1f       	adc	r31, r31
  68:	2a 95       	dec	r18
  6a:	01 f4       	brne	.+0      	; 0x6c <fileDelete+0x6c>
  6c:	e8 0f       	add	r30, r24
  6e:	f9 1f       	adc	r31, r25
		firstCluster = dir->firstClusterHigh;
  70:	c4 88       	ldd	r12, Z+20	; 0x14
  72:	d5 88       	ldd	r13, Z+21	; 0x15
  74:	ee 24       	eor	r14, r14
  76:	ff 24       	eor	r15, r15
		firstCluster <<= 16;
  78:	76 01       	movw	r14, r12
  7a:	dd 24       	eor	r13, r13
  7c:	cc 24       	eor	r12, r12
		firstCluster |= dir->firstClusterLow;
  7e:	82 8d       	ldd	r24, Z+26	; 0x1a
  80:	93 8d       	ldd	r25, Z+27	; 0x1b
  82:	a0 e0       	ldi	r26, 0x00	; 0
  84:	b0 e0       	ldi	r27, 0x00	; 0
  86:	c8 2a       	or	r12, r24
  88:	d9 2a       	or	r13, r25
  8a:	ea 2a       	or	r14, r26
  8c:	fb 2a       	or	r15, r27
		dir->filename[0] = 0xE5;		// Mark file as deleted
  8e:	85 ee       	ldi	r24, 0xE5	; 229
  90:	80 83       	st	Z, r24

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
  92:	c3 01       	movw	r24, r6
  94:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
static void _fatUnlinkClusterChain(const DISK* disk,CLUSTER firstCluster){
	CLUSTER tbd=0;

	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);
  98:	8e 01       	movw	r16, r28
  9a:	09 5f       	subi	r16, 0xF9	; 249
  9c:	1f 4f       	sbci	r17, 0xFF	; 255
  9e:	c8 01       	movw	r24, r16
  a0:	b7 01       	movw	r22, r14
  a2:	a6 01       	movw	r20, r12
  a4:	0e 94 00 00 	call	0	; 0x0 <fileDelete>

	CLUSTER_COUNT c=0;
  a8:	20 e0       	ldi	r18, 0x00	; 0
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	50 e0       	ldi	r21, 0x00	; 0

#include "FATImpl.h"

// Delete all cluster chains starting at the given entry
static void _fatUnlinkClusterChain(const DISK* disk,CLUSTER firstCluster){
	CLUSTER tbd=0;
  b0:	cc 24       	eor	r12, r12
  b2:	dd 24       	eor	r13, r13
  b4:	76 01       	movw	r14, r12
	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);

	CLUSTER_COUNT c=0;
	while(_fatNavigateTo(disk,&nav,c++)){
  b6:	28 01       	movw	r4, r16
  b8:	00 c0       	rjmp	.+0      	; 0xba <fileDelete+0xba>
		if(tbd!=0){					// Delete any current cluster
  ba:	c1 14       	cp	r12, r1
  bc:	d1 04       	cpc	r13, r1
  be:	e1 04       	cpc	r14, r1
  c0:	f1 04       	cpc	r15, r1
  c2:	01 f0       	breq	.+0      	; 0xc4 <fileDelete+0xc4>
			_fatSetNextClusterAddress(disk,tbd,0);
  c4:	c3 01       	movw	r24, r6
  c6:	b7 01       	movw	r22, r14
  c8:	a6 01       	movw	r20, r12
  ca:	00 e0       	ldi	r16, 0x00	; 0
  cc:	10 e0       	ldi	r17, 0x00	; 0
  ce:	20 e0       	ldi	r18, 0x00	; 0
  d0:	30 e0       	ldi	r19, 0x00	; 0
  d2:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
		}
		tbd=nav.currentCluster;		// The current cluser
  d6:	cf 84       	ldd	r12, Y+15	; 0x0f
  d8:	d8 88       	ldd	r13, Y+16	; 0x10
  da:	e9 88       	ldd	r14, Y+17	; 0x11
  dc:	fa 88       	ldd	r15, Y+18	; 0x12
	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav, firstCluster);

	CLUSTER_COUNT c=0;
	while(_fatNavigateTo(disk,&nav,c++)){
  de:	a5 01       	movw	r20, r10
  e0:	94 01       	movw	r18, r8
  e2:	49 01       	movw	r8, r18
  e4:	5a 01       	movw	r10, r20
  e6:	08 94       	sec
  e8:	81 1c       	adc	r8, r1
  ea:	91 1c       	adc	r9, r1
  ec:	a1 1c       	adc	r10, r1
  ee:	b1 1c       	adc	r11, r1
  f0:	c3 01       	movw	r24, r6
  f2:	b2 01       	movw	r22, r4
  f4:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
  f8:	88 23       	and	r24, r24
  fa:	01 f4       	brne	.+0      	; 0xfc <fileDelete+0xfc>
		if(tbd!=0){					// Delete any current cluster
			_fatSetNextClusterAddress(disk,tbd,0);
		}
		tbd=nav.currentCluster;		// The current cluser
	}
	_fatSetNextClusterAddress(disk,nav.currentCluster,0);
  fc:	4f 85       	ldd	r20, Y+15	; 0x0f
  fe:	58 89       	ldd	r21, Y+16	; 0x10
 100:	69 89       	ldd	r22, Y+17	; 0x11
 102:	7a 89       	ldd	r23, Y+18	; 0x12
 104:	c3 01       	movw	r24, r6
 106:	00 e0       	ldi	r16, 0x00	; 0
 108:	10 e0       	ldi	r17, 0x00	; 0
 10a:	20 e0       	ldi	r18, 0x00	; 0
 10c:	30 e0       	ldi	r19, 0x00	; 0
 10e:	0e 94 00 00 	call	0	; 0x0 <fileDelete>
		firstCluster |= dir->firstClusterLow;
		dir->filename[0] = 0xE5;		// Mark file as deleted
		partition_releaseSector(disk,buf);

 		_fatUnlinkClusterChain(disk,firstCluster);
		rtn = TRUE;
 112:	8f ef       	ldi	r24, 0xFF	; 255
 114:	00 c0       	rjmp	.+0      	; 0x116 <fileDelete+0x116>
	boolean rtn = FALSE;
	DIR_POSITION loc;

	if((_fileFindFile(disk,filename,&loc,0))==1){
		if(loc.attrib.flags.isReadOnly){
			return FALSE;
 116:	80 e0       	ldi	r24, 0x00	; 0

 		_fatUnlinkClusterChain(disk,firstCluster);
		rtn = TRUE;
	}
	return rtn;
}
 118:	6e 96       	adiw	r28, 0x1e	; 30
 11a:	0f b6       	in	r0, 0x3f	; 63
 11c:	f8 94       	cli
 11e:	de bf       	out	0x3e, r29	; 62
 120:	0f be       	out	0x3f, r0	; 63
 122:	cd bf       	out	0x3d, r28	; 61
 124:	df 91       	pop	r29
 126:	cf 91       	pop	r28
 128:	1f 91       	pop	r17
 12a:	0f 91       	pop	r16
 12c:	ff 90       	pop	r15
 12e:	ef 90       	pop	r14
 130:	df 90       	pop	r13
 132:	cf 90       	pop	r12
 134:	bf 90       	pop	r11
 136:	af 90       	pop	r10
 138:	9f 90       	pop	r9
 13a:	8f 90       	pop	r8
 13c:	7f 90       	pop	r7
 13e:	6f 90       	pop	r6
 140:	5f 90       	pop	r5
 142:	4f 90       	pop	r4
 144:	08 95       	ret

FATfile.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c44  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000c78  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000c78  2**0
                  ALLOC
  3 .debug_info   000011f7  00000000  00000000  00000c78  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000376  00000000  00000000  00001e6f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000015d0  00000000  00000000  000021e5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000037b5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  000037d5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000002a3  00000000  00000000  000037ed  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000079a  00000000  00000000  00003a90  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000360  00000000  00000000  0000422c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_dirGetFileStructure>:


// This function stores the filerecord located at loc in filerec.
// It fetches the required sector for this.
// Return value: void
static void _dirGetFileStructure(const DISK* disk,DIR_ENTRY *filerec,const DIR_POSITION *loc){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	8c 01       	movw	r16, r24
   e:	f6 2e       	mov	r15, r22
  10:	e7 2e       	mov	r14, r23
  12:	ea 01       	movw	r28, r20
	void* buf=_partitionGetSector(disk,loc->sector,BUFFER_MODE_READONLY);
  14:	48 81       	ld	r20, Y
  16:	59 81       	ldd	r21, Y+1	; 0x01
  18:	6a 81       	ldd	r22, Y+2	; 0x02
  1a:	7b 81       	ldd	r23, Y+3	; 0x03
  1c:	21 e0       	ldi	r18, 0x01	; 1
  1e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
  22:	bc 01       	movw	r22, r24
	DIR_ENTRY* dir = (DIR_ENTRY*)buf;
	memcpy(filerec,&dir[loc->entryInSector],sizeof(DIR_ENTRY));
  24:	ec 81       	ldd	r30, Y+4	; 0x04
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	25 e0       	ldi	r18, 0x05	; 5
  2a:	ee 0f       	add	r30, r30
  2c:	ff 1f       	adc	r31, r31
  2e:	2a 95       	dec	r18
  30:	01 f4       	brne	.+0      	; 0x32 <_dirGetFileStructure+0x32>
  32:	af 2d       	mov	r26, r15
  34:	be 2d       	mov	r27, r14
  36:	e8 0f       	add	r30, r24
  38:	f9 1f       	adc	r31, r25
  3a:	80 e2       	ldi	r24, 0x20	; 32
  3c:	01 90       	ld	r0, Z+
  3e:	0d 92       	st	X+, r0
  40:	81 50       	subi	r24, 0x01	; 1
  42:	01 f4       	brne	.+0      	; 0x44 <_dirGetFileStructure+0x44>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
  44:	c8 01       	movw	r24, r16
  46:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	partition_releaseSector(disk,buf);
}
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	08 95       	ret

00000058 <_fileInitFile>:
	memcpy(filerec->filename,fatfilename,11);
}


// Initialises a new file object
static void _fileInitFile(DISK* disk, FATFILE *file, const DIR_ENTRY* dir, const DIR_POSITION *loc){
  58:	0f 93       	push	r16
  5a:	1f 93       	push	r17
  5c:	cf 93       	push	r28
  5e:	df 93       	push	r29
  60:	fb 01       	movw	r30, r22
	file->disk=disk;
  62:	91 83       	std	Z+1, r25	; 0x01
  64:	80 83       	st	Z, r24
	file->fileSize=dir->fileSize;
  66:	ea 01       	movw	r28, r20
  68:	8c 8d       	ldd	r24, Y+28	; 0x1c
  6a:	9d 8d       	ldd	r25, Y+29	; 0x1d
  6c:	ae 8d       	ldd	r26, Y+30	; 0x1e
  6e:	bf 8d       	ldd	r27, Y+31	; 0x1f
  70:	81 a7       	std	Z+41, r24	; 0x29
  72:	92 a7       	std	Z+42, r25	; 0x2a
  74:	a3 a7       	std	Z+43, r26	; 0x2b
  76:	b4 a7       	std	Z+44, r27	; 0x2c
	file->filePos=0;
  78:	15 a2       	std	Z+37, r1	; 0x25
  7a:	16 a2       	std	Z+38, r1	; 0x26
  7c:	17 a2       	std	Z+39, r1	; 0x27
  7e:	10 a6       	std	Z+40, r1	; 0x28
	file->directory.sector=loc->sector;
  80:	e9 01       	movw	r28, r18
  82:	88 81       	ld	r24, Y
  84:	99 81       	ldd	r25, Y+1	; 0x01
  86:	aa 81       	ldd	r26, Y+2	; 0x02
  88:	bb 81       	ldd	r27, Y+3	; 0x03
  8a:	86 83       	std	Z+6, r24	; 0x06
  8c:	97 83       	std	Z+7, r25	; 0x07
  8e:	a0 87       	std	Z+8, r26	; 0x08
  90:	b1 87       	std	Z+9, r27	; 0x09
	file->directory.entryInSector=loc->entryInSector;
  92:	8c 81       	ldd	r24, Y+4	; 0x04
  94:	82 87       	std	Z+10, r24	; 0x0a

	CLUSTER firstCluster = (((CLUSTER)dir->firstClusterHigh)<<16)+dir->firstClusterLow;;
  96:	da 01       	movw	r26, r20
  98:	54 96       	adiw	r26, 0x14	; 20
  9a:	4d 91       	ld	r20, X+
  9c:	5c 91       	ld	r21, X
  9e:	55 97       	sbiw	r26, 0x15	; 21
  a0:	60 e0       	ldi	r22, 0x00	; 0
  a2:	70 e0       	ldi	r23, 0x00	; 0
  a4:	ba 01       	movw	r22, r20
  a6:	55 27       	eor	r21, r21
  a8:	44 27       	eor	r20, r20
  aa:	5a 96       	adiw	r26, 0x1a	; 26
  ac:	8d 91       	ld	r24, X+
  ae:	9c 91       	ld	r25, X
  b0:	5b 97       	sbiw	r26, 0x1b	; 27
  b2:	a0 e0       	ldi	r26, 0x00	; 0
  b4:	b0 e0       	ldi	r27, 0x00	; 0
  b6:	48 0f       	add	r20, r24
  b8:	59 1f       	adc	r21, r25
  ba:	6a 1f       	adc	r22, r26
  bc:	7b 1f       	adc	r23, r27
	file->startCluster = firstCluster;
  be:	42 83       	std	Z+2, r20	; 0x02
  c0:	53 83       	std	Z+3, r21	; 0x03
  c2:	64 83       	std	Z+4, r22	; 0x04
  c4:	75 83       	std	Z+5, r23	; 0x05

	_navInitClusterChain(&file->nav, firstCluster);
  c6:	cf 01       	movw	r24, r30
  c8:	0c 96       	adiw	r24, 0x0c	; 12
  ca:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
}
  ce:	df 91       	pop	r29
  d0:	cf 91       	pop	r28
  d2:	1f 91       	pop	r17
  d4:	0f 91       	pop	r16
  d6:	08 95       	ret

000000d8 <_allocateFirstCluster>:
	dir[loc->entryInSector].firstClusterLow=cluster_addr&0xFFFF;
	partition_releaseSector(disk,dir);
}


static void _allocateFirstCluster(DISK* disk, FATFILE* file, DIR_ENTRY* dir, const DIR_POSITION *loc){
  d8:	6f 92       	push	r6
  da:	7f 92       	push	r7
  dc:	8f 92       	push	r8
  de:	9f 92       	push	r9
  e0:	af 92       	push	r10
  e2:	bf 92       	push	r11
  e4:	cf 92       	push	r12
  e6:	df 92       	push	r13
  e8:	ef 92       	push	r14
  ea:	ff 92       	push	r15
  ec:	0f 93       	push	r16
  ee:	1f 93       	push	r17
  f0:	cf 93       	push	r28
  f2:	df 93       	push	r29
  f4:	ec 01       	movw	r28, r24
  f6:	5b 01       	movw	r10, r22
  f8:	4a 01       	movw	r8, r20
  fa:	39 01       	movw	r6, r18
	CLUSTER cluster=_fatGetFreeCluster(disk);
  fc:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 100:	6b 01       	movw	r12, r22
 102:	7c 01       	movw	r14, r24
	if(cluster != 0){
 104:	61 15       	cp	r22, r1
 106:	71 05       	cpc	r23, r1
 108:	81 05       	cpc	r24, r1
 10a:	91 05       	cpc	r25, r1
 10c:	01 f0       	breq	.+0      	; 0x10e <_allocateFirstCluster+0x36>
	}
}

// Update a disk directory entry with the given start cluster
static void _dirSetFirstCluster(const DISK* disk,const DIR_POSITION *loc,CLUSTER cluster_addr){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 10e:	d5 01       	movw	r26, r10
 110:	16 96       	adiw	r26, 0x06	; 6
 112:	4d 91       	ld	r20, X+
 114:	5d 91       	ld	r21, X+
 116:	6d 91       	ld	r22, X+
 118:	7c 91       	ld	r23, X
 11a:	19 97       	sbiw	r26, 0x09	; 9
 11c:	ce 01       	movw	r24, r28
 11e:	22 e0       	ldi	r18, 0x02	; 2
 120:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 124:	bc 01       	movw	r22, r24
	dir[loc->entryInSector].firstClusterHigh=cluster_addr>>16;
 126:	d5 01       	movw	r26, r10
 128:	1a 96       	adiw	r26, 0x0a	; 10
 12a:	ec 91       	ld	r30, X
 12c:	1a 97       	sbiw	r26, 0x0a	; 10
 12e:	f0 e0       	ldi	r31, 0x00	; 0
 130:	25 e0       	ldi	r18, 0x05	; 5
 132:	ee 0f       	add	r30, r30
 134:	ff 1f       	adc	r31, r31
 136:	2a 95       	dec	r18
 138:	01 f4       	brne	.+0      	; 0x13a <_allocateFirstCluster+0x62>
 13a:	e8 0f       	add	r30, r24
 13c:	f9 1f       	adc	r31, r25
 13e:	f5 8a       	std	Z+21, r15	; 0x15
 140:	e4 8a       	std	Z+20, r14	; 0x14
	dir[loc->entryInSector].firstClusterLow=cluster_addr&0xFFFF;
 142:	1a 96       	adiw	r26, 0x0a	; 10
 144:	ec 91       	ld	r30, X
 146:	f0 e0       	ldi	r31, 0x00	; 0
 148:	35 e0       	ldi	r19, 0x05	; 5
 14a:	ee 0f       	add	r30, r30
 14c:	ff 1f       	adc	r31, r31
 14e:	3a 95       	dec	r19
 150:	01 f4       	brne	.+0      	; 0x152 <_allocateFirstCluster+0x7a>
 152:	e8 0f       	add	r30, r24
 154:	f9 1f       	adc	r31, r25
 156:	d3 8e       	std	Z+27, r13	; 0x1b
 158:	c2 8e       	std	Z+26, r12	; 0x1a
 15a:	ce 01       	movw	r24, r28
 15c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	if(cluster != 0){
		// Update disk dir with first cluster
		_dirSetFirstCluster(disk,&(file->directory),cluster);

		// Update directory with first cluster
		_dirSetFirstClusterInDirEntry(dir,cluster);
 160:	c4 01       	movw	r24, r8
 162:	b7 01       	movw	r22, r14
 164:	a6 01       	movw	r20, r12
 166:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

		// First cluster is end of chain
		_fatSetNextClusterAddress(disk,cluster,_fatGiveEndMarker(disk));
 16a:	ce 01       	movw	r24, r28
 16c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 170:	8b 01       	movw	r16, r22
 172:	9c 01       	movw	r18, r24
 174:	ce 01       	movw	r24, r28
 176:	b7 01       	movw	r22, r14
 178:	a6 01       	movw	r20, r12
 17a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

		// Re-initialise the file with the changes
		_fileInitFile(disk,file,dir,loc);
 17e:	ce 01       	movw	r24, r28
 180:	b5 01       	movw	r22, r10
 182:	a4 01       	movw	r20, r8
 184:	93 01       	movw	r18, r6
 186:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	}
}
 18a:	df 91       	pop	r29
 18c:	cf 91       	pop	r28
 18e:	1f 91       	pop	r17
 190:	0f 91       	pop	r16
 192:	ff 90       	pop	r15
 194:	ef 90       	pop	r14
 196:	df 90       	pop	r13
 198:	cf 90       	pop	r12
 19a:	bf 90       	pop	r11
 19c:	af 90       	pop	r10
 19e:	9f 90       	pop	r9
 1a0:	8f 90       	pop	r8
 1a2:	7f 90       	pop	r7
 1a4:	6f 90       	pop	r6
 1a6:	08 95       	ret

000001a8 <_fileSetAttr.isra.1>:

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
}

static void _fileSetAttr(FATFILE* file,uint8_t attribute,uint8_t val){
 1a8:	fc 01       	movw	r30, r24
 1aa:	20 81       	ld	r18, Z
	if(val){
		file->mode|=1<<attribute;
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	90 e0       	ldi	r25, 0x00	; 0
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <_fileSetAttr.isra.1+0xa>
 1b2:	88 0f       	add	r24, r24
 1b4:	99 1f       	adc	r25, r25
 1b6:	6a 95       	dec	r22
 1b8:	02 f4       	brpl	.+0      	; 0x1ba <_fileSetAttr.isra.1+0x12>
static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
}

static void _fileSetAttr(FATFILE* file,uint8_t attribute,uint8_t val){
	if(val){
 1ba:	44 23       	and	r20, r20
 1bc:	01 f0       	breq	.+0      	; 0x1be <_fileSetAttr.isra.1+0x16>
		file->mode|=1<<attribute;
 1be:	82 2b       	or	r24, r18
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <_fileSetAttr.isra.1+0x1a>
	}else{
		file->mode&=~(1<<attribute);
 1c2:	80 95       	com	r24
 1c4:	82 23       	and	r24, r18
 1c6:	80 83       	st	Z, r24
 1c8:	08 95       	ret

000001ca <fileSetPos>:
	file->startCluster = firstCluster;

	_navInitClusterChain(&file->nav, firstCluster);
}

boolean fileSetPos(FATFILE *file,uint32_t pos){
 1ca:	fc 01       	movw	r30, r24
	if(pos<=file->fileSize){
 1cc:	81 a5       	ldd	r24, Z+41	; 0x29
 1ce:	92 a5       	ldd	r25, Z+42	; 0x2a
 1d0:	a3 a5       	ldd	r26, Z+43	; 0x2b
 1d2:	b4 a5       	ldd	r27, Z+44	; 0x2c
 1d4:	84 17       	cp	r24, r20
 1d6:	95 07       	cpc	r25, r21
 1d8:	a6 07       	cpc	r26, r22
 1da:	b7 07       	cpc	r27, r23
 1dc:	00 f0       	brcs	.+0      	; 0x1de <fileSetPos+0x14>
		file->filePos=pos;
 1de:	45 a3       	std	Z+37, r20	; 0x25
 1e0:	56 a3       	std	Z+38, r21	; 0x26
 1e2:	67 a3       	std	Z+39, r22	; 0x27
 1e4:	70 a7       	std	Z+40, r23	; 0x28
		return(TRUE);
 1e6:	8f ef       	ldi	r24, 0xFF	; 255
 1e8:	08 95       	ret
	}
	return(FALSE);
 1ea:	80 e0       	ldi	r24, 0x00	; 0
}
 1ec:	08 95       	ret

000001ee <fileExists>:
		// Re-initialise the file with the changes
		_fileInitFile(disk,file,dir,loc);
	}
}

boolean fileExists(DISK * disk,const char* filename){
 1ee:	ef 92       	push	r14
 1f0:	ff 92       	push	r15
 1f2:	0f 93       	push	r16
 1f4:	1f 93       	push	r17
 1f6:	cf 93       	push	r28
 1f8:	df 93       	push	r29
 1fa:	cd b7       	in	r28, 0x3d	; 61
 1fc:	de b7       	in	r29, 0x3e	; 62
 1fe:	61 97       	sbiw	r28, 0x11	; 17
 200:	0f b6       	in	r0, 0x3f	; 63
 202:	f8 94       	cli
 204:	de bf       	out	0x3e, r29	; 62
 206:	0f be       	out	0x3f, r0	; 63
 208:	cd bf       	out	0x3d, r28	; 61
 20a:	7c 01       	movw	r14, r24
 20c:	8b 01       	movw	r16, r22
    DIR_POSITION loc;
    char fatfilename[11];
    _dirGetFatFileName(filename,fatfilename);
 20e:	cb 01       	movw	r24, r22
 210:	be 01       	movw	r22, r28
 212:	69 5f       	subi	r22, 0xF9	; 249
 214:	7f 4f       	sbci	r23, 0xFF	; 255
 216:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
    return (_fileFindFile(disk,filename,&loc,null)==0) ? FALSE : TRUE;
 21a:	c7 01       	movw	r24, r14
 21c:	b8 01       	movw	r22, r16
 21e:	ae 01       	movw	r20, r28
 220:	4f 5f       	subi	r20, 0xFF	; 255
 222:	5f 4f       	sbci	r21, 0xFF	; 255
 224:	20 e0       	ldi	r18, 0x00	; 0
 226:	30 e0       	ldi	r19, 0x00	; 0
 228:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 22c:	81 11       	cpse	r24, r1
 22e:	8f ef       	ldi	r24, 0xFF	; 255
}
 230:	61 96       	adiw	r28, 0x11	; 17
 232:	0f b6       	in	r0, 0x3f	; 63
 234:	f8 94       	cli
 236:	de bf       	out	0x3e, r29	; 62
 238:	0f be       	out	0x3f, r0	; 63
 23a:	cd bf       	out	0x3d, r28	; 61
 23c:	df 91       	pop	r29
 23e:	cf 91       	pop	r28
 240:	1f 91       	pop	r17
 242:	0f 91       	pop	r16
 244:	ff 90       	pop	r15
 246:	ef 90       	pop	r14
 248:	08 95       	ret

0000024a <fileOpen>:

// Open a file and return a file handle 'File'
int8_t fileOpen(DISK* disk, FATFILE* file,const char* filename,char mode){
 24a:	cf 92       	push	r12
 24c:	df 92       	push	r13
 24e:	ef 92       	push	r14
 250:	ff 92       	push	r15
 252:	0f 93       	push	r16
 254:	1f 93       	push	r17
 256:	cf 93       	push	r28
 258:	df 93       	push	r29
 25a:	cd b7       	in	r28, 0x3d	; 61
 25c:	de b7       	in	r29, 0x3e	; 62
 25e:	e6 97       	sbiw	r28, 0x36	; 54
 260:	0f b6       	in	r0, 0x3f	; 63
 262:	f8 94       	cli
 264:	de bf       	out	0x3e, r29	; 62
 266:	0f be       	out	0x3f, r0	; 63
 268:	cd bf       	out	0x3d, r28	; 61
 26a:	8c 01       	movw	r16, r24
 26c:	7b 01       	movw	r14, r22
 26e:	6a 01       	movw	r12, r20
    DIR_POSITION loc;
    char fatfilename[11];
    CLUSTER dirCluster;
	DIR_ENTRY wtmp;

    _dirGetFatFileName(filename,fatfilename);
 270:	ca 01       	movw	r24, r20
 272:	be 01       	movw	r22, r28
 274:	65 5f       	subi	r22, 0xF5	; 245
 276:	7f 4f       	sbci	r23, 0xFF	; 255
 278:	2e ab       	std	Y+54, r18	; 0x36
 27a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

    switch(mode){
 27e:	2e a9       	ldd	r18, Y+54	; 0x36
 280:	22 37       	cpi	r18, 0x72	; 114
 282:	01 f0       	breq	.+0      	; 0x284 <fileOpen+0x3a>
 284:	27 37       	cpi	r18, 0x77	; 119
 286:	01 f0       	breq	.+0      	; 0x288 <fileOpen+0x3e>
 288:	21 36       	cpi	r18, 0x61	; 97
 28a:	01 f0       	breq	.+0      	; 0x28c <fileOpen+0x42>
 28c:	00 c0       	rjmp	.+0      	; 0x28e <fileOpen+0x44>
 28e:	00 c0       	rjmp	.+0      	; 0x290 <fileOpen+0x46>
        case MODE_READ:
            if(_fileFindFile(disk,filename,&loc,null)==1){
 290:	c8 01       	movw	r24, r16
 292:	b6 01       	movw	r22, r12
 294:	ae 01       	movw	r20, r28
 296:	4b 5f       	subi	r20, 0xFB	; 251
 298:	5f 4f       	sbci	r21, 0xFF	; 255
 29a:	20 e0       	ldi	r18, 0x00	; 0
 29c:	30 e0       	ldi	r19, 0x00	; 0
 29e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 2a2:	81 30       	cpi	r24, 0x01	; 1
 2a4:	01 f0       	breq	.+0      	; 0x2a6 <fileOpen+0x5c>
 2a6:	00 c0       	rjmp	.+0      	; 0x2a8 <fileOpen+0x5e>
                _dirGetFileStructure(disk,&wtmp, &loc);
 2a8:	c8 01       	movw	r24, r16
 2aa:	be 01       	movw	r22, r28
 2ac:	6a 5e       	subi	r22, 0xEA	; 234
 2ae:	7f 4f       	sbci	r23, 0xFF	; 255
 2b0:	ae 01       	movw	r20, r28
 2b2:	4b 5f       	subi	r20, 0xFB	; 251
 2b4:	5f 4f       	sbci	r21, 0xFF	; 255
 2b6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
                _fileInitFile(disk,file,&wtmp,&loc);
 2ba:	c8 01       	movw	r24, r16
 2bc:	b7 01       	movw	r22, r14
 2be:	ae 01       	movw	r20, r28
 2c0:	4a 5e       	subi	r20, 0xEA	; 234
 2c2:	5f 4f       	sbci	r21, 0xFF	; 255
 2c4:	9e 01       	movw	r18, r28
 2c6:	2b 5f       	subi	r18, 0xFB	; 251
 2c8:	3f 4f       	sbci	r19, 0xFF	; 255
 2ca:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
}

Writer fileGetWriter(const FATFILE* file){
	activeFile = (FATFILE*)file;
	return &writer;
}
 2ce:	87 01       	movw	r16, r14
 2d0:	0c 5d       	subi	r16, 0xDC	; 220
 2d2:	1f 4f       	sbci	r17, 0xFF	; 255
    switch(mode){
        case MODE_READ:
            if(_fileFindFile(disk,filename,&loc,null)==1){
                _dirGetFileStructure(disk,&wtmp, &loc);
                _fileInitFile(disk,file,&wtmp,&loc);
				_fileSetAttr(file,FILE_STATUS_OPEN,1);
 2d4:	c8 01       	movw	r24, r16
 2d6:	60 e0       	ldi	r22, 0x00	; 0
 2d8:	41 e0       	ldi	r20, 0x01	; 1
 2da:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				_fileSetAttr(file,FILE_STATUS_WRITE,0);
 2de:	c8 01       	movw	r24, r16
 2e0:	61 e0       	ldi	r22, 0x01	; 1
 2e2:	40 e0       	ldi	r20, 0x00	; 0
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <fileOpen+0x9c>
                return(0);
            }
            return(-1);
        case MODE_WRITE:
            if(_fileFindFile(disk,filename,&loc,&dirCluster)){
 2e6:	c8 01       	movw	r24, r16
 2e8:	b6 01       	movw	r22, r12
 2ea:	ae 01       	movw	r20, r28
 2ec:	4b 5f       	subi	r20, 0xFB	; 251
 2ee:	5f 4f       	sbci	r21, 0xFF	; 255
 2f0:	9e 01       	movw	r18, r28
 2f2:	2f 5f       	subi	r18, 0xFF	; 255
 2f4:	3f 4f       	sbci	r19, 0xFF	; 255
 2f6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 2fa:	88 23       	and	r24, r24
 2fc:	01 f0       	breq	.+0      	; 0x2fe <fileOpen+0xb4>
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <fileOpen+0xb6>
                return(-2);	// File already exists
			}
			if(dirCluster==0){ 	// Parent dir does not exist
 300:	89 81       	ldd	r24, Y+1	; 0x01
 302:	9a 81       	ldd	r25, Y+2	; 0x02
 304:	ab 81       	ldd	r26, Y+3	; 0x03
 306:	bc 81       	ldd	r27, Y+4	; 0x04
 308:	00 97       	sbiw	r24, 0x00	; 0
 30a:	a1 05       	cpc	r26, r1
 30c:	b1 05       	cpc	r27, r1
 30e:	01 f0       	breq	.+0      	; 0x310 <fileOpen+0xc6>
 310:	00 c0       	rjmp	.+0      	; 0x312 <fileOpen+0xc8>
 312:	00 c0       	rjmp	.+0      	; 0x314 <fileOpen+0xca>
 				return(-3);
			}
			goto create;
        case MODE_APPEND:
			if(_fileFindFile(disk,filename,&loc,0)==1){ /* File exists */
 314:	c8 01       	movw	r24, r16
 316:	b6 01       	movw	r22, r12
 318:	ae 01       	movw	r20, r28
 31a:	4b 5f       	subi	r20, 0xFB	; 251
 31c:	5f 4f       	sbci	r21, 0xFF	; 255
 31e:	20 e0       	ldi	r18, 0x00	; 0
 320:	30 e0       	ldi	r19, 0x00	; 0
 322:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 326:	81 30       	cpi	r24, 0x01	; 1
 328:	01 f4       	brne	.+0      	; 0x32a <fileOpen+0xe0>
				if(loc.attrib.flags.isReadOnly){
 32a:	8a 85       	ldd	r24, Y+10	; 0x0a
 32c:	80 fd       	sbrc	r24, 0
 32e:	00 c0       	rjmp	.+0      	; 0x330 <fileOpen+0xe6>
					return -4;						  /* but is read only */
				}
				_dirGetFileStructure(disk,&wtmp, &loc);
 330:	c8 01       	movw	r24, r16
 332:	be 01       	movw	r22, r28
 334:	6a 5e       	subi	r22, 0xEA	; 234
 336:	7f 4f       	sbci	r23, 0xFF	; 255
 338:	ae 01       	movw	r20, r28
 33a:	4b 5f       	subi	r20, 0xFB	; 251
 33c:	5f 4f       	sbci	r21, 0xFF	; 255
 33e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				_fileInitFile(disk,file,&wtmp,&loc);
 342:	c8 01       	movw	r24, r16
 344:	b7 01       	movw	r22, r14
 346:	ae 01       	movw	r20, r28
 348:	4a 5e       	subi	r20, 0xEA	; 234
 34a:	5f 4f       	sbci	r21, 0xFF	; 255
 34c:	9e 01       	movw	r18, r28
 34e:	2b 5f       	subi	r18, 0xFB	; 251
 350:	3f 4f       	sbci	r19, 0xFF	; 255
 352:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				if(file->nav.startCluster==0){
 356:	f7 01       	movw	r30, r14
 358:	80 8d       	ldd	r24, Z+24	; 0x18
 35a:	91 8d       	ldd	r25, Z+25	; 0x19
 35c:	a2 8d       	ldd	r26, Z+26	; 0x1a
 35e:	b3 8d       	ldd	r27, Z+27	; 0x1b
 360:	00 97       	sbiw	r24, 0x00	; 0
 362:	a1 05       	cpc	r26, r1
 364:	b1 05       	cpc	r27, r1
 366:	01 f4       	brne	.+0      	; 0x368 <fileOpen+0x11e>
					// The file is empty
					_allocateFirstCluster(disk,file,&wtmp,&loc);
 368:	c8 01       	movw	r24, r16
 36a:	b7 01       	movw	r22, r14
 36c:	ae 01       	movw	r20, r28
 36e:	4a 5e       	subi	r20, 0xEA	; 234
 370:	5f 4f       	sbci	r21, 0xFF	; 255
 372:	9e 01       	movw	r18, r28
 374:	2b 5f       	subi	r18, 0xFB	; 251
 376:	3f 4f       	sbci	r19, 0xFF	; 255
 378:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	_navInitClusterChain(&file->nav, firstCluster);
}

boolean fileSetPos(FATFILE *file,uint32_t pos){
	if(pos<=file->fileSize){
		file->filePos=pos;
 37c:	f7 01       	movw	r30, r14
 37e:	81 a5       	ldd	r24, Z+41	; 0x29
 380:	92 a5       	ldd	r25, Z+42	; 0x2a
 382:	a3 a5       	ldd	r26, Z+43	; 0x2b
 384:	b4 a5       	ldd	r27, Z+44	; 0x2c
 386:	85 a3       	std	Z+37, r24	; 0x25
 388:	96 a3       	std	Z+38, r25	; 0x26
 38a:	a7 a3       	std	Z+39, r26	; 0x27
 38c:	b0 a7       	std	Z+40, r27	; 0x28
 38e:	00 c0       	rjmp	.+0      	; 0x390 <fileOpen+0x146>
				_fileSetAttr(file,FILE_STATUS_OPEN,1);
				_fileSetAttr(file,FILE_STATUS_WRITE,1);
			}else{ /* File does not excist */
create:
				// Create a new file
				if(_dirFindFreeFile(disk,filename,&loc))	{
 390:	c8 01       	movw	r24, r16
 392:	b6 01       	movw	r22, r12
 394:	ae 01       	movw	r20, r28
 396:	4b 5f       	subi	r20, 0xFB	; 251
 398:	5f 4f       	sbci	r21, 0xFF	; 255
 39a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 39e:	88 23       	and	r24, r24
 3a0:	01 f4       	brne	.+0      	; 0x3a2 <fileOpen+0x158>
 3a2:	00 c0       	rjmp	.+0      	; 0x3a4 <fileOpen+0x15a>
					_dirCreateDefaultEntry(&wtmp,fatfilename);
 3a4:	de 01       	movw	r26, r28
 3a6:	56 96       	adiw	r26, 0x16	; 22
// This function fills in a filerecord with safe default values, and
// a given fatfilename. If your system has a means of knowing time, here is an
// excellent place to apply it to the filerecord.
// Return value: void
static void _dirCreateDefaultEntry(DIR_ENTRY *filerec,const char* fatfilename){
	memclr(filerec,sizeof(DIR_ENTRY));
 3a8:	80 e2       	ldi	r24, 0x20	; 32
 3aa:	fd 01       	movw	r30, r26
 3ac:	11 92       	st	Z+, r1
 3ae:	8a 95       	dec	r24
 3b0:	01 f4       	brne	.+0      	; 0x3b2 <fileOpen+0x168>
	memcpy(filerec->filename,fatfilename,11);
 3b2:	fe 01       	movw	r30, r28
 3b4:	3b 96       	adiw	r30, 0x0b	; 11
 3b6:	8b e0       	ldi	r24, 0x0B	; 11
 3b8:	01 90       	ld	r0, Z+
 3ba:	0d 92       	st	X+, r0
 3bc:	81 50       	subi	r24, 0x01	; 1
 3be:	01 f4       	brne	.+0      	; 0x3c0 <fileOpen+0x176>
create:
				// Create a new file
				if(_dirFindFreeFile(disk,filename,&loc))	{
					_dirCreateDefaultEntry(&wtmp,fatfilename);
					// Copy directory to disk
					_dirCreateDirectoryEntry(disk,&wtmp,&loc);
 3c0:	c8 01       	movw	r24, r16
 3c2:	be 01       	movw	r22, r28
 3c4:	6a 5e       	subi	r22, 0xEA	; 234
 3c6:	7f 4f       	sbci	r23, 0xFF	; 255
 3c8:	ae 01       	movw	r20, r28
 3ca:	4b 5f       	subi	r20, 0xFB	; 251
 3cc:	5f 4f       	sbci	r21, 0xFF	; 255
 3ce:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		rprintfInit(old);}
#endif


					// Initialise file with directory info
					_fileInitFile(disk,file,&wtmp, &loc);
 3d2:	c8 01       	movw	r24, r16
 3d4:	b7 01       	movw	r22, r14
 3d6:	ae 01       	movw	r20, r28
 3d8:	4a 5e       	subi	r20, 0xEA	; 234
 3da:	5f 4f       	sbci	r21, 0xFF	; 255
 3dc:	9e 01       	movw	r18, r28
 3de:	2b 5f       	subi	r18, 0xFB	; 251
 3e0:	3f 4f       	sbci	r19, 0xFF	; 255
 3e2:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

					// Allocate the first cluster to the file data
					_allocateFirstCluster(disk,file,&wtmp,&loc);
 3e6:	c8 01       	movw	r24, r16
 3e8:	b7 01       	movw	r22, r14
 3ea:	ae 01       	movw	r20, r28
 3ec:	4a 5e       	subi	r20, 0xEA	; 234
 3ee:	5f 4f       	sbci	r21, 0xFF	; 255
 3f0:	9e 01       	movw	r18, r28
 3f2:	2b 5f       	subi	r18, 0xFB	; 251
 3f4:	3f 4f       	sbci	r19, 0xFF	; 255
 3f6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
}

Writer fileGetWriter(const FATFILE* file){
	activeFile = (FATFILE*)file;
	return &writer;
}
 3fa:	87 01       	movw	r16, r14
 3fc:	0c 5d       	subi	r16, 0xDC	; 220
 3fe:	1f 4f       	sbci	r17, 0xFF	; 255
					_fileInitFile(disk,file,&wtmp, &loc);

					// Allocate the first cluster to the file data
					_allocateFirstCluster(disk,file,&wtmp,&loc);

					_fileSetAttr(file,FILE_STATUS_OPEN,1);
 400:	c8 01       	movw	r24, r16
 402:	60 e0       	ldi	r22, 0x00	; 0
 404:	41 e0       	ldi	r20, 0x01	; 1
 406:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
					_fileSetAttr(file,FILE_STATUS_WRITE,1);
 40a:	c8 01       	movw	r24, r16
 40c:	61 e0       	ldi	r22, 0x01	; 1
 40e:	41 e0       	ldi	r20, 0x01	; 1
 410:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
				}else{
					return(-5);
				}
			}
			return(0);
 414:	80 e0       	ldi	r24, 0x00	; 0
 416:	00 c0       	rjmp	.+0      	; 0x418 <fileOpen+0x1ce>
    }
    return(-6);
 418:	8a ef       	ldi	r24, 0xFA	; 250
 41a:	00 c0       	rjmp	.+0      	; 0x41c <fileOpen+0x1d2>
                _fileInitFile(disk,file,&wtmp,&loc);
				_fileSetAttr(file,FILE_STATUS_OPEN,1);
				_fileSetAttr(file,FILE_STATUS_WRITE,0);
                return(0);
            }
            return(-1);
 41c:	8f ef       	ldi	r24, 0xFF	; 255
 41e:	00 c0       	rjmp	.+0      	; 0x420 <fileOpen+0x1d6>
        case MODE_WRITE:
            if(_fileFindFile(disk,filename,&loc,&dirCluster)){
                return(-2);	// File already exists
 420:	8e ef       	ldi	r24, 0xFE	; 254
 422:	00 c0       	rjmp	.+0      	; 0x424 <fileOpen+0x1da>
			}
			if(dirCluster==0){ 	// Parent dir does not exist
 				return(-3);
 424:	8d ef       	ldi	r24, 0xFD	; 253
 426:	00 c0       	rjmp	.+0      	; 0x428 <fileOpen+0x1de>
			}
			goto create;
        case MODE_APPEND:
			if(_fileFindFile(disk,filename,&loc,0)==1){ /* File exists */
				if(loc.attrib.flags.isReadOnly){
					return -4;						  /* but is read only */
 428:	8c ef       	ldi	r24, 0xFC	; 252
 42a:	00 c0       	rjmp	.+0      	; 0x42c <fileOpen+0x1e2>
					_allocateFirstCluster(disk,file,&wtmp,&loc);

					_fileSetAttr(file,FILE_STATUS_OPEN,1);
					_fileSetAttr(file,FILE_STATUS_WRITE,1);
				}else{
					return(-5);
 42c:	8b ef       	ldi	r24, 0xFB	; 251
				}
			}
			return(0);
    }
    return(-6);
}
 42e:	e6 96       	adiw	r28, 0x36	; 54
 430:	0f b6       	in	r0, 0x3f	; 63
 432:	f8 94       	cli
 434:	de bf       	out	0x3e, r29	; 62
 436:	0f be       	out	0x3f, r0	; 63
 438:	cd bf       	out	0x3d, r28	; 61
 43a:	df 91       	pop	r29
 43c:	cf 91       	pop	r28
 43e:	1f 91       	pop	r17
 440:	0f 91       	pop	r16
 442:	ff 90       	pop	r15
 444:	ef 90       	pop	r14
 446:	df 90       	pop	r13
 448:	cf 90       	pop	r12
 44a:	08 95       	ret

0000044c <fileFlush>:

	// Return the count
	return(c-1);
}

void fileFlush(FATFILE* file){
 44c:	cf 92       	push	r12
 44e:	df 92       	push	r13
 450:	ef 92       	push	r14
 452:	ff 92       	push	r15
 454:	0f 93       	push	r16
 456:	1f 93       	push	r17
 458:	cf 93       	push	r28
 45a:	df 93       	push	r29
 45c:	ec 01       	movw	r28, r24
	}
	return(FALSE);
}

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
 45e:	8c a1       	ldd	r24, Y+36	; 0x24
	// Return the count
	return(c-1);
}

void fileFlush(FATFILE* file){
	if(_fileGetAttr(file,FILE_STATUS_WRITE)){
 460:	81 ff       	sbrs	r24, 1
 462:	00 c0       	rjmp	.+0      	; 0x464 <fileFlush+0x18>
		CLUSTER_COUNT cnt = _fatCountClustersInChain(file->disk,file->startCluster);
		rprintf("Flush File: First Cl=%lu, NumCl=%lu\n",file->startCluster,cnt);
		rprintfInit(old);}
#endif

		_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
 464:	08 81       	ld	r16, Y
 466:	19 81       	ldd	r17, Y+1	; 0x01
 468:	c9 a4       	ldd	r12, Y+41	; 0x29
 46a:	da a4       	ldd	r13, Y+42	; 0x2a
 46c:	eb a4       	ldd	r14, Y+43	; 0x2b
 46e:	fc a4       	ldd	r15, Y+44	; 0x2c

FATFILE* activeFile;

// Update a disk directory entry with the file size
static void _dirSetFileSize(const DISK *disk, DIR_POSITION *loc,uint32_t numbytes){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 470:	4e 81       	ldd	r20, Y+6	; 0x06
 472:	5f 81       	ldd	r21, Y+7	; 0x07
 474:	68 85       	ldd	r22, Y+8	; 0x08
 476:	79 85       	ldd	r23, Y+9	; 0x09
 478:	c8 01       	movw	r24, r16
 47a:	22 e0       	ldi	r18, 0x02	; 2
 47c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 480:	bc 01       	movw	r22, r24
	dir[loc->entryInSector].fileSize=numbytes;
 482:	ea 85       	ldd	r30, Y+10	; 0x0a
 484:	f0 e0       	ldi	r31, 0x00	; 0
 486:	a5 e0       	ldi	r26, 0x05	; 5
 488:	ee 0f       	add	r30, r30
 48a:	ff 1f       	adc	r31, r31
 48c:	aa 95       	dec	r26
 48e:	01 f4       	brne	.+0      	; 0x490 <fileFlush+0x44>
 490:	e8 0f       	add	r30, r24
 492:	f9 1f       	adc	r31, r25
 494:	c4 8e       	std	Z+28, r12	; 0x1c
 496:	d5 8e       	std	Z+29, r13	; 0x1d
 498:	e6 8e       	std	Z+30, r14	; 0x1e
 49a:	f7 8e       	std	Z+31, r15	; 0x1f
 49c:	c8 01       	movw	r24, r16
 49e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		rprintfInit(old);}
#endif

		_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
		// Flush everything for now
		diskFlush(file->disk);
 4a2:	88 81       	ld	r24, Y
 4a4:	99 81       	ldd	r25, Y+1	; 0x01
 4a6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	}
}
 4aa:	df 91       	pop	r29
 4ac:	cf 91       	pop	r28
 4ae:	1f 91       	pop	r17
 4b0:	0f 91       	pop	r16
 4b2:	ff 90       	pop	r15
 4b4:	ef 90       	pop	r14
 4b6:	df 90       	pop	r13
 4b8:	cf 90       	pop	r12
 4ba:	08 95       	ret

000004bc <fileClose>:

void fileClose(FATFILE *file){
 4bc:	cf 93       	push	r28
 4be:	df 93       	push	r29
 4c0:	ec 01       	movw	r28, r24
	fileFlush(file);
 4c2:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

	if(activeFile==file){
 4c6:	80 91 00 00 	lds	r24, 0x0000
 4ca:	90 91 00 00 	lds	r25, 0x0000
 4ce:	8c 17       	cp	r24, r28
 4d0:	9d 07       	cpc	r25, r29
 4d2:	01 f4       	brne	.+0      	; 0x4d4 <fileClose+0x18>
		activeFile = null;
 4d4:	10 92 00 00 	sts	0x0000, r1
 4d8:	10 92 00 00 	sts	0x0000, r1
	}

	memclr(file,sizeof(*file));
 4dc:	8d e2       	ldi	r24, 0x2D	; 45
 4de:	fe 01       	movw	r30, r28
 4e0:	11 92       	st	Z+, r1
 4e2:	8a 95       	dec	r24
 4e4:	01 f4       	brne	.+0      	; 0x4e6 <fileClose+0x2a>
//	file_setAttr(file,FILE_STATUS_OPEN,0);
//	file_setAttr(file,FILE_STATUS_WRITE,0);
}
 4e6:	df 91       	pop	r29
 4e8:	cf 91       	pop	r28
 4ea:	08 95       	ret

000004ec <_fileRequiredCluster>:


// Determine the number of clusters that neeed to be added to the end of the file
CLUSTER_COUNT _fileRequiredCluster(FATFILE *file,uint32_t offset, size_t size){
 4ec:	4f 92       	push	r4
 4ee:	5f 92       	push	r5
 4f0:	6f 92       	push	r6
 4f2:	7f 92       	push	r7
 4f4:	8f 92       	push	r8
 4f6:	9f 92       	push	r9
 4f8:	af 92       	push	r10
 4fa:	bf 92       	push	r11
 4fc:	cf 92       	push	r12
 4fe:	df 92       	push	r13
 500:	ef 92       	push	r14
 502:	ff 92       	push	r15
 504:	0f 93       	push	r16
 506:	1f 93       	push	r17
 508:	cf 93       	push	r28
 50a:	df 93       	push	r29
 50c:	cd b7       	in	r28, 0x3d	; 61
 50e:	de b7       	in	r29, 0x3e	; 62
 510:	6c 97       	sbiw	r28, 0x1c	; 28
 512:	0f b6       	in	r0, 0x3f	; 63
 514:	f8 94       	cli
 516:	de bf       	out	0x3e, r29	; 62
 518:	0f be       	out	0x3f, r0	; 63
 51a:	cd bf       	out	0x3d, r28	; 61
 51c:	4c 01       	movw	r8, r24
	CLUSTER_COUNT clusters_required=0;

	uint32_t endPos = offset + (uint32_t)size;
 51e:	c9 01       	movw	r24, r18
 520:	a0 e0       	ldi	r26, 0x00	; 0
 522:	b0 e0       	ldi	r27, 0x00	; 0
 524:	84 0f       	add	r24, r20
 526:	95 1f       	adc	r25, r21
 528:	a6 1f       	adc	r26, r22
 52a:	b7 1f       	adc	r27, r23
 52c:	89 8f       	std	Y+25, r24	; 0x19
 52e:	9a 8f       	std	Y+26, r25	; 0x1a
 530:	ab 8f       	std	Y+27, r26	; 0x1b
 532:	bc 8f       	std	Y+28, r27	; 0x1c

	if(endPos > file->fileSize){
 534:	f4 01       	movw	r30, r8
 536:	81 a5       	ldd	r24, Z+41	; 0x29
 538:	92 a5       	ldd	r25, Z+42	; 0x2a
 53a:	a3 a5       	ldd	r26, Z+43	; 0x2b
 53c:	b4 a5       	ldd	r27, Z+44	; 0x2c
 53e:	29 8d       	ldd	r18, Y+25	; 0x19
 540:	3a 8d       	ldd	r19, Y+26	; 0x1a
 542:	4b 8d       	ldd	r20, Y+27	; 0x1b
 544:	5c 8d       	ldd	r21, Y+28	; 0x1c
 546:	82 17       	cp	r24, r18
 548:	93 07       	cpc	r25, r19
 54a:	a4 07       	cpc	r26, r20
 54c:	b5 07       	cpc	r27, r21
 54e:	00 f0       	brcs	.+0      	; 0x550 <_fileRequiredCluster+0x64>
 550:	00 c0       	rjmp	.+0      	; 0x552 <_fileRequiredCluster+0x66>
		// Find the number of clusters allocated to the file
		CLUSTER_COUNT hc;
		if(file->nav.totalClusters==0){ /* Number of cluster unknown */
 552:	40 a0       	ldd	r4, Z+32	; 0x20
 554:	51 a0       	ldd	r5, Z+33	; 0x21
 556:	62 a0       	ldd	r6, Z+34	; 0x22
 558:	73 a0       	ldd	r7, Z+35	; 0x23
 55a:	41 14       	cp	r4, r1
 55c:	51 04       	cpc	r5, r1
 55e:	61 04       	cpc	r6, r1
 560:	71 04       	cpc	r7, r1
 562:	01 f4       	brne	.+0      	; 0x564 <_fileRequiredCluster+0x78>
			hc = _fatCountClustersInChain(file->disk,file->nav.startCluster);
 564:	a0 80       	ld	r10, Z
 566:	b1 80       	ldd	r11, Z+1	; 0x01
 568:	40 8d       	ldd	r20, Z+24	; 0x18
 56a:	51 8d       	ldd	r21, Z+25	; 0x19
 56c:	62 8d       	ldd	r22, Z+26	; 0x1a
 56e:	73 8d       	ldd	r23, Z+27	; 0x1b


// Calculate the number of clusters starting with a given one
static CLUSTER_COUNT _fatCountClustersInChain(const DISK *disk,CLUSTER firstcluster){

	if(firstcluster<=1){
 570:	42 30       	cpi	r20, 0x02	; 2
 572:	51 05       	cpc	r21, r1
 574:	61 05       	cpc	r22, r1
 576:	71 05       	cpc	r23, r1
 578:	00 f0       	brcs	.+0      	; 0x57a <_fileRequiredCluster+0x8e>
		return(0);
	}

	// Initialise to start of chain
	CLUSTER_NAV nav;
	_navInitClusterChain(&nav,firstcluster);
 57a:	6e 01       	movw	r12, r28
 57c:	08 94       	sec
 57e:	c1 1c       	adc	r12, r1
 580:	d1 1c       	adc	r13, r1
 582:	c6 01       	movw	r24, r12
 584:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

	// Step through each successive cluster
	CLUSTER_COUNT c=0;
	while( _fatNavigateTo(disk,&nav,c++) );
 588:	86 01       	movw	r16, r12
 58a:	00 c0       	rjmp	.+0      	; 0x58c <_fileRequiredCluster+0xa0>
 58c:	26 01       	movw	r4, r12
 58e:	37 01       	movw	r6, r14
 590:	73 01       	movw	r14, r6
 592:	62 01       	movw	r12, r4
 594:	08 94       	sec
 596:	c1 1c       	adc	r12, r1
 598:	d1 1c       	adc	r13, r1
 59a:	e1 1c       	adc	r14, r1
 59c:	f1 1c       	adc	r15, r1
 59e:	c5 01       	movw	r24, r10
 5a0:	b8 01       	movw	r22, r16
 5a2:	a3 01       	movw	r20, r6
 5a4:	92 01       	movw	r18, r4
 5a6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 5aa:	88 23       	and	r24, r24
 5ac:	01 f4       	brne	.+0      	; 0x5ae <_fileRequiredCluster+0xc2>
	if(endPos > file->fileSize){
		// Find the number of clusters allocated to the file
		CLUSTER_COUNT hc;
		if(file->nav.totalClusters==0){ /* Number of cluster unknown */
			hc = _fatCountClustersInChain(file->disk,file->nav.startCluster);
			file->nav.totalClusters = hc;
 5ae:	d4 01       	movw	r26, r8
 5b0:	90 96       	adiw	r26, 0x20	; 32
 5b2:	4d 92       	st	X+, r4
 5b4:	5d 92       	st	X+, r5
 5b6:	6d 92       	st	X+, r6
 5b8:	7c 92       	st	X, r7
 5ba:	93 97       	sbiw	r26, 0x23	; 35
		}

		// Find the clusters required for the file length.
		// NB 'hc' may be bigger than this if files are extended by more
		// than one cluster at a time
		uint32_t clustersize = file->disk->volume.bytesPerSector *
 5bc:	d4 01       	movw	r26, r8
 5be:	ed 91       	ld	r30, X+
 5c0:	fc 91       	ld	r31, X
 5c2:	11 97       	sbiw	r26, 0x01	; 1
 5c4:	20 89       	ldd	r18, Z+16	; 0x10
 5c6:	30 e0       	ldi	r19, 0x00	; 0
 5c8:	86 85       	ldd	r24, Z+14	; 0x0e
 5ca:	97 85       	ldd	r25, Z+15	; 0x0f
 5cc:	28 9f       	mul	r18, r24
 5ce:	60 01       	movw	r12, r0
 5d0:	29 9f       	mul	r18, r25
 5d2:	d0 0c       	add	r13, r0
 5d4:	38 9f       	mul	r19, r24
 5d6:	d0 0c       	add	r13, r0
 5d8:	11 24       	eor	r1, r1
 5da:	ee 24       	eor	r14, r14
 5dc:	ff 24       	eor	r15, r15
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
 5de:	99 96       	adiw	r26, 0x29	; 41
 5e0:	8d 91       	ld	r24, X+
 5e2:	9d 91       	ld	r25, X+
 5e4:	0d 90       	ld	r0, X+
 5e6:	bc 91       	ld	r27, X
 5e8:	a0 2d       	mov	r26, r0
		if( (endPos-file->fileSize) >
 5ea:	89 8c       	ldd	r8, Y+25	; 0x19
 5ec:	9a 8c       	ldd	r9, Y+26	; 0x1a
 5ee:	ab 8c       	ldd	r10, Y+27	; 0x1b
 5f0:	bc 8c       	ldd	r11, Y+28	; 0x1c
 5f2:	88 1a       	sub	r8, r24
 5f4:	99 0a       	sbc	r9, r25
 5f6:	aa 0a       	sbc	r10, r26
 5f8:	bb 0a       	sbc	r11, r27
		// than one cluster at a time
		uint32_t clustersize = file->disk->volume.bytesPerSector *
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
 5fa:	bc 01       	movw	r22, r24
 5fc:	cd 01       	movw	r24, r26
 5fe:	61 50       	subi	r22, 0x01	; 1
 600:	70 40       	sbci	r23, 0x00	; 0
 602:	80 40       	sbci	r24, 0x00	; 0
 604:	90 40       	sbci	r25, 0x00	; 0
 606:	6c 0d       	add	r22, r12
 608:	7d 1d       	adc	r23, r13
 60a:	8e 1d       	adc	r24, r14
 60c:	9f 1d       	adc	r25, r15
 60e:	a7 01       	movw	r20, r14
 610:	96 01       	movw	r18, r12
 612:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
		if( (endPos-file->fileSize) >
		   ((hc-currentClusterSize)*clustersize)){
 616:	c3 01       	movw	r24, r6
 618:	b2 01       	movw	r22, r4
 61a:	62 1b       	sub	r22, r18
 61c:	73 0b       	sbc	r23, r19
 61e:	84 0b       	sbc	r24, r20
 620:	95 0b       	sbc	r25, r21
 622:	a7 01       	movw	r20, r14
 624:	96 01       	movw	r18, r12
 626:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 62a:	dc 01       	movw	r26, r24
 62c:	cb 01       	movw	r24, r22
		uint32_t clustersize = file->disk->volume.bytesPerSector *
							   file->disk->volume.sectorsPerCluster;

		// Find the total number of clusters for the current file size
		CLUSTER currentClusterSize = (file->fileSize+clustersize-1) / clustersize;
		if( (endPos-file->fileSize) >
 62e:	88 15       	cp	r24, r8
 630:	99 05       	cpc	r25, r9
 632:	aa 05       	cpc	r26, r10
 634:	bb 05       	cpc	r27, r11
 636:	00 f4       	brcc	.+0      	; 0x638 <_fileRequiredCluster+0x14c>
		   ((hc-currentClusterSize)*clustersize)){
			clusters_required = ((endPos-(hc*clustersize))+clustersize-1)/clustersize;
 638:	46 01       	movw	r8, r12
 63a:	57 01       	movw	r10, r14
 63c:	08 94       	sec
 63e:	81 08       	sbc	r8, r1
 640:	91 08       	sbc	r9, r1
 642:	a1 08       	sbc	r10, r1
 644:	b1 08       	sbc	r11, r1
 646:	29 8d       	ldd	r18, Y+25	; 0x19
 648:	3a 8d       	ldd	r19, Y+26	; 0x1a
 64a:	4b 8d       	ldd	r20, Y+27	; 0x1b
 64c:	5c 8d       	ldd	r21, Y+28	; 0x1c
 64e:	82 0e       	add	r8, r18
 650:	93 1e       	adc	r9, r19
 652:	a4 1e       	adc	r10, r20
 654:	b5 1e       	adc	r11, r21
 656:	c3 01       	movw	r24, r6
 658:	b2 01       	movw	r22, r4
 65a:	a7 01       	movw	r20, r14
 65c:	96 01       	movw	r18, r12
 65e:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 662:	dc 01       	movw	r26, r24
 664:	cb 01       	movw	r24, r22
 666:	88 1a       	sub	r8, r24
 668:	99 0a       	sbc	r9, r25
 66a:	aa 0a       	sbc	r10, r26
 66c:	bb 0a       	sbc	r11, r27
 66e:	c5 01       	movw	r24, r10
 670:	b4 01       	movw	r22, r8
 672:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 676:	89 01       	movw	r16, r18
 678:	9a 01       	movw	r18, r20
 67a:	00 c0       	rjmp	.+0      	; 0x67c <_fileRequiredCluster+0x190>
}


// Determine the number of clusters that neeed to be added to the end of the file
CLUSTER_COUNT _fileRequiredCluster(FATFILE *file,uint32_t offset, size_t size){
	CLUSTER_COUNT clusters_required=0;
 67c:	00 e0       	ldi	r16, 0x00	; 0
 67e:	10 e0       	ldi	r17, 0x00	; 0
 680:	20 e0       	ldi	r18, 0x00	; 0
 682:	30 e0       	ldi	r19, 0x00	; 0
		   ((hc-currentClusterSize)*clustersize)){
			clusters_required = ((endPos-(hc*clustersize))+clustersize-1)/clustersize;
		}
	}
	return(clusters_required);
}
 684:	b8 01       	movw	r22, r16
 686:	c9 01       	movw	r24, r18
 688:	6c 96       	adiw	r28, 0x1c	; 28
 68a:	0f b6       	in	r0, 0x3f	; 63
 68c:	f8 94       	cli
 68e:	de bf       	out	0x3e, r29	; 62
 690:	0f be       	out	0x3f, r0	; 63
 692:	cd bf       	out	0x3d, r28	; 61
 694:	df 91       	pop	r29
 696:	cf 91       	pop	r28
 698:	1f 91       	pop	r17
 69a:	0f 91       	pop	r16
 69c:	ff 90       	pop	r15
 69e:	ef 90       	pop	r14
 6a0:	df 90       	pop	r13
 6a2:	cf 90       	pop	r12
 6a4:	bf 90       	pop	r11
 6a6:	af 90       	pop	r10
 6a8:	9f 90       	pop	r9
 6aa:	8f 90       	pop	r8
 6ac:	7f 90       	pop	r7
 6ae:	6f 90       	pop	r6
 6b0:	5f 90       	pop	r5
 6b2:	4f 90       	pop	r4
 6b4:	08 95       	ret

000006b6 <fileRead>:
// This function reads 'size' bytes from 'file' starting at
// 'offset' and puts the result in '*buf'.
// This will not modify the current file position but can be used for random reads
// Return value: amount of bytes actually read (can differ from the given
// size when the file was smaller)
size_t fileRead(FATFILE *file,uint32_t offset, size_t size,void *buf){
 6b6:	2f 92       	push	r2
 6b8:	3f 92       	push	r3
 6ba:	4f 92       	push	r4
 6bc:	5f 92       	push	r5
 6be:	6f 92       	push	r6
 6c0:	7f 92       	push	r7
 6c2:	8f 92       	push	r8
 6c4:	9f 92       	push	r9
 6c6:	af 92       	push	r10
 6c8:	bf 92       	push	r11
 6ca:	cf 92       	push	r12
 6cc:	df 92       	push	r13
 6ce:	ef 92       	push	r14
 6d0:	ff 92       	push	r15
 6d2:	0f 93       	push	r16
 6d4:	1f 93       	push	r17
 6d6:	cf 93       	push	r28
 6d8:	df 93       	push	r29
 6da:	cd b7       	in	r28, 0x3d	; 61
 6dc:	de b7       	in	r29, 0x3e	; 62
 6de:	6a 97       	sbiw	r28, 0x1a	; 26
 6e0:	0f b6       	in	r0, 0x3f	; 63
 6e2:	f8 94       	cli
 6e4:	de bf       	out	0x3e, r29	; 62
 6e6:	0f be       	out	0x3f, r0	; 63
 6e8:	cd bf       	out	0x3d, r28	; 61
 6ea:	5c 01       	movw	r10, r24
 6ec:	c9 01       	movw	r24, r18
 6ee:	18 8f       	std	Y+24, r17	; 0x18
 6f0:	0f 8b       	std	Y+23, r16	; 0x17
	}
	return(FALSE);
}

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
 6f2:	d5 01       	movw	r26, r10
 6f4:	94 96       	adiw	r26, 0x24	; 36
 6f6:	2c 91       	ld	r18, X
 6f8:	94 97       	sbiw	r26, 0x24	; 36
	size_t size_left=size;			// The number of bytes left to read

	uint32_t currentOffset=offset;		// The current file position

	// Check that the file has been opened
	if(!_fileGetAttr(file,FILE_STATUS_OPEN)){
 6fa:	20 ff       	sbrs	r18, 0
 6fc:	00 c0       	rjmp	.+0      	; 0x6fe <fileRead+0x48>
		return(0);
	}

	// Dont read beyond end of file
	if(offset>=file->fileSize){
 6fe:	99 96       	adiw	r26, 0x29	; 41
 700:	0d 91       	ld	r16, X+
 702:	1d 91       	ld	r17, X+
 704:	2d 91       	ld	r18, X+
 706:	3c 91       	ld	r19, X
 708:	9c 97       	sbiw	r26, 0x2c	; 44
 70a:	40 17       	cp	r20, r16
 70c:	51 07       	cpc	r21, r17
 70e:	62 07       	cpc	r22, r18
 710:	73 07       	cpc	r23, r19
 712:	00 f4       	brcc	.+0      	; 0x714 <fileRead+0x5e>
// This will not modify the current file position but can be used for random reads
// Return value: amount of bytes actually read (can differ from the given
// size when the file was smaller)
size_t fileRead(FATFILE *file,uint32_t offset, size_t size,void *buf){
	size_t bytes_read=0;			// The number of bytes read
	size_t size_left=size;			// The number of bytes left to read
 714:	7c 01       	movw	r14, r24
 716:	00 c0       	rjmp	.+0      	; 0x718 <fileRead+0x62>
		return(0);
	}

	// Dont read beyond end of file
	if(offset>=file->fileSize){
		size_left=0; /* Offset check */
 718:	ee 24       	eor	r14, r14
 71a:	ff 24       	eor	r15, r15
	}

	// Limit reads from going beyond end of file
	if( (offset+size > file->fileSize) && size_left!=0){
 71c:	a0 e0       	ldi	r26, 0x00	; 0
 71e:	b0 e0       	ldi	r27, 0x00	; 0
 720:	84 0f       	add	r24, r20
 722:	95 1f       	adc	r25, r21
 724:	a6 1f       	adc	r26, r22
 726:	b7 1f       	adc	r27, r23
 728:	08 17       	cp	r16, r24
 72a:	19 07       	cpc	r17, r25
 72c:	2a 07       	cpc	r18, r26
 72e:	3b 07       	cpc	r19, r27
 730:	00 f4       	brcc	.+0      	; 0x732 <fileRead+0x7c>
 732:	e1 14       	cp	r14, r1
 734:	f1 04       	cpc	r15, r1
 736:	01 f0       	breq	.+0      	; 0x738 <fileRead+0x82>
		size_left=file->fileSize-offset;
 738:	78 01       	movw	r14, r16
 73a:	e4 1a       	sub	r14, r20
 73c:	f5 0a       	sbc	r15, r21
		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
		}else{
			bytesToRead = 512;
 73e:	2a 01       	movw	r4, r20
 740:	3b 01       	movw	r6, r22
 742:	88 24       	eor	r8, r8
 744:	99 24       	eor	r9, r9
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 746:	f5 01       	movw	r30, r10
 748:	3c 96       	adiw	r30, 0x0c	; 12
 74a:	fa 8f       	std	Y+26, r31	; 0x1a
 74c:	e9 8f       	std	Y+25, r30	; 0x19
 74e:	00 c0       	rjmp	.+0      	; 0x750 <fileRead+0x9a>
		size_left=file->fileSize-offset;
	}

	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
 750:	c2 01       	movw	r24, r4
 752:	91 70       	andi	r25, 0x01	; 1
 754:	9a 8b       	std	Y+18, r25	; 0x12
 756:	89 8b       	std	Y+17, r24	; 0x11
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 758:	d5 01       	movw	r26, r10
 75a:	cd 90       	ld	r12, X+
 75c:	dc 90       	ld	r13, X
	}

	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
 75e:	c3 01       	movw	r24, r6
 760:	b2 01       	movw	r22, r4
 762:	19 e0       	ldi	r17, 0x09	; 9
 764:	96 95       	lsr	r25
 766:	87 95       	ror	r24
 768:	77 95       	ror	r23
 76a:	67 95       	ror	r22
 76c:	1a 95       	dec	r17
 76e:	01 f4       	brne	.+0      	; 0x770 <fileRead+0xba>
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 770:	f6 01       	movw	r30, r12
 772:	20 89       	ldd	r18, Z+16	; 0x10
 774:	30 e0       	ldi	r19, 0x00	; 0
 776:	40 e0       	ldi	r20, 0x00	; 0
 778:	50 e0       	ldi	r21, 0x00	; 0
 77a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 77e:	29 87       	std	Y+9, r18	; 0x09
 780:	3a 87       	std	Y+10, r19	; 0x0a
 782:	4b 87       	std	Y+11, r20	; 0x0b
 784:	5c 87       	std	Y+12, r21	; 0x0c
 786:	6d 87       	std	Y+13, r22	; 0x0d
 788:	7e 87       	std	Y+14, r23	; 0x0e
 78a:	8f 87       	std	Y+15, r24	; 0x0f
 78c:	98 8b       	std	Y+16, r25	; 0x10
 78e:	fe 01       	movw	r30, r28
 790:	31 96       	adiw	r30, 0x01	; 1
 792:	de 01       	movw	r26, r28
 794:	19 96       	adiw	r26, 0x09	; 9
 796:	88 e0       	ldi	r24, 0x08	; 8
 798:	0d 90       	ld	r0, X+
 79a:	01 92       	st	Z+, r0
 79c:	81 50       	subi	r24, 0x01	; 1
 79e:	01 f4       	brne	.+0      	; 0x7a0 <fileRead+0xea>
		CLUSTER_COUNT currentCluster = div.quot;
 7a0:	29 81       	ldd	r18, Y+1	; 0x01
 7a2:	3a 81       	ldd	r19, Y+2	; 0x02
 7a4:	4b 81       	ldd	r20, Y+3	; 0x03
 7a6:	5c 81       	ldd	r21, Y+4	; 0x04
		SECTOR        sectorInCluster  = div.rem;
 7a8:	8d 81       	ldd	r24, Y+5	; 0x05
 7aa:	9e 81       	ldd	r25, Y+6	; 0x06
 7ac:	af 81       	ldd	r26, Y+7	; 0x07
 7ae:	b8 85       	ldd	r27, Y+8	; 0x08
 7b0:	8b 8b       	std	Y+19, r24	; 0x13
 7b2:	9c 8b       	std	Y+20, r25	; 0x14
 7b4:	ad 8b       	std	Y+21, r26	; 0x15
 7b6:	be 8b       	std	Y+22, r27	; 0x16


		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
 7b8:	a9 89       	ldd	r26, Y+17	; 0x11
 7ba:	ba 89       	ldd	r27, Y+18	; 0x12
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
 7bc:	00 e0       	ldi	r16, 0x00	; 0
 7be:	12 e0       	ldi	r17, 0x02	; 2
		SECTOR        sectorInCluster  = div.rem;


		// Calculate the number of bytes required to read from the sector
		size_t bytesToRead;
		if(offsetInSector!=0 || size_left<512){
 7c0:	10 97       	sbiw	r26, 0x00	; 0
 7c2:	01 f4       	brne	.+0      	; 0x7c4 <fileRead+0x10e>
 7c4:	b0 e0       	ldi	r27, 0x00	; 0
 7c6:	eb 16       	cp	r14, r27
 7c8:	b2 e0       	ldi	r27, 0x02	; 2
 7ca:	fb 06       	cpc	r15, r27
 7cc:	00 f4       	brcc	.+0      	; 0x7ce <fileRead+0x118>
			bytesToRead = (512-offsetInSector >= size_left) ? size_left : 512-offsetInSector;
 7ce:	e9 89       	ldd	r30, Y+17	; 0x11
 7d0:	fa 89       	ldd	r31, Y+18	; 0x12
 7d2:	0e 1b       	sub	r16, r30
 7d4:	1f 0b       	sbc	r17, r31
 7d6:	e0 16       	cp	r14, r16
 7d8:	f1 06       	cpc	r15, r17
 7da:	00 f4       	brcc	.+0      	; 0x7dc <fileRead+0x126>
 7dc:	87 01       	movw	r16, r14
		}else{
			bytesToRead = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 7de:	c6 01       	movw	r24, r12
 7e0:	69 8d       	ldd	r22, Y+25	; 0x19
 7e2:	7a 8d       	ldd	r23, Y+26	; 0x1a
 7e4:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 7e8:	88 23       	and	r24, r24
 7ea:	01 f4       	brne	.+0      	; 0x7ec <fileRead+0x136>
 7ec:	00 c0       	rjmp	.+0      	; 0x7ee <fileRead+0x138>
			return(0);													// Cluster out of bounds
		}

		// Calc the sector# in the partition
		SECTOR readSector=_diskClusterToSector(file->disk,file->nav.currentCluster) + sectorInCluster;
 7ee:	d5 01       	movw	r26, r10
 7f0:	54 96       	adiw	r26, 0x14	; 20
 7f2:	4d 91       	ld	r20, X+
 7f4:	5d 91       	ld	r21, X+
 7f6:	6d 91       	ld	r22, X+
 7f8:	7c 91       	ld	r23, X
 7fa:	57 97       	sbiw	r26, 0x17	; 23
 7fc:	8d 91       	ld	r24, X+
 7fe:	9c 91       	ld	r25, X
 800:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 804:	ab 01       	movw	r20, r22
 806:	bc 01       	movw	r22, r24
 808:	8b 89       	ldd	r24, Y+19	; 0x13
 80a:	9c 89       	ldd	r25, Y+20	; 0x14
 80c:	ad 89       	ldd	r26, Y+21	; 0x15
 80e:	be 89       	ldd	r27, Y+22	; 0x16
 810:	48 0f       	add	r20, r24
 812:	59 1f       	adc	r21, r25
 814:	6a 1f       	adc	r22, r26
 816:	7b 1f       	adc	r23, r27
 818:	d5 01       	movw	r26, r10
 81a:	8d 91       	ld	r24, X+
 81c:	9c 91       	ld	r25, X
 81e:	11 97       	sbiw	r26, 0x01	; 1
 820:	2f 88       	ldd	r2, Y+23	; 0x17
 822:	38 8c       	ldd	r3, Y+24	; 0x18
 824:	28 0c       	add	r2, r8
 826:	39 1c       	adc	r3, r9

		if(bytesToRead==512){
 828:	b2 e0       	ldi	r27, 0x02	; 2
 82a:	00 30       	cpi	r16, 0x00	; 0
 82c:	1b 07       	cpc	r17, r27
 82e:	01 f4       	brne	.+0      	; 0x830 <fileRead+0x17a>
			// Read it via the buffers or directly to user RAM
			_partitionDirectSectorRead(file->disk,readSector,((uint8_t*)buf)+bytes_read);
 830:	91 01       	movw	r18, r2
 832:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 836:	00 c0       	rjmp	.+0      	; 0x838 <fileRead+0x182>
		}else{
			// Read it into the buffers
			uint8_t* tbuf = _partitionGetSector(file->disk,readSector,BUFFER_MODE_READONLY);
 838:	21 e0       	ldi	r18, 0x01	; 1
 83a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 83e:	6c 01       	movw	r12, r24
			// Copy data from buffer into user memory
			memcpy(((uint8_t*)buf)+bytes_read, tbuf+offsetInSector,  bytesToRead);
 840:	69 89       	ldd	r22, Y+17	; 0x11
 842:	7a 89       	ldd	r23, Y+18	; 0x12
 844:	68 0f       	add	r22, r24
 846:	79 1f       	adc	r23, r25
 848:	c1 01       	movw	r24, r2
 84a:	a8 01       	movw	r20, r16
 84c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 850:	f5 01       	movw	r30, r10
 852:	80 81       	ld	r24, Z
 854:	91 81       	ldd	r25, Z+1	; 0x01
 856:	b6 01       	movw	r22, r12
 858:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
			// Release the sector
			partition_releaseSector(file->disk,tbuf);
		}

		currentOffset += bytesToRead;
 85c:	c8 01       	movw	r24, r16
 85e:	a0 e0       	ldi	r26, 0x00	; 0
 860:	b0 e0       	ldi	r27, 0x00	; 0
 862:	48 0e       	add	r4, r24
 864:	59 1e       	adc	r5, r25
 866:	6a 1e       	adc	r6, r26
 868:	7b 1e       	adc	r7, r27
		bytes_read += bytesToRead;
 86a:	80 0e       	add	r8, r16
 86c:	91 1e       	adc	r9, r17
		size_left -= bytesToRead;
 86e:	e0 1a       	sub	r14, r16
 870:	f1 0a       	sbc	r15, r17
	// Limit reads from going beyond end of file
	if( (offset+size > file->fileSize) && size_left!=0){
		size_left=file->fileSize-offset;
	}

	while(size_left>0){
 872:	e1 14       	cp	r14, r1
 874:	f1 04       	cpc	r15, r1
 876:	01 f0       	breq	.+0      	; 0x878 <fileRead+0x1c2>
 878:	00 c0       	rjmp	.+0      	; 0x87a <fileRead+0x1c4>
 87a:	00 c0       	rjmp	.+0      	; 0x87c <fileRead+0x1c6>
		}else{
			bytesToRead = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
			return(0);													// Cluster out of bounds
 87c:	88 24       	eor	r8, r8
 87e:	99 24       	eor	r9, r9
		bytes_read += bytesToRead;
		size_left -= bytesToRead;
	}

	return(bytes_read);
}
 880:	c4 01       	movw	r24, r8
 882:	6a 96       	adiw	r28, 0x1a	; 26
 884:	0f b6       	in	r0, 0x3f	; 63
 886:	f8 94       	cli
 888:	de bf       	out	0x3e, r29	; 62
 88a:	0f be       	out	0x3f, r0	; 63
 88c:	cd bf       	out	0x3d, r28	; 61
 88e:	df 91       	pop	r29
 890:	cf 91       	pop	r28
 892:	1f 91       	pop	r17
 894:	0f 91       	pop	r16
 896:	ff 90       	pop	r15
 898:	ef 90       	pop	r14
 89a:	df 90       	pop	r13
 89c:	cf 90       	pop	r12
 89e:	bf 90       	pop	r11
 8a0:	af 90       	pop	r10
 8a2:	9f 90       	pop	r9
 8a4:	8f 90       	pop	r8
 8a6:	7f 90       	pop	r7
 8a8:	6f 90       	pop	r6
 8aa:	5f 90       	pop	r5
 8ac:	4f 90       	pop	r4
 8ae:	3f 90       	pop	r3
 8b0:	2f 90       	pop	r2
 8b2:	08 95       	ret

000008b4 <fileReadNext>:

size_t fileReadNext(FATFILE *file,size_t size,void *buf){
 8b4:	0f 93       	push	r16
 8b6:	1f 93       	push	r17
 8b8:	cf 93       	push	r28
 8ba:	df 93       	push	r29
 8bc:	ec 01       	movw	r28, r24
 8be:	9b 01       	movw	r18, r22
 8c0:	8a 01       	movw	r16, r20
	size_t r=fileRead(file,file->filePos,size,buf);
 8c2:	4d a1       	ldd	r20, Y+37	; 0x25
 8c4:	5e a1       	ldd	r21, Y+38	; 0x26
 8c6:	6f a1       	ldd	r22, Y+39	; 0x27
 8c8:	78 a5       	ldd	r23, Y+40	; 0x28
 8ca:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 8ce:	9c 01       	movw	r18, r24
	file->filePos+=r;
 8d0:	ac 01       	movw	r20, r24
 8d2:	60 e0       	ldi	r22, 0x00	; 0
 8d4:	70 e0       	ldi	r23, 0x00	; 0
 8d6:	8d a1       	ldd	r24, Y+37	; 0x25
 8d8:	9e a1       	ldd	r25, Y+38	; 0x26
 8da:	af a1       	ldd	r26, Y+39	; 0x27
 8dc:	b8 a5       	ldd	r27, Y+40	; 0x28
 8de:	84 0f       	add	r24, r20
 8e0:	95 1f       	adc	r25, r21
 8e2:	a6 1f       	adc	r26, r22
 8e4:	b7 1f       	adc	r27, r23
 8e6:	8d a3       	std	Y+37, r24	; 0x25
 8e8:	9e a3       	std	Y+38, r25	; 0x26
 8ea:	af a3       	std	Y+39, r26	; 0x27
 8ec:	b8 a7       	std	Y+40, r27	; 0x28
	return(r);
}
 8ee:	c9 01       	movw	r24, r18
 8f0:	df 91       	pop	r29
 8f2:	cf 91       	pop	r28
 8f4:	1f 91       	pop	r17
 8f6:	0f 91       	pop	r16
 8f8:	08 95       	ret

000008fa <fileWrite>:


// This function writes to a file, at offset 'offset' and size 'size'.
// It also updates the FileSize in the object, and disk directory
// Returns Bytes actually written.
size_t fileWrite(FATFILE* file,uint32_t offset,size_t size,const void* buf){
 8fa:	2f 92       	push	r2
 8fc:	3f 92       	push	r3
 8fe:	4f 92       	push	r4
 900:	5f 92       	push	r5
 902:	6f 92       	push	r6
 904:	7f 92       	push	r7
 906:	8f 92       	push	r8
 908:	9f 92       	push	r9
 90a:	af 92       	push	r10
 90c:	bf 92       	push	r11
 90e:	cf 92       	push	r12
 910:	df 92       	push	r13
 912:	ef 92       	push	r14
 914:	ff 92       	push	r15
 916:	0f 93       	push	r16
 918:	1f 93       	push	r17
 91a:	cf 93       	push	r28
 91c:	df 93       	push	r29
 91e:	cd b7       	in	r28, 0x3d	; 61
 920:	de b7       	in	r29, 0x3e	; 62
 922:	6c 97       	sbiw	r28, 0x1c	; 28
 924:	0f b6       	in	r0, 0x3f	; 63
 926:	f8 94       	cli
 928:	de bf       	out	0x3e, r29	; 62
 92a:	0f be       	out	0x3f, r0	; 63
 92c:	cd bf       	out	0x3d, r28	; 61
 92e:	5c 01       	movw	r10, r24
 930:	e4 2e       	mov	r14, r20
 932:	d5 2e       	mov	r13, r21
 934:	96 2e       	mov	r9, r22
 936:	87 2e       	mov	r8, r23
 938:	c2 2e       	mov	r12, r18
 93a:	f3 2e       	mov	r15, r19
 93c:	1a 8f       	std	Y+26, r17	; 0x1a
 93e:	09 8f       	std	Y+25, r16	; 0x19
	}
	return(FALSE);
}

static uint8_t _fileGetAttr(FATFILE* file,uint8_t attribute){
	return(file->mode&(1<<attribute));
 940:	dc 01       	movw	r26, r24
 942:	94 96       	adiw	r26, 0x24	; 36
 944:	8c 91       	ld	r24, X
 946:	94 97       	sbiw	r26, 0x24	; 36
// Returns Bytes actually written.
size_t fileWrite(FATFILE* file,uint32_t offset,size_t size,const void* buf){
	uint32_t currentOffset=offset;

	// Make sure file is open for write
	if(!_fileGetAttr(file,FILE_STATUS_OPEN) || !_fileGetAttr(file,FILE_STATUS_WRITE)){
 948:	80 ff       	sbrs	r24, 0
 94a:	00 c0       	rjmp	.+0      	; 0x94c <fileWrite+0x52>
 94c:	81 ff       	sbrs	r24, 1
 94e:	00 c0       	rjmp	.+0      	; 0x950 <fileWrite+0x56>
 950:	99 96       	adiw	r26, 0x29	; 41
 952:	8d 91       	ld	r24, X+
 954:	9d 91       	ld	r25, X+
 956:	0d 90       	ld	r0, X+
 958:	bc 91       	ld	r27, X
 95a:	a0 2d       	mov	r26, r0
 95c:	44 2e       	mov	r4, r20
 95e:	55 2e       	mov	r5, r21
 960:	66 2e       	mov	r6, r22
 962:	77 2e       	mov	r7, r23
 964:	84 15       	cp	r24, r4
 966:	95 05       	cpc	r25, r5
 968:	a6 05       	cpc	r26, r6
 96a:	b7 05       	cpc	r27, r7
 96c:	00 f4       	brcc	.+0      	; 0x96e <fileWrite+0x74>
 96e:	2c 01       	movw	r4, r24
 970:	3d 01       	movw	r6, r26
	if(offset>file->fileSize){
		offset=file->fileSize;
	}

	// Find if need to allocate more clusters to the end of the file
	CLUSTER_COUNT need_cluster = _fileRequiredCluster(file,offset,size);
 972:	c5 01       	movw	r24, r10
 974:	b3 01       	movw	r22, r6
 976:	a2 01       	movw	r20, r4
 978:	2c 2d       	mov	r18, r12
 97a:	3f 2d       	mov	r19, r15
 97c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 980:	9b 01       	movw	r18, r22
 982:	ac 01       	movw	r20, r24
	if(need_cluster){
 984:	61 15       	cp	r22, r1
 986:	71 05       	cpc	r23, r1
 988:	81 05       	cpc	r24, r1
 98a:	91 05       	cpc	r25, r1
 98c:	01 f0       	breq	.+0      	; 0x98e <fileWrite+0x94>
	{ Writer old = rprintfInit(uartGetWriter(FAT_DEBUG));
		rprintf("\nWrite to file@%lu, extend by %lu clusters\n",currentOffset,need_cluster);
		rprintfInit(old);}
#endif

		if(!_fatExtend(file->disk,&(file->nav),need_cluster)){
 98e:	b5 01       	movw	r22, r10
 990:	64 5f       	subi	r22, 0xF4	; 244
 992:	7f 4f       	sbci	r23, 0xFF	; 255
 994:	f5 01       	movw	r30, r10
 996:	80 81       	ld	r24, Z
 998:	91 81       	ldd	r25, Z+1	; 0x01
 99a:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 99e:	88 23       	and	r24, r24
 9a0:	01 f4       	brne	.+0      	; 0x9a2 <fileWrite+0xa8>
 9a2:	00 c0       	rjmp	.+0      	; 0x9a4 <fileWrite+0xaa>
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
		}else{
			bytesToWrite = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 9a4:	cd 8a       	std	Y+21, r12	; 0x15
 9a6:	fe 8a       	std	Y+22, r15	; 0x16
 9a8:	e9 8a       	std	Y+17, r14	; 0x11
 9aa:	da 8a       	std	Y+18, r13	; 0x12
 9ac:	9b 8a       	std	Y+19, r9	; 0x13
 9ae:	8c 8a       	std	Y+20, r8	; 0x14
 9b0:	88 24       	eor	r8, r8
 9b2:	99 24       	eor	r9, r9
 9b4:	95 01       	movw	r18, r10
 9b6:	24 5f       	subi	r18, 0xF4	; 244
 9b8:	3f 4f       	sbci	r19, 0xFF	; 255
 9ba:	3c 8f       	std	Y+28, r19	; 0x1c
 9bc:	2b 8f       	std	Y+27, r18	; 0x1b
 9be:	00 c0       	rjmp	.+0      	; 0x9c0 <fileWrite+0xc6>

	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
 9c0:	49 89       	ldd	r20, Y+17	; 0x11
 9c2:	5a 89       	ldd	r21, Y+18	; 0x12
 9c4:	51 70       	andi	r21, 0x01	; 1
 9c6:	58 8f       	std	Y+24, r21	; 0x18
 9c8:	4f 8b       	std	Y+23, r20	; 0x17
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 9ca:	d5 01       	movw	r26, r10
 9cc:	2d 90       	ld	r2, X+
 9ce:	3c 90       	ld	r3, X
	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){

		size_t offsetInSector = ((size_t)(currentOffset)) & 511;	// Remainder
		SECTOR relativeSector = (currentOffset >> 9);				// Divide by 512
 9d0:	69 89       	ldd	r22, Y+17	; 0x11
 9d2:	7a 89       	ldd	r23, Y+18	; 0x12
 9d4:	8b 89       	ldd	r24, Y+19	; 0x13
 9d6:	9c 89       	ldd	r25, Y+20	; 0x14
 9d8:	29 e0       	ldi	r18, 0x09	; 9
 9da:	96 95       	lsr	r25
 9dc:	87 95       	ror	r24
 9de:	77 95       	ror	r23
 9e0:	67 95       	ror	r22
 9e2:	2a 95       	dec	r18
 9e4:	01 f4       	brne	.+0      	; 0x9e6 <fileWrite+0xec>
		ldiv_t div = ldiv(relativeSector, file->disk->volume.sectorsPerCluster);
 9e6:	f1 01       	movw	r30, r2
 9e8:	20 89       	ldd	r18, Z+16	; 0x10
 9ea:	30 e0       	ldi	r19, 0x00	; 0
 9ec:	40 e0       	ldi	r20, 0x00	; 0
 9ee:	50 e0       	ldi	r21, 0x00	; 0
 9f0:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 9f4:	29 87       	std	Y+9, r18	; 0x09
 9f6:	3a 87       	std	Y+10, r19	; 0x0a
 9f8:	4b 87       	std	Y+11, r20	; 0x0b
 9fa:	5c 87       	std	Y+12, r21	; 0x0c
 9fc:	6d 87       	std	Y+13, r22	; 0x0d
 9fe:	7e 87       	std	Y+14, r23	; 0x0e
 a00:	8f 87       	std	Y+15, r24	; 0x0f
 a02:	98 8b       	std	Y+16, r25	; 0x10
 a04:	fe 01       	movw	r30, r28
 a06:	31 96       	adiw	r30, 0x01	; 1
 a08:	de 01       	movw	r26, r28
 a0a:	19 96       	adiw	r26, 0x09	; 9
 a0c:	88 e0       	ldi	r24, 0x08	; 8
 a0e:	0d 90       	ld	r0, X+
 a10:	01 92       	st	Z+, r0
 a12:	81 50       	subi	r24, 0x01	; 1
 a14:	01 f4       	brne	.+0      	; 0xa16 <fileWrite+0x11c>
		CLUSTER_COUNT currentCluster = div.quot;
 a16:	29 81       	ldd	r18, Y+1	; 0x01
 a18:	3a 81       	ldd	r19, Y+2	; 0x02
 a1a:	4b 81       	ldd	r20, Y+3	; 0x03
 a1c:	5c 81       	ldd	r21, Y+4	; 0x04
		SECTOR        sectorInCluster  = div.rem;
 a1e:	cd 80       	ldd	r12, Y+5	; 0x05
 a20:	de 80       	ldd	r13, Y+6	; 0x06
 a22:	ef 80       	ldd	r14, Y+7	; 0x07
 a24:	f8 84       	ldd	r15, Y+8	; 0x08

		// calc the number of bytes required from the current sector
		size_t bytesToWrite;
		if(offsetInSector!=0 || size_left<512){
 a26:	8f 89       	ldd	r24, Y+23	; 0x17
 a28:	98 8d       	ldd	r25, Y+24	; 0x18
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
 a2a:	00 e0       	ldi	r16, 0x00	; 0
 a2c:	12 e0       	ldi	r17, 0x02	; 2
		CLUSTER_COUNT currentCluster = div.quot;
		SECTOR        sectorInCluster  = div.rem;

		// calc the number of bytes required from the current sector
		size_t bytesToWrite;
		if(offsetInSector!=0 || size_left<512){
 a2e:	00 97       	sbiw	r24, 0x00	; 0
 a30:	01 f4       	brne	.+0      	; 0xa32 <fileWrite+0x138>
 a32:	ad 89       	ldd	r26, Y+21	; 0x15
 a34:	be 89       	ldd	r27, Y+22	; 0x16
 a36:	e2 e0       	ldi	r30, 0x02	; 2
 a38:	a0 30       	cpi	r26, 0x00	; 0
 a3a:	be 07       	cpc	r27, r30
 a3c:	00 f4       	brcc	.+0      	; 0xa3e <fileWrite+0x144>
			bytesToWrite = (512-offsetInSector>=size_left) ? size_left : 512-offsetInSector;
 a3e:	8f 89       	ldd	r24, Y+23	; 0x17
 a40:	98 8d       	ldd	r25, Y+24	; 0x18
 a42:	08 1b       	sub	r16, r24
 a44:	19 0b       	sbc	r17, r25
 a46:	ad 89       	ldd	r26, Y+21	; 0x15
 a48:	be 89       	ldd	r27, Y+22	; 0x16
 a4a:	a0 17       	cp	r26, r16
 a4c:	b1 07       	cpc	r27, r17
 a4e:	00 f4       	brcc	.+0      	; 0xa50 <fileWrite+0x156>
 a50:	8d 01       	movw	r16, r26
		}else{
			bytesToWrite = 512;
		}

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
 a52:	c1 01       	movw	r24, r2
 a54:	6b 8d       	ldd	r22, Y+27	; 0x1b
 a56:	7c 8d       	ldd	r23, Y+28	; 0x1c
 a58:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 a5c:	f5 01       	movw	r30, r10
 a5e:	20 80       	ld	r2, Z
 a60:	31 80       	ldd	r3, Z+1	; 0x01
 a62:	88 23       	and	r24, r24
 a64:	01 f4       	brne	.+0      	; 0xa66 <fileWrite+0x16c>
			// cluster is out of bounds
			file->fileSize+=bytes_written;
 a66:	64 01       	movw	r12, r8
 a68:	ee 24       	eor	r14, r14
 a6a:	ff 24       	eor	r15, r15
 a6c:	81 a5       	ldd	r24, Z+41	; 0x29
 a6e:	92 a5       	ldd	r25, Z+42	; 0x2a
 a70:	a3 a5       	ldd	r26, Z+43	; 0x2b
 a72:	b4 a5       	ldd	r27, Z+44	; 0x2c
 a74:	c8 0e       	add	r12, r24
 a76:	d9 1e       	adc	r13, r25
 a78:	ea 1e       	adc	r14, r26
 a7a:	fb 1e       	adc	r15, r27
 a7c:	c1 a6       	std	Z+41, r12	; 0x29
 a7e:	d2 a6       	std	Z+42, r13	; 0x2a
 a80:	e3 a6       	std	Z+43, r14	; 0x2b
 a82:	f4 a6       	std	Z+44, r15	; 0x2c

FATFILE* activeFile;

// Update a disk directory entry with the file size
static void _dirSetFileSize(const DISK *disk, DIR_POSITION *loc,uint32_t numbytes){
	DIR_ENTRY* dir = _partitionGetSector(disk,loc->sector,BUFFER_MODE_READWRITE);
 a84:	46 81       	ldd	r20, Z+6	; 0x06
 a86:	57 81       	ldd	r21, Z+7	; 0x07
 a88:	60 85       	ldd	r22, Z+8	; 0x08
 a8a:	71 85       	ldd	r23, Z+9	; 0x09
 a8c:	c1 01       	movw	r24, r2
 a8e:	22 e0       	ldi	r18, 0x02	; 2
 a90:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 a94:	bc 01       	movw	r22, r24
	dir[loc->entryInSector].fileSize=numbytes;
 a96:	d5 01       	movw	r26, r10
 a98:	1a 96       	adiw	r26, 0x0a	; 10
 a9a:	ec 91       	ld	r30, X
 a9c:	f0 e0       	ldi	r31, 0x00	; 0
 a9e:	05 e0       	ldi	r16, 0x05	; 5
 aa0:	ee 0f       	add	r30, r30
 aa2:	ff 1f       	adc	r31, r31
 aa4:	0a 95       	dec	r16
 aa6:	01 f4       	brne	.+0      	; 0xaa8 <fileWrite+0x1ae>
 aa8:	e8 0f       	add	r30, r24
 aaa:	f9 1f       	adc	r31, r25
 aac:	c4 8e       	std	Z+28, r12	; 0x1c
 aae:	d5 8e       	std	Z+29, r13	; 0x1d
 ab0:	e6 8e       	std	Z+30, r14	; 0x1e
 ab2:	f7 8e       	std	Z+31, r15	; 0x1f
 ab4:	c1 01       	movw	r24, r2
 ab6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>

		if((_fatNavigateTo(file->disk,&(file->nav),currentCluster))==FALSE){
			// cluster is out of bounds
			file->fileSize+=bytes_written;
			_dirSetFileSize(file->disk,&(file->directory),file->fileSize);
			return(bytes_written);
 aba:	00 c0       	rjmp	.+0      	; 0xabc <fileWrite+0x1c2>
		}

		SECTOR writeSector=_diskClusterToSector(file->disk,file->nav.currentCluster) + sectorInCluster;
 abc:	f5 01       	movw	r30, r10
 abe:	44 89       	ldd	r20, Z+20	; 0x14
 ac0:	55 89       	ldd	r21, Z+21	; 0x15
 ac2:	66 89       	ldd	r22, Z+22	; 0x16
 ac4:	77 89       	ldd	r23, Z+23	; 0x17
 ac6:	c1 01       	movw	r24, r2
 ac8:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 acc:	ab 01       	movw	r20, r22
 ace:	bc 01       	movw	r22, r24
 ad0:	4c 0d       	add	r20, r12
 ad2:	5d 1d       	adc	r21, r13
 ad4:	6e 1d       	adc	r22, r14
 ad6:	7f 1d       	adc	r23, r15
 ad8:	d5 01       	movw	r26, r10
 ada:	8d 91       	ld	r24, X+
 adc:	9c 91       	ld	r25, X
 ade:	11 97       	sbiw	r26, 0x01	; 1
 ae0:	c9 8c       	ldd	r12, Y+25	; 0x19
 ae2:	da 8c       	ldd	r13, Y+26	; 0x1a
 ae4:	c8 0c       	add	r12, r8
 ae6:	d9 1c       	adc	r13, r9

		if(bytesToWrite==512){
 ae8:	b2 e0       	ldi	r27, 0x02	; 2
 aea:	00 30       	cpi	r16, 0x00	; 0
 aec:	1b 07       	cpc	r17, r27
 aee:	01 f4       	brne	.+0      	; 0xaf0 <fileWrite+0x1f6>
			// Write directly from user memory to the device
			_partitionDirectSectorWrite(file->disk,writeSector,((const uint8_t*)buf)+bytes_written);
 af0:	96 01       	movw	r18, r12
 af2:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 af6:	00 c0       	rjmp	.+0      	; 0xaf8 <fileWrite+0x1fe>
		}else{
			// read the sector into the buffer for read/write
			uint8_t* tbuf = _partitionGetSector(file->disk,writeSector,BUFFER_MODE_READWRITE);
 af8:	22 e0       	ldi	r18, 0x02	; 2
 afa:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 afe:	7c 01       	movw	r14, r24
			// copy the user memory into the buffer
			memcpy(tbuf+offsetInSector,((const uint8_t*)buf)+bytes_written,bytesToWrite);
 b00:	8f 89       	ldd	r24, Y+23	; 0x17
 b02:	98 8d       	ldd	r25, Y+24	; 0x18
 b04:	8e 0d       	add	r24, r14
 b06:	9f 1d       	adc	r25, r15
 b08:	b6 01       	movw	r22, r12
 b0a:	a8 01       	movw	r20, r16
 b0c:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 b10:	f5 01       	movw	r30, r10
 b12:	80 81       	ld	r24, Z
 b14:	91 81       	ldd	r25, Z+1	; 0x01
 b16:	b7 01       	movw	r22, r14
 b18:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
			// release the sector
			partition_releaseSector(file->disk,tbuf);
		}

		currentOffset += bytesToWrite;
 b1c:	c8 01       	movw	r24, r16
 b1e:	a0 e0       	ldi	r26, 0x00	; 0
 b20:	b0 e0       	ldi	r27, 0x00	; 0
 b22:	29 89       	ldd	r18, Y+17	; 0x11
 b24:	3a 89       	ldd	r19, Y+18	; 0x12
 b26:	4b 89       	ldd	r20, Y+19	; 0x13
 b28:	5c 89       	ldd	r21, Y+20	; 0x14
 b2a:	28 0f       	add	r18, r24
 b2c:	39 1f       	adc	r19, r25
 b2e:	4a 1f       	adc	r20, r26
 b30:	5b 1f       	adc	r21, r27
 b32:	29 8b       	std	Y+17, r18	; 0x11
 b34:	3a 8b       	std	Y+18, r19	; 0x12
 b36:	4b 8b       	std	Y+19, r20	; 0x13
 b38:	5c 8b       	std	Y+20, r21	; 0x14
		bytes_written += bytesToWrite;
 b3a:	80 0e       	add	r8, r16
 b3c:	91 1e       	adc	r9, r17
		size_left -= bytesToWrite;
 b3e:	4d 89       	ldd	r20, Y+21	; 0x15
 b40:	5e 89       	ldd	r21, Y+22	; 0x16
 b42:	40 1b       	sub	r20, r16
 b44:	51 0b       	sbc	r21, r17
 b46:	5e 8b       	std	Y+22, r21	; 0x16
 b48:	4d 8b       	std	Y+21, r20	; 0x15
		}
	}

	size_t size_left=size;
	size_t bytes_written=0;
	while(size_left>0){
 b4a:	8d 89       	ldd	r24, Y+21	; 0x15
 b4c:	9e 89       	ldd	r25, Y+22	; 0x16
 b4e:	00 97       	sbiw	r24, 0x00	; 0
 b50:	01 f0       	breq	.+0      	; 0xb52 <fileWrite+0x258>
 b52:	00 c0       	rjmp	.+0      	; 0xb54 <fileWrite+0x25a>
		bytes_written += bytesToWrite;
		size_left -= bytesToWrite;
	}

	// Update the file size
	if(bytes_written > file->fileSize - offset){
 b54:	a4 01       	movw	r20, r8
 b56:	60 e0       	ldi	r22, 0x00	; 0
 b58:	70 e0       	ldi	r23, 0x00	; 0
 b5a:	f5 01       	movw	r30, r10
 b5c:	81 a5       	ldd	r24, Z+41	; 0x29
 b5e:	92 a5       	ldd	r25, Z+42	; 0x2a
 b60:	a3 a5       	ldd	r26, Z+43	; 0x2b
 b62:	b4 a5       	ldd	r27, Z+44	; 0x2c
 b64:	84 19       	sub	r24, r4
 b66:	95 09       	sbc	r25, r5
 b68:	a6 09       	sbc	r26, r6
 b6a:	b7 09       	sbc	r27, r7
 b6c:	84 17       	cp	r24, r20
 b6e:	95 07       	cpc	r25, r21
 b70:	a6 07       	cpc	r26, r22
 b72:	b7 07       	cpc	r27, r23
 b74:	00 f4       	brcc	.+0      	; 0xb76 <fileWrite+0x27c>
		file->fileSize += bytes_written - (file->fileSize-offset);
 b76:	44 0d       	add	r20, r4
 b78:	55 1d       	adc	r21, r5
 b7a:	66 1d       	adc	r22, r6
 b7c:	77 1d       	adc	r23, r7
 b7e:	41 a7       	std	Z+41, r20	; 0x29
 b80:	52 a7       	std	Z+42, r21	; 0x2a
 b82:	63 a7       	std	Z+43, r22	; 0x2b
 b84:	74 a7       	std	Z+44, r23	; 0x2c
 b86:	00 c0       	rjmp	.+0      	; 0xb88 <fileWrite+0x28e>
		rprintfInit(old);}
#endif

		if(!_fatExtend(file->disk,&(file->nav),need_cluster)){
			// FAT is full
			return(0);
 b88:	88 24       	eor	r8, r8
 b8a:	99 24       	eor	r9, r9
	if(bytes_written > file->fileSize - offset){
		file->fileSize += bytes_written - (file->fileSize-offset);
   }

	return(bytes_written);
}
 b8c:	c4 01       	movw	r24, r8
 b8e:	6c 96       	adiw	r28, 0x1c	; 28
 b90:	0f b6       	in	r0, 0x3f	; 63
 b92:	f8 94       	cli
 b94:	de bf       	out	0x3e, r29	; 62
 b96:	0f be       	out	0x3f, r0	; 63
 b98:	cd bf       	out	0x3d, r28	; 61
 b9a:	df 91       	pop	r29
 b9c:	cf 91       	pop	r28
 b9e:	1f 91       	pop	r17
 ba0:	0f 91       	pop	r16
 ba2:	ff 90       	pop	r15
 ba4:	ef 90       	pop	r14
 ba6:	df 90       	pop	r13
 ba8:	cf 90       	pop	r12
 baa:	bf 90       	pop	r11
 bac:	af 90       	pop	r10
 bae:	9f 90       	pop	r9
 bb0:	8f 90       	pop	r8
 bb2:	7f 90       	pop	r7
 bb4:	6f 90       	pop	r6
 bb6:	5f 90       	pop	r5
 bb8:	4f 90       	pop	r4
 bba:	3f 90       	pop	r3
 bbc:	2f 90       	pop	r2
 bbe:	08 95       	ret

00000bc0 <fileWriteNext>:
size_t fileWriteNext(FATFILE *file, size_t size,const void *buf){
 bc0:	0f 93       	push	r16
 bc2:	1f 93       	push	r17
 bc4:	cf 93       	push	r28
 bc6:	df 93       	push	r29
 bc8:	ec 01       	movw	r28, r24
 bca:	9b 01       	movw	r18, r22
 bcc:	8a 01       	movw	r16, r20
	size_t r=fileWrite(file,file->filePos,size,buf);
 bce:	4d a1       	ldd	r20, Y+37	; 0x25
 bd0:	5e a1       	ldd	r21, Y+38	; 0x26
 bd2:	6f a1       	ldd	r22, Y+39	; 0x27
 bd4:	78 a5       	ldd	r23, Y+40	; 0x28
 bd6:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
 bda:	9c 01       	movw	r18, r24
	file->filePos+=r;
 bdc:	ac 01       	movw	r20, r24
 bde:	60 e0       	ldi	r22, 0x00	; 0
 be0:	70 e0       	ldi	r23, 0x00	; 0
 be2:	8d a1       	ldd	r24, Y+37	; 0x25
 be4:	9e a1       	ldd	r25, Y+38	; 0x26
 be6:	af a1       	ldd	r26, Y+39	; 0x27
 be8:	b8 a5       	ldd	r27, Y+40	; 0x28
 bea:	84 0f       	add	r24, r20
 bec:	95 1f       	adc	r25, r21
 bee:	a6 1f       	adc	r26, r22
 bf0:	b7 1f       	adc	r27, r23
 bf2:	8d a3       	std	Y+37, r24	; 0x25
 bf4:	9e a3       	std	Y+38, r25	; 0x26
 bf6:	af a3       	std	Y+39, r26	; 0x27
 bf8:	b8 a7       	std	Y+40, r27	; 0x28
	return(r);
}
 bfa:	c9 01       	movw	r24, r18
 bfc:	df 91       	pop	r29
 bfe:	cf 91       	pop	r28
 c00:	1f 91       	pop	r17
 c02:	0f 91       	pop	r16
 c04:	08 95       	ret

00000c06 <writer>:

static MAKE_WRITER(writer){
 c06:	cf 93       	push	r28
 c08:	df 93       	push	r29
 c0a:	0f 92       	push	r0
 c0c:	cd b7       	in	r28, 0x3d	; 61
 c0e:	de b7       	in	r29, 0x3e	; 62
 c10:	89 83       	std	Y+1, r24	; 0x01
	if(activeFile){
 c12:	80 91 00 00 	lds	r24, 0x0000
 c16:	90 91 00 00 	lds	r25, 0x0000
 c1a:	00 97       	sbiw	r24, 0x00	; 0
 c1c:	01 f0       	breq	.+0      	; 0xc1e <writer+0x18>
		fileWriteNext(activeFile,1,&byte);
 c1e:	61 e0       	ldi	r22, 0x01	; 1
 c20:	70 e0       	ldi	r23, 0x00	; 0
 c22:	ae 01       	movw	r20, r28
 c24:	4f 5f       	subi	r20, 0xFF	; 255
 c26:	5f 4f       	sbci	r21, 0xFF	; 255
 c28:	0e 94 00 00 	call	0	; 0x0 <_dirGetFileStructure>
	}
	return byte;
}
 c2c:	89 81       	ldd	r24, Y+1	; 0x01
 c2e:	0f 90       	pop	r0
 c30:	df 91       	pop	r29
 c32:	cf 91       	pop	r28
 c34:	08 95       	ret

00000c36 <fileGetWriter>:

Writer fileGetWriter(const FATFILE* file){
	activeFile = (FATFILE*)file;
 c36:	90 93 00 00 	sts	0x0000, r25
 c3a:	80 93 00 00 	sts	0x0000, r24
	return &writer;
}
 c3e:	80 e0       	ldi	r24, 0x00	; 0
 c40:	90 e0       	ldi	r25, 0x00	; 0
 c42:	08 95       	ret

FATlist.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000256  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000028a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000028a  2**0
                  ALLOC
  3 .debug_info   0000093b  00000000  00000000  0000028a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000022f  00000000  00000000  00000bc5  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000313  00000000  00000000  00000df4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001107  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000058  00000000  00000000  00001127  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000128  00000000  00000000  0000117f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000005af  00000000  00000000  000012a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000088  00000000  00000000  00001858  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_fileEntryToDirListEntry>:
 *      Author: Clive Webster
 */
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	buf+=offset;
   6:	25 e0       	ldi	r18, 0x05	; 5
   8:	44 0f       	add	r20, r20
   a:	55 1f       	adc	r21, r21
   c:	2a 95       	dec	r18
   e:	01 f4       	brne	.+0      	; 0x10 <_fileEntryToDirListEntry+0x10>
  10:	64 0f       	add	r22, r20
  12:	75 1f       	adc	r23, r21
  14:	fb 01       	movw	r30, r22
	uint8_t srcpos = 0;
	uint8_t dstpos = 0;
  16:	20 e0       	ldi	r18, 0x00	; 0
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
	buf+=offset;
	uint8_t srcpos = 0;
  18:	80 e0       	ldi	r24, 0x00	; 0
	uint8_t dstpos = 0;

	while(srcpos < 8){
		char c = buf->filename[srcpos];
  1a:	91 91       	ld	r25, Z+
		if(c != ' ' && c != '\0'){
  1c:	90 32       	cpi	r25, 0x20	; 32
  1e:	01 f0       	breq	.+0      	; 0x20 <_fileEntryToDirListEntry+0x20>
  20:	99 23       	and	r25, r25
  22:	01 f0       	breq	.+0      	; 0x24 <_fileEntryToDirListEntry+0x24>
			dlist->filename[dstpos++] = c;
  24:	de 01       	movw	r26, r28
  26:	a2 0f       	add	r26, r18
  28:	b1 1d       	adc	r27, r1
  2a:	9c 93       	st	X, r25
  2c:	2f 5f       	subi	r18, 0xFF	; 255
		}
		srcpos++;
  2e:	8f 5f       	subi	r24, 0xFF	; 255
static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
	buf+=offset;
	uint8_t srcpos = 0;
	uint8_t dstpos = 0;

	while(srcpos < 8){
  30:	88 30       	cpi	r24, 0x08	; 8
  32:	01 f4       	brne	.+0      	; 0x34 <_fileEntryToDirListEntry+0x34>
		if(c != ' ' && c != '\0'){
			dlist->filename[dstpos++] = c;
		}
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';
  34:	fe 01       	movw	r30, r28
  36:	e2 0f       	add	r30, r18
  38:	f1 1d       	adc	r31, r1
  3a:	8e e2       	ldi	r24, 0x2E	; 46
  3c:	80 83       	st	Z, r24
  3e:	2f 5f       	subi	r18, 0xFF	; 255
  40:	80 e0       	ldi	r24, 0x00	; 0
  42:	90 e0       	ldi	r25, 0x00	; 0
 *      Author: Clive Webster
 */
#include "FATImpl.h"


static void _fileEntryToDirListEntry(FILE_ITERATOR *dlist, const DIR_ENTRY* buf, uint16_t offset){
  44:	fb 01       	movw	r30, r22
  46:	e8 0f       	add	r30, r24
  48:	f9 1f       	adc	r31, r25
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';

	while(srcpos < 8+3){
		char c = buf->filename[srcpos];
  4a:	30 85       	ldd	r19, Z+8	; 0x08
		if(c != ' ' && c != '\0'){
  4c:	30 32       	cpi	r19, 0x20	; 32
  4e:	01 f0       	breq	.+0      	; 0x50 <_fileEntryToDirListEntry+0x50>
  50:	33 23       	and	r19, r19
  52:	01 f0       	breq	.+0      	; 0x54 <_fileEntryToDirListEntry+0x54>
			dlist->filename[dstpos++] = c;
  54:	fe 01       	movw	r30, r28
  56:	e2 0f       	add	r30, r18
  58:	f1 1d       	adc	r31, r1
  5a:	30 83       	st	Z, r19
  5c:	2f 5f       	subi	r18, 0xFF	; 255
  5e:	01 96       	adiw	r24, 0x01	; 1
		}
		srcpos++;
	}
	dlist->filename[dstpos++] = '.';

	while(srcpos < 8+3){
  60:	83 30       	cpi	r24, 0x03	; 3
  62:	91 05       	cpc	r25, r1
  64:	01 f4       	brne	.+0      	; 0x66 <_fileEntryToDirListEntry+0x66>
			dlist->filename[dstpos++] = c;
		}
		srcpos++;
	}

	if(dlist->filename[dstpos-1] == '.'){
  66:	fe 01       	movw	r30, r28
  68:	e2 0f       	add	r30, r18
  6a:	f1 1d       	adc	r31, r1
  6c:	31 97       	sbiw	r30, 0x01	; 1
  6e:	80 81       	ld	r24, Z
  70:	8e 32       	cpi	r24, 0x2E	; 46
  72:	01 f4       	brne	.+0      	; 0x74 <_fileEntryToDirListEntry+0x74>
		dstpos--;
  74:	21 50       	subi	r18, 0x01	; 1
	}
	dlist->filename[dstpos] = '\0';
  76:	fe 01       	movw	r30, r28
  78:	e2 0f       	add	r30, r18
  7a:	f1 1d       	adc	r31, r1
  7c:	10 82       	st	Z, r1

	dlist->attribute = buf->attribute;
  7e:	fb 01       	movw	r30, r22
  80:	83 85       	ldd	r24, Z+11	; 0x0b
  82:	89 8b       	std	Y+17, r24	; 0x11
	dlist->fileSize = buf->fileSize;
  84:	84 8d       	ldd	r24, Z+28	; 0x1c
  86:	95 8d       	ldd	r25, Z+29	; 0x1d
  88:	a6 8d       	ldd	r26, Z+30	; 0x1e
  8a:	b7 8d       	ldd	r27, Z+31	; 0x1f
  8c:	8d 87       	std	Y+13, r24	; 0x0d
  8e:	9e 87       	std	Y+14, r25	; 0x0e
  90:	af 87       	std	Y+15, r26	; 0x0f
  92:	b8 8b       	std	Y+16, r27	; 0x10
}
  94:	df 91       	pop	r29
  96:	cf 91       	pop	r28
  98:	08 95       	ret

0000009a <fileFindNext>:
 	return TRUE;
}


// Get the next directory entry
boolean fileFindNext(FILE_ITERATOR *dlist){
  9a:	ef 92       	push	r14
  9c:	ff 92       	push	r15
  9e:	0f 93       	push	r16
  a0:	1f 93       	push	r17
  a2:	cf 93       	push	r28
  a4:	df 93       	push	r29
  a6:	ec 01       	movw	r28, r24
	if(dlist->nav.startCluster<=1){
		return(FALSE);
	}

	CLUSTER_COUNT clusterInDir = (dlist->dirEntry)/(16 * dlist->disk->volume.sectorsPerCluster);
	if(_fatNavigateTo(dlist->disk,
  a8:	06 e1       	ldi	r16, 0x16	; 22
  aa:	e0 2e       	mov	r14, r16
  ac:	f1 2c       	mov	r15, r1
  ae:	e8 0e       	add	r14, r24
  b0:	f9 1e       	adc	r15, r25

	return(TRUE);
}

static boolean _getDirEntry(FILE_ITERATOR *dlist){
	if(dlist->nav.startCluster == 1){
  b2:	8a a1       	ldd	r24, Y+34	; 0x22
  b4:	9b a1       	ldd	r25, Y+35	; 0x23
  b6:	ac a1       	ldd	r26, Y+36	; 0x24
  b8:	bd a1       	ldd	r27, Y+37	; 0x25
  ba:	81 30       	cpi	r24, 0x01	; 1
  bc:	91 05       	cpc	r25, r1
  be:	a1 05       	cpc	r26, r1
  c0:	b1 05       	cpc	r27, r1
  c2:	01 f4       	brne	.+0      	; 0xc4 <fileFindNext+0x2a>
	dlist->attribute = buf->attribute;
	dlist->fileSize = buf->fileSize;
}

static boolean _getRootAreaEntry(FILE_ITERATOR *dlist){
	if((dlist->disk->fatType != 12) && (dlist->disk->fatType != 16)){
  c4:	ea 89       	ldd	r30, Y+18	; 0x12
  c6:	fb 89       	ldd	r31, Y+19	; 0x13
  c8:	86 a1       	ldd	r24, Z+38	; 0x26
  ca:	8c 30       	cpi	r24, 0x0C	; 12
  cc:	01 f0       	breq	.+0      	; 0xce <fileFindNext+0x34>
  ce:	80 31       	cpi	r24, 0x10	; 16
  d0:	01 f0       	breq	.+0      	; 0xd2 <fileFindNext+0x38>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <fileFindNext+0x3a>
		return(FALSE);
	}
	if(dlist->dirEntry>=dlist->disk->volume.rootDirEntryCount){
  d4:	4c 89       	ldd	r20, Y+20	; 0x14
  d6:	5d 89       	ldd	r21, Y+21	; 0x15
  d8:	84 89       	ldd	r24, Z+20	; 0x14
  da:	95 89       	ldd	r25, Z+21	; 0x15
  dc:	48 17       	cp	r20, r24
  de:	59 07       	cpc	r21, r25
  e0:	00 f0       	brcs	.+0      	; 0xe2 <fileFindNext+0x48>
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <fileFindNext+0x4a>
		return(FALSE);
	}

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,
					   dlist->disk->firstSectorRootDir+dlist->dirEntry/16,
  e4:	14 e0       	ldi	r17, 0x04	; 4
  e6:	56 95       	lsr	r21
  e8:	47 95       	ror	r20
  ea:	1a 95       	dec	r17
  ec:	01 f4       	brne	.+0      	; 0xee <fileFindNext+0x54>
	}
	if(dlist->dirEntry>=dlist->disk->volume.rootDirEntryCount){
		return(FALSE);
	}

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,
  ee:	60 e0       	ldi	r22, 0x00	; 0
  f0:	70 e0       	ldi	r23, 0x00	; 0
  f2:	87 a1       	ldd	r24, Z+39	; 0x27
  f4:	90 a5       	ldd	r25, Z+40	; 0x28
  f6:	a1 a5       	ldd	r26, Z+41	; 0x29
  f8:	b2 a5       	ldd	r27, Z+42	; 0x2a
  fa:	48 0f       	add	r20, r24
  fc:	59 1f       	adc	r21, r25
  fe:	6a 1f       	adc	r22, r26
 100:	7b 1f       	adc	r23, r27
 102:	cf 01       	movw	r24, r30
 104:	00 c0       	rjmp	.+0      	; 0x106 <fileFindNext+0x6c>
}

static boolean _getDirEntry(FILE_ITERATOR *dlist){
	if(dlist->nav.startCluster == 1){
		return(_getRootAreaEntry(dlist));
	}else if(dlist->nav.startCluster){
 106:	00 97       	sbiw	r24, 0x00	; 0
 108:	a1 05       	cpc	r26, r1
 10a:	b1 05       	cpc	r27, r1
 10c:	01 f4       	brne	.+0      	; 0x10e <fileFindNext+0x74>
 10e:	00 c0       	rjmp	.+0      	; 0x110 <fileFindNext+0x76>
}


static boolean _getRealDirEntry(FILE_ITERATOR *dlist){

	if(dlist->nav.startCluster<=1){
 110:	82 30       	cpi	r24, 0x02	; 2
 112:	91 05       	cpc	r25, r1
 114:	a1 05       	cpc	r26, r1
 116:	b1 05       	cpc	r27, r1
 118:	00 f4       	brcc	.+0      	; 0x11a <fileFindNext+0x80>
 11a:	00 c0       	rjmp	.+0      	; 0x11c <fileFindNext+0x82>
		return(FALSE);
	}

	CLUSTER_COUNT clusterInDir = (dlist->dirEntry)/(16 * dlist->disk->volume.sectorsPerCluster);
 11c:	ea 89       	ldd	r30, Y+18	; 0x12
 11e:	fb 89       	ldd	r31, Y+19	; 0x13
 120:	60 89       	ldd	r22, Z+16	; 0x10
 122:	70 e0       	ldi	r23, 0x00	; 0
 124:	b4 e0       	ldi	r27, 0x04	; 4
 126:	66 0f       	add	r22, r22
 128:	77 1f       	adc	r23, r23
 12a:	ba 95       	dec	r27
 12c:	01 f4       	brne	.+0      	; 0x12e <fileFindNext+0x94>
 12e:	8c 89       	ldd	r24, Y+20	; 0x14
 130:	9d 89       	ldd	r25, Y+21	; 0x15
 132:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 136:	9b 01       	movw	r18, r22
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	50 e0       	ldi	r21, 0x00	; 0
	if(_fatNavigateTo(dlist->disk,
 13c:	cf 01       	movw	r24, r30
 13e:	b7 01       	movw	r22, r14
 140:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 144:	88 23       	and	r24, r24
 146:	01 f4       	brne	.+0      	; 0x148 <fileFindNext+0xae>
 148:	00 c0       	rjmp	.+0      	; 0x14a <fileFindNext+0xb0>
						   &(dlist->nav),
						   clusterInDir)==FALSE){
		return(FALSE);
	}

	SECTOR sector = _diskClusterToSector(dlist->disk,dlist->nav.currentCluster) +
 14a:	4e 8d       	ldd	r20, Y+30	; 0x1e
 14c:	5f 8d       	ldd	r21, Y+31	; 0x1f
 14e:	68 a1       	ldd	r22, Y+32	; 0x20
 150:	79 a1       	ldd	r23, Y+33	; 0x21
 152:	8a 89       	ldd	r24, Y+18	; 0x12
 154:	9b 89       	ldd	r25, Y+19	; 0x13
 156:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 15a:	8b 01       	movw	r16, r22
 15c:	9c 01       	movw	r18, r24
					(dlist->dirEntry/16)%dlist->disk->volume.sectorsPerCluster;
 15e:	ea 89       	ldd	r30, Y+18	; 0x12
 160:	fb 89       	ldd	r31, Y+19	; 0x13
 162:	8c 89       	ldd	r24, Y+20	; 0x14
 164:	9d 89       	ldd	r25, Y+21	; 0x15
 166:	a4 e0       	ldi	r26, 0x04	; 4
 168:	96 95       	lsr	r25
 16a:	87 95       	ror	r24
 16c:	aa 95       	dec	r26
 16e:	01 f4       	brne	.+0      	; 0x170 <fileFindNext+0xd6>
 170:	60 89       	ldd	r22, Z+16	; 0x10
 172:	70 e0       	ldi	r23, 0x00	; 0
 174:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
						   &(dlist->nav),
						   clusterInDir)==FALSE){
		return(FALSE);
	}

	SECTOR sector = _diskClusterToSector(dlist->disk,dlist->nav.currentCluster) +
 178:	a0 e0       	ldi	r26, 0x00	; 0
 17a:	b0 e0       	ldi	r27, 0x00	; 0
 17c:	08 0f       	add	r16, r24
 17e:	19 1f       	adc	r17, r25
 180:	2a 1f       	adc	r18, r26
 182:	3b 1f       	adc	r19, r27
					(dlist->dirEntry/16)%dlist->disk->volume.sectorsPerCluster;

	DIR_ENTRY* buf = _partitionGetSector(dlist->disk,sector,BUFFER_MODE_READONLY);
 184:	cf 01       	movw	r24, r30
 186:	b9 01       	movw	r22, r18
 188:	a8 01       	movw	r20, r16
 18a:	21 e0       	ldi	r18, 0x01	; 1
 18c:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 190:	8c 01       	movw	r16, r24
	_fileEntryToDirListEntry(dlist,buf,(dlist->dirEntry%16));
 192:	4c 89       	ldd	r20, Y+20	; 0x14
 194:	5d 89       	ldd	r21, Y+21	; 0x15
 196:	4f 70       	andi	r20, 0x0F	; 15
 198:	50 70       	andi	r21, 0x00	; 0
 19a:	ce 01       	movw	r24, r28
 19c:	b8 01       	movw	r22, r16
 19e:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
 1a2:	8a 89       	ldd	r24, Y+18	; 0x12
 1a4:	9b 89       	ldd	r25, Y+19	; 0x13
 1a6:	b8 01       	movw	r22, r16
 1a8:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
boolean fileFindNext(FILE_ITERATOR *dlist){
	do{
		if(!_getDirEntry(dlist)){
			return FALSE;
		}
		dlist->dirEntry++;
 1ac:	8c 89       	ldd	r24, Y+20	; 0x14
 1ae:	9d 89       	ldd	r25, Y+21	; 0x15
 1b0:	01 96       	adiw	r24, 0x01	; 1
 1b2:	9d 8b       	std	Y+21, r25	; 0x15
 1b4:	8c 8b       	std	Y+20, r24	; 0x14
	}
	return(FALSE);
}

static boolean _isValidFileEntry(FILE_ITERATOR *entry){
	if(entry->filename[0] == 0 || entry->filename[0] == 0xE5 || entry->filename[0] == '.'){
 1b6:	88 81       	ld	r24, Y
 1b8:	88 23       	and	r24, r24
 1ba:	01 f4       	brne	.+0      	; 0x1bc <fileFindNext+0x122>
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <fileFindNext+0x124>
 1be:	85 3e       	cpi	r24, 0xE5	; 229
 1c0:	01 f4       	brne	.+0      	; 0x1c2 <fileFindNext+0x128>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <fileFindNext+0x12a>
 1c4:	8e 32       	cpi	r24, 0x2E	; 46
 1c6:	01 f4       	brne	.+0      	; 0x1c8 <fileFindNext+0x12e>
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <fileFindNext+0x130>
		return FALSE;
	}
	if((entry->attribute.bits & 0x0F)==0x0F){
 1ca:	89 89       	ldd	r24, Y+17	; 0x11
 1cc:	8f 70       	andi	r24, 0x0F	; 15
 1ce:	8f 30       	cpi	r24, 0x0F	; 15
 1d0:	01 f4       	brne	.+0      	; 0x1d2 <fileFindNext+0x138>
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <fileFindNext+0x13a>
		}
		dlist->dirEntry++;

	}while(!_isValidFileEntry(dlist));

	return TRUE;
 1d4:	8f ef       	ldi	r24, 0xFF	; 255
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <fileFindNext+0x13e>

// Get the next directory entry
boolean fileFindNext(FILE_ITERATOR *dlist){
	do{
		if(!_getDirEntry(dlist)){
			return FALSE;
 1d8:	80 e0       	ldi	r24, 0x00	; 0
		dlist->dirEntry++;

	}while(!_isValidFileEntry(dlist));

	return TRUE;
}
 1da:	df 91       	pop	r29
 1dc:	cf 91       	pop	r28
 1de:	1f 91       	pop	r17
 1e0:	0f 91       	pop	r16
 1e2:	ff 90       	pop	r15
 1e4:	ef 90       	pop	r14
 1e6:	08 95       	ret

000001e8 <fileFindFirst>:

// Open a directory
// This will fill in the FILE_ITERATOR
// Returns: FALSE if it cannot find the directory
// else use ls_getNext to iterate through each file name in the directory
boolean fileFindFirst(const DISK* disk,FILE_ITERATOR *dlist,const char* dirname){
 1e8:	0f 93       	push	r16
 1ea:	1f 93       	push	r17
 1ec:	cf 93       	push	r28
 1ee:	df 93       	push	r29
 1f0:	cd b7       	in	r28, 0x3d	; 61
 1f2:	de b7       	in	r29, 0x3e	; 62
 1f4:	2a 97       	sbiw	r28, 0x0a	; 10
 1f6:	0f b6       	in	r0, 0x3f	; 63
 1f8:	f8 94       	cli
 1fa:	de bf       	out	0x3e, r29	; 62
 1fc:	0f be       	out	0x3f, r0	; 63
 1fe:	cd bf       	out	0x3d, r28	; 61
 200:	8b 01       	movw	r16, r22
 202:	ba 01       	movw	r22, r20
	DIR_POSITION loc;
	CLUSTER directoryCluster;

	dlist->disk=disk;
 204:	f8 01       	movw	r30, r16
 206:	93 8b       	std	Z+19, r25	; 0x13
 208:	82 8b       	std	Z+18, r24	; 0x12

	if(_fileFindFile(disk,dirname,&loc,&directoryCluster)!=2){
 20a:	ae 01       	movw	r20, r28
 20c:	4b 5f       	subi	r20, 0xFB	; 251
 20e:	5f 4f       	sbci	r21, 0xFF	; 255
 210:	9e 01       	movw	r18, r28
 212:	2f 5f       	subi	r18, 0xFF	; 255
 214:	3f 4f       	sbci	r19, 0xFF	; 255
 216:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 21a:	82 30       	cpi	r24, 0x02	; 2
 21c:	01 f4       	brne	.+0      	; 0x21e <fileFindFirst+0x36>
		// Cant find directory
		return FALSE;
	}


	_navInitClusterChain(&(dlist->nav),directoryCluster);
 21e:	49 81       	ldd	r20, Y+1	; 0x01
 220:	5a 81       	ldd	r21, Y+2	; 0x02
 222:	6b 81       	ldd	r22, Y+3	; 0x03
 224:	7c 81       	ldd	r23, Y+4	; 0x04
 226:	c8 01       	movw	r24, r16
 228:	46 96       	adiw	r24, 0x16	; 22
 22a:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>

	dlist->filename[0] = '\0';
 22e:	f8 01       	movw	r30, r16
 230:	10 82       	st	Z, r1
	dlist->dirEntry=0;
 232:	15 8a       	std	Z+21, r1	; 0x15
 234:	14 8a       	std	Z+20, r1	; 0x14

	return fileFindNext(dlist);
 236:	c8 01       	movw	r24, r16
 238:	0e 94 00 00 	call	0	; 0x0 <_fileEntryToDirListEntry>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <fileFindFirst+0x56>

	dlist->disk=disk;

	if(_fileFindFile(disk,dirname,&loc,&directoryCluster)!=2){
		// Cant find directory
		return FALSE;
 23e:	80 e0       	ldi	r24, 0x00	; 0

	dlist->filename[0] = '\0';
	dlist->dirEntry=0;

	return fileFindNext(dlist);
}
 240:	2a 96       	adiw	r28, 0x0a	; 10
 242:	0f b6       	in	r0, 0x3f	; 63
 244:	f8 94       	cli
 246:	de bf       	out	0x3e, r29	; 62
 248:	0f be       	out	0x3f, r0	; 63
 24a:	cd bf       	out	0x3d, r28	; 61
 24c:	df 91       	pop	r29
 24e:	cf 91       	pop	r28
 250:	1f 91       	pop	r17
 252:	0f 91       	pop	r16
 254:	08 95       	ret

FATmkdir.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001f2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000018  00000000  00000000  00000226  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000023e  2**0
                  ALLOC
  3 .debug_info   00000671  00000000  00000000  0000023e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000199  00000000  00000000  000008af  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001c0  00000000  00000000  00000a48  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000c08  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f9  00000000  00000000  00000c28  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000489  00000000  00000000  00000d21  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000064  00000000  00000000  000011ac  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <diskMkdir>:
 *  Created on: 4 Mar 2010
 *      Author: Clive Webster
 */
#include "FATImpl.h"

int8_t diskMkdir(DISK* disk,const char* dirname){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	e5 97       	sbiw	r28, 0x35	; 53
  1e:	0f b6       	in	r0, 0x3f	; 63
  20:	f8 94       	cli
  22:	de bf       	out	0x3e, r29	; 62
  24:	0f be       	out	0x3f, r0	; 63
  26:	cd bf       	out	0x3d, r28	; 61
  28:	7c 01       	movw	r14, r24
  2a:	8b 01       	movw	r16, r22
	DIR_POSITION loc;
	DIR_ENTRY direntry;
	CLUSTER parentdir;
	char ffname[11];

	if( _fileFindFile(disk,dirname,&loc,&parentdir) ){
  2c:	ae 01       	movw	r20, r28
  2e:	4b 5f       	subi	r20, 0xFB	; 251
  30:	5f 4f       	sbci	r21, 0xFF	; 255
  32:	9e 01       	movw	r18, r28
  34:	2f 5f       	subi	r18, 0xFF	; 255
  36:	3f 4f       	sbci	r19, 0xFF	; 255
  38:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  3c:	88 23       	and	r24, r24
  3e:	01 f0       	breq	.+0      	; 0x40 <diskMkdir+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <diskMkdir+0x42>
		// File or Dir already exists
		return(-1);
	}

	if(parentdir==0){
  42:	89 81       	ldd	r24, Y+1	; 0x01
  44:	9a 81       	ldd	r25, Y+2	; 0x02
  46:	ab 81       	ldd	r26, Y+3	; 0x03
  48:	bc 81       	ldd	r27, Y+4	; 0x04
  4a:	00 97       	sbiw	r24, 0x00	; 0
  4c:	a1 05       	cpc	r26, r1
  4e:	b1 05       	cpc	r27, r1
  50:	01 f4       	brne	.+0      	; 0x52 <diskMkdir+0x52>
  52:	00 c0       	rjmp	.+0      	; 0x54 <diskMkdir+0x54>
		// Cannot create a new root
		return(-1);
	}

	if(!_dirFindFreeFile(disk,dirname,&loc)){
  54:	c7 01       	movw	r24, r14
  56:	b8 01       	movw	r22, r16
  58:	ae 01       	movw	r20, r28
  5a:	4b 5f       	subi	r20, 0xFB	; 251
  5c:	5f 4f       	sbci	r21, 0xFF	; 255
  5e:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  62:	88 23       	and	r24, r24
  64:	01 f4       	brne	.+0      	; 0x66 <diskMkdir+0x66>
  66:	00 c0       	rjmp	.+0      	; 0x68 <diskMkdir+0x68>
		// No directory space
		return(-2);
	}

	CLUSTER nc = _fatGetFreeCluster(disk);
  68:	c7 01       	movw	r24, r14
  6a:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  6e:	4b 01       	movw	r8, r22
  70:	5c 01       	movw	r10, r24
	if(nc==0){
  72:	61 15       	cp	r22, r1
  74:	71 05       	cpc	r23, r1
  76:	81 05       	cpc	r24, r1
  78:	91 05       	cpc	r25, r1
  7a:	01 f4       	brne	.+0      	; 0x7c <diskMkdir+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <diskMkdir+0x7e>
		// No space to create the new directory area
		return(-3);
	}

	_partitionClearCluster(disk,nc);
  7e:	c7 01       	movw	r24, r14
  80:	b5 01       	movw	r22, r10
  82:	a4 01       	movw	r20, r8
  84:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>


	// Create it in the parent directory
	_dirGetFatFileName(dirname,ffname);
  88:	c8 01       	movw	r24, r16
  8a:	be 01       	movw	r22, r28
  8c:	65 5f       	subi	r22, 0xF5	; 245
  8e:	7f 4f       	sbci	r23, 0xFF	; 255
  90:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memclr(&direntry,sizeof(direntry));
  94:	de 01       	movw	r26, r28
  96:	56 96       	adiw	r26, 0x16	; 22
  98:	80 e2       	ldi	r24, 0x20	; 32
  9a:	fd 01       	movw	r30, r26
  9c:	11 92       	st	Z+, r1
  9e:	8a 95       	dec	r24
  a0:	01 f4       	brne	.+0      	; 0xa2 <diskMkdir+0xa2>
	memcpy(&direntry,ffname,11);
  a2:	fe 01       	movw	r30, r28
  a4:	3b 96       	adiw	r30, 0x0b	; 11
  a6:	8b e0       	ldi	r24, 0x0B	; 11
  a8:	01 90       	ld	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	81 50       	subi	r24, 0x01	; 1
  ae:	01 f4       	brne	.+0      	; 0xb0 <diskMkdir+0xb0>
	_dirSetFirstClusterInDirEntry(&direntry,nc);
  b0:	8e 01       	movw	r16, r28
  b2:	0a 5e       	subi	r16, 0xEA	; 234
  b4:	1f 4f       	sbci	r17, 0xFF	; 255
  b6:	c8 01       	movw	r24, r16
  b8:	b5 01       	movw	r22, r10
  ba:	a4 01       	movw	r20, r8
  bc:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	direntry.attribute.flags.isDirectory = 1;
  c0:	89 a1       	ldd	r24, Y+33	; 0x21
  c2:	80 61       	ori	r24, 0x10	; 16
  c4:	89 a3       	std	Y+33, r24	; 0x21
	_dirCreateDirectoryEntry(disk,&direntry,&loc);
  c6:	c7 01       	movw	r24, r14
  c8:	b8 01       	movw	r22, r16
  ca:	ae 01       	movw	r20, r28
  cc:	4b 5f       	subi	r20, 0xFB	; 251
  ce:	5f 4f       	sbci	r21, 0xFF	; 255
  d0:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	// Now add the '.' and '..' entries into the new directory
	DIR_ENTRY* dir = _partitionGetSector(disk,_diskClusterToSector(disk,nc),BUFFER_MODE_READWRITE);
  d4:	c7 01       	movw	r24, r14
  d6:	b5 01       	movw	r22, r10
  d8:	a4 01       	movw	r20, r8
  da:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  de:	ab 01       	movw	r20, r22
  e0:	bc 01       	movw	r22, r24
  e2:	c7 01       	movw	r24, r14
  e4:	22 e0       	ldi	r18, 0x02	; 2
  e6:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
  ea:	6c 01       	movw	r12, r24
	memclr(&direntry,sizeof(direntry));
  ec:	80 e2       	ldi	r24, 0x20	; 32
  ee:	f8 01       	movw	r30, r16
  f0:	11 92       	st	Z+, r1
  f2:	8a 95       	dec	r24
  f4:	01 f4       	brne	.+0      	; 0xf6 <diskMkdir+0xf6>
	memcpy(&direntry,".          ",11);
  f6:	d8 01       	movw	r26, r16
  f8:	e0 e0       	ldi	r30, 0x00	; 0
  fa:	f0 e0       	ldi	r31, 0x00	; 0
  fc:	8b e0       	ldi	r24, 0x0B	; 11
  fe:	01 90       	ld	r0, Z+
 100:	0d 92       	st	X+, r0
 102:	81 50       	subi	r24, 0x01	; 1
 104:	01 f4       	brne	.+0      	; 0x106 <diskMkdir+0x106>
	direntry.attribute.flags.isDirectory = 1;
 106:	89 a1       	ldd	r24, Y+33	; 0x21
 108:	80 61       	ori	r24, 0x10	; 16
 10a:	89 a3       	std	Y+33, r24	; 0x21
	_dirSetFirstClusterInDirEntry(&direntry,nc);
 10c:	ce 01       	movw	r24, r28
 10e:	46 96       	adiw	r24, 0x16	; 22
 110:	b5 01       	movw	r22, r10
 112:	a4 01       	movw	r20, r8
 114:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memcpy(&dir[0],&direntry,sizeof(DIR_ENTRY));
 118:	d6 01       	movw	r26, r12
 11a:	fe 01       	movw	r30, r28
 11c:	76 96       	adiw	r30, 0x16	; 22
 11e:	80 e2       	ldi	r24, 0x20	; 32
 120:	01 90       	ld	r0, Z+
 122:	0d 92       	st	X+, r0
 124:	81 50       	subi	r24, 0x01	; 1
 126:	01 f4       	brne	.+0      	; 0x128 <diskMkdir+0x128>

	if(disk->fatType == 32 && parentdir == disk->volume.rootDirCluster){
 128:	f7 01       	movw	r30, r14
 12a:	26 a1       	ldd	r18, Z+38	; 0x26
 12c:	89 81       	ldd	r24, Y+1	; 0x01
 12e:	9a 81       	ldd	r25, Y+2	; 0x02
 130:	ab 81       	ldd	r26, Y+3	; 0x03
 132:	bc 81       	ldd	r27, Y+4	; 0x04
 134:	20 32       	cpi	r18, 0x20	; 32
 136:	01 f4       	brne	.+0      	; 0x138 <diskMkdir+0x138>
 138:	46 89       	ldd	r20, Z+22	; 0x16
 13a:	57 89       	ldd	r21, Z+23	; 0x17
 13c:	60 8d       	ldd	r22, Z+24	; 0x18
 13e:	71 8d       	ldd	r23, Z+25	; 0x19
 140:	84 17       	cp	r24, r20
 142:	95 07       	cpc	r25, r21
 144:	a6 07       	cpc	r26, r22
 146:	b7 07       	cpc	r27, r23
 148:	01 f4       	brne	.+0      	; 0x14a <diskMkdir+0x14a>
 14a:	00 c0       	rjmp	.+0      	; 0x14c <diskMkdir+0x14c>
		parentdir = 0;
	}
	if(disk->fatType != 32 && parentdir<=1){
 14c:	82 30       	cpi	r24, 0x02	; 2
 14e:	91 05       	cpc	r25, r1
 150:	a1 05       	cpc	r26, r1
 152:	b1 05       	cpc	r27, r1
 154:	00 f4       	brcc	.+0      	; 0x156 <diskMkdir+0x156>
		parentdir = 0;
 156:	19 82       	std	Y+1, r1	; 0x01
 158:	1a 82       	std	Y+2, r1	; 0x02
 15a:	1b 82       	std	Y+3, r1	; 0x03
 15c:	1c 82       	std	Y+4, r1	; 0x04
	}

	memclr(&direntry,sizeof(direntry));
 15e:	de 01       	movw	r26, r28
 160:	56 96       	adiw	r26, 0x16	; 22
 162:	80 e2       	ldi	r24, 0x20	; 32
 164:	fd 01       	movw	r30, r26
 166:	11 92       	st	Z+, r1
 168:	8a 95       	dec	r24
 16a:	01 f4       	brne	.+0      	; 0x16c <diskMkdir+0x16c>
	memcpy(&direntry,"..         ",11);
 16c:	e0 e0       	ldi	r30, 0x00	; 0
 16e:	f0 e0       	ldi	r31, 0x00	; 0
 170:	8b e0       	ldi	r24, 0x0B	; 11
 172:	01 90       	ld	r0, Z+
 174:	0d 92       	st	X+, r0
 176:	81 50       	subi	r24, 0x01	; 1
 178:	01 f4       	brne	.+0      	; 0x17a <diskMkdir+0x17a>
	direntry.attribute.flags.isDirectory = 1;
 17a:	89 a1       	ldd	r24, Y+33	; 0x21
 17c:	80 61       	ori	r24, 0x10	; 16
 17e:	89 a3       	std	Y+33, r24	; 0x21
	_dirSetFirstClusterInDirEntry(&direntry,parentdir);
 180:	49 81       	ldd	r20, Y+1	; 0x01
 182:	5a 81       	ldd	r21, Y+2	; 0x02
 184:	6b 81       	ldd	r22, Y+3	; 0x03
 186:	7c 81       	ldd	r23, Y+4	; 0x04
 188:	ce 01       	movw	r24, r28
 18a:	46 96       	adiw	r24, 0x16	; 22
 18c:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
	memcpy(&dir[1],&direntry,sizeof(DIR_ENTRY));
 190:	d6 01       	movw	r26, r12
 192:	90 96       	adiw	r26, 0x20	; 32
 194:	fe 01       	movw	r30, r28
 196:	76 96       	adiw	r30, 0x16	; 22
 198:	80 e2       	ldi	r24, 0x20	; 32
 19a:	01 90       	ld	r0, Z+
 19c:	0d 92       	st	X+, r0
 19e:	81 50       	subi	r24, 0x01	; 1
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <diskMkdir+0x1a2>

#define memclr(dst,size) memset(dst,0,size)

void _ioReleaseSector(const DISK* disc,const void* buf);
static __inline__ void partition_releaseSector(const DISK* disk, const void *buf){
	_ioReleaseSector(disk,buf);
 1a2:	c7 01       	movw	r24, r14
 1a4:	b6 01       	movw	r22, r12
 1a6:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	partition_releaseSector(disk,dir);


	// Now tell the FAT that the new directory is only one cluster long
	_fatSetNextClusterAddress(disk,nc,_fatGiveEndMarker(disk));
 1aa:	c7 01       	movw	r24, r14
 1ac:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>
 1b0:	8b 01       	movw	r16, r22
 1b2:	9c 01       	movw	r18, r24
 1b4:	c7 01       	movw	r24, r14
 1b6:	b5 01       	movw	r22, r10
 1b8:	a4 01       	movw	r20, r8
 1ba:	0e 94 00 00 	call	0	; 0x0 <diskMkdir>

	return(0);
 1be:	80 e0       	ldi	r24, 0x00	; 0
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <diskMkdir+0x1c2>
		return(-1);
	}

	if(parentdir==0){
		// Cannot create a new root
		return(-1);
 1c2:	8f ef       	ldi	r24, 0xFF	; 255
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <diskMkdir+0x1c6>
	}

	if(!_dirFindFreeFile(disk,dirname,&loc)){
		// No directory space
		return(-2);
 1c6:	8e ef       	ldi	r24, 0xFE	; 254
 1c8:	00 c0       	rjmp	.+0      	; 0x1ca <diskMkdir+0x1ca>
	}

	CLUSTER nc = _fatGetFreeCluster(disk);
	if(nc==0){
		// No space to create the new directory area
		return(-3);
 1ca:	8d ef       	ldi	r24, 0xFD	; 253

	// Now tell the FAT that the new directory is only one cluster long
	_fatSetNextClusterAddress(disk,nc,_fatGiveEndMarker(disk));

	return(0);
}
 1cc:	e5 96       	adiw	r28, 0x35	; 53
 1ce:	0f b6       	in	r0, 0x3f	; 63
 1d0:	f8 94       	cli
 1d2:	de bf       	out	0x3e, r29	; 62
 1d4:	0f be       	out	0x3f, r0	; 63
 1d6:	cd bf       	out	0x3d, r28	; 61
 1d8:	df 91       	pop	r29
 1da:	cf 91       	pop	r28
 1dc:	1f 91       	pop	r17
 1de:	0f 91       	pop	r16
 1e0:	ff 90       	pop	r15
 1e2:	ef 90       	pop	r14
 1e4:	df 90       	pop	r13
 1e6:	cf 90       	pop	r12
 1e8:	bf 90       	pop	r11
 1ea:	af 90       	pop	r10
 1ec:	9f 90       	pop	r9
 1ee:	8f 90       	pop	r8
 1f0:	08 95       	ret

i2cEEPROM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000310  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000344  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000344  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  00000344  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000849  00000000  00000000  0000034a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001ef  00000000  00000000  00000b93  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000008f6  00000000  00000000  00000d82  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001678  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000178  00000000  00000000  00001698  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000328  00000000  00000000  00001810  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000198  00000000  00000000  00001b38  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
	EEPROM_ADDR addr = absSector * 512;
	i2cEEPROM_writeBytes(eeprom,addr,dta,512);
	return TRUE;
}

static uint32_t disk_total_sectors(void* device){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

// Write a sequence of bytes
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes);

static __inline__ EEPROM_ADDR i2cEEPROM_totalBytes(const I2C_EEPROM* eeprom){
	return eeprom->totalBytes;
   4:	fc 01       	movw	r30, r24
   6:	06 81       	ldd	r16, Z+6	; 0x06
   8:	17 81       	ldd	r17, Z+7	; 0x07
   a:	20 85       	ldd	r18, Z+8	; 0x08
   c:	31 85       	ldd	r19, Z+9	; 0x09
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	uint32_t sectors = i2cEEPROM_totalBytes(eeprom);
	sectors /= 512;
   e:	49 e0       	ldi	r20, 0x09	; 9
  10:	36 95       	lsr	r19
  12:	27 95       	ror	r18
  14:	17 95       	ror	r17
  16:	07 95       	ror	r16
  18:	4a 95       	dec	r20
  1a:	01 f4       	brne	.+0      	; 0x1c <disk_total_sectors+0x1c>
	return sectors;
}
  1c:	b8 01       	movw	r22, r16
  1e:	c9 01       	movw	r24, r18
  20:	1f 91       	pop	r17
  22:	0f 91       	pop	r16
  24:	08 95       	ret

00000026 <i2cEEPROM_readBytes>:

	return rtn;
}

// Read a sequence of byte
void i2cEEPROM_readBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
  26:	4f 92       	push	r4
  28:	5f 92       	push	r5
  2a:	6f 92       	push	r6
  2c:	7f 92       	push	r7
  2e:	8f 92       	push	r8
  30:	9f 92       	push	r9
  32:	af 92       	push	r10
  34:	bf 92       	push	r11
  36:	cf 92       	push	r12
  38:	df 92       	push	r13
  3a:	ef 92       	push	r14
  3c:	ff 92       	push	r15
  3e:	0f 93       	push	r16
  40:	1f 93       	push	r17
  42:	cf 93       	push	r28
  44:	df 93       	push	r29
  46:	cd b7       	in	r28, 0x3d	; 61
  48:	de b7       	in	r29, 0x3e	; 62
  4a:	27 97       	sbiw	r28, 0x07	; 7
  4c:	0f b6       	in	r0, 0x3f	; 63
  4e:	f8 94       	cli
  50:	de bf       	out	0x3e, r29	; 62
  52:	0f be       	out	0x3f, r0	; 63
  54:	cd bf       	out	0x3d, r28	; 61
  56:	6c 01       	movw	r12, r24
  58:	79 01       	movw	r14, r18
  5a:	38 01       	movw	r6, r16
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
  5c:	fc 01       	movw	r30, r24
  5e:	06 81       	ldd	r16, Z+6	; 0x06
  60:	17 81       	ldd	r17, Z+7	; 0x07
  62:	20 85       	ldd	r18, Z+8	; 0x08
  64:	31 85       	ldd	r19, Z+9	; 0x09
  66:	cb 01       	movw	r24, r22
  68:	ba 01       	movw	r22, r20
  6a:	a9 01       	movw	r20, r18
  6c:	98 01       	movw	r18, r16
  6e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  72:	4b 01       	movw	r8, r22
  74:	5c 01       	movw	r10, r24
	uint8_t* pos = dest;
  76:	27 01       	movw	r4, r14
	uint8_t  buf[4];


	while(numBytes){
  78:	00 c0       	rjmp	.+0      	; 0x7a <i2cEEPROM_readBytes+0x54>
		size_t offset = src % eeprom->pageSize;			/* Offset into the page						*/
  7a:	f6 01       	movw	r30, r12
  7c:	e4 80       	ldd	r14, Z+4	; 0x04
  7e:	f5 80       	ldd	r15, Z+5	; 0x05
  80:	97 01       	movw	r18, r14
  82:	40 e0       	ldi	r20, 0x00	; 0
  84:	50 e0       	ldi	r21, 0x00	; 0
  86:	c5 01       	movw	r24, r10
  88:	b4 01       	movw	r22, r8
  8a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  8e:	dc 01       	movw	r26, r24
  90:	cb 01       	movw	r24, r22
		size_t bytesToRead = eeprom->pageSize - offset;	/* The number of bytes left in page 	  	*/
  92:	e8 1a       	sub	r14, r24
  94:	f9 0a       	sbc	r15, r25
  96:	6e 14       	cp	r6, r14
  98:	7f 04       	cpc	r7, r15
  9a:	00 f4       	brcc	.+0      	; 0x9c <i2cEEPROM_readBytes+0x76>
  9c:	73 01       	movw	r14, r6
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
}


static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;
  9e:	f6 01       	movw	r30, r12
  a0:	62 81       	ldd	r22, Z+2	; 0x02

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  a2:	53 81       	ldd	r21, Z+3	; 0x03
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
  a4:	25 2f       	mov	r18, r21
  a6:	30 e0       	ldi	r19, 0x00	; 0

static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
  a8:	d5 01       	movw	r26, r10
  aa:	c4 01       	movw	r24, r8
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  ac:	41 e0       	ldi	r20, 0x01	; 1
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <i2cEEPROM_readBytes+0x8a>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
  b0:	f9 01       	movw	r30, r18
  b2:	e4 1b       	sub	r30, r20
  b4:	f1 09       	sbc	r31, r1
  b6:	04 e0       	ldi	r16, 0x04	; 4
  b8:	10 e0       	ldi	r17, 0x00	; 0
  ba:	0c 0f       	add	r16, r28
  bc:	1d 1f       	adc	r17, r29
  be:	e0 0f       	add	r30, r16
  c0:	f1 1f       	adc	r31, r17
  c2:	80 83       	st	Z, r24
		hiBits >>= 8;
  c4:	89 2f       	mov	r24, r25
  c6:	9a 2f       	mov	r25, r26
  c8:	ab 2f       	mov	r26, r27
  ca:	bb 27       	eor	r27, r27
static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
  cc:	4f 5f       	subi	r20, 0xFF	; 255
  ce:	54 17       	cp	r21, r20
  d0:	00 f4       	brcc	.+0      	; 0xd2 <i2cEEPROM_readBytes+0xac>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
		hiBits >>= 8;
	}
	uint8_t mask = hiBits & 0xff;
	rtn |= (mask<<1);
  d2:	88 0f       	add	r24, r24
  d4:	86 2b       	or	r24, r22
		size_t bytesToRead = eeprom->pageSize - offset;	/* The number of bytes left in page 	  	*/
		if(bytesToRead > numBytes){
			bytesToRead = numBytes;						/* The number of bytes to read from page  	*/
		}
		// Create dummy i2c device
		I2C_DEVICE i2c = MAKE_I2C_DEVICE(address(eeprom,src,buf));
  d6:	8e 7f       	andi	r24, 0xFE	; 254
  d8:	8b 83       	std	Y+3, r24	; 0x03
		i2c.bus = eeprom->i2cInfo.bus;
  da:	f6 01       	movw	r30, r12
  dc:	80 81       	ld	r24, Z
  de:	91 81       	ldd	r25, Z+1	; 0x01
  e0:	9a 83       	std	Y+2, r25	; 0x02
  e2:	89 83       	std	Y+1, r24	; 0x01

		// Keep sending the data as it may fail if eeprom is busy writing
		// Write the 'address' then reads the data
		while(!i2cMasterTransfer(&i2c, eeprom->addrBytes, buf, bytesToRead, pos));
  e4:	f6 01       	movw	r30, r12
  e6:	63 81       	ldd	r22, Z+3	; 0x03
  e8:	ce 01       	movw	r24, r28
  ea:	01 96       	adiw	r24, 0x01	; 1
  ec:	70 e0       	ldi	r23, 0x00	; 0
  ee:	ae 01       	movw	r20, r28
  f0:	4c 5f       	subi	r20, 0xFC	; 252
  f2:	5f 4f       	sbci	r21, 0xFF	; 255
  f4:	97 01       	movw	r18, r14
  f6:	82 01       	movw	r16, r4
  f8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  fc:	88 23       	and	r24, r24
  fe:	01 f0       	breq	.+0      	; 0x100 <i2cEEPROM_readBytes+0xda>

		src += bytesToRead;
 100:	c7 01       	movw	r24, r14
 102:	a0 e0       	ldi	r26, 0x00	; 0
 104:	b0 e0       	ldi	r27, 0x00	; 0
 106:	88 0e       	add	r8, r24
 108:	99 1e       	adc	r9, r25
 10a:	aa 1e       	adc	r10, r26
 10c:	bb 1e       	adc	r11, r27
		pos += bytesToRead;
 10e:	4e 0c       	add	r4, r14
 110:	5f 1c       	adc	r5, r15
		numBytes -= bytesToRead;
 112:	6e 18       	sub	r6, r14
 114:	7f 08       	sbc	r7, r15
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;
	uint8_t  buf[4];


	while(numBytes){
 116:	61 14       	cp	r6, r1
 118:	71 04       	cpc	r7, r1
 11a:	01 f0       	breq	.+0      	; 0x11c <i2cEEPROM_readBytes+0xf6>
 11c:	00 c0       	rjmp	.+0      	; 0x11e <i2cEEPROM_readBytes+0xf8>

		src += bytesToRead;
		pos += bytesToRead;
		numBytes -= bytesToRead;
	}
}
 11e:	27 96       	adiw	r28, 0x07	; 7
 120:	0f b6       	in	r0, 0x3f	; 63
 122:	f8 94       	cli
 124:	de bf       	out	0x3e, r29	; 62
 126:	0f be       	out	0x3f, r0	; 63
 128:	cd bf       	out	0x3d, r28	; 61
 12a:	df 91       	pop	r29
 12c:	cf 91       	pop	r28
 12e:	1f 91       	pop	r17
 130:	0f 91       	pop	r16
 132:	ff 90       	pop	r15
 134:	ef 90       	pop	r14
 136:	df 90       	pop	r13
 138:	cf 90       	pop	r12
 13a:	bf 90       	pop	r11
 13c:	af 90       	pop	r10
 13e:	9f 90       	pop	r9
 140:	8f 90       	pop	r8
 142:	7f 90       	pop	r7
 144:	6f 90       	pop	r6
 146:	5f 90       	pop	r5
 148:	4f 90       	pop	r4
 14a:	08 95       	ret

0000014c <disk_read>:
		pos += bytesToWrite;
		numBytes -= bytesToWrite;
	}
}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 14c:	0f 93       	push	r16
 14e:	1f 93       	push	r17
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 150:	e9 e0       	ldi	r30, 0x09	; 9
 152:	44 0f       	add	r20, r20
 154:	55 1f       	adc	r21, r21
 156:	66 1f       	adc	r22, r22
 158:	77 1f       	adc	r23, r23
 15a:	ea 95       	dec	r30
 15c:	01 f4       	brne	.+0      	; 0x15e <disk_read+0x12>
	i2cEEPROM_readBytes(eeprom,addr,dta,512);
 15e:	00 e0       	ldi	r16, 0x00	; 0
 160:	12 e0       	ldi	r17, 0x02	; 2
 162:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 166:	8f ef       	ldi	r24, 0xFF	; 255
 168:	1f 91       	pop	r17
 16a:	0f 91       	pop	r16
 16c:	08 95       	ret

0000016e <i2cEEPROM_readByte>:

#include "i2cEEPROM.h"



uint8_t i2cEEPROM_readByte(I2C_EEPROM* eeprom, EEPROM_ADDR addr){
 16e:	0f 93       	push	r16
 170:	1f 93       	push	r17
 172:	cf 93       	push	r28
 174:	df 93       	push	r29
 176:	0f 92       	push	r0
 178:	cd b7       	in	r28, 0x3d	; 61
 17a:	de b7       	in	r29, 0x3e	; 62
	uint8_t rtn;
	i2cEEPROM_readBytes(eeprom, addr, &rtn, 1);
 17c:	9e 01       	movw	r18, r28
 17e:	2f 5f       	subi	r18, 0xFF	; 255
 180:	3f 4f       	sbci	r19, 0xFF	; 255
 182:	01 e0       	ldi	r16, 0x01	; 1
 184:	10 e0       	ldi	r17, 0x00	; 0
 186:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return rtn;
}
 18a:	89 81       	ldd	r24, Y+1	; 0x01
 18c:	0f 90       	pop	r0
 18e:	df 91       	pop	r29
 190:	cf 91       	pop	r28
 192:	1f 91       	pop	r17
 194:	0f 91       	pop	r16
 196:	08 95       	ret

00000198 <i2cEEPROM_writeBytes>:
		numBytes -= bytesToRead;
	}
}

// Write a sequence of bytes
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 198:	4f 92       	push	r4
 19a:	5f 92       	push	r5
 19c:	6f 92       	push	r6
 19e:	7f 92       	push	r7
 1a0:	8f 92       	push	r8
 1a2:	9f 92       	push	r9
 1a4:	af 92       	push	r10
 1a6:	bf 92       	push	r11
 1a8:	cf 92       	push	r12
 1aa:	df 92       	push	r13
 1ac:	ef 92       	push	r14
 1ae:	ff 92       	push	r15
 1b0:	0f 93       	push	r16
 1b2:	1f 93       	push	r17
 1b4:	cf 93       	push	r28
 1b6:	df 93       	push	r29
 1b8:	cd b7       	in	r28, 0x3d	; 61
 1ba:	de b7       	in	r29, 0x3e	; 62
 1bc:	27 97       	sbiw	r28, 0x07	; 7
 1be:	0f b6       	in	r0, 0x3f	; 63
 1c0:	f8 94       	cli
 1c2:	de bf       	out	0x3e, r29	; 62
 1c4:	0f be       	out	0x3f, r0	; 63
 1c6:	cd bf       	out	0x3d, r28	; 61
 1c8:	6c 01       	movw	r12, r24
 1ca:	79 01       	movw	r14, r18
 1cc:	38 01       	movw	r6, r16
	EEPROM_ADDR dst = addr % eeprom->totalBytes;	/* Put address in range				*/
 1ce:	fc 01       	movw	r30, r24
 1d0:	06 81       	ldd	r16, Z+6	; 0x06
 1d2:	17 81       	ldd	r17, Z+7	; 0x07
 1d4:	20 85       	ldd	r18, Z+8	; 0x08
 1d6:	31 85       	ldd	r19, Z+9	; 0x09
 1d8:	cb 01       	movw	r24, r22
 1da:	ba 01       	movw	r22, r20
 1dc:	a9 01       	movw	r20, r18
 1de:	98 01       	movw	r18, r16
 1e0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 1e4:	4b 01       	movw	r8, r22
 1e6:	5c 01       	movw	r10, r24
	const uint8_t* pos = src;
 1e8:	27 01       	movw	r4, r14
	uint8_t  buf[4];

	while(numBytes){
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <i2cEEPROM_writeBytes+0x54>
		size_t offset = dst % eeprom->pageSize;			/* Offset into the page						*/
 1ec:	f6 01       	movw	r30, r12
 1ee:	e4 80       	ldd	r14, Z+4	; 0x04
 1f0:	f5 80       	ldd	r15, Z+5	; 0x05
 1f2:	97 01       	movw	r18, r14
 1f4:	40 e0       	ldi	r20, 0x00	; 0
 1f6:	50 e0       	ldi	r21, 0x00	; 0
 1f8:	c5 01       	movw	r24, r10
 1fa:	b4 01       	movw	r22, r8
 1fc:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 200:	dc 01       	movw	r26, r24
 202:	cb 01       	movw	r24, r22
		size_t bytesToWrite = eeprom->pageSize - offset;/* The number of bytes left in page 	  	*/
 204:	e8 1a       	sub	r14, r24
 206:	f9 0a       	sbc	r15, r25
 208:	6e 14       	cp	r6, r14
 20a:	7f 04       	cpc	r7, r15
 20c:	00 f4       	brcc	.+0      	; 0x20e <i2cEEPROM_writeBytes+0x76>
 20e:	73 01       	movw	r14, r6
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
}


static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;
 210:	f6 01       	movw	r30, r12
 212:	62 81       	ldd	r22, Z+2	; 0x02

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 214:	53 81       	ldd	r21, Z+3	; 0x03
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
 216:	25 2f       	mov	r18, r21
 218:	30 e0       	ldi	r19, 0x00	; 0

static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
 21a:	d5 01       	movw	r26, r10
 21c:	c4 01       	movw	r24, r8
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 21e:	41 e0       	ldi	r20, 0x01	; 1
 220:	00 c0       	rjmp	.+0      	; 0x222 <i2cEEPROM_writeBytes+0x8a>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
 222:	f9 01       	movw	r30, r18
 224:	e4 1b       	sub	r30, r20
 226:	f1 09       	sbc	r31, r1
 228:	04 e0       	ldi	r16, 0x04	; 4
 22a:	10 e0       	ldi	r17, 0x00	; 0
 22c:	0c 0f       	add	r16, r28
 22e:	1d 1f       	adc	r17, r29
 230:	e0 0f       	add	r30, r16
 232:	f1 1f       	adc	r31, r17
 234:	80 83       	st	Z, r24
		hiBits >>= 8;
 236:	89 2f       	mov	r24, r25
 238:	9a 2f       	mov	r25, r26
 23a:	ab 2f       	mov	r26, r27
 23c:	bb 27       	eor	r27, r27
static uint8_t address(I2C_EEPROM* eeprom,EEPROM_ADDR addr, uint8_t* buf){
	uint8_t rtn = eeprom->i2cInfo.addr;

	// Find any left over bits to merge into the I2C address
	EEPROM_ADDR hiBits = addr;
	for(uint8_t n = 1; n <= eeprom->addrBytes; n++){
 23e:	4f 5f       	subi	r20, 0xFF	; 255
 240:	54 17       	cp	r21, r20
 242:	00 f4       	brcc	.+0      	; 0x244 <i2cEEPROM_writeBytes+0xac>
		buf[eeprom->addrBytes -n] = hiBits & 0xff;
		hiBits >>= 8;
	}
	uint8_t mask = hiBits & 0xff;
	rtn |= (mask<<1);
 244:	88 0f       	add	r24, r24
 246:	86 2b       	or	r24, r22
		if(bytesToWrite > numBytes){
			bytesToWrite = numBytes;					/* The number of bytes to write to the page	*/
		}

		// Create dummy i2c device
		I2C_DEVICE i2c = MAKE_I2C_DEVICE(address(eeprom,dst,buf));
 248:	8e 7f       	andi	r24, 0xFE	; 254
 24a:	8b 83       	std	Y+3, r24	; 0x03
		i2c.bus = eeprom->i2cInfo.bus;
 24c:	f6 01       	movw	r30, r12
 24e:	80 81       	ld	r24, Z
 250:	91 81       	ldd	r25, Z+1	; 0x01
 252:	9a 83       	std	Y+2, r25	; 0x02
 254:	89 83       	std	Y+1, r24	; 0x01

		// Keep sending the data as it may fail if eeprom is busy writing
		// Writes the 'address' and then writes the data
		while(!i2cMasterSendWithPrefix(&i2c, eeprom->addrBytes, buf, bytesToWrite, pos));
 256:	f6 01       	movw	r30, r12
 258:	63 81       	ldd	r22, Z+3	; 0x03
 25a:	ce 01       	movw	r24, r28
 25c:	01 96       	adiw	r24, 0x01	; 1
 25e:	70 e0       	ldi	r23, 0x00	; 0
 260:	ae 01       	movw	r20, r28
 262:	4c 5f       	subi	r20, 0xFC	; 252
 264:	5f 4f       	sbci	r21, 0xFF	; 255
 266:	97 01       	movw	r18, r14
 268:	82 01       	movw	r16, r4
 26a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 26e:	88 23       	and	r24, r24
 270:	01 f0       	breq	.+0      	; 0x272 <i2cEEPROM_writeBytes+0xda>

		dst += bytesToWrite;
 272:	c7 01       	movw	r24, r14
 274:	a0 e0       	ldi	r26, 0x00	; 0
 276:	b0 e0       	ldi	r27, 0x00	; 0
 278:	88 0e       	add	r8, r24
 27a:	99 1e       	adc	r9, r25
 27c:	aa 1e       	adc	r10, r26
 27e:	bb 1e       	adc	r11, r27
		pos += bytesToWrite;
 280:	4e 0c       	add	r4, r14
 282:	5f 1c       	adc	r5, r15
		numBytes -= bytesToWrite;
 284:	6e 18       	sub	r6, r14
 286:	7f 08       	sbc	r7, r15
void i2cEEPROM_writeBytes(I2C_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;	/* Put address in range				*/
	const uint8_t* pos = src;
	uint8_t  buf[4];

	while(numBytes){
 288:	61 14       	cp	r6, r1
 28a:	71 04       	cpc	r7, r1
 28c:	01 f0       	breq	.+0      	; 0x28e <i2cEEPROM_writeBytes+0xf6>
 28e:	00 c0       	rjmp	.+0      	; 0x290 <i2cEEPROM_writeBytes+0xf8>

		dst += bytesToWrite;
		pos += bytesToWrite;
		numBytes -= bytesToWrite;
	}
}
 290:	27 96       	adiw	r28, 0x07	; 7
 292:	0f b6       	in	r0, 0x3f	; 63
 294:	f8 94       	cli
 296:	de bf       	out	0x3e, r29	; 62
 298:	0f be       	out	0x3f, r0	; 63
 29a:	cd bf       	out	0x3d, r28	; 61
 29c:	df 91       	pop	r29
 29e:	cf 91       	pop	r28
 2a0:	1f 91       	pop	r17
 2a2:	0f 91       	pop	r16
 2a4:	ff 90       	pop	r15
 2a6:	ef 90       	pop	r14
 2a8:	df 90       	pop	r13
 2aa:	cf 90       	pop	r12
 2ac:	bf 90       	pop	r11
 2ae:	af 90       	pop	r10
 2b0:	9f 90       	pop	r9
 2b2:	8f 90       	pop	r8
 2b4:	7f 90       	pop	r7
 2b6:	6f 90       	pop	r6
 2b8:	5f 90       	pop	r5
 2ba:	4f 90       	pop	r4
 2bc:	08 95       	ret

000002be <disk_write>:
	EEPROM_ADDR addr = absSector * 512;
	i2cEEPROM_readBytes(eeprom,addr,dta,512);
	return TRUE;
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 2be:	0f 93       	push	r16
 2c0:	1f 93       	push	r17
	I2C_EEPROM* eeprom = (I2C_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 2c2:	e9 e0       	ldi	r30, 0x09	; 9
 2c4:	44 0f       	add	r20, r20
 2c6:	55 1f       	adc	r21, r21
 2c8:	66 1f       	adc	r22, r22
 2ca:	77 1f       	adc	r23, r23
 2cc:	ea 95       	dec	r30
 2ce:	01 f4       	brne	.+0      	; 0x2d0 <disk_write+0x12>
	i2cEEPROM_writeBytes(eeprom,addr,dta,512);
 2d0:	00 e0       	ldi	r16, 0x00	; 0
 2d2:	12 e0       	ldi	r17, 0x02	; 2
 2d4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 2d8:	8f ef       	ldi	r24, 0xFF	; 255
 2da:	1f 91       	pop	r17
 2dc:	0f 91       	pop	r16
 2de:	08 95       	ret

000002e0 <i2cEEPROM_writeByte>:
	i2cEEPROM_readBytes(eeprom, addr, &rtn, 1);
	return rtn;
}

// Write a byte to the eeprom
void i2cEEPROM_writeByte(I2C_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
 2e0:	0f 93       	push	r16
 2e2:	1f 93       	push	r17
 2e4:	cf 93       	push	r28
 2e6:	df 93       	push	r29
 2e8:	0f 92       	push	r0
 2ea:	cd b7       	in	r28, 0x3d	; 61
 2ec:	de b7       	in	r29, 0x3e	; 62
 2ee:	29 83       	std	Y+1, r18	; 0x01
	i2cEEPROM_writeBytes(eeprom, addr, &data, 1);
 2f0:	9e 01       	movw	r18, r28
 2f2:	2f 5f       	subi	r18, 0xFF	; 255
 2f4:	3f 4f       	sbci	r19, 0xFF	; 255
 2f6:	01 e0       	ldi	r16, 0x01	; 1
 2f8:	10 e0       	ldi	r17, 0x00	; 0
 2fa:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 2fe:	0f 90       	pop	r0
 300:	df 91       	pop	r29
 302:	cf 91       	pop	r28
 304:	1f 91       	pop	r17
 306:	0f 91       	pop	r16
 308:	08 95       	ret

0000030a <i2cEEPROMGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* i2cEEPROMGetStorageClass(void){
	return &c_i2ceeprom_disk;
}
 30a:	80 e0       	ldi	r24, 0x00	; 0
 30c:	90 e0       	ldi	r25, 0x00	; 0
 30e:	08 95       	ret

sdCard.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000006d0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000704  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000704  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  00000704  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001095  00000000  00000000  0000070a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000003a5  00000000  00000000  0000179f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000e92  00000000  00000000  00001b44  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000029d6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000078  00000000  00000000  000029f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000002b5  00000000  00000000  00002a6e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000060a  00000000  00000000  00002d23  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000234  00000000  00000000  00003330  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
static boolean disk_write(void* device, uint32_t absSector,const void* dta){
	SD_CARD* card = (SD_CARD*)device;
	return sdCardWrite(card, absSector,dta,1);
}

static uint32_t disk_total_sectors(void* device){
   0:	fc 01       	movw	r30, r24
	SD_CARD* card = (SD_CARD*)device;
	return card->numSectors;
   2:	61 85       	ldd	r22, Z+9	; 0x09
   4:	72 85       	ldd	r23, Z+10	; 0x0a
}
   6:	83 85       	ldd	r24, Z+11	; 0x0b
   8:	94 85       	ldd	r25, Z+12	; 0x0c
   a:	08 95       	ret

0000000c <wait_ready>:
	rprintf("<0x");rprintfu08(rtn);
	#endif
	return rtn;
}

static uint8_t wait_ready(SD_CARD* card){
   c:	cf 92       	push	r12
   e:	df 92       	push	r13
  10:	ef 92       	push	r14
  12:	ff 92       	push	r15
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	18 2f       	mov	r17, r24
  1c:	d9 2f       	mov	r29, r25
	uint8_t res;

	TICK_COUNT timer2 = clockGetus();;
  1e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  22:	6b 01       	movw	r12, r22
  24:	7c 01       	movw	r14, r24
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
  26:	81 2f       	mov	r24, r17
  28:	9d 2f       	mov	r25, r29
  2a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  2e:	81 2f       	mov	r24, r17
  30:	9d 2f       	mov	r25, r29
  32:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  36:	c8 2f       	mov	r28, r24

	TICK_COUNT timer2 = clockGetus();;
	receive(card);
	do{
		res = receive(card);			// Timeout after 500ms
	}while ((res != 0xFF) && !clockHasElapsed(timer2, 500000));
  38:	8f 3f       	cpi	r24, 0xFF	; 255
  3a:	01 f0       	breq	.+0      	; 0x3c <wait_ready+0x30>
  3c:	c7 01       	movw	r24, r14
  3e:	b6 01       	movw	r22, r12
  40:	20 e2       	ldi	r18, 0x20	; 32
  42:	31 ea       	ldi	r19, 0xA1	; 161
  44:	47 e0       	ldi	r20, 0x07	; 7
  46:	50 e0       	ldi	r21, 0x00	; 0
  48:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  4c:	88 23       	and	r24, r24
  4e:	01 f0       	breq	.+0      	; 0x50 <wait_ready+0x44>

	return res;
}
  50:	8c 2f       	mov	r24, r28
  52:	df 91       	pop	r29
  54:	cf 91       	pop	r28
  56:	1f 91       	pop	r17
  58:	ff 90       	pop	r15
  5a:	ef 90       	pop	r14
  5c:	df 90       	pop	r13
  5e:	cf 90       	pop	r12
  60:	08 95       	ret

00000062 <deselect>:

static void deselect(SD_CARD* card){
  62:	cf 93       	push	r28
  64:	df 93       	push	r29
  66:	ec 01       	movw	r28, r24
	spiDeviceSelect(card, FALSE);	// deselect the card
  68:	60 e0       	ldi	r22, 0x00	; 0
  6a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
  6e:	ce 01       	movw	r24, r28
  70:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}

static void deselect(SD_CARD* card){
	spiDeviceSelect(card, FALSE);	// deselect the card
	receive(card);
}
  74:	df 91       	pop	r29
  76:	cf 91       	pop	r28
  78:	08 95       	ret

0000007a <send_cmd>:

	return TRUE;
}


static uint8_t send_cmd(SD_CARD *card,uint8_t cmd, uint32_t param){
  7a:	bf 92       	push	r11
  7c:	cf 92       	push	r12
  7e:	df 92       	push	r13
  80:	ef 92       	push	r14
  82:	ff 92       	push	r15
  84:	0f 93       	push	r16
  86:	1f 93       	push	r17
  88:	cf 93       	push	r28
  8a:	df 93       	push	r29
  8c:	00 d0       	rcall	.+0      	; 0x8e <send_cmd+0x14>
  8e:	00 d0       	rcall	.+0      	; 0x90 <send_cmd+0x16>
  90:	00 d0       	rcall	.+0      	; 0x92 <send_cmd+0x18>
  92:	cd b7       	in	r28, 0x3d	; 61
  94:	de b7       	in	r29, 0x3e	; 62
  96:	8c 01       	movw	r16, r24
  98:	f6 2e       	mov	r15, r22
  9a:	b2 2e       	mov	r11, r18
  9c:	c3 2e       	mov	r12, r19
  9e:	d4 2e       	mov	r13, r20
  a0:	e5 2e       	mov	r14, r21
	uint8_t res;

	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
  a2:	67 ff       	sbrs	r22, 7
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <send_cmd+0x2c>
		cmd &= 0x7F;
		res = send_cmd(card,CMD55, 0);
  a6:	67 e7       	ldi	r22, 0x77	; 119
  a8:	20 e0       	ldi	r18, 0x00	; 0
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	40 e0       	ldi	r20, 0x00	; 0
  ae:	50 e0       	ldi	r21, 0x00	; 0
  b0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		if (res > 1)
  b4:	82 30       	cpi	r24, 0x02	; 2
  b6:	00 f0       	brcs	.+0      	; 0xb8 <send_cmd+0x3e>
  b8:	00 c0       	rjmp	.+0      	; 0xba <send_cmd+0x40>

static uint8_t send_cmd(SD_CARD *card,uint8_t cmd, uint32_t param){
	uint8_t res;

	if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
		cmd &= 0x7F;
  ba:	8f e7       	ldi	r24, 0x7F	; 127
  bc:	f8 22       	and	r15, r24
	#ifdef DEBUG_SD
	rprintf("\nSend cmd %d:",(cmd & 0x3f));
	#endif

	/* Select the card and wait for ready */
	deselect(card);
  be:	c8 01       	movw	r24, r16
  c0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if(cmd == CMD0){
  c4:	80 e4       	ldi	r24, 0x40	; 64
  c6:	f8 16       	cp	r15, r24
  c8:	01 f4       	brne	.+0      	; 0xca <send_cmd+0x50>
		spiDeviceSelect(card, TRUE);	// select the card - with no reading of status
  ca:	c8 01       	movw	r24, r16
  cc:	6f ef       	ldi	r22, 0xFF	; 255
  ce:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
			return 0xFF;
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
  d2:	85 e9       	ldi	r24, 0x95	; 149
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <send_cmd+0x5c>
	spiDeviceSelect(card, FALSE);	// deselect the card
	receive(card);
}

static boolean select(SD_CARD* card){	/* TRUE:Successful, FALSE:Timeout */
	spiDeviceSelect(card, TRUE);	// select the card
  d6:	c8 01       	movw	r24, r16
  d8:	6f ef       	ldi	r22, 0xFF	; 255
  da:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	if (wait_ready(card) != 0xFF) {
  de:	c8 01       	movw	r24, r16
  e0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  e4:	8f 3f       	cpi	r24, 0xFF	; 255
  e6:	01 f0       	breq	.+0      	; 0xe8 <send_cmd+0x6e>
		deselect(card);
  e8:	c8 01       	movw	r24, r16
  ea:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if(cmd == CMD0){
		spiDeviceSelect(card, TRUE);	// select the card - with no reading of status
	}else{
		if (!select(card))
			return 0xFF;
  ee:	8f ef       	ldi	r24, 0xFF	; 255
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <send_cmd+0x78>
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
  f2:	88 e4       	ldi	r24, 0x48	; 72
  f4:	f8 16       	cp	r15, r24
  f6:	01 f0       	breq	.+0      	; 0xf8 <send_cmd+0x7e>
		if (!select(card))
			return 0xFF;
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	00 c0       	rjmp	.+0      	; 0xfc <send_cmd+0x82>
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
  fc:	87 e8       	ldi	r24, 0x87	; 135

	uint8_t cmdBuf[] = { cmd, (param>>24),(param>>16),(param>>8),(param), n};
  fe:	f9 82       	std	Y+1, r15	; 0x01
 100:	ea 82       	std	Y+2, r14	; 0x02
 102:	db 82       	std	Y+3, r13	; 0x03
 104:	cc 82       	std	Y+4, r12	; 0x04
 106:	bd 82       	std	Y+5, r11	; 0x05
 108:	8e 83       	std	Y+6, r24	; 0x06
	spiDeviceSendBytes(card, cmdBuf, sizeof(cmdBuf));
 10a:	c8 01       	movw	r24, r16
 10c:	be 01       	movw	r22, r28
 10e:	6f 5f       	subi	r22, 0xFF	; 255
 110:	7f 4f       	sbci	r23, 0xFF	; 255
 112:	46 e0       	ldi	r20, 0x06	; 6
 114:	50 e0       	ldi	r21, 0x00	; 0
 116:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	/* Receive command response */
	if (cmd == CMD12)
 11a:	8c e4       	ldi	r24, 0x4C	; 76
 11c:	f8 16       	cp	r15, r24
 11e:	01 f4       	brne	.+0      	; 0x120 <send_cmd+0xa6>
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 120:	c8 01       	movw	r24, r16
 122:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}

	// Calc checksum
	uint8_t n = 1;						/* dummy CRC + stop bit */
	if (cmd == CMD0) n = 0x95;			/* Valid CRC for CMD0(0) */
	if (cmd == CMD8) n = 0x87;			/* Valid CRC for CMD8(0x1AA) */
 126:	8a e0       	ldi	r24, 0x0A	; 10
 128:	f8 2e       	mov	r15, r24
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 12a:	c8 01       	movw	r24, r16
 12c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		receive(card);					/* Skip a stuff byte when stop reading */

	n = 10;								/* Wait for a valid response in timeout of 10 attempts */
	do{
		res = receive(card);
	}while ((res & 0x80) && --n);
 130:	87 ff       	sbrs	r24, 7
 132:	00 c0       	rjmp	.+0      	; 0x134 <send_cmd+0xba>
 134:	fa 94       	dec	r15
 136:	01 f4       	brne	.+0      	; 0x138 <send_cmd+0xbe>

	return res;							/* Return with the response value */

}
 138:	26 96       	adiw	r28, 0x06	; 6
 13a:	0f b6       	in	r0, 0x3f	; 63
 13c:	f8 94       	cli
 13e:	de bf       	out	0x3e, r29	; 62
 140:	0f be       	out	0x3f, r0	; 63
 142:	cd bf       	out	0x3d, r28	; 61
 144:	df 91       	pop	r29
 146:	cf 91       	pop	r28
 148:	1f 91       	pop	r17
 14a:	0f 91       	pop	r16
 14c:	ff 90       	pop	r15
 14e:	ef 90       	pop	r14
 150:	df 90       	pop	r13
 152:	cf 90       	pop	r12
 154:	bf 90       	pop	r11
 156:	08 95       	ret

00000158 <rcvr_datablock>:
		return FALSE;
	}
	return TRUE;
}

static boolean rcvr_datablock(SD_CARD* card, uint8_t *buff, size_t btr ){
 158:	af 92       	push	r10
 15a:	bf 92       	push	r11
 15c:	cf 92       	push	r12
 15e:	df 92       	push	r13
 160:	ef 92       	push	r14
 162:	ff 92       	push	r15
 164:	0f 93       	push	r16
 166:	1f 93       	push	r17
 168:	cf 93       	push	r28
 16a:	df 93       	push	r29
 16c:	d8 2f       	mov	r29, r24
 16e:	c9 2f       	mov	r28, r25
 170:	8b 01       	movw	r16, r22
 172:	5a 01       	movw	r10, r20
	uint8_t token;


	TICK_COUNT Timer1 = clockGetus();
 174:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 178:	6b 01       	movw	r12, r22
 17a:	7c 01       	movw	r14, r24
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 17c:	8d 2f       	mov	r24, r29
 17e:	9c 2f       	mov	r25, r28
 180:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>


	TICK_COUNT Timer1 = clockGetus();
	do {							/* Wait for data packet in timeout of 200ms */
		token = receive(card);
	} while ((token != 0xFE) && !clockHasElapsed(Timer1, 200000));
 184:	8e 3f       	cpi	r24, 0xFE	; 254
 186:	01 f0       	breq	.+0      	; 0x188 <rcvr_datablock+0x30>
 188:	c7 01       	movw	r24, r14
 18a:	b6 01       	movw	r22, r12
 18c:	20 e4       	ldi	r18, 0x40	; 64
 18e:	3d e0       	ldi	r19, 0x0D	; 13
 190:	43 e0       	ldi	r20, 0x03	; 3
 192:	50 e0       	ldi	r21, 0x00	; 0
 194:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 198:	88 23       	and	r24, r24
 19a:	01 f0       	breq	.+0      	; 0x19c <rcvr_datablock+0x44>

	spiDeviceReceiveBytes(card, buff,btr);
 19c:	8d 2f       	mov	r24, r29
 19e:	9c 2f       	mov	r25, r28
 1a0:	b8 01       	movw	r22, r16
 1a2:	a5 01       	movw	r20, r10
 1a4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	spiDeviceReceiveWord(card);		/* Discard CRC */
 1a8:	8d 2f       	mov	r24, r29
 1aa:	9c 2f       	mov	r25, r28
 1ac:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	return TRUE;					/* Return with success */
}
 1b0:	8f ef       	ldi	r24, 0xFF	; 255
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	1f 91       	pop	r17
 1b8:	0f 91       	pop	r16
 1ba:	ff 90       	pop	r15
 1bc:	ef 90       	pop	r14
 1be:	df 90       	pop	r13
 1c0:	cf 90       	pop	r12
 1c2:	bf 90       	pop	r11
 1c4:	af 90       	pop	r10
 1c6:	08 95       	ret

000001c8 <xmit_datablock>:

static boolean xmit_datablock(SD_CARD* card, const uint8_t *buff, uint8_t token){
 1c8:	ff 92       	push	r15
 1ca:	0f 93       	push	r16
 1cc:	1f 93       	push	r17
 1ce:	cf 93       	push	r28
 1d0:	df 93       	push	r29
 1d2:	8c 01       	movw	r16, r24
 1d4:	eb 01       	movw	r28, r22
 1d6:	f4 2e       	mov	r15, r20
	if (wait_ready(card) != 0xFF){
 1d8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 1dc:	8f 3f       	cpi	r24, 0xFF	; 255
 1de:	01 f4       	brne	.+0      	; 0x1e0 <xmit_datablock+0x18>

static void xmit(const SD_CARD* card, uint8_t byte){
	#ifdef DEBUG_SD
	rprintf(">0x");rprintfu08(byte);
	#endif
	spiDeviceSendByte(card,byte);
 1e0:	c8 01       	movw	r24, r16
 1e2:	6f 2d       	mov	r22, r15
 1e4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	if (wait_ready(card) != 0xFF){
		return FALSE;
	}

	xmit(card,token);					/* Xmit data token */
	if (token != 0xFD) {				/* Is data token */
 1e8:	8d ef       	ldi	r24, 0xFD	; 253
 1ea:	f8 16       	cp	r15, r24
 1ec:	01 f0       	breq	.+0      	; 0x1ee <xmit_datablock+0x26>

		spiDeviceSendBytes(card, buff, 512);
 1ee:	c8 01       	movw	r24, r16
 1f0:	be 01       	movw	r22, r28
 1f2:	40 e0       	ldi	r20, 0x00	; 0
 1f4:	52 e0       	ldi	r21, 0x02	; 2
 1f6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		spiDeviceSendWord(card,0xFFFF); /* CRC (Dummy)		*/
 1fa:	c8 01       	movw	r24, r16
 1fc:	6f ef       	ldi	r22, 0xFF	; 255
 1fe:	7f ef       	ldi	r23, 0xFF	; 255
 200:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 204:	c8 01       	movw	r24, r16
 206:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		spiDeviceSendBytes(card, buff, 512);
		spiDeviceSendWord(card,0xFFFF); /* CRC (Dummy)		*/

		uint8_t resp = receive(card);	/* Reveive data response token */
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
 20a:	8f 71       	andi	r24, 0x1F	; 31
 20c:	85 30       	cpi	r24, 0x05	; 5
 20e:	01 f4       	brne	.+0      	; 0x210 <xmit_datablock+0x48>
			return FALSE;
	}

	return TRUE;
 210:	8f ef       	ldi	r24, 0xFF	; 255
 212:	00 c0       	rjmp	.+0      	; 0x214 <xmit_datablock+0x4c>
	return TRUE;					/* Return with success */
}

static boolean xmit_datablock(SD_CARD* card, const uint8_t *buff, uint8_t token){
	if (wait_ready(card) != 0xFF){
		return FALSE;
 214:	80 e0       	ldi	r24, 0x00	; 0
		if ((resp & 0x1F) != 0x05)		/* If not accepted, return with error */
			return FALSE;
	}

	return TRUE;
}
 216:	df 91       	pop	r29
 218:	cf 91       	pop	r28
 21a:	1f 91       	pop	r17
 21c:	0f 91       	pop	r16
 21e:	ff 90       	pop	r15
 220:	08 95       	ret

00000222 <sdCardInit>:
	}
	return rtn;
}


boolean sdCardInit(SD_CARD* card){
 222:	4f 92       	push	r4
 224:	5f 92       	push	r5
 226:	6f 92       	push	r6
 228:	7f 92       	push	r7
 22a:	9f 92       	push	r9
 22c:	af 92       	push	r10
 22e:	bf 92       	push	r11
 230:	cf 92       	push	r12
 232:	df 92       	push	r13
 234:	ef 92       	push	r14
 236:	ff 92       	push	r15
 238:	0f 93       	push	r16
 23a:	1f 93       	push	r17
 23c:	cf 93       	push	r28
 23e:	df 93       	push	r29
 240:	cd b7       	in	r28, 0x3d	; 61
 242:	de b7       	in	r29, 0x3e	; 62
 244:	60 97       	sbiw	r28, 0x10	; 16
 246:	0f b6       	in	r0, 0x3f	; 63
 248:	f8 94       	cli
 24a:	de bf       	out	0x3e, r29	; 62
 24c:	0f be       	out	0x3f, r0	; 63
 24e:	cd bf       	out	0x3d, r28	; 61
 250:	8c 01       	movw	r16, r24
 252:	34 e6       	ldi	r19, 0x64	; 100
 254:	e3 2e       	mov	r14, r19
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 256:	5c 01       	movw	r10, r24
 258:	c5 01       	movw	r24, r10
 25a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 25e:	ea 94       	dec	r14

	#ifdef DEBUG_SD
	rprintf("\nStart: sdCard init\n");
	#endif

	for (n = 100; n; n--)
 260:	01 f4       	brne	.+0      	; 0x262 <sdCardInit+0x40>
		receive(card);							/* dummy clocks */

	// Helps fix re-initing a card thats try to do something
	spiDeviceSelect(card, TRUE);				// select the card
 262:	90 2e       	mov	r9, r16
 264:	c1 2e       	mov	r12, r17
 266:	c8 01       	movw	r24, r16
 268:	6f ef       	ldi	r22, 0xFF	; 255
 26a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 26e:	e1 2c       	mov	r14, r1
 270:	22 e0       	ldi	r18, 0x02	; 2
 272:	f2 2e       	mov	r15, r18
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 274:	c5 01       	movw	r24, r10
 276:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 27a:	08 94       	sec
 27c:	e1 08       	sbc	r14, r1
 27e:	f1 08       	sbc	r15, r1
	for (n = 100; n; n--)
		receive(card);							/* dummy clocks */

	// Helps fix re-initing a card thats try to do something
	spiDeviceSelect(card, TRUE);				// select the card
	for(uint16_t i = 512; i; i--)
 280:	e1 14       	cp	r14, r1
 282:	f1 04       	cpc	r15, r1
 284:	01 f4       	brne	.+0      	; 0x286 <sdCardInit+0x64>
		receive(card);							/* dummy clocks */
	spiDeviceSelect(card, FALSE);				// deselect the card
 286:	89 2d       	mov	r24, r9
 288:	9c 2d       	mov	r25, r12
 28a:	60 e0       	ldi	r22, 0x00	; 0
 28c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 290:	ee 24       	eor	r14, r14
 292:	ea 94       	dec	r14
 294:	fe 2c       	mov	r15, r14
static boolean enterIdleState(SD_CARD* card){
	for(uint16_t n=0; ; n++){
		if(n == MAX_U16){
			return FALSE;					// Timed out
		}
		if(send_cmd(card, CMD0, 0)==1){		// send command 0 - Enter idle state
 296:	c8 01       	movw	r24, r16
 298:	60 e4       	ldi	r22, 0x40	; 64
 29a:	20 e0       	ldi	r18, 0x00	; 0
 29c:	30 e0       	ldi	r19, 0x00	; 0
 29e:	40 e0       	ldi	r20, 0x00	; 0
 2a0:	50 e0       	ldi	r21, 0x00	; 0
 2a2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2a6:	81 30       	cpi	r24, 0x01	; 1
 2a8:	01 f4       	brne	.+0      	; 0x2aa <sdCardInit+0x88>
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <sdCardInit+0x8a>
 2ac:	08 94       	sec
 2ae:	e1 08       	sbc	r14, r1
 2b0:	f1 08       	sbc	r15, r1

}

static boolean enterIdleState(SD_CARD* card){
	for(uint16_t n=0; ; n++){
		if(n == MAX_U16){
 2b2:	e1 14       	cp	r14, r1
 2b4:	f1 04       	cpc	r15, r1
 2b6:	01 f4       	brne	.+0      	; 0x2b8 <sdCardInit+0x96>
 2b8:	00 c0       	rjmp	.+0      	; 0x2ba <sdCardInit+0x98>
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 2ba:	c5 01       	movw	r24, r10
 2bc:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
		uint8_t ocr[4];								// remaining four bytes from R7 response
		#ifdef DEBUG_SD
		rprintf("\n**Version 2'ish**\n");
		#endif
		for (n = 0; n < 4; n++){
			ocr[n] = receive(card);					/* Get trailing return value of R7 resp */
 2c0:	f2 01       	movw	r30, r4
 2c2:	81 93       	st	Z+, r24
 2c4:	2f 01       	movw	r4, r30
 2c6:	9a 94       	dec	r9
	if( (send_cmd(card,CMD8, 0x1AA)) == 1 ) {			/* SDHC */
		uint8_t ocr[4];								// remaining four bytes from R7 response
		#ifdef DEBUG_SD
		rprintf("\n**Version 2'ish**\n");
		#endif
		for (n = 0; n < 4; n++){
 2c8:	01 f4       	brne	.+0      	; 0x2ca <sdCardInit+0xa8>
			ocr[n] = receive(card);					/* Get trailing return value of R7 resp */
		}
		if (ocr[2] == 0x01 && ocr[3] == 0xAA) {				/* The card can work at vdd range of 2.7-3.6V */
 2ca:	8b 81       	ldd	r24, Y+3	; 0x03
 2cc:	81 30       	cpi	r24, 0x01	; 1
 2ce:	01 f0       	breq	.+0      	; 0x2d0 <sdCardInit+0xae>
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <sdCardInit+0xb0>
 2d2:	8c 81       	ldd	r24, Y+4	; 0x04
 2d4:	8a 3a       	cpi	r24, 0xAA	; 170
 2d6:	01 f0       	breq	.+0      	; 0x2d8 <sdCardInit+0xb6>
 2d8:	00 c0       	rjmp	.+0      	; 0x2da <sdCardInit+0xb8>
			#ifdef DEBUG_SD
			rprintf("\nLeave idle state\n");
			#endif
			while(!clockHasElapsed(timer1,1000000) && send_cmd(card, ACMD41, 1UL << 30)){
 2da:	c7 01       	movw	r24, r14
 2dc:	b6 01       	movw	r22, r12
 2de:	20 e4       	ldi	r18, 0x40	; 64
 2e0:	32 e4       	ldi	r19, 0x42	; 66
 2e2:	4f e0       	ldi	r20, 0x0F	; 15
 2e4:	50 e0       	ldi	r21, 0x00	; 0
 2e6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2ea:	88 23       	and	r24, r24
 2ec:	01 f4       	brne	.+0      	; 0x2ee <sdCardInit+0xcc>
 2ee:	c8 01       	movw	r24, r16
 2f0:	69 ee       	ldi	r22, 0xE9	; 233
 2f2:	20 e0       	ldi	r18, 0x00	; 0
 2f4:	30 e0       	ldi	r19, 0x00	; 0
 2f6:	40 e0       	ldi	r20, 0x00	; 0
 2f8:	50 e4       	ldi	r21, 0x40	; 64
 2fa:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 2fe:	88 23       	and	r24, r24
 300:	01 f4       	brne	.+0      	; 0x302 <sdCardInit+0xe0>
			/* Wait for leaving idle state (ACMD41 with HCS bit) */
			}

			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
 302:	c7 01       	movw	r24, r14
 304:	b6 01       	movw	r22, r12
 306:	20 e4       	ldi	r18, 0x40	; 64
 308:	32 e4       	ldi	r19, 0x42	; 66
 30a:	4f e0       	ldi	r20, 0x0F	; 15
 30c:	50 e0       	ldi	r21, 0x00	; 0
 30e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 312:	88 23       	and	r24, r24
 314:	01 f0       	breq	.+0      	; 0x316 <sdCardInit+0xf4>
 316:	00 c0       	rjmp	.+0      	; 0x318 <sdCardInit+0xf6>
 318:	c8 01       	movw	r24, r16
 31a:	6a e7       	ldi	r22, 0x7A	; 122
 31c:	20 e0       	ldi	r18, 0x00	; 0
 31e:	30 e0       	ldi	r19, 0x00	; 0
 320:	40 e0       	ldi	r20, 0x00	; 0
 322:	50 e0       	ldi	r21, 0x00	; 0
 324:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 328:	88 23       	and	r24, r24
 32a:	01 f0       	breq	.+0      	; 0x32c <sdCardInit+0x10a>
 32c:	00 c0       	rjmp	.+0      	; 0x32e <sdCardInit+0x10c>
 32e:	94 e0       	ldi	r25, 0x04	; 4
 330:	e9 2e       	mov	r14, r25
	#endif
	spiDeviceSendByte(card,byte);
}

static uint8_t receive(const SD_CARD* card){
	uint8_t rtn = spiDeviceReceiveByte(card);
 332:	c5 01       	movw	r24, r10
 334:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
				#ifdef DEBUG_SD
				rprintf("\nGet card type\n");
				#endif
				for (n = 0; n < 4; n++){
					ocr[n] = receive(card);
 338:	f3 01       	movw	r30, r6
 33a:	81 93       	st	Z+, r24
 33c:	3f 01       	movw	r6, r30
 33e:	ea 94       	dec	r14

			if(!clockHasElapsed(timer1,1000000) && send_cmd(card, CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
				#ifdef DEBUG_SD
				rprintf("\nGet card type\n");
				#endif
				for (n = 0; n < 4; n++){
 340:	01 f4       	brne	.+0      	; 0x342 <sdCardInit+0x120>
					ocr[n] = receive(card);
				}
				cardType = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
 342:	89 81       	ldd	r24, Y+1	; 0x01
 344:	86 fd       	sbrc	r24, 6
 346:	00 c0       	rjmp	.+0      	; 0x348 <sdCardInit+0x126>
 348:	84 e0       	ldi	r24, 0x04	; 4
 34a:	b8 2e       	mov	r11, r24
 34c:	00 c0       	rjmp	.+0      	; 0x34e <sdCardInit+0x12c>
		}
	} else {							/* SDSC or MMC */
		#ifdef DEBUG_SD
		rprintf("\n**Version 1'ish**\n");
		#endif
		if (send_cmd(card, ACMD41, 0) <= 1) 	{
 34e:	c8 01       	movw	r24, r16
 350:	69 ee       	ldi	r22, 0xE9	; 233
 352:	20 e0       	ldi	r18, 0x00	; 0
 354:	30 e0       	ldi	r19, 0x00	; 0
 356:	40 e0       	ldi	r20, 0x00	; 0
 358:	50 e0       	ldi	r21, 0x00	; 0
 35a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 35e:	82 30       	cpi	r24, 0x02	; 2
 360:	00 f4       	brcc	.+0      	; 0x362 <sdCardInit+0x140>
			cardType = CT_SD1;
 362:	a2 e0       	ldi	r26, 0x02	; 2
 364:	ba 2e       	mov	r11, r26
			cmd = ACMD41;				/* SDv1 */
 366:	b9 ee       	ldi	r27, 0xE9	; 233
 368:	ab 2e       	mov	r10, r27
 36a:	00 c0       	rjmp	.+0      	; 0x36c <sdCardInit+0x14a>
		} else {
			cardType = CT_MMC;
 36c:	bb 24       	eor	r11, r11
 36e:	b3 94       	inc	r11
			cmd = CMD1;					/* MMCv3 */
 370:	f1 e4       	ldi	r31, 0x41	; 65
 372:	af 2e       	mov	r10, r31
		}
		#ifdef DEBUG_SD
		rprintf("\nCard type:%u\n",cardType);
		rprintf("\nLeaving idle state\n");
		#endif
		while(!clockHasElapsed(timer1,1000000) && send_cmd(card, cmd, 0)){	/* Wait for leaving idle state */
 374:	c7 01       	movw	r24, r14
 376:	b6 01       	movw	r22, r12
 378:	20 e4       	ldi	r18, 0x40	; 64
 37a:	32 e4       	ldi	r19, 0x42	; 66
 37c:	4f e0       	ldi	r20, 0x0F	; 15
 37e:	50 e0       	ldi	r21, 0x00	; 0
 380:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 384:	88 23       	and	r24, r24
 386:	01 f4       	brne	.+0      	; 0x388 <sdCardInit+0x166>
 388:	c8 01       	movw	r24, r16
 38a:	6a 2d       	mov	r22, r10
 38c:	20 e0       	ldi	r18, 0x00	; 0
 38e:	30 e0       	ldi	r19, 0x00	; 0
 390:	40 e0       	ldi	r20, 0x00	; 0
 392:	50 e0       	ldi	r21, 0x00	; 0
 394:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 398:	88 23       	and	r24, r24
 39a:	01 f4       	brne	.+0      	; 0x39c <sdCardInit+0x17a>
		}

		if (clockHasElapsed(timer1,1000000) || send_cmd( card, CMD16, 512) != 0){	/* Set R/W block length to 512 */
 39c:	c7 01       	movw	r24, r14
 39e:	b6 01       	movw	r22, r12
 3a0:	20 e4       	ldi	r18, 0x40	; 64
 3a2:	32 e4       	ldi	r19, 0x42	; 66
 3a4:	4f e0       	ldi	r20, 0x0F	; 15
 3a6:	50 e0       	ldi	r21, 0x00	; 0
 3a8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3ac:	88 23       	and	r24, r24
 3ae:	01 f0       	breq	.+0      	; 0x3b0 <sdCardInit+0x18e>
 3b0:	00 c0       	rjmp	.+0      	; 0x3b2 <sdCardInit+0x190>
 3b2:	c8 01       	movw	r24, r16
 3b4:	60 e5       	ldi	r22, 0x50	; 80
 3b6:	20 e0       	ldi	r18, 0x00	; 0
 3b8:	32 e0       	ldi	r19, 0x02	; 2
 3ba:	40 e0       	ldi	r20, 0x00	; 0
 3bc:	50 e0       	ldi	r21, 0x00	; 0
 3be:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3c2:	88 23       	and	r24, r24
 3c4:	01 f4       	brne	.+0      	; 0x3c6 <sdCardInit+0x1a4>
 3c6:	00 c0       	rjmp	.+0      	; 0x3c8 <sdCardInit+0x1a6>
 3c8:	00 c0       	rjmp	.+0      	; 0x3ca <sdCardInit+0x1a8>
static uint32_t getTotalDiskSectors(SD_CARD* card){
	uint32_t rtn = 0;
	uint8_t csd[16];
	uint16_t csize;

	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
 3ca:	c8 01       	movw	r24, r16
 3cc:	be 01       	movw	r22, r28
 3ce:	6f 5f       	subi	r22, 0xFF	; 255
 3d0:	7f 4f       	sbci	r23, 0xFF	; 255
 3d2:	40 e1       	ldi	r20, 0x10	; 16
 3d4:	50 e0       	ldi	r21, 0x00	; 0
 3d6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 3da:	88 23       	and	r24, r24
 3dc:	01 f4       	brne	.+0      	; 0x3de <sdCardInit+0x1bc>
 3de:	00 c0       	rjmp	.+0      	; 0x3e0 <sdCardInit+0x1be>
		if ((csd[0] >> 6) == 1) {						/* SDC ver 2.00 */
 3e0:	89 81       	ldd	r24, Y+1	; 0x01
 3e2:	82 95       	swap	r24
 3e4:	86 95       	lsr	r24
 3e6:	86 95       	lsr	r24
 3e8:	83 70       	andi	r24, 0x03	; 3
 3ea:	29 85       	ldd	r18, Y+9	; 0x09
 3ec:	81 30       	cpi	r24, 0x01	; 1
 3ee:	01 f4       	brne	.+0      	; 0x3f0 <sdCardInit+0x1ce>
			csize = csd[9] + ((uint16_t)csd[8] << 8) + 1;
 3f0:	4a 85       	ldd	r20, Y+10	; 0x0a
 3f2:	50 e0       	ldi	r21, 0x00	; 0
 3f4:	4f 5f       	subi	r20, 0xFF	; 255
 3f6:	5f 4f       	sbci	r21, 0xFF	; 255
 3f8:	92 2f       	mov	r25, r18
 3fa:	80 e0       	ldi	r24, 0x00	; 0
 3fc:	48 0f       	add	r20, r24
 3fe:	59 1f       	adc	r21, r25
			rtn = (uint32_t)csize << 10;
 400:	60 e0       	ldi	r22, 0x00	; 0
 402:	70 e0       	ldi	r23, 0x00	; 0
 404:	ea e0       	ldi	r30, 0x0A	; 10
 406:	44 0f       	add	r20, r20
 408:	55 1f       	adc	r21, r21
 40a:	66 1f       	adc	r22, r22
 40c:	77 1f       	adc	r23, r23
 40e:	ea 95       	dec	r30
 410:	01 f4       	brne	.+0      	; 0x412 <sdCardInit+0x1f0>
 412:	00 c0       	rjmp	.+0      	; 0x414 <sdCardInit+0x1f2>
		} else {										/* SDC ver 1.XX or MMC*/
			uint8_t n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
			csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1;
 414:	22 95       	swap	r18
 416:	26 95       	lsr	r18
 418:	26 95       	lsr	r18
 41a:	23 70       	andi	r18, 0x03	; 3
 41c:	48 85       	ldd	r20, Y+8	; 0x08
 41e:	50 e0       	ldi	r21, 0x00	; 0
 420:	44 0f       	add	r20, r20
 422:	55 1f       	adc	r21, r21
 424:	44 0f       	add	r20, r20
 426:	55 1f       	adc	r21, r21
 428:	42 0f       	add	r20, r18
 42a:	51 1d       	adc	r21, r1
 42c:	4f 5f       	subi	r20, 0xFF	; 255
 42e:	5f 4f       	sbci	r21, 0xFF	; 255
 430:	8f 81       	ldd	r24, Y+7	; 0x07
 432:	90 e0       	ldi	r25, 0x00	; 0
 434:	83 70       	andi	r24, 0x03	; 3
 436:	90 70       	andi	r25, 0x00	; 0
 438:	98 2f       	mov	r25, r24
 43a:	88 27       	eor	r24, r24
 43c:	99 0f       	add	r25, r25
 43e:	99 0f       	add	r25, r25
 440:	48 0f       	add	r20, r24
 442:	59 1f       	adc	r21, r25
			rtn = (uint32_t)csize << (n - 9);
 444:	60 e0       	ldi	r22, 0x00	; 0
 446:	70 e0       	ldi	r23, 0x00	; 0
	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
		if ((csd[0] >> 6) == 1) {						/* SDC ver 2.00 */
			csize = csd[9] + ((uint16_t)csd[8] << 8) + 1;
			rtn = (uint32_t)csize << 10;
		} else {										/* SDC ver 1.XX or MMC*/
			uint8_t n = (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2;
 448:	8e 81       	ldd	r24, Y+6	; 0x06
 44a:	8f 70       	andi	r24, 0x0F	; 15
 44c:	9b 85       	ldd	r25, Y+11	; 0x0b
 44e:	99 1f       	adc	r25, r25
 450:	99 27       	eor	r25, r25
 452:	99 1f       	adc	r25, r25
 454:	89 0f       	add	r24, r25
 456:	8e 5f       	subi	r24, 0xFE	; 254
 458:	9a 85       	ldd	r25, Y+10	; 0x0a
 45a:	93 70       	andi	r25, 0x03	; 3
 45c:	99 0f       	add	r25, r25
 45e:	89 0f       	add	r24, r25
			csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1;
			rtn = (uint32_t)csize << (n - 9);
 460:	90 e0       	ldi	r25, 0x00	; 0
 462:	09 97       	sbiw	r24, 0x09	; 9
 464:	00 c0       	rjmp	.+0      	; 0x466 <sdCardInit+0x244>
 466:	44 0f       	add	r20, r20
 468:	55 1f       	adc	r21, r21
 46a:	66 1f       	adc	r22, r22
 46c:	77 1f       	adc	r23, r23
 46e:	8a 95       	dec	r24
 470:	02 f4       	brpl	.+0      	; 0x472 <sdCardInit+0x250>
 472:	00 c0       	rjmp	.+0      	; 0x474 <sdCardInit+0x252>
	}
	return TRUE;
}

static uint32_t getTotalDiskSectors(SD_CARD* card){
	uint32_t rtn = 0;
 474:	40 e0       	ldi	r20, 0x00	; 0
 476:	50 e0       	ldi	r21, 0x00	; 0
 478:	60 e0       	ldi	r22, 0x00	; 0
 47a:	70 e0       	ldi	r23, 0x00	; 0
			#endif
		}
	}

	if(cardType){
		card->numSectors = getTotalDiskSectors(card);
 47c:	f8 01       	movw	r30, r16
 47e:	41 87       	std	Z+9, r20	; 0x09
 480:	52 87       	std	Z+10, r21	; 0x0a
 482:	63 87       	std	Z+11, r22	; 0x0b
 484:	74 87       	std	Z+12, r23	; 0x0c
 486:	00 c0       	rjmp	.+0      	; 0x488 <sdCardInit+0x266>
boolean sdCardInit(SD_CARD* card){
	boolean rtn = FALSE;

	uint8_t n;
	uint8_t cmd;
	uint8_t cardType = 0;
 488:	bb 24       	eor	r11, r11
exit:
	#ifdef DEBUG_SD
	rprintf("\nFinished\n");
	#endif

	deselect(card);
 48a:	c8 01       	movw	r24, r16
 48c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	if (cardType) {			/* Initialization succeded */
 490:	bb 20       	and	r11, r11
 492:	01 f4       	brne	.+0      	; 0x494 <sdCardInit+0x272>
	return rtn;
}


boolean sdCardInit(SD_CARD* card){
	boolean rtn = FALSE;
 494:	80 e0       	ldi	r24, 0x00	; 0
 496:	00 c0       	rjmp	.+0      	; 0x498 <sdCardInit+0x276>
	#endif

	deselect(card);

	if (cardType) {			/* Initialization succeded */
		rtn = TRUE;
 498:	8f ef       	ldi	r24, 0xFF	; 255
		rprintf("Success: Card Type=%d\n",cardType);
	}else{
		rprintf("Failure\n");
	}
	#endif
	card->cardType = cardType;
 49a:	f8 01       	movw	r30, r16
 49c:	b5 86       	std	Z+13, r11	; 0x0d
	card->initialised=rtn;
 49e:	80 87       	std	Z+8, r24	; 0x08
	return rtn;


}
 4a0:	60 96       	adiw	r28, 0x10	; 16
 4a2:	0f b6       	in	r0, 0x3f	; 63
 4a4:	f8 94       	cli
 4a6:	de bf       	out	0x3e, r29	; 62
 4a8:	0f be       	out	0x3f, r0	; 63
 4aa:	cd bf       	out	0x3d, r28	; 61
 4ac:	df 91       	pop	r29
 4ae:	cf 91       	pop	r28
 4b0:	1f 91       	pop	r17
 4b2:	0f 91       	pop	r16
 4b4:	ff 90       	pop	r15
 4b6:	ef 90       	pop	r14
 4b8:	df 90       	pop	r13
 4ba:	cf 90       	pop	r12
 4bc:	bf 90       	pop	r11
 4be:	af 90       	pop	r10
 4c0:	9f 90       	pop	r9
 4c2:	7f 90       	pop	r7
 4c4:	6f 90       	pop	r6
 4c6:	5f 90       	pop	r5
 4c8:	4f 90       	pop	r4
 4ca:	08 95       	ret
		rprintf("\nEnter idle state FAILED\n");
		#endif
		goto exit;
	}

	TICK_COUNT timer1 = clockGetus();				/* Initialization timeout of 1 second */
 4cc:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 4d0:	6b 01       	movw	r12, r22
 4d2:	7c 01       	movw	r14, r24


	// CMD8 is new to version 2
	if( (send_cmd(card,CMD8, 0x1AA)) == 1 ) {			/* SDHC */
 4d4:	c8 01       	movw	r24, r16
 4d6:	68 e4       	ldi	r22, 0x48	; 72
 4d8:	2a ea       	ldi	r18, 0xAA	; 170
 4da:	31 e0       	ldi	r19, 0x01	; 1
 4dc:	40 e0       	ldi	r20, 0x00	; 0
 4de:	50 e0       	ldi	r21, 0x00	; 0
 4e0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 4e4:	81 30       	cpi	r24, 0x01	; 1
 4e6:	01 f0       	breq	.+0      	; 0x4e8 <sdCardInit+0x2c6>
 4e8:	00 c0       	rjmp	.+0      	; 0x4ea <sdCardInit+0x2c8>
 4ea:	3e 01       	movw	r6, r28
 4ec:	08 94       	sec
 4ee:	61 1c       	adc	r6, r1
 4f0:	71 1c       	adc	r7, r1
 4f2:	23 01       	movw	r4, r6
 4f4:	24 e0       	ldi	r18, 0x04	; 4
 4f6:	92 2e       	mov	r9, r18
 4f8:	00 c0       	rjmp	.+0      	; 0x4fa <sdCardInit+0x2d8>
				rprintf("\nGet card type\n");
				#endif
				for (n = 0; n < 4; n++){
					ocr[n] = receive(card);
				}
				cardType = (ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 */
 4fa:	9c e0       	ldi	r25, 0x0C	; 12
 4fc:	b9 2e       	mov	r11, r25
static uint32_t getTotalDiskSectors(SD_CARD* card){
	uint32_t rtn = 0;
	uint8_t csd[16];
	uint16_t csize;

	if ((send_cmd(card,CMD9, 0) == 0) && rcvr_datablock(card, csd, 16)) {
 4fe:	c8 01       	movw	r24, r16
 500:	69 e4       	ldi	r22, 0x49	; 73
 502:	20 e0       	ldi	r18, 0x00	; 0
 504:	30 e0       	ldi	r19, 0x00	; 0
 506:	40 e0       	ldi	r20, 0x00	; 0
 508:	50 e0       	ldi	r21, 0x00	; 0
 50a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 50e:	88 23       	and	r24, r24
 510:	01 f0       	breq	.+0      	; 0x512 <sdCardInit+0x2f0>
 512:	00 c0       	rjmp	.+0      	; 0x514 <sdCardInit+0x2f2>
 514:	00 c0       	rjmp	.+0      	; 0x516 <sdCardRead>

00000516 <sdCardRead>:
	return rtn;


}

boolean sdCardRead(SD_CARD* card,uint32_t absSector,void* dta,uint8_t numSectors){
 516:	ef 92       	push	r14
 518:	ff 92       	push	r15
 51a:	0f 93       	push	r16
 51c:	cf 93       	push	r28
 51e:	df 93       	push	r29
 520:	ec 01       	movw	r28, r24
 522:	79 01       	movw	r14, r18
	if(card->initialised && numSectors!=0 && dta){
 524:	88 85       	ldd	r24, Y+8	; 0x08
 526:	88 23       	and	r24, r24
 528:	01 f4       	brne	.+0      	; 0x52a <sdCardRead+0x14>
 52a:	00 c0       	rjmp	.+0      	; 0x52c <sdCardRead+0x16>
 52c:	00 23       	and	r16, r16
 52e:	01 f4       	brne	.+0      	; 0x530 <sdCardRead+0x1a>
 530:	00 c0       	rjmp	.+0      	; 0x532 <sdCardRead+0x1c>
 532:	21 15       	cp	r18, r1
 534:	31 05       	cpc	r19, r1
 536:	01 f4       	brne	.+0      	; 0x538 <sdCardRead+0x22>
 538:	00 c0       	rjmp	.+0      	; 0x53a <sdCardRead+0x24>
		// convert sector to address
		uint32_t address = (card->cardType & CT_BLOCK) ? absSector : absSector * 512;
 53a:	8d 85       	ldd	r24, Y+13	; 0x0d
 53c:	9a 01       	movw	r18, r20
 53e:	ab 01       	movw	r20, r22
 540:	83 fd       	sbrc	r24, 3
 542:	00 c0       	rjmp	.+0      	; 0x544 <sdCardRead+0x2e>
 544:	69 e0       	ldi	r22, 0x09	; 9
 546:	22 0f       	add	r18, r18
 548:	33 1f       	adc	r19, r19
 54a:	44 1f       	adc	r20, r20
 54c:	55 1f       	adc	r21, r21
 54e:	6a 95       	dec	r22
 550:	01 f4       	brne	.+0      	; 0x552 <sdCardRead+0x3c>

		if(numSectors==1){
			/* READ_SINGLE_BLOCK */
			if ((send_cmd(card, CMD17, address) == 0)
 552:	ce 01       	movw	r24, r28
boolean sdCardRead(SD_CARD* card,uint32_t absSector,void* dta,uint8_t numSectors){
	if(card->initialised && numSectors!=0 && dta){
		// convert sector to address
		uint32_t address = (card->cardType & CT_BLOCK) ? absSector : absSector * 512;

		if(numSectors==1){
 554:	01 30       	cpi	r16, 0x01	; 1
 556:	01 f4       	brne	.+0      	; 0x558 <sdCardRead+0x42>
			/* READ_SINGLE_BLOCK */
			if ((send_cmd(card, CMD17, address) == 0)
 558:	61 e5       	ldi	r22, 0x51	; 81
 55a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 55e:	88 23       	and	r24, r24
 560:	01 f4       	brne	.+0      	; 0x562 <sdCardRead+0x4c>
				&& rcvr_datablock(card,dta, 512)){
 562:	ce 01       	movw	r24, r28
 564:	b7 01       	movw	r22, r14
 566:	40 e0       	ldi	r20, 0x00	; 0
 568:	52 e0       	ldi	r21, 0x02	; 2
 56a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 56e:	88 23       	and	r24, r24
 570:	01 f4       	brne	.+0      	; 0x572 <sdCardRead+0x5c>
 572:	00 c0       	rjmp	.+0      	; 0x574 <sdCardRead+0x5e>
				numSectors = 0;
			}
		}else{
			/* READ_MULTIPLE_BLOCKS */
			if(send_cmd(card, CMD18, address) == 0){
 574:	62 e5       	ldi	r22, 0x52	; 82
 576:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 57a:	88 23       	and	r24, r24
 57c:	01 f4       	brne	.+0      	; 0x57e <sdCardRead+0x68>
				do {
					if (!rcvr_datablock(card, dta, 512))
 57e:	ce 01       	movw	r24, r28
 580:	b7 01       	movw	r22, r14
 582:	40 e0       	ldi	r20, 0x00	; 0
 584:	52 e0       	ldi	r21, 0x02	; 2
 586:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 58a:	88 23       	and	r24, r24
 58c:	01 f0       	breq	.+0      	; 0x58e <sdCardRead+0x78>
						break;
					dta += 512;
 58e:	80 e0       	ldi	r24, 0x00	; 0
 590:	92 e0       	ldi	r25, 0x02	; 2
 592:	e8 0e       	add	r14, r24
 594:	f9 1e       	adc	r15, r25
				} while (--numSectors);
 596:	01 50       	subi	r16, 0x01	; 1
 598:	01 f4       	brne	.+0      	; 0x59a <sdCardRead+0x84>
				send_cmd(card, CMD12, 0);				/* STOP_TRANSMISSION */
 59a:	ce 01       	movw	r24, r28
 59c:	6c e4       	ldi	r22, 0x4C	; 76
 59e:	20 e0       	ldi	r18, 0x00	; 0
 5a0:	30 e0       	ldi	r19, 0x00	; 0
 5a2:	40 e0       	ldi	r20, 0x00	; 0
 5a4:	50 e0       	ldi	r21, 0x00	; 0
 5a6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 5aa:	00 c0       	rjmp	.+0      	; 0x5ac <sdCardRead+0x96>

		if(numSectors==1){
			/* READ_SINGLE_BLOCK */
			if ((send_cmd(card, CMD17, address) == 0)
				&& rcvr_datablock(card,dta, 512)){
				numSectors = 0;
 5ac:	00 e0       	ldi	r16, 0x00	; 0
					dta += 512;
				} while (--numSectors);
				send_cmd(card, CMD12, 0);				/* STOP_TRANSMISSION */
			}
		}
		deselect(card);
 5ae:	ce 01       	movw	r24, r28
 5b0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}
	return (numSectors==0) ? TRUE : FALSE;
 5b4:	00 23       	and	r16, r16
 5b6:	01 f0       	breq	.+0      	; 0x5b8 <sdCardRead+0xa2>
 5b8:	80 e0       	ldi	r24, 0x00	; 0
 5ba:	00 c0       	rjmp	.+0      	; 0x5bc <sdCardRead+0xa6>
 5bc:	8f ef       	ldi	r24, 0xFF	; 255
}
 5be:	df 91       	pop	r29
 5c0:	cf 91       	pop	r28
 5c2:	0f 91       	pop	r16
 5c4:	ff 90       	pop	r15
 5c6:	ef 90       	pop	r14
 5c8:	08 95       	ret

000005ca <disk_read>:
	}

	return (numSectors==0) ? TRUE : FALSE;
}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 5ca:	0f 93       	push	r16
	SD_CARD* card = (SD_CARD*)device;
	return sdCardRead(card, absSector,dta,1);
 5cc:	01 e0       	ldi	r16, 0x01	; 1
 5ce:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 5d2:	0f 91       	pop	r16
 5d4:	08 95       	ret

000005d6 <sdCardWrite>:
		deselect(card);
	}
	return (numSectors==0) ? TRUE : FALSE;
}

boolean sdCardWrite(SD_CARD* card, uint32_t absSector,const void* dta,uint8_t numSectors){
 5d6:	af 92       	push	r10
 5d8:	bf 92       	push	r11
 5da:	cf 92       	push	r12
 5dc:	df 92       	push	r13
 5de:	ef 92       	push	r14
 5e0:	ff 92       	push	r15
 5e2:	0f 93       	push	r16
 5e4:	cf 93       	push	r28
 5e6:	df 93       	push	r29
 5e8:	ec 01       	movw	r28, r24
 5ea:	59 01       	movw	r10, r18
	if(card->initialised && numSectors!=0 && dta){
 5ec:	88 85       	ldd	r24, Y+8	; 0x08
 5ee:	88 23       	and	r24, r24
 5f0:	01 f4       	brne	.+0      	; 0x5f2 <sdCardWrite+0x1c>
 5f2:	00 c0       	rjmp	.+0      	; 0x5f4 <sdCardWrite+0x1e>
 5f4:	00 23       	and	r16, r16
 5f6:	01 f4       	brne	.+0      	; 0x5f8 <sdCardWrite+0x22>
 5f8:	00 c0       	rjmp	.+0      	; 0x5fa <sdCardWrite+0x24>
 5fa:	21 15       	cp	r18, r1
 5fc:	31 05       	cpc	r19, r1
 5fe:	01 f4       	brne	.+0      	; 0x600 <sdCardWrite+0x2a>
 600:	00 c0       	rjmp	.+0      	; 0x602 <sdCardWrite+0x2c>
		// convert sector to address
		uint32_t address = (card->cardType & CT_BLOCK) ? absSector : absSector * 512;
 602:	8d 85       	ldd	r24, Y+13	; 0x0d
 604:	90 e0       	ldi	r25, 0x00	; 0
 606:	6a 01       	movw	r12, r20
 608:	7b 01       	movw	r14, r22
 60a:	83 fd       	sbrc	r24, 3
 60c:	00 c0       	rjmp	.+0      	; 0x60e <sdCardWrite+0x38>
 60e:	79 e0       	ldi	r23, 0x09	; 9
 610:	cc 0c       	add	r12, r12
 612:	dd 1c       	adc	r13, r13
 614:	ee 1c       	adc	r14, r14
 616:	ff 1c       	adc	r15, r15
 618:	7a 95       	dec	r23
 61a:	01 f4       	brne	.+0      	; 0x61c <sdCardWrite+0x46>

		if(numSectors == 1){
 61c:	01 30       	cpi	r16, 0x01	; 1
 61e:	01 f4       	brne	.+0      	; 0x620 <sdCardWrite+0x4a>
			/* WRITE_BLOCK */
			if ((send_cmd(card, CMD24, address) == 0)
 620:	ce 01       	movw	r24, r28
 622:	68 e5       	ldi	r22, 0x58	; 88
 624:	a7 01       	movw	r20, r14
 626:	96 01       	movw	r18, r12
 628:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 62c:	88 23       	and	r24, r24
 62e:	01 f4       	brne	.+0      	; 0x630 <sdCardWrite+0x5a>
				&& xmit_datablock(card, dta, 0xFE)){
 630:	ce 01       	movw	r24, r28
 632:	b5 01       	movw	r22, r10
 634:	4e ef       	ldi	r20, 0xFE	; 254
 636:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 63a:	88 23       	and	r24, r24
 63c:	01 f4       	brne	.+0      	; 0x63e <sdCardWrite+0x68>
 63e:	00 c0       	rjmp	.+0      	; 0x640 <sdCardWrite+0x6a>
				numSectors = 0;
			}
		}else{
			if (card->cardType & CT_SDC)
 640:	86 70       	andi	r24, 0x06	; 6
 642:	90 70       	andi	r25, 0x00	; 0
 644:	00 97       	sbiw	r24, 0x00	; 0
 646:	01 f0       	breq	.+0      	; 0x648 <sdCardWrite+0x72>
				send_cmd(card, ACMD23, numSectors);
 648:	20 2f       	mov	r18, r16
 64a:	30 e0       	ldi	r19, 0x00	; 0
 64c:	40 e0       	ldi	r20, 0x00	; 0
 64e:	50 e0       	ldi	r21, 0x00	; 0
 650:	ce 01       	movw	r24, r28
 652:	67 ed       	ldi	r22, 0xD7	; 215
 654:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

			if (send_cmd(card, CMD25, address) == 0) {	/* WRITE_MULTIPLE_BLOCK */
 658:	ce 01       	movw	r24, r28
 65a:	69 e5       	ldi	r22, 0x59	; 89
 65c:	a7 01       	movw	r20, r14
 65e:	96 01       	movw	r18, r12
 660:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 664:	88 23       	and	r24, r24
 666:	01 f4       	brne	.+0      	; 0x668 <sdCardWrite+0x92>
				do {
					if (!xmit_datablock(card,dta, 0xFC))
 668:	ce 01       	movw	r24, r28
 66a:	b5 01       	movw	r22, r10
 66c:	4c ef       	ldi	r20, 0xFC	; 252
 66e:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 672:	88 23       	and	r24, r24
 674:	01 f0       	breq	.+0      	; 0x676 <sdCardWrite+0xa0>
						break;
					dta += 512;
 676:	80 e0       	ldi	r24, 0x00	; 0
 678:	92 e0       	ldi	r25, 0x02	; 2
 67a:	a8 0e       	add	r10, r24
 67c:	b9 1e       	adc	r11, r25
				} while (--numSectors);
 67e:	01 50       	subi	r16, 0x01	; 1
 680:	01 f4       	brne	.+0      	; 0x682 <sdCardWrite+0xac>

				if (!xmit_datablock(card, 0, 0xFD))	/* STOP_TRAN token */
 682:	ce 01       	movw	r24, r28
 684:	60 e0       	ldi	r22, 0x00	; 0
 686:	70 e0       	ldi	r23, 0x00	; 0
 688:	4d ef       	ldi	r20, 0xFD	; 253
 68a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 68e:	88 23       	and	r24, r24
 690:	01 f0       	breq	.+0      	; 0x692 <sdCardWrite+0xbc>
 692:	00 c0       	rjmp	.+0      	; 0x694 <sdCardWrite+0xbe>

		if(numSectors == 1){
			/* WRITE_BLOCK */
			if ((send_cmd(card, CMD24, address) == 0)
				&& xmit_datablock(card, dta, 0xFE)){
				numSectors = 0;
 694:	00 e0       	ldi	r16, 0x00	; 0
 696:	00 c0       	rjmp	.+0      	; 0x698 <sdCardWrite+0xc2>
						break;
					dta += 512;
				} while (--numSectors);

				if (!xmit_datablock(card, 0, 0xFD))	/* STOP_TRAN token */
					numSectors = 1;					// forced error
 698:	01 e0       	ldi	r16, 0x01	; 1
			}

		}
		deselect(card);
 69a:	ce 01       	movw	r24, r28
 69c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	}

	return (numSectors==0) ? TRUE : FALSE;
 6a0:	00 23       	and	r16, r16
 6a2:	01 f0       	breq	.+0      	; 0x6a4 <sdCardWrite+0xce>
 6a4:	80 e0       	ldi	r24, 0x00	; 0
 6a6:	00 c0       	rjmp	.+0      	; 0x6a8 <sdCardWrite+0xd2>
 6a8:	8f ef       	ldi	r24, 0xFF	; 255
}
 6aa:	df 91       	pop	r29
 6ac:	cf 91       	pop	r28
 6ae:	0f 91       	pop	r16
 6b0:	ff 90       	pop	r15
 6b2:	ef 90       	pop	r14
 6b4:	df 90       	pop	r13
 6b6:	cf 90       	pop	r12
 6b8:	bf 90       	pop	r11
 6ba:	af 90       	pop	r10
 6bc:	08 95       	ret

000006be <disk_write>:
static boolean disk_read(void* device,uint32_t absSector,void* dta){
	SD_CARD* card = (SD_CARD*)device;
	return sdCardRead(card, absSector,dta,1);
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 6be:	0f 93       	push	r16
	SD_CARD* card = (SD_CARD*)device;
	return sdCardWrite(card, absSector,dta,1);
 6c0:	01 e0       	ldi	r16, 0x01	; 1
 6c2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 6c6:	0f 91       	pop	r16
 6c8:	08 95       	ret

000006ca <sdCardGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* sdCardGetStorageClass(void){
	return &c_sdCard_disk;
}
 6ca:	80 e0       	ldi	r24, 0x00	; 0
 6cc:	90 e0       	ldi	r25, 0x00	; 0
 6ce:	08 95       	ret

spiEEPROM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003e0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000414  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000414  2**0
                  ALLOC
  3 .progmem.data 00000006  00000000  00000000  00000414  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000a82  00000000  00000000  0000041a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000242  00000000  00000000  00000e9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000a7b  00000000  00000000  000010de  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001b59  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000048  00000000  00000000  00001b79  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001b4  00000000  00000000  00001bc1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000004af  00000000  00000000  00001d75  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000001d0  00000000  00000000  00002224  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <disk_total_sectors>:
	EEPROM_ADDR addr = absSector * 512;
	spiEEPROM_writeBytes(eeprom,addr,dta,512);
	return TRUE;
}

static uint32_t disk_total_sectors(void* device){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes);

static __inline__ EEPROM_ADDR spiEEPROM_totalBytes(const SPI_EEPROM* eeprom){
	return eeprom->totalBytes;
   4:	fc 01       	movw	r30, r24
   6:	03 85       	ldd	r16, Z+11	; 0x0b
   8:	14 85       	ldd	r17, Z+12	; 0x0c
   a:	25 85       	ldd	r18, Z+13	; 0x0d
   c:	36 85       	ldd	r19, Z+14	; 0x0e
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	uint32_t sectors = spiEEPROM_totalBytes(eeprom);
	sectors /= 512;
   e:	49 e0       	ldi	r20, 0x09	; 9
  10:	36 95       	lsr	r19
  12:	27 95       	ror	r18
  14:	17 95       	ror	r17
  16:	07 95       	ror	r16
  18:	4a 95       	dec	r20
  1a:	01 f4       	brne	.+0      	; 0x1c <disk_total_sectors+0x1c>
	return sectors;
}
  1c:	b8 01       	movw	r22, r16
  1e:	c9 01       	movw	r24, r18
  20:	1f 91       	pop	r17
  22:	0f 91       	pop	r16
  24:	08 95       	ret

00000026 <spiEEPROM_isBusy>:
	spiDeviceSelect(eeprom,FALSE);
	return status;
}

// Is the chip busy doing a write?
static boolean spiEEPROM_isBusy(SPI_EEPROM* eeprom){
  26:	1f 93       	push	r17
  28:	cf 93       	push	r28
  2a:	df 93       	push	r29
  2c:	d8 2f       	mov	r29, r24
  2e:	c9 2f       	mov	r28, r25

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_RDSR);
  30:	65 e0       	ldi	r22, 0x05	; 5
  32:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	// get status register value
	uint8_t status = spiDeviceReceiveByte(eeprom);
  36:	8d 2f       	mov	r24, r29
  38:	9c 2f       	mov	r25, r28
  3a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  3e:	18 2f       	mov	r17, r24

	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
  40:	8d 2f       	mov	r24, r29
  42:	9c 2f       	mov	r25, r28
  44:	60 e0       	ldi	r22, 0x00	; 0
  46:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}

// Is the chip busy doing a write?
static boolean spiEEPROM_isBusy(SPI_EEPROM* eeprom){
	uint8_t status = spiEEPROM_readStatus(eeprom);
	return (status & SPIEEPROM_STATUS_WIP) ? TRUE : FALSE;
  4a:	10 ff       	sbrs	r17, 0
  4c:	00 c0       	rjmp	.+0      	; 0x4e <spiEEPROM_isBusy+0x28>
  4e:	8f ef       	ldi	r24, 0xFF	; 255
  50:	00 c0       	rjmp	.+0      	; 0x52 <spiEEPROM_isBusy+0x2c>
  52:	80 e0       	ldi	r24, 0x00	; 0
}
  54:	df 91       	pop	r29
  56:	cf 91       	pop	r28
  58:	1f 91       	pop	r17
  5a:	08 95       	ret

0000005c <spiEEPROM_readBytes>:
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
}

// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
  5c:	2f 92       	push	r2
  5e:	3f 92       	push	r3
  60:	4f 92       	push	r4
  62:	5f 92       	push	r5
  64:	6f 92       	push	r6
  66:	7f 92       	push	r7
  68:	8f 92       	push	r8
  6a:	9f 92       	push	r9
  6c:	af 92       	push	r10
  6e:	bf 92       	push	r11
  70:	cf 92       	push	r12
  72:	df 92       	push	r13
  74:	ef 92       	push	r14
  76:	ff 92       	push	r15
  78:	0f 93       	push	r16
  7a:	1f 93       	push	r17
  7c:	cf 93       	push	r28
  7e:	df 93       	push	r29
  80:	00 d0       	rcall	.+0      	; 0x82 <spiEEPROM_readBytes+0x26>
  82:	00 d0       	rcall	.+0      	; 0x84 <spiEEPROM_readBytes+0x28>
  84:	cd b7       	in	r28, 0x3d	; 61
  86:	de b7       	in	r29, 0x3e	; 62
  88:	2c 01       	movw	r4, r24
  8a:	b2 2e       	mov	r11, r18
  8c:	a3 2e       	mov	r10, r19
  8e:	18 01       	movw	r2, r16
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
  90:	dc 01       	movw	r26, r24
  92:	1b 96       	adiw	r26, 0x0b	; 11
  94:	0d 91       	ld	r16, X+
  96:	1d 91       	ld	r17, X+
  98:	2d 91       	ld	r18, X+
  9a:	3c 91       	ld	r19, X
  9c:	1e 97       	sbiw	r26, 0x0e	; 14
  9e:	cb 01       	movw	r24, r22
  a0:	ba 01       	movw	r22, r20
  a2:	a9 01       	movw	r20, r18
  a4:	98 01       	movw	r18, r16
  a6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  aa:	6b 01       	movw	r12, r22
  ac:	7c 01       	movw	r14, r24
	uint8_t* pos = dest;
  ae:	35 01       	movw	r6, r10

		size_t offset = src % eeprom->pageSize;			/* Offset into the page			*/

		while(spiEEPROM_isBusy(eeprom));				/* Wait while busy				*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
  b0:	b4 2c       	mov	r11, r4
  b2:	a5 2c       	mov	r10, r5
// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;

	while(numBytes){
  b4:	00 c0       	rjmp	.+0      	; 0xb6 <spiEEPROM_readBytes+0x5a>


		size_t offset = src % eeprom->pageSize;			/* Offset into the page			*/
  b6:	f2 01       	movw	r30, r4
  b8:	21 85       	ldd	r18, Z+9	; 0x09
  ba:	32 85       	ldd	r19, Z+10	; 0x0a
  bc:	40 e0       	ldi	r20, 0x00	; 0
  be:	50 e0       	ldi	r21, 0x00	; 0
  c0:	c7 01       	movw	r24, r14
  c2:	b6 01       	movw	r22, r12
  c4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  c8:	dc 01       	movw	r26, r24
  ca:	cb 01       	movw	r24, r22
  cc:	9a 83       	std	Y+2, r25	; 0x02
  ce:	89 83       	std	Y+1, r24	; 0x01

		while(spiEEPROM_isBusy(eeprom));				/* Wait while busy				*/
  d0:	c2 01       	movw	r24, r4
  d2:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
  d6:	88 23       	and	r24, r24
  d8:	01 f4       	brne	.+0      	; 0xda <spiEEPROM_readBytes+0x7e>
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
  da:	8b 2d       	mov	r24, r11
  dc:	9a 2d       	mov	r25, r10
  de:	63 e0       	ldi	r22, 0x03	; 3
  e0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
  e4:	d2 01       	movw	r26, r4
  e6:	18 96       	adiw	r26, 0x08	; 8
  e8:	0c 91       	ld	r16, X
  ea:	18 97       	sbiw	r26, 0x08	; 8
  ec:	00 c0       	rjmp	.+0      	; 0xee <spiEEPROM_readBytes+0x92>
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
  ee:	40 2f       	mov	r20, r16
  f0:	50 e0       	ldi	r21, 0x00	; 0
  f2:	41 50       	subi	r20, 0x01	; 1
  f4:	50 40       	sbci	r21, 0x00	; 0
  f6:	63 e0       	ldi	r22, 0x03	; 3
  f8:	44 0f       	add	r20, r20
  fa:	55 1f       	adc	r21, r21
  fc:	6a 95       	dec	r22
  fe:	01 f4       	brne	.+0      	; 0x100 <spiEEPROM_readBytes+0xa4>
 100:	d7 01       	movw	r26, r14
 102:	c6 01       	movw	r24, r12
 104:	00 c0       	rjmp	.+0      	; 0x106 <spiEEPROM_readBytes+0xaa>
 106:	b6 95       	lsr	r27
 108:	a7 95       	ror	r26
 10a:	97 95       	ror	r25
 10c:	87 95       	ror	r24
 10e:	4a 95       	dec	r20
 110:	02 f4       	brpl	.+0      	; 0x112 <spiEEPROM_readBytes+0xb6>
 112:	ac 01       	movw	r20, r24
 114:	bd 01       	movw	r22, r26
		spiDeviceSendByte(eeprom, (uint8_t)shft);
 116:	8b 2d       	mov	r24, r11
 118:	9a 2d       	mov	r25, r10
 11a:	64 2f       	mov	r22, r20
 11c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
 120:	01 50       	subi	r16, 0x01	; 1
 122:	00 23       	and	r16, r16
 124:	01 f4       	brne	.+0      	; 0x126 <spiEEPROM_readBytes+0xca>
 126:	47 2d       	mov	r20, r7
 128:	56 2d       	mov	r21, r6
 12a:	41 01       	movw	r8, r2
 12c:	00 e0       	ldi	r16, 0x00	; 0
 12e:	10 e0       	ldi	r17, 0x00	; 0
 130:	00 c0       	rjmp	.+0      	; 0x132 <spiEEPROM_readBytes+0xd6>
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
		address(eeprom,src);							/* send the address				*/

		size_t bytesRead = 0;
		while(numBytes--){
			*pos++ = spiDeviceReceiveByte(eeprom);		/* read the next byte			*/
 132:	8b 2d       	mov	r24, r11
 134:	9a 2d       	mov	r25, r10
 136:	4b 83       	std	Y+3, r20	; 0x03
 138:	5c 83       	std	Y+4, r21	; 0x04
 13a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 13e:	4b 81       	ldd	r20, Y+3	; 0x03
 140:	5c 81       	ldd	r21, Y+4	; 0x04
 142:	da 01       	movw	r26, r20
 144:	8d 93       	st	X+, r24
 146:	ad 01       	movw	r20, r26
 148:	7a 2e       	mov	r7, r26
 14a:	65 2e       	mov	r6, r21
			bytesRead++;								/* one more byte read			*/
 14c:	0f 5f       	subi	r16, 0xFF	; 255
 14e:	1f 4f       	sbci	r17, 0xFF	; 255
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
}

// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
 150:	89 81       	ldd	r24, Y+1	; 0x01
 152:	9a 81       	ldd	r25, Y+2	; 0x02
 154:	80 0f       	add	r24, r16
 156:	91 1f       	adc	r25, r17

		size_t bytesRead = 0;
		while(numBytes--){
			*pos++ = spiDeviceReceiveByte(eeprom);		/* read the next byte			*/
			bytesRead++;								/* one more byte read			*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
 158:	f2 01       	movw	r30, r4
 15a:	21 85       	ldd	r18, Z+9	; 0x09
 15c:	32 85       	ldd	r19, Z+10	; 0x0a
 15e:	82 17       	cp	r24, r18
 160:	93 07       	cpc	r25, r19
 162:	01 f0       	breq	.+0      	; 0x164 <spiEEPROM_readBytes+0x108>
 164:	74 2e       	mov	r7, r20
 166:	65 2e       	mov	r6, r21
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_READ);	/* issue read command 			*/
		address(eeprom,src);							/* send the address				*/

		size_t bytesRead = 0;
		while(numBytes--){
 168:	08 94       	sec
 16a:	81 08       	sbc	r8, r1
 16c:	91 08       	sbc	r9, r1
 16e:	02 15       	cp	r16, r2
 170:	13 05       	cpc	r17, r3
 172:	01 f4       	brne	.+0      	; 0x174 <spiEEPROM_readBytes+0x118>
			bytesRead++;								/* one more byte read			*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
				break;
			}
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/
 174:	8b 2d       	mov	r24, r11
 176:	9a 2d       	mov	r25, r10
 178:	60 e0       	ldi	r22, 0x00	; 0
 17a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		src += bytesRead;								/* update the address			*/
 17e:	20 e0       	ldi	r18, 0x00	; 0
 180:	30 e0       	ldi	r19, 0x00	; 0
 182:	c0 0e       	add	r12, r16
 184:	d1 1e       	adc	r13, r17
 186:	e2 1e       	adc	r14, r18
 188:	f3 1e       	adc	r15, r19
 18a:	14 01       	movw	r2, r8
// Read a sequence of bytes
void spiEEPROM_readBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, void* dest, size_t numBytes){
	EEPROM_ADDR src = addr % eeprom->totalBytes;	/* Put address in range				*/
	uint8_t* pos = dest;

	while(numBytes){
 18c:	21 14       	cp	r2, r1
 18e:	31 04       	cpc	r3, r1
 190:	01 f0       	breq	.+0      	; 0x192 <spiEEPROM_readBytes+0x136>
 192:	00 c0       	rjmp	.+0      	; 0x194 <spiEEPROM_readBytes+0x138>
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/

		src += bytesRead;								/* update the address			*/
	}
}
 194:	0f 90       	pop	r0
 196:	0f 90       	pop	r0
 198:	0f 90       	pop	r0
 19a:	0f 90       	pop	r0
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	1f 91       	pop	r17
 1a2:	0f 91       	pop	r16
 1a4:	ff 90       	pop	r15
 1a6:	ef 90       	pop	r14
 1a8:	df 90       	pop	r13
 1aa:	cf 90       	pop	r12
 1ac:	bf 90       	pop	r11
 1ae:	af 90       	pop	r10
 1b0:	9f 90       	pop	r9
 1b2:	8f 90       	pop	r8
 1b4:	7f 90       	pop	r7
 1b6:	6f 90       	pop	r6
 1b8:	5f 90       	pop	r5
 1ba:	4f 90       	pop	r4
 1bc:	3f 90       	pop	r3
 1be:	2f 90       	pop	r2
 1c0:	08 95       	ret

000001c2 <disk_read>:
		dst += bytesWritten;							/* update the address			*/
	}

}

static boolean disk_read(void* device,uint32_t absSector,void* dta){
 1c2:	0f 93       	push	r16
 1c4:	1f 93       	push	r17
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 1c6:	e9 e0       	ldi	r30, 0x09	; 9
 1c8:	44 0f       	add	r20, r20
 1ca:	55 1f       	adc	r21, r21
 1cc:	66 1f       	adc	r22, r22
 1ce:	77 1f       	adc	r23, r23
 1d0:	ea 95       	dec	r30
 1d2:	01 f4       	brne	.+0      	; 0x1d4 <disk_read+0x12>
	spiEEPROM_readBytes(eeprom,addr,dta,512);
 1d4:	00 e0       	ldi	r16, 0x00	; 0
 1d6:	12 e0       	ldi	r17, 0x02	; 2
 1d8:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 1dc:	8f ef       	ldi	r24, 0xFF	; 255
 1de:	1f 91       	pop	r17
 1e0:	0f 91       	pop	r16
 1e2:	08 95       	ret

000001e4 <spiEEPROM_readByte>:
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
		spiDeviceSendByte(eeprom, (uint8_t)shft);
	}
}

uint8_t spiEEPROM_readByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
 1e4:	0f 93       	push	r16
 1e6:	1f 93       	push	r17
 1e8:	cf 93       	push	r28
 1ea:	df 93       	push	r29
 1ec:	0f 92       	push	r0
 1ee:	cd b7       	in	r28, 0x3d	; 61
 1f0:	de b7       	in	r29, 0x3e	; 62
	uint8_t rtn;
	spiEEPROM_readBytes(eeprom, addr, &rtn, 1);
 1f2:	9e 01       	movw	r18, r28
 1f4:	2f 5f       	subi	r18, 0xFF	; 255
 1f6:	3f 4f       	sbci	r19, 0xFF	; 255
 1f8:	01 e0       	ldi	r16, 0x01	; 1
 1fa:	10 e0       	ldi	r17, 0x00	; 0
 1fc:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return rtn;
}
 200:	89 81       	ldd	r24, Y+1	; 0x01
 202:	0f 90       	pop	r0
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	1f 91       	pop	r17
 20a:	0f 91       	pop	r16
 20c:	08 95       	ret

0000020e <spiEEPROM_writeBytes>:
	}
}


// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 20e:	2f 92       	push	r2
 210:	3f 92       	push	r3
 212:	4f 92       	push	r4
 214:	5f 92       	push	r5
 216:	6f 92       	push	r6
 218:	7f 92       	push	r7
 21a:	8f 92       	push	r8
 21c:	9f 92       	push	r9
 21e:	af 92       	push	r10
 220:	bf 92       	push	r11
 222:	cf 92       	push	r12
 224:	df 92       	push	r13
 226:	ef 92       	push	r14
 228:	ff 92       	push	r15
 22a:	0f 93       	push	r16
 22c:	1f 93       	push	r17
 22e:	cf 93       	push	r28
 230:	df 93       	push	r29
 232:	00 d0       	rcall	.+0      	; 0x234 <spiEEPROM_writeBytes+0x26>
 234:	00 d0       	rcall	.+0      	; 0x236 <spiEEPROM_writeBytes+0x28>
 236:	cd b7       	in	r28, 0x3d	; 61
 238:	de b7       	in	r29, 0x3e	; 62
 23a:	1c 01       	movw	r2, r24
 23c:	f2 2e       	mov	r15, r18
 23e:	c3 2e       	mov	r12, r19
 240:	1a 83       	std	Y+2, r17	; 0x02
 242:	09 83       	std	Y+1, r16	; 0x01
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
 244:	dc 01       	movw	r26, r24
 246:	1b 96       	adiw	r26, 0x0b	; 11
 248:	0d 91       	ld	r16, X+
 24a:	1d 91       	ld	r17, X+
 24c:	2d 91       	ld	r18, X+
 24e:	3c 91       	ld	r19, X
 250:	1e 97       	sbiw	r26, 0x0e	; 14
 252:	cb 01       	movw	r24, r22
 254:	ba 01       	movw	r22, r20
 256:	a9 01       	movw	r20, r18
 258:	98 01       	movw	r18, r16
 25a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 25e:	4b 01       	movw	r8, r22
 260:	5c 01       	movw	r10, r24
	const uint8_t* pos = src;
 262:	ef 2c       	mov	r14, r15
 264:	5c 2c       	mov	r5, r12

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WREN);
 266:	42 2c       	mov	r4, r2
 268:	f3 2c       	mov	r15, r3
// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
	const uint8_t* pos = src;

	while(numBytes){
 26a:	00 c0       	rjmp	.+0      	; 0x26c <spiEEPROM_writeBytes+0x5e>

		size_t offset = dst % eeprom->pageSize;			/* Offset into the page			*/
 26c:	f1 01       	movw	r30, r2
 26e:	21 85       	ldd	r18, Z+9	; 0x09
 270:	32 85       	ldd	r19, Z+10	; 0x0a
 272:	40 e0       	ldi	r20, 0x00	; 0
 274:	50 e0       	ldi	r21, 0x00	; 0
 276:	c5 01       	movw	r24, r10
 278:	b4 01       	movw	r22, r8
 27a:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 27e:	dc 01       	movw	r26, r24
 280:	cb 01       	movw	r24, r22
 282:	9c 83       	std	Y+4, r25	; 0x04
 284:	8b 83       	std	Y+3, r24	; 0x03

// Enable writes
static void writeEnable(SPI_EEPROM* eeprom){
//	SPI_ABSTRACT_BUS* bus = __spiDeviceGetBus(eeprom->_device_.bus);

	while(spiEEPROM_isBusy(eeprom));
 286:	c1 01       	movw	r24, r2
 288:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
 28c:	88 23       	and	r24, r24
 28e:	01 f4       	brne	.+0      	; 0x290 <spiEEPROM_writeBytes+0x82>

	// Select the device
//	spiDeviceSelect(eeprom,TRUE);

	// send command
	spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WREN);
 290:	84 2d       	mov	r24, r4
 292:	9f 2d       	mov	r25, r15
 294:	66 e0       	ldi	r22, 0x06	; 6
 296:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
 29a:	84 2d       	mov	r24, r4
 29c:	9f 2d       	mov	r25, r15
 29e:	60 e0       	ldi	r22, 0x00	; 0
 2a0:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		size_t offset = dst % eeprom->pageSize;			/* Offset into the page			*/

		writeEnable(eeprom);							/* Allow writes					*/
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
 2a4:	84 2d       	mov	r24, r4
 2a6:	9f 2d       	mov	r25, r15
 2a8:	62 e0       	ldi	r22, 0x02	; 2
 2aa:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
 2ae:	d1 01       	movw	r26, r2
 2b0:	18 96       	adiw	r26, 0x08	; 8
 2b2:	0c 91       	ld	r16, X
 2b4:	18 97       	sbiw	r26, 0x08	; 8
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <spiEEPROM_writeBytes+0xaa>
		EEPROM_ADDR shft = (addr >> (8 * (b-1)));
 2b8:	40 2f       	mov	r20, r16
 2ba:	50 e0       	ldi	r21, 0x00	; 0
 2bc:	41 50       	subi	r20, 0x01	; 1
 2be:	50 40       	sbci	r21, 0x00	; 0
 2c0:	f3 e0       	ldi	r31, 0x03	; 3
 2c2:	44 0f       	add	r20, r20
 2c4:	55 1f       	adc	r21, r21
 2c6:	fa 95       	dec	r31
 2c8:	01 f4       	brne	.+0      	; 0x2ca <spiEEPROM_writeBytes+0xbc>
 2ca:	d5 01       	movw	r26, r10
 2cc:	c4 01       	movw	r24, r8
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <spiEEPROM_writeBytes+0xc2>
 2d0:	b6 95       	lsr	r27
 2d2:	a7 95       	ror	r26
 2d4:	97 95       	ror	r25
 2d6:	87 95       	ror	r24
 2d8:	4a 95       	dec	r20
 2da:	02 f4       	brpl	.+0      	; 0x2dc <spiEEPROM_writeBytes+0xce>
 2dc:	ac 01       	movw	r20, r24
 2de:	bd 01       	movw	r22, r26
		spiDeviceSendByte(eeprom, (uint8_t)shft);
 2e0:	84 2d       	mov	r24, r4
 2e2:	9f 2d       	mov	r25, r15
 2e4:	64 2f       	mov	r22, r20
 2e6:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	// Un-select the device
	spiDeviceSelect(eeprom,FALSE);
}

static void address(SPI_EEPROM* eeprom, EEPROM_ADDR addr){
	for(uint8_t b = eeprom->addrBytes; b > 0; b--){
 2ea:	01 50       	subi	r16, 0x01	; 1
 2ec:	00 23       	and	r16, r16
 2ee:	01 f4       	brne	.+0      	; 0x2f0 <spiEEPROM_writeBytes+0xe2>
 2f0:	ce 2c       	mov	r12, r14
 2f2:	d5 2c       	mov	r13, r5
 2f4:	69 80       	ldd	r6, Y+1	; 0x01
 2f6:	7a 80       	ldd	r7, Y+2	; 0x02
 2f8:	00 e0       	ldi	r16, 0x00	; 0
 2fa:	10 e0       	ldi	r17, 0x00	; 0
 2fc:	00 c0       	rjmp	.+0      	; 0x2fe <spiEEPROM_writeBytes+0xf0>
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
		address(eeprom,dst);							/* send the address				*/

		size_t bytesWritten = 0;
		while(numBytes--){
			spiDeviceSendByte(eeprom,*pos++);           /* send the byte				*/
 2fe:	d6 01       	movw	r26, r12
 300:	6d 91       	ld	r22, X+
 302:	6d 01       	movw	r12, r26
 304:	ea 2e       	mov	r14, r26
 306:	5d 2c       	mov	r5, r13
 308:	84 2d       	mov	r24, r4
 30a:	9f 2d       	mov	r25, r15
 30c:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
			bytesWritten++;								/* one more byte written		*/
 310:	0f 5f       	subi	r16, 0xFF	; 255
 312:	1f 4f       	sbci	r17, 0xFF	; 255
	}
}


// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
 314:	8b 81       	ldd	r24, Y+3	; 0x03
 316:	9c 81       	ldd	r25, Y+4	; 0x04
 318:	80 0f       	add	r24, r16
 31a:	91 1f       	adc	r25, r17

		size_t bytesWritten = 0;
		while(numBytes--){
			spiDeviceSendByte(eeprom,*pos++);           /* send the byte				*/
			bytesWritten++;								/* one more byte written		*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
 31c:	f1 01       	movw	r30, r2
 31e:	21 85       	ldd	r18, Z+9	; 0x09
 320:	32 85       	ldd	r19, Z+10	; 0x0a
 322:	82 17       	cp	r24, r18
 324:	93 07       	cpc	r25, r19
 326:	01 f0       	breq	.+0      	; 0x328 <spiEEPROM_writeBytes+0x11a>
 328:	ec 2c       	mov	r14, r12
 32a:	5d 2c       	mov	r5, r13
		//spiDeviceSelect(eeprom,TRUE);					/* Select the device 			*/
		spiDeviceSendByte(eeprom,SPIEEPROM_CMD_WRITE);	/* issue write command 			*/
		address(eeprom,dst);							/* send the address				*/

		size_t bytesWritten = 0;
		while(numBytes--){
 32c:	08 94       	sec
 32e:	61 08       	sbc	r6, r1
 330:	71 08       	sbc	r7, r1
 332:	89 81       	ldd	r24, Y+1	; 0x01
 334:	9a 81       	ldd	r25, Y+2	; 0x02
 336:	08 17       	cp	r16, r24
 338:	19 07       	cpc	r17, r25
 33a:	01 f4       	brne	.+0      	; 0x33c <spiEEPROM_writeBytes+0x12e>
			bytesWritten++;								/* one more byte written		*/
			if(++offset==eeprom->pageSize){				/* if at end of page boundary	*/
				break;
			}
		}
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/
 33c:	84 2d       	mov	r24, r4
 33e:	9f 2d       	mov	r25, r15
 340:	60 e0       	ldi	r22, 0x00	; 0
 342:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>

		dst += bytesWritten;							/* update the address			*/
 346:	20 e0       	ldi	r18, 0x00	; 0
 348:	30 e0       	ldi	r19, 0x00	; 0
 34a:	80 0e       	add	r8, r16
 34c:	91 1e       	adc	r9, r17
 34e:	a2 1e       	adc	r10, r18
 350:	b3 1e       	adc	r11, r19
 352:	7a 82       	std	Y+2, r7	; 0x02
 354:	69 82       	std	Y+1, r6	; 0x01
// Write a sequence of bytes
void spiEEPROM_writeBytes(SPI_EEPROM* eeprom, EEPROM_ADDR addr, const void* src, size_t numBytes){
	EEPROM_ADDR dst = addr % eeprom->totalBytes;		/* Put address in range				*/
	const uint8_t* pos = src;

	while(numBytes){
 356:	a9 81       	ldd	r26, Y+1	; 0x01
 358:	ba 81       	ldd	r27, Y+2	; 0x02
 35a:	10 97       	sbiw	r26, 0x00	; 0
 35c:	01 f0       	breq	.+0      	; 0x35e <spiEEPROM_writeBytes+0x150>
 35e:	00 c0       	rjmp	.+0      	; 0x360 <spiEEPROM_writeBytes+0x152>
		spiDeviceSelect(eeprom,FALSE);					/* De-select the device			*/

		dst += bytesWritten;							/* update the address			*/
	}

}
 360:	0f 90       	pop	r0
 362:	0f 90       	pop	r0
 364:	0f 90       	pop	r0
 366:	0f 90       	pop	r0
 368:	df 91       	pop	r29
 36a:	cf 91       	pop	r28
 36c:	1f 91       	pop	r17
 36e:	0f 91       	pop	r16
 370:	ff 90       	pop	r15
 372:	ef 90       	pop	r14
 374:	df 90       	pop	r13
 376:	cf 90       	pop	r12
 378:	bf 90       	pop	r11
 37a:	af 90       	pop	r10
 37c:	9f 90       	pop	r9
 37e:	8f 90       	pop	r8
 380:	7f 90       	pop	r7
 382:	6f 90       	pop	r6
 384:	5f 90       	pop	r5
 386:	4f 90       	pop	r4
 388:	3f 90       	pop	r3
 38a:	2f 90       	pop	r2
 38c:	08 95       	ret

0000038e <disk_write>:
	EEPROM_ADDR addr = absSector * 512;
	spiEEPROM_readBytes(eeprom,addr,dta,512);
	return TRUE;
}

static boolean disk_write(void* device, uint32_t absSector,const void* dta){
 38e:	0f 93       	push	r16
 390:	1f 93       	push	r17
	SPI_EEPROM* eeprom = (SPI_EEPROM*)device;
	EEPROM_ADDR addr = absSector * 512;
 392:	a9 e0       	ldi	r26, 0x09	; 9
 394:	44 0f       	add	r20, r20
 396:	55 1f       	adc	r21, r21
 398:	66 1f       	adc	r22, r22
 39a:	77 1f       	adc	r23, r23
 39c:	aa 95       	dec	r26
 39e:	01 f4       	brne	.+0      	; 0x3a0 <disk_write+0x12>
	spiEEPROM_writeBytes(eeprom,addr,dta,512);
 3a0:	00 e0       	ldi	r16, 0x00	; 0
 3a2:	12 e0       	ldi	r17, 0x02	; 2
 3a4:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
	return TRUE;
}
 3a8:	8f ef       	ldi	r24, 0xFF	; 255
 3aa:	1f 91       	pop	r17
 3ac:	0f 91       	pop	r16
 3ae:	08 95       	ret

000003b0 <spiEEPROM_writeByte>:
	spiEEPROM_readBytes(eeprom, addr, &rtn, 1);
	return rtn;
}

// Write a byte to the eeprom - note the write may be delayed
void spiEEPROM_writeByte(SPI_EEPROM* eeprom, EEPROM_ADDR addr, uint8_t data){
 3b0:	0f 93       	push	r16
 3b2:	1f 93       	push	r17
 3b4:	cf 93       	push	r28
 3b6:	df 93       	push	r29
 3b8:	0f 92       	push	r0
 3ba:	cd b7       	in	r28, 0x3d	; 61
 3bc:	de b7       	in	r29, 0x3e	; 62
 3be:	29 83       	std	Y+1, r18	; 0x01
	spiEEPROM_writeBytes(eeprom, addr, &data, 1);
 3c0:	9e 01       	movw	r18, r28
 3c2:	2f 5f       	subi	r18, 0xFF	; 255
 3c4:	3f 4f       	sbci	r19, 0xFF	; 255
 3c6:	01 e0       	ldi	r16, 0x01	; 1
 3c8:	10 e0       	ldi	r17, 0x00	; 0
 3ca:	0e 94 00 00 	call	0	; 0x0 <disk_total_sectors>
}
 3ce:	0f 90       	pop	r0
 3d0:	df 91       	pop	r29
 3d2:	cf 91       	pop	r28
 3d4:	1f 91       	pop	r17
 3d6:	0f 91       	pop	r16
 3d8:	08 95       	ret

000003da <spiEEPROMGetStorageClass>:
		&disk_write, \
		&disk_total_sectors);

const STORAGE_CLASS* spiEEPROMGetStorageClass(void){
	return &c_spieeprom_disk;
}
 3da:	80 e0       	ldi	r24, 0x00	; 0
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	08 95       	ret

_i2c_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .debug_info   000000ad  00000000  00000000  00000034  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000065  00000000  00000000  000000e1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   0000003f  00000000  00000000  00000146  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_str    0000010a  00000000  00000000  00000185  2**0
                  CONTENTS, READONLY, DEBUGGING

_spi_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003e6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000041a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000041a  2**0
                  ALLOC
  3 .debug_info   00000bfe  00000000  00000000  0000041a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000021d  00000000  00000000  00001018  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000c91  00000000  00000000  00001235  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001ec6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000016a  00000000  00000000  00001ee6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000471  00000000  00000000  00002050  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000208  00000000  00000000  000024c4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <spiAbstractBusInit>:
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
    return rxData;
}

//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	f6 2e       	mov	r15, r22
	if(spi && !spi->initialised){
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <spiAbstractBusInit+0x16>
  16:	89 85       	ldd	r24, Y+9	; 0x09
  18:	88 23       	and	r24, r24
  1a:	01 f4       	brne	.+0      	; 0x1c <spiAbstractBusInit+0x1c>
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
  1c:	e8 81       	ld	r30, Y
  1e:	f9 81       	ldd	r31, Y+1	; 0x01
  20:	85 91       	lpm	r24, Z+
  22:	94 91       	lpm	r25, Z
  24:	6c 01       	movw	r12, r24
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
  26:	00 e0       	ldi	r16, 0x00	; 0
  28:	10 e0       	ldi	r17, 0x00	; 0
  2a:	00 c0       	rjmp	.+0      	; 0x2c <spiAbstractBusInit+0x2c>
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
    return rxData;
}

//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
  2c:	c8 01       	movw	r24, r16
  2e:	88 0f       	add	r24, r24
  30:	99 1f       	adc	r25, r25
	if(spi && !spi->initialised){
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
			SPI_ABSTRACT_DEVICE* device = (SPI_ABSTRACT_DEVICE *)pgm_read_word(&spi->devices[deviceNo]);
  32:	ea 81       	ldd	r30, Y+2	; 0x02
  34:	fb 81       	ldd	r31, Y+3	; 0x03
  36:	e8 0f       	add	r30, r24
  38:	f9 1f       	adc	r31, r25
  3a:	85 91       	lpm	r24, Z+
  3c:	94 91       	lpm	r25, Z
  3e:	fc 01       	movw	r30, r24
			device->bus = (struct s_spi_abstract_bus*)spi;
  40:	d1 83       	std	Z+1, r29	; 0x01
  42:	c0 83       	st	Z, r28
			if(device->select!=null){
  44:	84 81       	ldd	r24, Z+4	; 0x04
  46:	95 81       	ldd	r25, Z+5	; 0x05
  48:	00 97       	sbiw	r24, 0x00	; 0
  4a:	01 f0       	breq	.+0      	; 0x4c <spiAbstractBusInit+0x4c>
				// Make into output pin and deselect
				pin_make_output(device->select, TRUE);
  4c:	6f ef       	ldi	r22, 0xFF	; 255
  4e:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
//--------------- Implement the virtual functions for an SPI_ABSTRACT_BUS -----
void spiAbstractBusInit(SPI_ABSTRACT_BUS* spi, boolean master){
	if(spi && !spi->initialised){
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,boolean) = (void (*)(SPI_ABSTRACT_BUS*, boolean))pgm_read_word(&class->init);
		for(int deviceNo=0;deviceNo < spi->numDevices; deviceNo++){
  52:	0f 5f       	subi	r16, 0xFF	; 255
  54:	1f 4f       	sbci	r17, 0xFF	; 255
  56:	8c 81       	ldd	r24, Y+4	; 0x04
  58:	9d 81       	ldd	r25, Y+5	; 0x05
  5a:	08 17       	cp	r16, r24
  5c:	19 07       	cpc	r17, r25
  5e:	00 f0       	brcs	.+0      	; 0x60 <spiAbstractBusInit+0x60>
			if(device->select!=null){
				// Make into output pin and deselect
				pin_make_output(device->select, TRUE);
			}
		}
		spi->selectedDevice=null;
  60:	1b 86       	std	Y+11, r1	; 0x0b
  62:	1a 86       	std	Y+10, r1	; 0x0a
		fn(spi,master);				// initialise the bus
  64:	ce 01       	movw	r24, r28
  66:	6f 2d       	mov	r22, r15
  68:	f6 01       	movw	r30, r12
  6a:	09 95       	icall
		spi->initialised = TRUE;
  6c:	8f ef       	ldi	r24, 0xFF	; 255
  6e:	89 87       	std	Y+9, r24	; 0x09
	}
}
  70:	df 91       	pop	r29
  72:	cf 91       	pop	r28
  74:	1f 91       	pop	r17
  76:	0f 91       	pop	r16
  78:	ff 90       	pop	r15
  7a:	df 90       	pop	r13
  7c:	cf 90       	pop	r12
  7e:	08 95       	ret

00000080 <spiAbstractBusOff>:
void spiAbstractBusOff(SPI_ABSTRACT_BUS* spi){
  80:	cf 93       	push	r28
  82:	df 93       	push	r29
  84:	ec 01       	movw	r28, r24
	if(spi && spi->initialised){
  86:	00 97       	sbiw	r24, 0x00	; 0
  88:	01 f0       	breq	.+0      	; 0x8a <spiAbstractBusOff+0xa>
  8a:	89 85       	ldd	r24, Y+9	; 0x09
  8c:	88 23       	and	r24, r24
  8e:	01 f0       	breq	.+0      	; 0x90 <spiAbstractBusOff+0x10>
		const SPI_CLASS* class = spi->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*) = (void (*)(SPI_ABSTRACT_BUS*))pgm_read_word(&class->off);
  90:	e8 81       	ld	r30, Y
  92:	f9 81       	ldd	r31, Y+1	; 0x01
  94:	32 96       	adiw	r30, 0x02	; 2
  96:	25 91       	lpm	r18, Z+
  98:	34 91       	lpm	r19, Z
		fn(spi);
  9a:	ce 01       	movw	r24, r28
  9c:	f9 01       	movw	r30, r18
  9e:	09 95       	icall
		spi->initialised = FALSE;
  a0:	19 86       	std	Y+9, r1	; 0x09
	}
}
  a2:	df 91       	pop	r29
  a4:	cf 91       	pop	r28
  a6:	08 95       	ret

000000a8 <spiAbstractBusSetMode>:

void spiAbstractBusSetMode(SPI_ABSTRACT_BUS* bus,SPI_MODE mode){
	if(bus){
  a8:	00 97       	sbiw	r24, 0x00	; 0
  aa:	01 f0       	breq	.+0      	; 0xac <spiAbstractBusSetMode+0x4>
		bus->mode = mode;
  ac:	dc 01       	movw	r26, r24
  ae:	17 96       	adiw	r26, 0x07	; 7
  b0:	6c 93       	st	X, r22
  b2:	17 97       	sbiw	r26, 0x07	; 7
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_MODE mode) = (void (*)(SPI_ABSTRACT_BUS*,SPI_MODE mode))pgm_read_word(&class->mode);
  b4:	ed 91       	ld	r30, X+
  b6:	fc 91       	ld	r31, X
  b8:	38 96       	adiw	r30, 0x08	; 8
  ba:	25 91       	lpm	r18, Z+
  bc:	34 91       	lpm	r19, Z
		fn(bus,mode);
  be:	f9 01       	movw	r30, r18
  c0:	09 95       	icall
  c2:	08 95       	ret

000000c4 <spiAbstractBusSetDataOrder>:
	}
}
void spiAbstractBusSetDataOrder(SPI_ABSTRACT_BUS* bus,SPI_DATA_ORDER order){
	if(bus){
  c4:	00 97       	sbiw	r24, 0x00	; 0
  c6:	01 f0       	breq	.+0      	; 0xc8 <spiAbstractBusSetDataOrder+0x4>
		bus->order = order;
  c8:	dc 01       	movw	r26, r24
  ca:	18 96       	adiw	r26, 0x08	; 8
  cc:	6c 93       	st	X, r22
  ce:	18 97       	sbiw	r26, 0x08	; 8
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order) = (void (*)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order))pgm_read_word(&class->order);
  d0:	ed 91       	ld	r30, X+
  d2:	fc 91       	ld	r31, X
  d4:	36 96       	adiw	r30, 0x06	; 6
  d6:	25 91       	lpm	r18, Z+
  d8:	34 91       	lpm	r19, Z
		fn(bus,order);
  da:	f9 01       	movw	r30, r18
  dc:	09 95       	icall
  de:	08 95       	ret

000000e0 <spiAbstractDeviceSelect>:
#include "_spi_common.h"


//--------------- Implement the virtual functions for an SPI_ABSTRACT_DEVICE -----

void spiAbstractDeviceSelect(const SPI_ABSTRACT_DEVICE* device, boolean active){
  e0:	ef 92       	push	r14
  e2:	ff 92       	push	r15
  e4:	0f 93       	push	r16
  e6:	1f 93       	push	r17
  e8:	cf 93       	push	r28
  ea:	df 93       	push	r29
  ec:	8c 01       	movw	r16, r24
	SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
  ee:	fc 01       	movw	r30, r24
  f0:	c0 81       	ld	r28, Z
  f2:	d1 81       	ldd	r29, Z+1	; 0x01

	if(bus){
  f4:	20 97       	sbiw	r28, 0x00	; 0
  f6:	01 f4       	brne	.+0      	; 0xf8 <spiAbstractDeviceSelect+0x18>
  f8:	00 c0       	rjmp	.+0      	; 0xfa <spiAbstractDeviceSelect+0x1a>
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(const SPI_ABSTRACT_DEVICE*,boolean) = (void (*)(const SPI_ABSTRACT_DEVICE*, boolean))pgm_read_word(&class->sel);
  fa:	e8 81       	ld	r30, Y
  fc:	f9 81       	ldd	r31, Y+1	; 0x01
  fe:	70 96       	adiw	r30, 0x10	; 16
 100:	85 91       	lpm	r24, Z+
 102:	94 91       	lpm	r25, Z
 104:	7c 01       	movw	r14, r24


		if(active){
 106:	66 23       	and	r22, r22
 108:	01 f0       	breq	.+0      	; 0x10a <spiAbstractDeviceSelect+0x2a>
			// Deselect the current device
			if(bus->selectedDevice!=null){
 10a:	8a 85       	ldd	r24, Y+10	; 0x0a
 10c:	9b 85       	ldd	r25, Y+11	; 0x0b
 10e:	00 97       	sbiw	r24, 0x00	; 0
 110:	01 f0       	breq	.+0      	; 0x112 <spiAbstractDeviceSelect+0x32>
				spiAbstractDeviceSelect(bus->selectedDevice,FALSE);
 112:	60 e0       	ldi	r22, 0x00	; 0
 114:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// Now set the mode and order for the bus for this device
			if(bus->mode!=device->mode){
 118:	f8 01       	movw	r30, r16
 11a:	62 81       	ldd	r22, Z+2	; 0x02
 11c:	8f 81       	ldd	r24, Y+7	; 0x07
 11e:	86 17       	cp	r24, r22
 120:	01 f0       	breq	.+0      	; 0x122 <spiAbstractDeviceSelect+0x42>
				spiAbstractBusSetMode(bus,device->mode);
 122:	ce 01       	movw	r24, r28
 124:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}
			if(bus->order!=device->order){
 128:	f8 01       	movw	r30, r16
 12a:	63 81       	ldd	r22, Z+3	; 0x03
 12c:	88 85       	ldd	r24, Y+8	; 0x08
 12e:	86 17       	cp	r24, r22
 130:	01 f0       	breq	.+0      	; 0x132 <spiAbstractDeviceSelect+0x52>
				spiAbstractBusSetDataOrder(bus,device->order);
 132:	ce 01       	movw	r24, r28
 134:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// Tell the bus the selected device is changing
			if(fn){
 138:	e1 14       	cp	r14, r1
 13a:	f1 04       	cpc	r15, r1
 13c:	01 f0       	breq	.+0      	; 0x13e <spiAbstractDeviceSelect+0x5e>
				fn(device,TRUE);
 13e:	c8 01       	movw	r24, r16
 140:	6f ef       	ldi	r22, 0xFF	; 255
 142:	f7 01       	movw	r30, r14
 144:	09 95       	icall
			}

			// Select the chip
			bus->selectedDevice=(SPI_ABSTRACT_DEVICE*)device;
 146:	1b 87       	std	Y+11, r17	; 0x0b
 148:	0a 87       	std	Y+10, r16	; 0x0a
			if(device->select!=null){
 14a:	f8 01       	movw	r30, r16
 14c:	84 81       	ldd	r24, Z+4	; 0x04
 14e:	95 81       	ldd	r25, Z+5	; 0x05
 150:	00 97       	sbiw	r24, 0x00	; 0
 152:	01 f0       	breq	.+0      	; 0x154 <spiAbstractDeviceSelect+0x74>
				pin_low(device->select);
 154:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 158:	00 c0       	rjmp	.+0      	; 0x15a <spiAbstractDeviceSelect+0x7a>
			}
		}else{
			// Deselect the chip
			if(device->select!=null){
 15a:	f8 01       	movw	r30, r16
 15c:	84 81       	ldd	r24, Z+4	; 0x04
 15e:	95 81       	ldd	r25, Z+5	; 0x05
 160:	00 97       	sbiw	r24, 0x00	; 0
 162:	01 f0       	breq	.+0      	; 0x164 <spiAbstractDeviceSelect+0x84>
				pin_high(device->select);
 164:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
			}

			// If its the currently selected device then notify it
			if(bus->selectedDevice==device){
 168:	8a 85       	ldd	r24, Y+10	; 0x0a
 16a:	9b 85       	ldd	r25, Y+11	; 0x0b
 16c:	80 17       	cp	r24, r16
 16e:	91 07       	cpc	r25, r17
 170:	01 f4       	brne	.+0      	; 0x172 <spiAbstractDeviceSelect+0x92>
				bus->selectedDevice = NULL;
 172:	1b 86       	std	Y+11, r1	; 0x0b
 174:	1a 86       	std	Y+10, r1	; 0x0a
				// Tell the bus the device is no longer selected
				if(fn){
 176:	e1 14       	cp	r14, r1
 178:	f1 04       	cpc	r15, r1
 17a:	01 f0       	breq	.+0      	; 0x17c <spiAbstractDeviceSelect+0x9c>
					fn(device,FALSE);
 17c:	c8 01       	movw	r24, r16
 17e:	60 e0       	ldi	r22, 0x00	; 0
 180:	f7 01       	movw	r30, r14
 182:	09 95       	icall
 184:	00 c0       	rjmp	.+0      	; 0x186 <spiAbstractDeviceSelect+0xa6>
				}
			}
		}
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
 186:	82 ee       	ldi	r24, 0xE2	; 226
 188:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
	}

}
 18c:	df 91       	pop	r29
 18e:	cf 91       	pop	r28
 190:	1f 91       	pop	r17
 192:	0f 91       	pop	r16
 194:	ff 90       	pop	r15
 196:	ef 90       	pop	r14
 198:	08 95       	ret

0000019a <spiAbstractDeviceSendBytes>:
			setError(SPI_BUS_NOT_INITIALIZED);
		}

	}
}
void spiAbstractDeviceSendBytes(const SPI_ABSTRACT_DEVICE* device, const void* buff, size_t size){
 19a:	8f 92       	push	r8
 19c:	9f 92       	push	r9
 19e:	af 92       	push	r10
 1a0:	bf 92       	push	r11
 1a2:	cf 92       	push	r12
 1a4:	df 92       	push	r13
 1a6:	ef 92       	push	r14
 1a8:	ff 92       	push	r15
 1aa:	1f 93       	push	r17
 1ac:	cf 93       	push	r28
 1ae:	df 93       	push	r29
 1b0:	0f 92       	push	r0
 1b2:	cd b7       	in	r28, 0x3d	; 61
 1b4:	de b7       	in	r29, 0x3e	; 62
 1b6:	5c 01       	movw	r10, r24
 1b8:	16 2f       	mov	r17, r22
 1ba:	7a 01       	movw	r14, r20
	if(size){
 1bc:	41 15       	cp	r20, r1
 1be:	51 05       	cpc	r21, r1
 1c0:	01 f4       	brne	.+0      	; 0x1c2 <spiAbstractDeviceSendBytes+0x28>
 1c2:	00 c0       	rjmp	.+0      	; 0x1c4 <spiAbstractDeviceSendBytes+0x2a>
		// Select the device if required
		SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 1c4:	fc 01       	movw	r30, r24
 1c6:	c0 80       	ld	r12, Z
 1c8:	d1 80       	ldd	r13, Z+1	; 0x01
		if(bus){
 1ca:	c1 14       	cp	r12, r1
 1cc:	d1 04       	cpc	r13, r1
 1ce:	01 f0       	breq	.+0      	; 0x1d0 <spiAbstractDeviceSendBytes+0x36>
			if(bus->selectedDevice != device){
 1d0:	f6 01       	movw	r30, r12
 1d2:	82 85       	ldd	r24, Z+10	; 0x0a
 1d4:	93 85       	ldd	r25, Z+11	; 0x0b
 1d6:	8a 15       	cp	r24, r10
 1d8:	9b 05       	cpc	r25, r11
 1da:	01 f0       	breq	.+0      	; 0x1dc <spiAbstractDeviceSendBytes+0x42>
				spiAbstractDeviceSelect(device,TRUE);
 1dc:	c5 01       	movw	r24, r10
 1de:	6f ef       	ldi	r22, 0xFF	; 255
 1e0:	79 83       	std	Y+1, r23	; 0x01
 1e2:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 1e6:	79 81       	ldd	r23, Y+1	; 0x01
			}
			const SPI_CLASS* class = bus->sclass;
 1e8:	f6 01       	movw	r30, r12
 1ea:	80 81       	ld	r24, Z
 1ec:	91 81       	ldd	r25, Z+1	; 0x01
			void (*fn)(const SPI_ABSTRACT_DEVICE*,const void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, const void*,size_t))pgm_read_word(&class->writeMany);
 1ee:	fc 01       	movw	r30, r24
 1f0:	3e 96       	adiw	r30, 0x0e	; 14
 1f2:	25 91       	lpm	r18, Z+
 1f4:	34 91       	lpm	r19, Z
 1f6:	f9 01       	movw	r30, r18

			if(fn){
 1f8:	30 97       	sbiw	r30, 0x00	; 0
 1fa:	01 f0       	breq	.+0      	; 0x1fc <spiAbstractDeviceSendBytes+0x62>
				// It has a special method for writing many bytes in a row
				fn(device,buff,size);
 1fc:	c5 01       	movw	r24, r10
 1fe:	61 2f       	mov	r22, r17
 200:	a7 01       	movw	r20, r14
 202:	09 95       	icall
 204:	00 c0       	rjmp	.+0      	; 0x206 <spiAbstractDeviceSendBytes+0x6c>
			}else{
				// No special routine so just write each in turn

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 206:	fc 01       	movw	r30, r24
 208:	3a 96       	adiw	r30, 0x0a	; 10
 20a:	85 91       	lpm	r24, Z+
 20c:	94 91       	lpm	r25, Z
 20e:	5c 01       	movw	r10, r24
				const uint8_t* dta = (const uint8_t*)buff;
 210:	81 2e       	mov	r8, r17
 212:	97 2e       	mov	r9, r23
				while(size--){
					fn(bus,*dta++);
 214:	f4 01       	movw	r30, r8
 216:	61 91       	ld	r22, Z+
 218:	4f 01       	movw	r8, r30
 21a:	c6 01       	movw	r24, r12
 21c:	f5 01       	movw	r30, r10
 21e:	09 95       	icall
 220:	08 94       	sec
 222:	e1 08       	sbc	r14, r1
 224:	f1 08       	sbc	r15, r1

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				const uint8_t* dta = (const uint8_t*)buff;
				while(size--){
 226:	e1 14       	cp	r14, r1
 228:	f1 04       	cpc	r15, r1
 22a:	01 f4       	brne	.+0      	; 0x22c <spiAbstractDeviceSendBytes+0x92>
 22c:	00 c0       	rjmp	.+0      	; 0x22e <spiAbstractDeviceSendBytes+0x94>
					fn(bus,*dta++);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 22e:	82 ee       	ldi	r24, 0xE2	; 226
 230:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		}
	}
}
 234:	0f 90       	pop	r0
 236:	df 91       	pop	r29
 238:	cf 91       	pop	r28
 23a:	1f 91       	pop	r17
 23c:	ff 90       	pop	r15
 23e:	ef 90       	pop	r14
 240:	df 90       	pop	r13
 242:	cf 90       	pop	r12
 244:	bf 90       	pop	r11
 246:	af 90       	pop	r10
 248:	9f 90       	pop	r9
 24a:	8f 90       	pop	r8
 24c:	08 95       	ret

0000024e <spiAbstractDeviceReceiveBytes>:
	xmit |= device->fillerByte;

	return spiAbstractDeviceXferWord(device, xmit);
}

void spiAbstractDeviceReceiveBytes(const SPI_ABSTRACT_DEVICE* device, void* buff, size_t size){
 24e:	6f 92       	push	r6
 250:	7f 92       	push	r7
 252:	8f 92       	push	r8
 254:	9f 92       	push	r9
 256:	af 92       	push	r10
 258:	bf 92       	push	r11
 25a:	cf 92       	push	r12
 25c:	df 92       	push	r13
 25e:	ef 92       	push	r14
 260:	ff 92       	push	r15
 262:	1f 93       	push	r17
 264:	cf 93       	push	r28
 266:	df 93       	push	r29
 268:	0f 92       	push	r0
 26a:	cd b7       	in	r28, 0x3d	; 61
 26c:	de b7       	in	r29, 0x3e	; 62
 26e:	6c 01       	movw	r12, r24
 270:	16 2f       	mov	r17, r22
 272:	7a 01       	movw	r14, r20
	if(size){
 274:	41 15       	cp	r20, r1
 276:	51 05       	cpc	r21, r1
 278:	01 f4       	brne	.+0      	; 0x27a <spiAbstractDeviceReceiveBytes+0x2c>
 27a:	00 c0       	rjmp	.+0      	; 0x27c <spiAbstractDeviceReceiveBytes+0x2e>
		// Select the device if required
		SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 27c:	fc 01       	movw	r30, r24
 27e:	a0 80       	ld	r10, Z
 280:	b1 80       	ldd	r11, Z+1	; 0x01

		if(bus){
 282:	a1 14       	cp	r10, r1
 284:	b1 04       	cpc	r11, r1
 286:	01 f0       	breq	.+0      	; 0x288 <spiAbstractDeviceReceiveBytes+0x3a>
			if(bus->selectedDevice != device){
 288:	f5 01       	movw	r30, r10
 28a:	82 85       	ldd	r24, Z+10	; 0x0a
 28c:	93 85       	ldd	r25, Z+11	; 0x0b
 28e:	8c 15       	cp	r24, r12
 290:	9d 05       	cpc	r25, r13
 292:	01 f0       	breq	.+0      	; 0x294 <spiAbstractDeviceReceiveBytes+0x46>
				spiAbstractDeviceSelect(device,TRUE);
 294:	c6 01       	movw	r24, r12
 296:	6f ef       	ldi	r22, 0xFF	; 255
 298:	79 83       	std	Y+1, r23	; 0x01
 29a:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 29e:	79 81       	ldd	r23, Y+1	; 0x01
			}
			const SPI_CLASS* class = bus->sclass;
 2a0:	f5 01       	movw	r30, r10
 2a2:	80 81       	ld	r24, Z
 2a4:	91 81       	ldd	r25, Z+1	; 0x01
			void (*fn)(const SPI_ABSTRACT_DEVICE*,void*,size_t) = (void (*)(const SPI_ABSTRACT_DEVICE*, void*,size_t))pgm_read_word(&class->readMany);
 2a6:	fc 01       	movw	r30, r24
 2a8:	3c 96       	adiw	r30, 0x0c	; 12
 2aa:	25 91       	lpm	r18, Z+
 2ac:	34 91       	lpm	r19, Z
 2ae:	f9 01       	movw	r30, r18

			if(fn){
 2b0:	30 97       	sbiw	r30, 0x00	; 0
 2b2:	01 f0       	breq	.+0      	; 0x2b4 <spiAbstractDeviceReceiveBytes+0x66>
				// It has a special method for receiving many bytes in a row
				fn(device,buff,size);
 2b4:	c6 01       	movw	r24, r12
 2b6:	61 2f       	mov	r22, r17
 2b8:	a7 01       	movw	r20, r14
 2ba:	09 95       	icall
 2bc:	00 c0       	rjmp	.+0      	; 0x2be <spiAbstractDeviceReceiveBytes+0x70>
			}else{
				// No special routine so just receive each in turn

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 2be:	fc 01       	movw	r30, r24
 2c0:	3a 96       	adiw	r30, 0x0a	; 10
 2c2:	85 91       	lpm	r24, Z+
 2c4:	94 91       	lpm	r25, Z
 2c6:	4c 01       	movw	r8, r24
				uint8_t* dta = (uint8_t*)buff;
 2c8:	61 2e       	mov	r6, r17
 2ca:	77 2e       	mov	r7, r23
				while(size--){
					*dta++ = fn(bus,device->fillerByte);
 2cc:	c5 01       	movw	r24, r10
 2ce:	f6 01       	movw	r30, r12
 2d0:	67 81       	ldd	r22, Z+7	; 0x07
 2d2:	f4 01       	movw	r30, r8
 2d4:	09 95       	icall
 2d6:	f3 01       	movw	r30, r6
 2d8:	81 93       	st	Z+, r24
 2da:	3f 01       	movw	r6, r30
 2dc:	08 94       	sec
 2de:	e1 08       	sbc	r14, r1
 2e0:	f1 08       	sbc	r15, r1

				// Get the routine for xfering one byte
				const SPI_CLASS* class = bus->sclass;
				uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
				uint8_t* dta = (uint8_t*)buff;
				while(size--){
 2e2:	e1 14       	cp	r14, r1
 2e4:	f1 04       	cpc	r15, r1
 2e6:	01 f4       	brne	.+0      	; 0x2e8 <spiAbstractDeviceReceiveBytes+0x9a>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <spiAbstractDeviceReceiveBytes+0x9c>
					*dta++ = fn(bus,device->fillerByte);
				}
			}
		}else{
			setError(SPI_BUS_NOT_INITIALIZED);
 2ea:	82 ee       	ldi	r24, 0xE2	; 226
 2ec:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		}

	}
}
 2f0:	0f 90       	pop	r0
 2f2:	df 91       	pop	r29
 2f4:	cf 91       	pop	r28
 2f6:	1f 91       	pop	r17
 2f8:	ff 90       	pop	r15
 2fa:	ef 90       	pop	r14
 2fc:	df 90       	pop	r13
 2fe:	cf 90       	pop	r12
 300:	bf 90       	pop	r11
 302:	af 90       	pop	r10
 304:	9f 90       	pop	r9
 306:	8f 90       	pop	r8
 308:	7f 90       	pop	r7
 30a:	6f 90       	pop	r6
 30c:	08 95       	ret

0000030e <spiAbstractDeviceXferByte>:
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
}

// Send a byte and receive a response
uint8_t spiAbstractDeviceXferByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
 30e:	1f 93       	push	r17
 310:	cf 93       	push	r28
 312:	df 93       	push	r29
 314:	16 2f       	mov	r17, r22
	SPI_ABSTRACT_BUS* bus = spiAbstractDeviceGetBus(device);
 316:	fc 01       	movw	r30, r24
 318:	c0 81       	ld	r28, Z
 31a:	d1 81       	ldd	r29, Z+1	; 0x01
	uint8_t rtn;
	if(bus){
 31c:	20 97       	sbiw	r28, 0x00	; 0
 31e:	01 f0       	breq	.+0      	; 0x320 <spiAbstractDeviceXferByte+0x12>
		// Select the device if required
		if(bus->selectedDevice != device){
 320:	2a 85       	ldd	r18, Y+10	; 0x0a
 322:	3b 85       	ldd	r19, Y+11	; 0x0b
 324:	28 17       	cp	r18, r24
 326:	39 07       	cpc	r19, r25
 328:	01 f0       	breq	.+0      	; 0x32a <spiAbstractDeviceXferByte+0x1c>
			spiAbstractDeviceSelect(device,TRUE);
 32a:	6f ef       	ldi	r22, 0xFF	; 255
 32c:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		}

		const SPI_CLASS* class = bus->sclass;
		uint8_t (*fn)(SPI_ABSTRACT_BUS*,uint8_t) = (uint8_t (*)(SPI_ABSTRACT_BUS*, uint8_t))pgm_read_word(&class->xfer);
 330:	e8 81       	ld	r30, Y
 332:	f9 81       	ldd	r31, Y+1	; 0x01
 334:	3a 96       	adiw	r30, 0x0a	; 10
 336:	25 91       	lpm	r18, Z+
 338:	34 91       	lpm	r19, Z
		rtn = fn(bus,data);
 33a:	ce 01       	movw	r24, r28
 33c:	61 2f       	mov	r22, r17
 33e:	f9 01       	movw	r30, r18
 340:	09 95       	icall
 342:	00 c0       	rjmp	.+0      	; 0x344 <spiAbstractDeviceXferByte+0x36>
	}else{
		setError(SPI_BUS_NOT_INITIALIZED);
 344:	82 ee       	ldi	r24, 0xE2	; 226
 346:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
		rtn = 0;
 34a:	80 e0       	ldi	r24, 0x00	; 0
	}
	return rtn;
}
 34c:	df 91       	pop	r29
 34e:	cf 91       	pop	r28
 350:	1f 91       	pop	r17
 352:	08 95       	ret

00000354 <spiAbstractDeviceXferWord>:
	spiAbstractDeviceSendByte(device, ((data>>8) & 0xFF) );
	spiAbstractDeviceSendByte(device, (data & 0xFF) );
}

// Send a 16 bit word and receive a response
uint16_t spiAbstractDeviceXferWord(const SPI_ABSTRACT_DEVICE* device, uint16_t data){
 354:	ff 92       	push	r15
 356:	0f 93       	push	r16
 358:	1f 93       	push	r17
 35a:	cf 93       	push	r28
 35c:	df 93       	push	r29
 35e:	ec 01       	movw	r28, r24
 360:	f6 2e       	mov	r15, r22
 362:	67 2f       	mov	r22, r23
	// Send MSB
	uint16_t rxData = spiAbstractDeviceXferByte( device, ((data>>8) & 0x00FF) )<<8;
 364:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 368:	18 2f       	mov	r17, r24
 36a:	00 e0       	ldi	r16, 0x00	; 0
	// send LSB
	rxData |= spiAbstractDeviceXferByte( device, data & 0x00FF) ;
 36c:	ce 01       	movw	r24, r28
 36e:	6f 2d       	mov	r22, r15
 370:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
 374:	90 e0       	ldi	r25, 0x00	; 0
 376:	80 2b       	or	r24, r16
 378:	91 2b       	or	r25, r17
    return rxData;
}
 37a:	df 91       	pop	r29
 37c:	cf 91       	pop	r28
 37e:	1f 91       	pop	r17
 380:	0f 91       	pop	r16
 382:	ff 90       	pop	r15
 384:	08 95       	ret

00000386 <spiAbstractDeviceReceiveWord>:
	return spiAbstractDeviceXferByte(device, device->fillerByte);
}

// Get a word from the device
uint16_t spiAbstractDeviceReceiveWord(const SPI_ABSTRACT_DEVICE* device){
	uint16_t xmit = device->fillerByte;
 386:	fc 01       	movw	r30, r24
 388:	27 81       	ldd	r18, Z+7	; 0x07
 38a:	30 e0       	ldi	r19, 0x00	; 0
	xmit <<= 8;
 38c:	72 2f       	mov	r23, r18
 38e:	66 27       	eor	r22, r22
	xmit |= device->fillerByte;
 390:	62 2b       	or	r22, r18
 392:	73 2b       	or	r23, r19

	return spiAbstractDeviceXferWord(device, xmit);
 394:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
}
 398:	08 95       	ret

0000039a <spiAbstractDeviceReceiveByte>:
	}
	return rtn;
}

// Get a byte from the device
uint8_t spiAbstractDeviceReceiveByte(const SPI_ABSTRACT_DEVICE* device){
 39a:	fc 01       	movw	r30, r24
	return spiAbstractDeviceXferByte(device, device->fillerByte);
 39c:	67 81       	ldd	r22, Z+7	; 0x07
 39e:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
}
 3a2:	08 95       	ret

000003a4 <spiAbstractDeviceSendByte>:

}

// Send a byte with no response
void spiAbstractDeviceSendByte(const SPI_ABSTRACT_DEVICE* device, uint8_t data){
	spiAbstractDeviceXferByte(device, data);
 3a4:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
}
 3a8:	08 95       	ret

000003aa <spiAbstractDeviceSendWord>:
}


//-------------- Implement common methonds
// Send a 16 bit word with no response
void spiAbstractDeviceSendWord(const SPI_ABSTRACT_DEVICE* device, uint16_t data){
 3aa:	1f 93       	push	r17
 3ac:	cf 93       	push	r28
 3ae:	df 93       	push	r29
 3b0:	ec 01       	movw	r28, r24
 3b2:	16 2f       	mov	r17, r22
 3b4:	67 2f       	mov	r22, r23
	spiAbstractDeviceSendByte(device, ((data>>8) & 0xFF) );
 3b6:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
	spiAbstractDeviceSendByte(device, (data & 0xFF) );
 3ba:	ce 01       	movw	r24, r28
 3bc:	61 2f       	mov	r22, r17
 3be:	0e 94 00 00 	call	0	; 0x0 <spiAbstractBusInit>
}
 3c2:	df 91       	pop	r29
 3c4:	cf 91       	pop	r28
 3c6:	1f 91       	pop	r17
 3c8:	08 95       	ret

000003ca <spiAbstractBusSetClock>:
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order) = (void (*)(SPI_ABSTRACT_BUS*,SPI_DATA_ORDER order))pgm_read_word(&class->order);
		fn(bus,order);
	}
}
void spiAbstractBusSetClock(SPI_ABSTRACT_BUS* bus,SPI_CLOCK clock){
	if(bus){
 3ca:	00 97       	sbiw	r24, 0x00	; 0
 3cc:	01 f0       	breq	.+0      	; 0x3ce <spiAbstractBusSetClock+0x4>
		bus->clock = clock;
 3ce:	dc 01       	movw	r26, r24
 3d0:	16 96       	adiw	r26, 0x06	; 6
 3d2:	6c 93       	st	X, r22
 3d4:	16 97       	sbiw	r26, 0x06	; 6
		const SPI_CLASS* class = bus->sclass;
		void (*fn)(SPI_ABSTRACT_BUS*,SPI_CLOCK clock) = (void (*)(SPI_ABSTRACT_BUS*,SPI_CLOCK clock))pgm_read_word(&class->clock);
 3d6:	ed 91       	ld	r30, X+
 3d8:	fc 91       	ld	r31, X
 3da:	34 96       	adiw	r30, 0x04	; 4
 3dc:	25 91       	lpm	r18, Z+
 3de:	34 91       	lpm	r19, Z
		fn(bus,clock);
 3e0:	f9 01       	movw	r30, r18
 3e2:	09 95       	icall
 3e4:	08 95       	ret

_uart_common.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000332  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000366  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000366  2**0
                  ALLOC
  3 .debug_info   00000a1c  00000000  00000000  00000366  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000260  00000000  00000000  00000d82  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000008aa  00000000  00000000  00000fe2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000188c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  000018ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000180  00000000  00000000  000018dc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003b8  00000000  00000000  00001a5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000018c  00000000  00000000  00001e14  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_uartTransmitBlockStart>:
	void (*fn)(UART*,uint8_t) = (void (*)(UART*,uint8_t))pgm_read_word(&class->startXmit);
	fn(uart,txData);
}

// We are starting to transmit a block
static void _uartTransmitBlockStart(UART* uart){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	ec 01       	movw	r28, r24
	uart->readyTx = FALSE;				// indicate we are sending
   6:	88 85       	ldd	r24, Y+8	; 0x08
   8:	8e 7f       	andi	r24, 0xFE	; 254
   a:	88 87       	std	Y+8, r24	; 0x08
	if(uart->xmitCallback){
   c:	ee 89       	ldd	r30, Y+22	; 0x16
   e:	ff 89       	ldd	r31, Y+23	; 0x17
  10:	30 97       	sbiw	r30, 0x00	; 0
  12:	01 f0       	breq	.+0      	; 0x14 <_uartTransmitBlockStart+0x14>
		uart->xmitCallback(uart->callbackParam,TRUE);
  14:	88 8d       	ldd	r24, Y+24	; 0x18
  16:	99 8d       	ldd	r25, Y+25	; 0x19
  18:	6f ef       	ldi	r22, 0xFF	; 255
  1a:	09 95       	icall
	}
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->startXmitMode);
  1c:	e9 85       	ldd	r30, Y+9	; 0x09
  1e:	fa 85       	ldd	r31, Y+10	; 0x0a
  20:	38 96       	adiw	r30, 0x08	; 8
  22:	85 91       	lpm	r24, Z+
  24:	94 91       	lpm	r25, Z
  26:	fc 01       	movw	r30, r24
	if(fn){
  28:	00 97       	sbiw	r24, 0x00	; 0
  2a:	01 f0       	breq	.+0      	; 0x2c <_uartTransmitBlockStart+0x2c>
		fn(uart);
  2c:	ce 01       	movw	r24, r28
  2e:	09 95       	icall
	}
}
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	08 95       	ret

00000036 <_uartTransmitBlockEnd>:

// We have finished transmitting a block
static void _uartTransmitBlockEnd(UART* uart){
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	ec 01       	movw	r28, r24
	uart->readyTx = TRUE;				// indicate we are no longer sending
  3c:	88 85       	ldd	r24, Y+8	; 0x08
  3e:	81 60       	ori	r24, 0x01	; 1
  40:	88 87       	std	Y+8, r24	; 0x08
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->endXmitMode);
  42:	e9 85       	ldd	r30, Y+9	; 0x09
  44:	fa 85       	ldd	r31, Y+10	; 0x0a
  46:	3a 96       	adiw	r30, 0x0a	; 10
  48:	85 91       	lpm	r24, Z+
  4a:	94 91       	lpm	r25, Z
  4c:	fc 01       	movw	r30, r24
	if(fn){
  4e:	00 97       	sbiw	r24, 0x00	; 0
  50:	01 f0       	breq	.+0      	; 0x52 <_uartTransmitBlockEnd+0x1c>
		fn(uart);
  52:	ce 01       	movw	r24, r28
  54:	09 95       	icall
	}
	if(uart->xmitCallback){
  56:	ee 89       	ldd	r30, Y+22	; 0x16
  58:	ff 89       	ldd	r31, Y+23	; 0x17
  5a:	30 97       	sbiw	r30, 0x00	; 0
  5c:	01 f0       	breq	.+0      	; 0x5e <_uartTransmitBlockEnd+0x28>
		uart->xmitCallback(uart->callbackParam,FALSE);
  5e:	88 8d       	ldd	r24, Y+24	; 0x18
  60:	99 8d       	ldd	r25, Y+25	; 0x19
  62:	60 e0       	ldi	r22, 0x00	; 0
  64:	09 95       	icall
	}

}
  66:	df 91       	pop	r29
  68:	cf 91       	pop	r28
  6a:	08 95       	ret

0000006c <_uartStartXmit>:


// Virutal function - start sending the given byte
void _uartStartXmit(UART* uart,uint8_t txData){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,uint8_t) = (void (*)(UART*,uint8_t))pgm_read_word(&class->startXmit);
  6c:	dc 01       	movw	r26, r24
  6e:	19 96       	adiw	r26, 0x09	; 9
  70:	ed 91       	ld	r30, X+
  72:	fc 91       	ld	r31, X
  74:	1a 97       	sbiw	r26, 0x0a	; 10
  76:	32 96       	adiw	r30, 0x02	; 2
  78:	25 91       	lpm	r18, Z+
  7a:	34 91       	lpm	r19, Z
	fn(uart,txData);
  7c:	f9 01       	movw	r30, r18
  7e:	09 95       	icall
}
  80:	08 95       	ret

00000082 <__uartReceiveService>:
}



// A byte has been received - interrupts are off
void __uartReceiveService(UART* uart, uint8_t c){
  82:	cf 93       	push	r28
  84:	df 93       	push	r29
  86:	ec 01       	movw	r28, r24
	// if there's a user function to handle this receive event
	if(uart->rxFunc){
  88:	2c 81       	ldd	r18, Y+4	; 0x04
  8a:	3d 81       	ldd	r19, Y+5	; 0x05
  8c:	21 15       	cp	r18, r1
  8e:	31 05       	cpc	r19, r1
  90:	01 f0       	breq	.+0      	; 0x92 <__uartReceiveService+0x10>
		// call it and pass the received data
		uart->rxFunc(c,uart->rxFuncData);
  92:	ec 81       	ldd	r30, Y+4	; 0x04
  94:	fd 81       	ldd	r31, Y+5	; 0x05
  96:	2e 81       	ldd	r18, Y+6	; 0x06
  98:	3f 81       	ldd	r19, Y+7	; 0x07
  9a:	86 2f       	mov	r24, r22
  9c:	b9 01       	movw	r22, r18
  9e:	09 95       	icall
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <__uartReceiveService+0x20>
	}else if( uart->rxBuffer ){
  a2:	28 81       	ld	r18, Y
  a4:	39 81       	ldd	r19, Y+1	; 0x01
  a6:	21 15       	cp	r18, r1
  a8:	31 05       	cpc	r19, r1
  aa:	01 f0       	breq	.+0      	; 0xac <__uartReceiveService+0x2a>
		// there is a receive buffer so try to append it
		if(bufferPut(__uartGetRxBuffer(uart),c)==FALSE){
  ac:	c9 01       	movw	r24, r18
  ae:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
  b2:	88 23       	and	r24, r24
  b4:	01 f4       	brne	.+0      	; 0xb6 <__uartReceiveService+0x34>
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <__uartReceiveService+0x36>
			// track overflows
			uart->rxOverflow=TRUE;
			setError(UART_RECEIVE_OVERFLOW);
		}
	}else{
		if(uart->rxChar == -1){
  b8:	2b 85       	ldd	r18, Y+11	; 0x0b
  ba:	3c 85       	ldd	r19, Y+12	; 0x0c
  bc:	8f ef       	ldi	r24, 0xFF	; 255
  be:	2f 3f       	cpi	r18, 0xFF	; 255
  c0:	38 07       	cpc	r19, r24
  c2:	01 f4       	brne	.+0      	; 0xc4 <__uartReceiveService+0x42>
			uart->rxChar = c;
  c4:	70 e0       	ldi	r23, 0x00	; 0
  c6:	7c 87       	std	Y+12, r23	; 0x0c
  c8:	6b 87       	std	Y+11, r22	; 0x0b
  ca:	00 c0       	rjmp	.+0      	; 0xcc <__uartReceiveService+0x4a>
		}else{
			uart->rxOverflow=TRUE;
  cc:	88 85       	ldd	r24, Y+8	; 0x08
  ce:	84 60       	ori	r24, 0x04	; 4
  d0:	88 87       	std	Y+8, r24	; 0x08
			setError(UART_RECEIVE_OVERFLOW);
  d2:	85 ef       	ldi	r24, 0xF5	; 245
  d4:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		}
	}
}
  d8:	df 91       	pop	r29
  da:	cf 91       	pop	r28
  dc:	08 95       	ret

000000de <__uartTransmitService>:

// We have finished transmitting the current byte
void __uartTransmitService(UART* uart){
  de:	ff 92       	push	r15
  e0:	0f 93       	push	r16
  e2:	1f 93       	push	r17
  e4:	cf 93       	push	r28
  e6:	df 93       	push	r29
  e8:	0f 92       	push	r0
  ea:	cd b7       	in	r28, 0x3d	; 61
  ec:	de b7       	in	r29, 0x3e	; 62
  ee:	8c 01       	movw	r16, r24
	if(uart->sendingBuffer){
  f0:	fc 01       	movw	r30, r24
  f2:	80 85       	ldd	r24, Z+8	; 0x08
		// there is a transmit buffer
		uint8_t c;

		CRITICAL_SECTION_START;
  f4:	ff b6       	in	r15, 0x3f	; 63
  f6:	f8 94       	cli
	}
}

// We have finished transmitting the current byte
void __uartTransmitService(UART* uart){
	if(uart->sendingBuffer){
  f8:	81 ff       	sbrs	r24, 1
  fa:	00 c0       	rjmp	.+0      	; 0xfc <__uartTransmitService+0x1e>
		// there is a transmit buffer
		uint8_t c;

		CRITICAL_SECTION_START;
		if(bufferGet(__uartGetTxBuffer(uart),&c)){
  fc:	82 81       	ldd	r24, Z+2	; 0x02
  fe:	93 81       	ldd	r25, Z+3	; 0x03
 100:	be 01       	movw	r22, r28
 102:	6f 5f       	subi	r22, 0xFF	; 255
 104:	7f 4f       	sbci	r23, 0xFF	; 255
 106:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 10a:	88 23       	and	r24, r24
 10c:	01 f0       	breq	.+0      	; 0x10e <__uartTransmitService+0x30>
			// send the next byte
			_uartStartXmit(uart,c);
 10e:	c8 01       	movw	r24, r16
 110:	69 81       	ldd	r22, Y+1	; 0x01
 112:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 116:	00 c0       	rjmp	.+0      	; 0x118 <__uartTransmitService+0x3a>
		}else{
			// all done
			_uartTransmitBlockEnd(uart);		// we have finished sending
 118:	c8 01       	movw	r24, r16
 11a:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
			uart->sendingBuffer = FALSE;		// we are not sending a buffer
 11e:	f8 01       	movw	r30, r16
 120:	80 85       	ldd	r24, Z+8	; 0x08
 122:	8d 7f       	andi	r24, 0xFD	; 253
 124:	80 87       	std	Z+8, r24	; 0x08
 126:	00 c0       	rjmp	.+0      	; 0x128 <__uartTransmitService+0x4a>
		}
		CRITICAL_SECTION_END;
	}else{
		CRITICAL_SECTION_START;
		// indicate transmit complete, back to ready
		_uartTransmitBlockEnd(uart);				// we have finished sending
 128:	c8 01       	movw	r24, r16
 12a:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		CRITICAL_SECTION_END;
 12e:	ff be       	out	0x3f, r15	; 63
	}
}
 130:	0f 90       	pop	r0
 132:	df 91       	pop	r29
 134:	cf 91       	pop	r28
 136:	1f 91       	pop	r17
 138:	0f 91       	pop	r16
 13a:	ff 90       	pop	r15
 13c:	08 95       	ret

0000013e <__uartGetByte>:


// Gets a single byte from the uart receive buffer.
// Returns the byte, or -1 if no byte is available (getchar-style).
int __uartGetByte(UART* uart){
 13e:	cf 93       	push	r28
 140:	df 93       	push	r29
 142:	0f 92       	push	r0
 144:	cd b7       	in	r28, 0x3d	; 61
 146:	de b7       	in	r29, 0x3e	; 62
 148:	fc 01       	movw	r30, r24
}

// Returns pointer to the receive buffer structure.
#define uartGetRxBuffer(uart) __uartGetRxBuffer(&((uart)->_uart_))
static __inline__ cBuffer* __uartGetRxBuffer(const UART* uart){
	return uart->rxBuffer;
 14a:	80 81       	ld	r24, Z
 14c:	91 81       	ldd	r25, Z+1	; 0x01
	// get single byte from receive buffer (if available)
	uint8_t c;
	int rtn;

	cBuffer* buffer = __uartGetRxBuffer(uart);
	if(buffer!=null){
 14e:	00 97       	sbiw	r24, 0x00	; 0
 150:	01 f0       	breq	.+0      	; 0x152 <__uartGetByte+0x14>
		// There is a receive buffer
		if(bufferGet(buffer,&c))
 152:	be 01       	movw	r22, r28
 154:	6f 5f       	subi	r22, 0xFF	; 255
 156:	7f 4f       	sbci	r23, 0xFF	; 255
 158:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 15c:	88 23       	and	r24, r24
 15e:	01 f0       	breq	.+0      	; 0x160 <__uartGetByte+0x22>
			rtn = c;
 160:	29 81       	ldd	r18, Y+1	; 0x01
 162:	30 e0       	ldi	r19, 0x00	; 0
 164:	00 c0       	rjmp	.+0      	; 0x166 <__uartGetByte+0x28>
		else
			rtn = -1;
	}else{
		CRITICAL_SECTION_START;
 166:	4f b7       	in	r20, 0x3f	; 63
 168:	f8 94       	cli
		rtn = uart->rxChar;		// get the last received char
 16a:	23 85       	ldd	r18, Z+11	; 0x0b
 16c:	34 85       	ldd	r19, Z+12	; 0x0c
		uart->rxChar = -1;		// and reset it
 16e:	8f ef       	ldi	r24, 0xFF	; 255
 170:	9f ef       	ldi	r25, 0xFF	; 255
 172:	94 87       	std	Z+12, r25	; 0x0c
 174:	83 87       	std	Z+11, r24	; 0x0b
		CRITICAL_SECTION_END;
 176:	4f bf       	out	0x3f, r20	; 63
 178:	00 c0       	rjmp	.+0      	; 0x17a <__uartGetByte+0x3c>
	if(buffer!=null){
		// There is a receive buffer
		if(bufferGet(buffer,&c))
			rtn = c;
		else
			rtn = -1;
 17a:	2f ef       	ldi	r18, 0xFF	; 255
 17c:	3f ef       	ldi	r19, 0xFF	; 255
		rtn = uart->rxChar;		// get the last received char
		uart->rxChar = -1;		// and reset it
		CRITICAL_SECTION_END;
	}
	return rtn;
}
 17e:	c9 01       	movw	r24, r18
 180:	0f 90       	pop	r0
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	08 95       	ret

00000188 <_uartSendByte>:
	}
}


// Sends a single byte over the uart.
uint8_t _uartSendByte(UART* uart, uint8_t txData){
 188:	0f 93       	push	r16
 18a:	1f 93       	push	r17
 18c:	cf 93       	push	r28
 18e:	df 93       	push	r29
 190:	ec 01       	movw	r28, r24
 192:	16 2f       	mov	r17, r22
	if(uart->txBuffer){
 194:	2a 81       	ldd	r18, Y+2	; 0x02
 196:	3b 81       	ldd	r19, Y+3	; 0x03
 198:	21 15       	cp	r18, r1
 19a:	31 05       	cpc	r19, r1
 19c:	01 f4       	brne	.+0      	; 0x19e <_uartSendByte+0x16>
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <_uartSendByte+0x18>
		// Wait if the buffer is full
		while(bufferIsFull(uart->txBuffer)){
			breathe();
 1a0:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>

// Sends a single byte over the uart.
uint8_t _uartSendByte(UART* uart, uint8_t txData){
	if(uart->txBuffer){
		// Wait if the buffer is full
		while(bufferIsFull(uart->txBuffer)){
 1a4:	8a 81       	ldd	r24, Y+2	; 0x02
 1a6:	9b 81       	ldd	r25, Y+3	; 0x03
 1a8:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 1ac:	88 23       	and	r24, r24
 1ae:	01 f4       	brne	.+0      	; 0x1b0 <_uartSendByte+0x28>
			breathe();
		}

		CRITICAL_SECTION_START;
 1b0:	0f b7       	in	r16, 0x3f	; 63
 1b2:	f8 94       	cli
		if(!uart->sendingBuffer){
 1b4:	88 85       	ldd	r24, Y+8	; 0x08
 1b6:	81 fd       	sbrc	r24, 1
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <_uartSendByte+0x32>
			// Not already transmitting so start sending the buffer
			uart->sendingBuffer = TRUE;			// we are sending a buffer
 1ba:	88 85       	ldd	r24, Y+8	; 0x08
 1bc:	82 60       	ori	r24, 0x02	; 2
 1be:	88 87       	std	Y+8, r24	; 0x08
 1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <_uartSendByte+0x3a>
			_uartTransmitBlockStart(uart);			// indicate we are sending
			_uartStartXmit(uart,txData);		// put the byte
		}else{
			// add char to the output queue
			bufferPut(uart->txBuffer,txData);
 1c2:	8a 81       	ldd	r24, Y+2	; 0x02
 1c4:	9b 81       	ldd	r25, Y+3	; 0x03
 1c6:	61 2f       	mov	r22, r17
 1c8:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <_uartSendByte+0x46>
	}else{
		// There is no xmit buffer - just send now

		// Wait till sending has stopped
		while(!uart->readyTx){
			breathe();
 1ce:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>

	}else{
		// There is no xmit buffer - just send now

		// Wait till sending has stopped
		while(!uart->readyTx){
 1d2:	88 85       	ldd	r24, Y+8	; 0x08
 1d4:	80 ff       	sbrs	r24, 0
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <_uartSendByte+0x50>
			breathe();
		}
		CRITICAL_SECTION_START;
 1d8:	0f b7       	in	r16, 0x3f	; 63
 1da:	f8 94       	cli
		_uartTransmitBlockStart(uart);			// indicate we are sending
 1dc:	ce 01       	movw	r24, r28
 1de:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		_uartStartXmit(uart,txData);		// put the byte
 1e2:	ce 01       	movw	r24, r28
 1e4:	61 2f       	mov	r22, r17
 1e6:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		CRITICAL_SECTION_END;
 1ea:	0f bf       	out	0x3f, r16	; 63
	}
	return txData;
}
 1ec:	81 2f       	mov	r24, r17
 1ee:	df 91       	pop	r29
 1f0:	cf 91       	pop	r28
 1f2:	1f 91       	pop	r17
 1f4:	0f 91       	pop	r16
 1f6:	08 95       	ret

000001f8 <_uartSendBuffer>:
	}
	return rtn;
}

// Send a block of data
void _uartSendBuffer(UART* uart, const uint8_t* data, size_t count){
 1f8:	ef 92       	push	r14
 1fa:	ff 92       	push	r15
 1fc:	0f 93       	push	r16
 1fe:	1f 93       	push	r17
 200:	cf 93       	push	r28
 202:	df 93       	push	r29
 204:	7c 01       	movw	r14, r24
 206:	8b 01       	movw	r16, r22
 208:	ea 01       	movw	r28, r20
	while(count--){
 20a:	00 c0       	rjmp	.+0      	; 0x20c <_uartSendBuffer+0x14>
		_uartSendByte(uart,*data++);
 20c:	f8 01       	movw	r30, r16
 20e:	61 91       	ld	r22, Z+
 210:	8f 01       	movw	r16, r30
 212:	c7 01       	movw	r24, r14
 214:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 218:	21 97       	sbiw	r28, 0x01	; 1
	return rtn;
}

// Send a block of data
void _uartSendBuffer(UART* uart, const uint8_t* data, size_t count){
	while(count--){
 21a:	20 97       	sbiw	r28, 0x00	; 0
 21c:	01 f4       	brne	.+0      	; 0x21e <_uartSendBuffer+0x26>
		_uartSendByte(uart,*data++);
	}
}
 21e:	df 91       	pop	r29
 220:	cf 91       	pop	r28
 222:	1f 91       	pop	r17
 224:	0f 91       	pop	r16
 226:	ff 90       	pop	r15
 228:	ef 90       	pop	r14
 22a:	08 95       	ret

0000022c <_uartSetBaudRate>:
	return txData;
}

void _uartSetBaudRate(UART* uart, BAUD_RATE baud){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,BAUD_RATE) = (void (*)(UART*,BAUD_RATE))pgm_read_word(&class->setBaudRate);
 22c:	dc 01       	movw	r26, r24
 22e:	19 96       	adiw	r26, 0x09	; 9
 230:	ed 91       	ld	r30, X+
 232:	fc 91       	ld	r31, X
 234:	1a 97       	sbiw	r26, 0x0a	; 10
 236:	25 91       	lpm	r18, Z+
 238:	34 91       	lpm	r19, Z
	fn(uart,baud);
 23a:	f9 01       	movw	r30, r18
 23c:	09 95       	icall
}
 23e:	08 95       	ret

00000240 <_uartOff>:

void _uartOff(UART* uart){
	const UART_CLASS* class = uart->class;
	void (*fn)(UART*) = (void (*)(UART*))pgm_read_word(&class->off);
 240:	dc 01       	movw	r26, r24
 242:	19 96       	adiw	r26, 0x09	; 9
 244:	ed 91       	ld	r30, X+
 246:	fc 91       	ld	r31, X
 248:	1a 97       	sbiw	r26, 0x0a	; 10
 24a:	36 96       	adiw	r30, 0x06	; 6
 24c:	25 91       	lpm	r18, Z+
 24e:	34 91       	lpm	r19, Z
 250:	f9 01       	movw	r30, r18

	// Wait till everything has been sent
	INTERRUPTABLE_SECTION_START;
 252:	2f b7       	in	r18, 0x3f	; 63
 254:	78 94       	sei
int __uartGetByte(UART* uart);

// Is the UART busy doing something?
#define uartIsBusy(uart) __uartIsBusy(&((uart)->_uart_))
static __inline__ boolean __uartIsBusy(UART* uart){
	return (uart->readyTx) ? FALSE : TRUE;
 256:	dc 01       	movw	r26, r24
 258:	18 96       	adiw	r26, 0x08	; 8
 25a:	3c 91       	ld	r19, X
 25c:	18 97       	sbiw	r26, 0x08	; 8
 25e:	30 ff       	sbrs	r19, 0
 260:	00 c0       	rjmp	.+0      	; 0x262 <_uartOff+0x22>
	while(__uartIsBusy(uart));
	INTERRUPTABLE_SECTION_END;
 262:	2f bf       	out	0x3f, r18	; 63

	fn(uart);
 264:	09 95       	icall
}
 266:	08 95       	ret

00000268 <_uartInit>:


void _uartInit(UART* uart, BAUD_RATE baud){
 268:	cf 92       	push	r12
 26a:	df 92       	push	r13
 26c:	ef 92       	push	r14
 26e:	ff 92       	push	r15
 270:	cf 93       	push	r28
 272:	df 93       	push	r29
 274:	ec 01       	movw	r28, r24
 276:	6a 01       	movw	r12, r20
 278:	7b 01       	movw	r14, r22
	cli();
 27a:	f8 94       	cli

	// For one wire Make the pins into inputs with pullups enabled
	if(_uartIsOneWire(uart)){
 27c:	8d 89       	ldd	r24, Y+21	; 0x15
 27e:	88 23       	and	r24, r24
 280:	01 f0       	breq	.+0      	; 0x282 <_uartInit+0x1a>
		if(uart->rx_pin != uart->tx_pin){
 282:	8d 85       	ldd	r24, Y+13	; 0x0d
 284:	9e 85       	ldd	r25, Y+14	; 0x0e
 286:	2f 85       	ldd	r18, Y+15	; 0x0f
 288:	38 89       	ldd	r19, Y+16	; 0x10
 28a:	82 17       	cp	r24, r18
 28c:	93 07       	cpc	r25, r19
 28e:	01 f0       	breq	.+0      	; 0x290 <_uartInit+0x28>
			pin_make_input(uart->rx_pin,FALSE);
 290:	60 e0       	ldi	r22, 0x00	; 0
 292:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
		}
		pin_make_input(uart->tx_pin,TRUE);
 296:	8f 85       	ldd	r24, Y+15	; 0x0f
 298:	98 89       	ldd	r25, Y+16	; 0x10
 29a:	6f ef       	ldi	r22, 0xFF	; 255
 29c:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
	}

	// Initialise local variable
	uart->readyTx = TRUE;
 2a0:	88 85       	ldd	r24, Y+8	; 0x08
 2a2:	81 60       	ori	r24, 0x01	; 1
 2a4:	88 87       	std	Y+8, r24	; 0x08
	uart->rxOverflow = FALSE;
 2a6:	88 85       	ldd	r24, Y+8	; 0x08
 2a8:	8b 7f       	andi	r24, 0xFB	; 251
 2aa:	88 87       	std	Y+8, r24	; 0x08
	uart->sendingBuffer = FALSE;
 2ac:	88 85       	ldd	r24, Y+8	; 0x08
 2ae:	8d 7f       	andi	r24, 0xFD	; 253
 2b0:	88 87       	std	Y+8, r24	; 0x08
//	uart->rxFunc = null;

	const UART_CLASS* class = uart->class;
	void (*fn)(UART*,BAUD_RATE) = (void (*)(UART*,BAUD_RATE))pgm_read_word(&class->init);
 2b2:	e9 85       	ldd	r30, Y+9	; 0x09
 2b4:	fa 85       	ldd	r31, Y+10	; 0x0a
 2b6:	34 96       	adiw	r30, 0x04	; 4
 2b8:	25 91       	lpm	r18, Z+
 2ba:	34 91       	lpm	r19, Z

	fn(uart,baud);
 2bc:	ce 01       	movw	r24, r28
 2be:	b7 01       	movw	r22, r14
 2c0:	a6 01       	movw	r20, r12
 2c2:	f9 01       	movw	r30, r18
 2c4:	09 95       	icall
	sei();
 2c6:	78 94       	sei
}
 2c8:	df 91       	pop	r29
 2ca:	cf 91       	pop	r28
 2cc:	ff 90       	pop	r15
 2ce:	ef 90       	pop	r14
 2d0:	df 90       	pop	r13
 2d2:	cf 90       	pop	r12
 2d4:	08 95       	ret

000002d6 <__uartFlushReceiveBuffer>:

void __uartFlushReceiveBuffer(UART* uart){
 2d6:	fc 01       	movw	r30, r24
}

// Returns pointer to the receive buffer structure.
#define uartGetRxBuffer(uart) __uartGetRxBuffer(&((uart)->_uart_))
static __inline__ cBuffer* __uartGetRxBuffer(const UART* uart){
	return uart->rxBuffer;
 2d8:	80 81       	ld	r24, Z
 2da:	91 81       	ldd	r25, Z+1	; 0x01
	if(__uartGetRxBuffer(uart)){
 2dc:	00 97       	sbiw	r24, 0x00	; 0
 2de:	01 f0       	breq	.+0      	; 0x2e0 <__uartFlushReceiveBuffer+0xa>
		// flush all data from receive buffer
		bufferFlush(__uartGetRxBuffer(uart));
 2e0:	0e 94 00 00 	call	0	; 0x0 <_uartTransmitBlockStart>
 2e4:	08 95       	ret
	}else{
		CRITICAL_SECTION_START;
 2e6:	2f b7       	in	r18, 0x3f	; 63
 2e8:	f8 94       	cli
		uart->rxChar = -1;
 2ea:	8f ef       	ldi	r24, 0xFF	; 255
 2ec:	9f ef       	ldi	r25, 0xFF	; 255
 2ee:	94 87       	std	Z+12, r25	; 0x0c
 2f0:	83 87       	std	Z+11, r24	; 0x0b
		CRITICAL_SECTION_END;
 2f2:	2f bf       	out	0x3f, r18	; 63
 2f4:	08 95       	ret

000002f6 <__uartReceiveBufferIsEmpty>:
	}
}

boolean __uartReceiveBufferIsEmpty(const UART* uart){
 2f6:	fc 01       	movw	r30, r24
	boolean rtn;
	if(__uartGetRxBuffer(uart)){
 2f8:	80 81       	ld	r24, Z
 2fa:	91 81       	ldd	r25, Z+1	; 0x01
		CRITICAL_SECTION_START;
 2fc:	2f b7       	in	r18, 0x3f	; 63
 2fe:	f8 94       	cli
	}
}

boolean __uartReceiveBufferIsEmpty(const UART* uart){
	boolean rtn;
	if(__uartGetRxBuffer(uart)){
 300:	00 97       	sbiw	r24, 0x00	; 0
 302:	01 f0       	breq	.+0      	; 0x304 <__uartReceiveBufferIsEmpty+0xe>
		CRITICAL_SECTION_START;
		rtn = (__uartGetRxBuffer(uart)->datalength == 0) ? TRUE : FALSE;
 304:	01 90       	ld	r0, Z+
 306:	f0 81       	ld	r31, Z
 308:	e0 2d       	mov	r30, r0
 30a:	84 81       	ldd	r24, Z+4	; 0x04
 30c:	95 81       	ldd	r25, Z+5	; 0x05
 30e:	00 97       	sbiw	r24, 0x00	; 0
 310:	01 f4       	brne	.+0      	; 0x312 <__uartReceiveBufferIsEmpty+0x1c>
 312:	8f ef       	ldi	r24, 0xFF	; 255
 314:	00 c0       	rjmp	.+0      	; 0x316 <__uartReceiveBufferIsEmpty+0x20>
 316:	80 e0       	ldi	r24, 0x00	; 0
		CRITICAL_SECTION_END;
 318:	2f bf       	out	0x3f, r18	; 63
 31a:	08 95       	ret
	}else{
		CRITICAL_SECTION_START;
		rtn = (uart->rxChar == -1) ? TRUE : FALSE;
 31c:	83 85       	ldd	r24, Z+11	; 0x0b
 31e:	94 85       	ldd	r25, Z+12	; 0x0c
 320:	3f ef       	ldi	r19, 0xFF	; 255
 322:	8f 3f       	cpi	r24, 0xFF	; 255
 324:	93 07       	cpc	r25, r19
 326:	01 f4       	brne	.+0      	; 0x328 <__uartReceiveBufferIsEmpty+0x32>
 328:	8f ef       	ldi	r24, 0xFF	; 255
 32a:	00 c0       	rjmp	.+0      	; 0x32c <__uartReceiveBufferIsEmpty+0x36>
 32c:	80 e0       	ldi	r24, 0x00	; 0
		CRITICAL_SECTION_END;
 32e:	2f bf       	out	0x3f, r18	; 63
	}
	return rtn;
}
 330:	08 95       	ret

a2d.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000098  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000cc  2**0
                  ALLOC
  3 .text.startup 0000006c  00000000  00000000  000000cc  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .ctors        00000002  00000000  00000000  00000138  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  5 .debug_info   0000029a  00000000  00000000  0000013a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_abbrev 000001a3  00000000  00000000  000003d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_loc    00000111  00000000  00000000  00000577  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_aranges 00000028  00000000  00000000  00000688  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_ranges 00000018  00000000  00000000  000006b0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_line   000000e0  00000000  00000000  000006c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_str    00000218  00000000  00000000  000007a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000090  00000000  00000000  000009c0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <a2dOff>:

volatile uint8_t a2dCompleteFlag;

// turn off a2d converter
void a2dOff(void){
	cbi(ADCSR, ADIE);				// disable ADC interrupts
   0:	ea e7       	ldi	r30, 0x7A	; 122
   2:	f0 e0       	ldi	r31, 0x00	; 0
   4:	80 81       	ld	r24, Z
   6:	87 7f       	andi	r24, 0xF7	; 247
   8:	80 83       	st	Z, r24
	cbi(ADCSR, ADEN);				// disable ADC (turn off ADC power)
   a:	80 81       	ld	r24, Z
   c:	8f 77       	andi	r24, 0x7F	; 127
   e:	80 83       	st	Z, r24
}
  10:	08 95       	ret

00000012 <a2dSetPrescaler>:

// configure A2D converter clock division (prescaling)
void a2dSetPrescaler(ADC_PRESCALE prescale){
	ADCSR =  (ADCSR & ~ADC_PRESCALE_MASK) | (prescale & ADC_PRESCALE_MASK);
  12:	ea e7       	ldi	r30, 0x7A	; 122
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	90 81       	ld	r25, Z
  18:	87 70       	andi	r24, 0x07	; 7
  1a:	98 7f       	andi	r25, 0xF8	; 248
  1c:	89 2b       	or	r24, r25
  1e:	80 83       	st	Z, r24
}
  20:	08 95       	ret

00000022 <a2dConvert10bit>:

// sets the a2d input channel
static void a2dSetChannel(ADC_CHANNEL ch){
#ifdef MUX5
	if(ch & 0x20){
    	ADCSRB |= _BV(MUX5);
  22:	90 91 7b 00 	lds	r25, 0x007B


// sets the a2d input channel
static void a2dSetChannel(ADC_CHANNEL ch){
#ifdef MUX5
	if(ch & 0x20){
  26:	85 ff       	sbrs	r24, 5
  28:	00 c0       	rjmp	.+0      	; 0x2a <a2dConvert10bit+0x8>
    	ADCSRB |= _BV(MUX5);
  2a:	98 60       	ori	r25, 0x08	; 8
  2c:	00 c0       	rjmp	.+0      	; 0x2e <a2dConvert10bit+0xc>
	}else{
    	ADCSRB &= ~_BV(MUX5);
  2e:	97 7f       	andi	r25, 0xF7	; 247
  30:	90 93 7b 00 	sts	0x007B, r25
	}
#endif
	ADMUX = (ADMUX & ~ADC_MUX_MASK) | (ch & ADC_MUX_MASK);	// set channel
  34:	90 91 7c 00 	lds	r25, 0x007C
  38:	8f 71       	andi	r24, 0x1F	; 31
  3a:	90 7e       	andi	r25, 0xE0	; 224
  3c:	89 2b       	or	r24, r25
  3e:	80 93 7c 00 	sts	0x007C, r24
}

// start a conversion on the current a2d input channel
static void a2dStartConvert(void){
	a2dCompleteFlag = FALSE;		// clear conversion complete flag
  42:	10 92 00 00 	sts	0x0000, r1
	sbi(ADCSR, ADIF);				// clear hardware "conversion complete" flag
  46:	80 91 7a 00 	lds	r24, 0x007A
  4a:	80 61       	ori	r24, 0x10	; 16
  4c:	80 93 7a 00 	sts	0x007A, r24
	sbi(ADCSR, ADSC);				// start conversion
  50:	80 91 7a 00 	lds	r24, 0x007A
  54:	80 64       	ori	r24, 0x40	; 64
  56:	80 93 7a 00 	sts	0x007A, r24
}

static boolean a2dIsComplete(void){
	return bit_is_set(ADCSR, ADSC) ? FALSE : TRUE;
  5a:	80 91 7a 00 	lds	r24, 0x007A
  5e:	86 fd       	sbrc	r24, 6
  60:	00 c0       	rjmp	.+0      	; 0x62 <a2dConvert10bit+0x40>
uint16_t a2dConvert10bit(ADC_CHANNEL ch)
{
	a2dSetChannel(ch);						// set the channel
	a2dStartConvert();						// start the conversion
	while( !a2dIsComplete() );				// wait until conversion complete
	return ADC;
  62:	80 91 78 00 	lds	r24, 0x0078
  66:	90 91 79 00 	lds	r25, 0x0079
}
  6a:	08 95       	ret

0000006c <a2dConvert8bit>:

// Perform a 8-bit conversion.
// starts conversion, waits until conversion is done, and returns result
uint8_t a2dConvert8bit(ADC_CHANNEL ch){
 	uint16_t rtn = a2dConvert10bit(ch)>>2;
  6c:	0e 94 00 00 	call	0	; 0x0 <a2dOff>
  70:	96 95       	lsr	r25
  72:	87 95       	ror	r24
  74:	96 95       	lsr	r25
  76:	87 95       	ror	r24
	return (uint8_t)rtn;
}
  78:	08 95       	ret

0000007a <__vector_29>:
// Interrupt handler for ADC complete interrupt.
#ifndef ADC_vect
#  error Missing ADC_vect
#endif
ISR(ADC_vect)
{
  7a:	1f 92       	push	r1
  7c:	0f 92       	push	r0
  7e:	0f b6       	in	r0, 0x3f	; 63
  80:	0f 92       	push	r0
  82:	11 24       	eor	r1, r1
  84:	8f 93       	push	r24
	// set the a2d conversion flag to indicate "complete"
	a2dCompleteFlag = TRUE;
  86:	8f ef       	ldi	r24, 0xFF	; 255
  88:	80 93 00 00 	sts	0x0000, r24
}
  8c:	8f 91       	pop	r24
  8e:	0f 90       	pop	r0
  90:	0f be       	out	0x3f, r0	; 63
  92:	0f 90       	pop	r0
  94:	1f 90       	pop	r1
  96:	18 95       	reti

Disassembly of section .text.startup:

00000000 <a2dInit>:


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
   4:	80 91 7a 00 	lds	r24, 0x007A
   8:	80 68       	ori	r24, 0x80	; 128
   a:	80 93 7a 00 	sts	0x007A, r24
	cbi(ADCSR, ADFR);				// default to single sample convert mode
   e:	80 91 7a 00 	lds	r24, 0x007A
  12:	8f 7d       	andi	r24, 0xDF	; 223
  14:	80 93 7a 00 	sts	0x007A, r24
	a2dSetPrescaler(ADC_DEFAULT_PRESCALE);	// set default prescaler
  18:	86 e0       	ldi	r24, 0x06	; 6
  1a:	0e 94 00 00 	call	0	; 0x0 <a2dInit>
	ADCSR =  (ADCSR & ~ADC_PRESCALE_MASK) | (prescale & ADC_PRESCALE_MASK);
}

// configure A2D converter voltage reference
static void a2dSetReference(uint8_t ref){
	ADMUX = (ADMUX & ~ADC_REFERENCE_MASK) | ((ref<<REFS0) & ADC_REFERENCE_MASK);
  1e:	80 91 7c 00 	lds	r24, 0x007C
  22:	8f 73       	andi	r24, 0x3F	; 63
  24:	80 64       	ori	r24, 0x40	; 64
  26:	80 93 7c 00 	sts	0x007C, r24
void __attribute__ ((constructor)) a2dInit(void){
	sbi(ADCSR, ADEN);				// enable ADC (turn on ADC power)
	cbi(ADCSR, ADFR);				// default to single sample convert mode
	a2dSetPrescaler(ADC_DEFAULT_PRESCALE);	// set default prescaler
	a2dSetReference(ADC_DEFAULT_REFERENCE);	// set default reference
	cbi(ADMUX, ADLAR);				// set to right-adjusted result
  2a:	80 91 7c 00 	lds	r24, 0x007C
  2e:	8f 7d       	andi	r24, 0xDF	; 223
  30:	80 93 7c 00 	sts	0x007C, r24

	sbi(ADCSR, ADIE);				// enable ADC interrupts
  34:	80 91 7a 00 	lds	r24, 0x007A
  38:	88 60       	ori	r24, 0x08	; 8
  3a:	80 93 7a 00 	sts	0x007A, r24
	a2dCompleteFlag = TRUE;			// not doing an a2d
  3e:	8f ef       	ldi	r24, 0xFF	; 255
  40:	80 93 00 00 	sts	0x0000, r24
	sei();							// turn on interrupts (if not already on)
  44:	78 94       	sei

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
  46:	c0 91 00 00 	lds	r28, 0x0000
  4a:	d0 e0       	ldi	r29, 0x00	; 0
  4c:	00 c0       	rjmp	.+0      	; 0x4e <a2dInit+0x4e>
	a2dCompleteFlag = TRUE;
}


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
  4e:	8c 2f       	mov	r24, r28
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
  50:	c8 30       	cpi	r28, 0x08	; 8
  52:	d1 05       	cpc	r29, r1
  54:	04 f0       	brlt	.+0      	; 0x56 <a2dInit+0x56>
	a2dCompleteFlag = TRUE;
}


// initialize a2d converter. This is called automatically at startup
void __attribute__ ((constructor)) a2dInit(void){
  56:	88 5e       	subi	r24, 0xE8	; 232
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
  58:	0e 94 00 00 	call	0	; 0x0 <a2dInit>
	a2dCompleteFlag = TRUE;			// not doing an a2d
	sei();							// turn on interrupts (if not already on)

	//read all ADC pins once to ensure full internal capacitor charge
	// (fixes poor ADC accuracy on first read)'
	for(int i=NUM_ADC_CHANNELS-1; i>=0; i--){
  5c:	21 97       	sbiw	r28, 0x01	; 1
  5e:	8f ef       	ldi	r24, 0xFF	; 255
  60:	cf 3f       	cpi	r28, 0xFF	; 255
  62:	d8 07       	cpc	r29, r24
  64:	01 f4       	brne	.+0      	; 0x66 <a2dInit+0x66>
		a2dConvert10bit(ADC_NUMBER_TO_CHANNEL(i));
	}
}
  66:	df 91       	pop	r29
  68:	cf 91       	pop	r28
  6a:	08 95       	ret

a2dReadMv.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000026  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000005a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000005a  2**0
                  ALLOC
  3 .debug_info   00000127  00000000  00000000  0000005a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000d7  00000000  00000000  00000181  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000005a  00000000  00000000  00000258  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000002b2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000009a  00000000  00000000  000002d2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000109  00000000  00000000  0000036c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000030  00000000  00000000  00000478  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <a2dReadMv>:
 *  Read a voltage on an a2d input in millivolts
 *  This requires a specification of what AVcc actually is ie 100%
 */
#include "a2d.h"
#include "core.h"
uint16_t a2dReadMv(ADC_CHANNEL channel){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17

	uint16_t val10 = a2dConvert10bit(channel);	// 0..1023
   4:	0e 94 00 00 	call	0	; 0x0 <a2dReadMv>
// Read the input voltage in mV ie 1000 = 1V based on  AVcc
uint16_t a2dReadMv(ADC_CHANNEL channel);

// Get AVcc in mV. This is constant.
static __inline__ uint16_t a2dGetAVcc(void){
	return pgm_read_word(&AVcc_MV);
   8:	e0 e0       	ldi	r30, 0x00	; 0
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	05 91       	lpm	r16, Z+
   e:	14 91       	lpm	r17, Z
	uint16_t avcc = a2dGetAVcc();
	return interpolateU(val10,0,1023, 0,avcc);
  10:	60 e0       	ldi	r22, 0x00	; 0
  12:	70 e0       	ldi	r23, 0x00	; 0
  14:	4f ef       	ldi	r20, 0xFF	; 255
  16:	53 e0       	ldi	r21, 0x03	; 3
  18:	20 e0       	ldi	r18, 0x00	; 0
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <a2dReadMv>

}
  20:	1f 91       	pop	r17
  22:	0f 91       	pop	r16
  24:	08 95       	ret

actuators.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000068  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000009c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000009c  2**0
                  ALLOC
  3 .debug_info   00000265  00000000  00000000  0000009c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000108  00000000  00000000  00000301  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000159  00000000  00000000  00000409  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000562  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000ad  00000000  00000000  00000582  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000194  00000000  00000000  0000062f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  000007c4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__act_setSpeed>:
 *      Author: Clive Webster
 */
#include "actuators.h"


void __act_setSpeed(__ACTUATOR* act, DRIVE_SPEED speed){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	// clamp it to the given range
	speed = CLAMP(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX);
   a:	61 38       	cpi	r22, 0x81	; 129
   c:	04 f4       	brge	.+0      	; 0xe <__act_setSpeed+0xe>
   e:	11 e8       	ldi	r17, 0x81	; 129

	// Get the driver class
	const __ACTUATOR_DRIVER_CLASS* driver=act->class;
  10:	e8 81       	ld	r30, Y
  12:	f9 81       	ldd	r31, Y+1	; 0x01

	// Call the setSpeed method on the class
	if(driver){
  14:	30 97       	sbiw	r30, 0x00	; 0
  16:	01 f0       	breq	.+0      	; 0x18 <__act_setSpeed+0x18>
		void (*fn)(__ACTUATOR*,DRIVE_SPEED speed) = (void (*)(__ACTUATOR*, DRIVE_SPEED speed))pgm_read_word(&driver->setSpeed);
  18:	85 91       	lpm	r24, Z+
  1a:	94 91       	lpm	r25, Z
  1c:	fc 01       	movw	r30, r24
		if(fn!=null){
  1e:	00 97       	sbiw	r24, 0x00	; 0
  20:	01 f0       	breq	.+0      	; 0x22 <__act_setSpeed+0x22>
			fn(act,(act->inverted) ? speed*-1 : speed);
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	61 2f       	mov	r22, r17
  26:	81 fd       	sbrc	r24, 1
  28:	61 95       	neg	r22
  2a:	ce 01       	movw	r24, r28
  2c:	09 95       	icall
		}
	}

	// Store the new speed - do this at the end so that the setSpeed method
	// can access the previous speed
	act->required_speed = speed;
  2e:	1a 83       	std	Y+2, r17	; 0x02
}
  30:	df 91       	pop	r29
  32:	cf 91       	pop	r28
  34:	1f 91       	pop	r17
  36:	08 95       	ret

00000038 <__act_setConnected>:


void __act_setConnected(__ACTUATOR* act,boolean connected){
	// Change the variable
	act->connected = connected;
  38:	36 2f       	mov	r19, r22
  3a:	31 70       	andi	r19, 0x01	; 1
  3c:	dc 01       	movw	r26, r24
  3e:	13 96       	adiw	r26, 0x03	; 3
  40:	2c 91       	ld	r18, X
  42:	13 97       	sbiw	r26, 0x03	; 3
  44:	2e 7f       	andi	r18, 0xFE	; 254
  46:	23 2b       	or	r18, r19
  48:	13 96       	adiw	r26, 0x03	; 3
  4a:	2c 93       	st	X, r18
  4c:	13 97       	sbiw	r26, 0x03	; 3

	// Get the driver class
	const __ACTUATOR_DRIVER_CLASS* driver=act->class;
  4e:	ed 91       	ld	r30, X+
  50:	fc 91       	ld	r31, X
  52:	11 97       	sbiw	r26, 0x01	; 1

	// Call the setSpeed method on the class
	if(driver){
  54:	30 97       	sbiw	r30, 0x00	; 0
  56:	01 f0       	breq	.+0      	; 0x58 <__act_setConnected+0x20>
		void (*fn)(__ACTUATOR*,boolean connected) = (void (*)(__ACTUATOR*, boolean connected))pgm_read_word(&driver->setConnected);
  58:	32 96       	adiw	r30, 0x02	; 2
  5a:	25 91       	lpm	r18, Z+
  5c:	34 91       	lpm	r19, Z
  5e:	f9 01       	movw	r30, r18
		if(fn!=null){
  60:	30 97       	sbiw	r30, 0x00	; 0
  62:	01 f0       	breq	.+0      	; 0x64 <__act_setConnected+0x2c>
			fn(act,connected);
  64:	09 95       	icall
  66:	08 95       	ret

buffer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000114  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000148  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000148  2**0
                  ALLOC
  3 .debug_info   000003c8  00000000  00000000  00000148  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000164  00000000  00000000  00000510  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000002dd  00000000  00000000  00000674  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000951  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000139  00000000  00000000  00000971  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000197  00000000  00000000  00000aaa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000098  00000000  00000000  00000c44  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferInit>:
 *      Author: Clive Webster
 */
#include "buffer.h"

// initialize a buffer to start at a given address and have given size
void bufferInit(cBuffer* buffer, uint8_t* start, size_t size){
   0:	fc 01       	movw	r30, r24
	// begin critical section
	CRITICAL_SECTION_START;
   2:	8f b7       	in	r24, 0x3f	; 63
   4:	f8 94       	cli
		// set start pointer of the buffer
		buffer->dataptr = start;
   6:	71 83       	std	Z+1, r23	; 0x01
   8:	60 83       	st	Z, r22
		buffer->size = size;
   a:	53 83       	std	Z+3, r21	; 0x03
   c:	42 83       	std	Z+2, r20	; 0x02
		// initialize index and length
		buffer->dataindex = buffer->datalength = 0;
   e:	15 82       	std	Z+5, r1	; 0x05
  10:	14 82       	std	Z+4, r1	; 0x04
  12:	17 82       	std	Z+7, r1	; 0x07
  14:	16 82       	std	Z+6, r1	; 0x06
		// end critical section
	CRITICAL_SECTION_END;
  16:	8f bf       	out	0x3f, r24	; 63
}
  18:	08 95       	ret

0000001a <bufferGet>:


boolean bufferGet(cBuffer* buffer, uint8_t* rtn){
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	ec 01       	movw	r28, r24
	boolean ok=FALSE;
	// begin critical section
	CRITICAL_SECTION_START;
  20:	2f b7       	in	r18, 0x3f	; 63
  22:	f8 94       	cli
	// make sure we have a receive buffer
	if(buffer && buffer->size){
  24:	00 97       	sbiw	r24, 0x00	; 0
  26:	01 f0       	breq	.+0      	; 0x28 <bufferGet+0xe>
  28:	8a 81       	ldd	r24, Y+2	; 0x02
  2a:	9b 81       	ldd	r25, Y+3	; 0x03
  2c:	00 97       	sbiw	r24, 0x00	; 0
  2e:	01 f0       	breq	.+0      	; 0x30 <bufferGet+0x16>
		// make sure we have data
		if(buffer->datalength){
  30:	8c 81       	ldd	r24, Y+4	; 0x04
  32:	9d 81       	ldd	r25, Y+5	; 0x05
  34:	00 97       	sbiw	r24, 0x00	; 0
  36:	01 f0       	breq	.+0      	; 0x38 <bufferGet+0x1e>
			// get the first character from buffer
			*rtn = buffer->dataptr[buffer->dataindex];
  38:	e8 81       	ld	r30, Y
  3a:	f9 81       	ldd	r31, Y+1	; 0x01
  3c:	8e 81       	ldd	r24, Y+6	; 0x06
  3e:	9f 81       	ldd	r25, Y+7	; 0x07
  40:	e8 0f       	add	r30, r24
  42:	f9 1f       	adc	r31, r25
  44:	80 81       	ld	r24, Z
  46:	fb 01       	movw	r30, r22
  48:	80 83       	st	Z, r24
			// move index down and decrement length
			buffer->dataindex = (buffer->dataindex + 1) % buffer->size;
  4a:	8e 81       	ldd	r24, Y+6	; 0x06
  4c:	9f 81       	ldd	r25, Y+7	; 0x07
  4e:	01 96       	adiw	r24, 0x01	; 1
  50:	6a 81       	ldd	r22, Y+2	; 0x02
  52:	7b 81       	ldd	r23, Y+3	; 0x03
  54:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  58:	9f 83       	std	Y+7, r25	; 0x07
  5a:	8e 83       	std	Y+6, r24	; 0x06
			buffer->datalength--;
  5c:	8c 81       	ldd	r24, Y+4	; 0x04
  5e:	9d 81       	ldd	r25, Y+5	; 0x05
  60:	01 97       	sbiw	r24, 0x01	; 1
  62:	9d 83       	std	Y+5, r25	; 0x05
  64:	8c 83       	std	Y+4, r24	; 0x04
			ok = TRUE;
  66:	8f ef       	ldi	r24, 0xFF	; 255
  68:	00 c0       	rjmp	.+0      	; 0x6a <bufferGet+0x50>
	CRITICAL_SECTION_END;
}


boolean bufferGet(cBuffer* buffer, uint8_t* rtn){
	boolean ok=FALSE;
  6a:	80 e0       	ldi	r24, 0x00	; 0
			ok = TRUE;
		}
	}

	// end critical section
	CRITICAL_SECTION_END;
  6c:	2f bf       	out	0x3f, r18	; 63
	return ok;
}
  6e:	df 91       	pop	r29
  70:	cf 91       	pop	r28
  72:	08 95       	ret

00000074 <bufferPut>:


// add a byte to the end of the buffer
boolean	bufferPut(cBuffer* buffer, uint8_t data){
  74:	cf 93       	push	r28
  76:	fc 01       	movw	r30, r24
  78:	46 2f       	mov	r20, r22
	boolean rtn=FALSE; // failure

	// begin critical section
	CRITICAL_SECTION_START;
  7a:	cf b7       	in	r28, 0x3f	; 63
  7c:	f8 94       	cli

		// make sure the buffer has room
		if(buffer->datalength < buffer->size)
  7e:	24 81       	ldd	r18, Z+4	; 0x04
  80:	35 81       	ldd	r19, Z+5	; 0x05
  82:	62 81       	ldd	r22, Z+2	; 0x02
  84:	73 81       	ldd	r23, Z+3	; 0x03
  86:	26 17       	cp	r18, r22
  88:	37 07       	cpc	r19, r23
  8a:	00 f4       	brcc	.+0      	; 0x8c <bufferPut+0x18>
		{
			// save data byte at end of buffer
			buffer->dataptr[(buffer->dataindex + buffer->datalength) % buffer->size] = data;
  8c:	86 81       	ldd	r24, Z+6	; 0x06
  8e:	97 81       	ldd	r25, Z+7	; 0x07
  90:	82 0f       	add	r24, r18
  92:	93 1f       	adc	r25, r19
  94:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  98:	a0 81       	ld	r26, Z
  9a:	b1 81       	ldd	r27, Z+1	; 0x01
  9c:	a8 0f       	add	r26, r24
  9e:	b9 1f       	adc	r27, r25
  a0:	4c 93       	st	X, r20
			// increment the length
			buffer->datalength++;
  a2:	84 81       	ldd	r24, Z+4	; 0x04
  a4:	95 81       	ldd	r25, Z+5	; 0x05
  a6:	01 96       	adiw	r24, 0x01	; 1
  a8:	95 83       	std	Z+5, r25	; 0x05
  aa:	84 83       	std	Z+4, r24	; 0x04
			// return success
			rtn = TRUE;
  ac:	8f ef       	ldi	r24, 0xFF	; 255
  ae:	00 c0       	rjmp	.+0      	; 0xb0 <bufferPut+0x3c>
}


// add a byte to the end of the buffer
boolean	bufferPut(cBuffer* buffer, uint8_t data){
	boolean rtn=FALSE; // failure
  b0:	80 e0       	ldi	r24, 0x00	; 0
			buffer->datalength++;
			// return success
			rtn = TRUE;
		}
		// end critical section
	CRITICAL_SECTION_END;
  b2:	cf bf       	out	0x3f, r28	; 63
	return rtn;
}
  b4:	cf 91       	pop	r28
  b6:	08 95       	ret

000000b8 <bufferFreeSpace>:

size_t bufferFreeSpace(const cBuffer* buffer){
  b8:	fc 01       	movw	r30, r24
	size_t rtn;
	CRITICAL_SECTION{
  ba:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  bc:	f8 94       	cli
		rtn =  (buffer) ? buffer->size - buffer->datalength : 0;
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	01 f0       	breq	.+0      	; 0xc2 <bufferFreeSpace+0xa>
  c2:	22 81       	ldd	r18, Z+2	; 0x02
  c4:	33 81       	ldd	r19, Z+3	; 0x03
  c6:	84 81       	ldd	r24, Z+4	; 0x04
  c8:	95 81       	ldd	r25, Z+5	; 0x05
  ca:	28 1b       	sub	r18, r24
  cc:	39 0b       	sbc	r19, r25
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <bufferFreeSpace+0x18>
  d0:	20 e0       	ldi	r18, 0x00	; 0
  d2:	30 e0       	ldi	r19, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  d4:	4f bf       	out	0x3f, r20	; 63
	}
	return rtn;
}
  d6:	c9 01       	movw	r24, r18
  d8:	08 95       	ret

000000da <bufferBytesUsed>:

size_t bufferBytesUsed(const cBuffer* buffer){
	size_t rtn;
	CRITICAL_SECTION{
  da:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  dc:	f8 94       	cli
		rtn =  (buffer) ? buffer->datalength : 0;
  de:	00 97       	sbiw	r24, 0x00	; 0
  e0:	01 f0       	breq	.+0      	; 0xe2 <bufferBytesUsed+0x8>
  e2:	fc 01       	movw	r30, r24
  e4:	84 81       	ldd	r24, Z+4	; 0x04
  e6:	95 81       	ldd	r25, Z+5	; 0x05
  e8:	00 c0       	rjmp	.+0      	; 0xea <bufferBytesUsed+0x10>
  ea:	80 e0       	ldi	r24, 0x00	; 0
  ec:	90 e0       	ldi	r25, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  ee:	2f bf       	out	0x3f, r18	; 63
	}
	return rtn;
}
  f0:	08 95       	ret

000000f2 <bufferIsFull>:

boolean bufferIsFull(const cBuffer* buffer){
	return (bufferFreeSpace(buffer)==0) ? TRUE : FALSE;
  f2:	0e 94 00 00 	call	0	; 0x0 <bufferInit>
  f6:	00 97       	sbiw	r24, 0x00	; 0
  f8:	01 f4       	brne	.+0      	; 0xfa <bufferIsFull+0x8>
  fa:	8f ef       	ldi	r24, 0xFF	; 255
  fc:	08 95       	ret
  fe:	80 e0       	ldi	r24, 0x00	; 0
}
 100:	08 95       	ret

00000102 <bufferFlush>:

// flush (clear) the contents of the buffer
void bufferFlush(cBuffer* buffer){
	if(buffer){
 102:	00 97       	sbiw	r24, 0x00	; 0
 104:	01 f0       	breq	.+0      	; 0x106 <bufferFlush+0x4>
		// begin critical section
		CRITICAL_SECTION{
 106:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 108:	f8 94       	cli
			// flush contents of the buffer
			buffer->datalength = 0;
 10a:	fc 01       	movw	r30, r24
 10c:	15 82       	std	Z+5, r1	; 0x05
 10e:	14 82       	std	Z+4, r1	; 0x04
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 110:	2f bf       	out	0x3f, r18	; 63
 112:	08 95       	ret

buffer2.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000a2  2**0
                  ALLOC
  3 .debug_info   000001e0  00000000  00000000  000000a2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000109  00000000  00000000  00000282  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000011f  00000000  00000000  0000038b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000004aa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000e5  00000000  00000000  000004ca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000156  00000000  00000000  000005af  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000040  00000000  00000000  00000708  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <bufferDump>:
 *      Author: Clive Webster
 */
#include "buffer.h"

// dump (discard) the first numbytes from the front of the buffer
void bufferDump(cBuffer* buffer, size_t numbytes){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
   6:	9b 01       	movw	r18, r22
	// begin critical section
	CRITICAL_SECTION_START;
   8:	4f b7       	in	r20, 0x3f	; 63
   a:	f8 94       	cli
		// dump numbytes from the front of the buffer
		// are we dumping less than the entire buffer?
		if(numbytes < buffer->datalength){
   c:	c4 81       	ldd	r28, Z+4	; 0x04
   e:	d5 81       	ldd	r29, Z+5	; 0x05
  10:	6c 17       	cp	r22, r28
  12:	7d 07       	cpc	r23, r29
  14:	00 f4       	brcc	.+0      	; 0x16 <bufferDump+0x16>
			// move index down by numbytes and decrement length by numbytes
			buffer->dataindex = (buffer->dataindex + numbytes) % buffer->size;
  16:	86 81       	ldd	r24, Z+6	; 0x06
  18:	97 81       	ldd	r25, Z+7	; 0x07
  1a:	86 0f       	add	r24, r22
  1c:	97 1f       	adc	r25, r23
  1e:	62 81       	ldd	r22, Z+2	; 0x02
  20:	73 81       	ldd	r23, Z+3	; 0x03
  22:	0e 94 00 00 	call	0	; 0x0 <bufferDump>
  26:	97 83       	std	Z+7, r25	; 0x07
  28:	86 83       	std	Z+6, r24	; 0x06
			buffer->datalength -= numbytes;
  2a:	c2 1b       	sub	r28, r18
  2c:	d3 0b       	sbc	r29, r19
  2e:	d5 83       	std	Z+5, r29	; 0x05
  30:	c4 83       	std	Z+4, r28	; 0x04
  32:	00 c0       	rjmp	.+0      	; 0x34 <bufferDump+0x34>
		}else{
			// flush the whole buffer
			buffer->datalength = 0;
  34:	15 82       	std	Z+5, r1	; 0x05
  36:	14 82       	std	Z+4, r1	; 0x04
		}
		// end critical section
	CRITICAL_SECTION_END;
  38:	4f bf       	out	0x3f, r20	; 63
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	08 95       	ret

00000040 <bufferGetAtIndex>:

// get a byte at the specified index in the buffer (kind of like array access)
// ** note: this does not remove the byte that was read from the buffer
uint8_t	bufferGetAtIndex(const cBuffer* buffer, size_t index){
  40:	fc 01       	movw	r30, r24
	uint8_t data;

	// begin critical section
	CRITICAL_SECTION{
  42:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  44:	f8 94       	cli
		// return character at index in buffer
		data = (buffer) ? buffer->dataptr[(buffer->dataindex+index)%(buffer->size)] : 0;
  46:	00 97       	sbiw	r24, 0x00	; 0
  48:	01 f0       	breq	.+0      	; 0x4a <bufferGetAtIndex+0xa>
  4a:	86 81       	ldd	r24, Z+6	; 0x06
  4c:	97 81       	ldd	r25, Z+7	; 0x07
  4e:	86 0f       	add	r24, r22
  50:	97 1f       	adc	r25, r23
  52:	62 81       	ldd	r22, Z+2	; 0x02
  54:	73 81       	ldd	r23, Z+3	; 0x03
  56:	0e 94 00 00 	call	0	; 0x0 <bufferDump>
  5a:	01 90       	ld	r0, Z+
  5c:	f0 81       	ld	r31, Z
  5e:	e0 2d       	mov	r30, r0
  60:	e8 0f       	add	r30, r24
  62:	f9 1f       	adc	r31, r25
  64:	80 81       	ld	r24, Z
  66:	00 c0       	rjmp	.+0      	; 0x68 <bufferGetAtIndex+0x28>
  68:	80 e0       	ldi	r24, 0x00	; 0
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  6a:	2f bf       	out	0x3f, r18	; 63
		// end critical section
	}
	return data;
}
  6c:	08 95       	ret

color1.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000022a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000025e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000025e  2**0
                  ALLOC
  3 .debug_info   0000025d  00000000  00000000  0000025e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000014c  00000000  00000000  000004bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000023b  00000000  00000000  00000607  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000842  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000009f  00000000  00000000  00000862  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000128  00000000  00000000  00000901  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000084  00000000  00000000  00000a2c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <color2rgb>:
#include "color.h"
#include <string.h>		// for memcpy


// Convert the color to RGB
COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest){		// Convert the color to RGB
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <color2rgb+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <color2rgb+0x28>
  28:	cd b7       	in	r28, 0x3d	; 61
  2a:	de b7       	in	r29, 0x3e	; 62
  2c:	6c 01       	movw	r12, r24
  2e:	7a 83       	std	Y+2, r23	; 0x02
  30:	69 83       	std	Y+1, r22	; 0x01
	switch(src->colorSpace){
  32:	fc 01       	movw	r30, r24
  34:	80 81       	ld	r24, Z
  36:	88 23       	and	r24, r24
  38:	01 f0       	breq	.+0      	; 0x3a <color2rgb+0x3a>
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <color2rgb+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <color2rgb+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <color2rgb+0x42>

	case RGB:{
		// Nothing to do
		if(dest!=src){
  42:	89 81       	ldd	r24, Y+1	; 0x01
  44:	9a 81       	ldd	r25, Y+2	; 0x02
  46:	8c 15       	cp	r24, r12
  48:	9d 05       	cpc	r25, r13
  4a:	01 f4       	brne	.+0      	; 0x4c <color2rgb+0x4c>
  4c:	00 c0       	rjmp	.+0      	; 0x4e <color2rgb+0x4e>
			memcpy(dest, src, sizeof(COLOR));
  4e:	f6 01       	movw	r30, r12
  50:	80 81       	ld	r24, Z
  52:	91 81       	ldd	r25, Z+1	; 0x01
  54:	a2 81       	ldd	r26, Z+2	; 0x02
  56:	b3 81       	ldd	r27, Z+3	; 0x03
  58:	e9 81       	ldd	r30, Y+1	; 0x01
  5a:	fa 81       	ldd	r31, Y+2	; 0x02
  5c:	80 83       	st	Z, r24
  5e:	91 83       	std	Z+1, r25	; 0x01
  60:	a2 83       	std	Z+2, r26	; 0x02
  62:	b3 83       	std	Z+3, r27	; 0x03
  64:	00 c0       	rjmp	.+0      	; 0x66 <color2rgb+0x66>
		r = (int) (( 298.082 * Y               + 408.583 * V  ) / 256 - 222.921);
		g = (int) (( 298.082 * Y - 100.291 * U - 208.120 * V  ) / 256 + 135.576);
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
  66:	f6 01       	movw	r30, r12
  68:	61 81       	ldd	r22, Z+1	; 0x01
		int Cb = src->bands.yuv.u;
		int Cr = src->bands.yuv.v;

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
  6a:	70 e0       	ldi	r23, 0x00	; 0
  6c:	80 e0       	ldi	r24, 0x00	; 0
  6e:	90 e0       	ldi	r25, 0x00	; 0
  70:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  74:	2f e7       	ldi	r18, 0x7F	; 127
  76:	3a e0       	ldi	r19, 0x0A	; 10
  78:	45 e9       	ldi	r20, 0x95	; 149
  7a:	53 e4       	ldi	r21, 0x43	; 67
  7c:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  80:	16 2f       	mov	r17, r22
  82:	07 2f       	mov	r16, r23
  84:	38 2e       	mov	r3, r24
  86:	29 2e       	mov	r2, r25
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
		int Cb = src->bands.yuv.u;
		int Cr = src->bands.yuv.v;
  88:	f6 01       	movw	r30, r12
  8a:	63 81       	ldd	r22, Z+3	; 0x03

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
  8c:	70 e0       	ldi	r23, 0x00	; 0
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	90 e0       	ldi	r25, 0x00	; 0
  92:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  96:	2b 01       	movw	r4, r22
  98:	3c 01       	movw	r6, r24
  9a:	20 ea       	ldi	r18, 0xA0	; 160
  9c:	3a e4       	ldi	r19, 0x4A	; 74
  9e:	4c ec       	ldi	r20, 0xCC	; 204
  a0:	53 e4       	ldi	r21, 0x43	; 67
  a2:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  a6:	9b 01       	movw	r18, r22
  a8:	ac 01       	movw	r20, r24
  aa:	f8 01       	movw	r30, r16
  ac:	b1 01       	movw	r22, r2
  ae:	8f 2f       	mov	r24, r31
  b0:	9e 2f       	mov	r25, r30
  b2:	a7 2f       	mov	r26, r23
  b4:	b6 2f       	mov	r27, r22
  b6:	bc 01       	movw	r22, r24
  b8:	cd 01       	movw	r24, r26
  ba:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  be:	20 e0       	ldi	r18, 0x00	; 0
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	40 e8       	ldi	r20, 0x80	; 128
  c4:	5b e3       	ldi	r21, 0x3B	; 59
  c6:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  ca:	27 ec       	ldi	r18, 0xC7	; 199
  cc:	3b ee       	ldi	r19, 0xEB	; 235
  ce:	4e e5       	ldi	r20, 0x5E	; 94
  d0:	53 e4       	ldi	r21, 0x43	; 67
  d2:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  d6:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  da:	6b 83       	std	Y+3, r22	; 0x03
  dc:	7c 83       	std	Y+4, r23	; 0x04
		g = (int) (( 298.082 * Y - 100.291 * U - 208.120 * V  ) / 256 + 135.576);
		b = (int) (( 298.082 * Y + 516.412 * U                ) / 256 - 276.836);
		*/

		int Y = src->bands.yuv.y;
		int Cb = src->bands.yuv.u;
  de:	f6 01       	movw	r30, r12
  e0:	62 81       	ldd	r22, Z+2	; 0x02
		int Cr = src->bands.yuv.v;

		int r,g,b;
		r = (int) (( 298.082 * Y                + 408.583 * Cr ) / 256 - 222.921);
		g = (int) (( 298.082 * Y - 100.291 * Cb - 208.120 * Cr ) / 256 + 135.576);
  e2:	70 e0       	ldi	r23, 0x00	; 0
  e4:	80 e0       	ldi	r24, 0x00	; 0
  e6:	90 e0       	ldi	r25, 0x00	; 0
  e8:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  ec:	6b 01       	movw	r12, r22
  ee:	7c 01       	movw	r14, r24
  f0:	2e ef       	ldi	r18, 0xFE	; 254
  f2:	34 e9       	ldi	r19, 0x94	; 148
  f4:	48 ec       	ldi	r20, 0xC8	; 200
  f6:	52 e4       	ldi	r21, 0x42	; 66
  f8:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
  fc:	9b 01       	movw	r18, r22
  fe:	ac 01       	movw	r20, r24
 100:	f8 01       	movw	r30, r16
 102:	b1 01       	movw	r22, r2
 104:	8f 2f       	mov	r24, r31
 106:	9e 2f       	mov	r25, r30
 108:	a7 2f       	mov	r26, r23
 10a:	b6 2f       	mov	r27, r22
 10c:	bc 01       	movw	r22, r24
 10e:	cd 01       	movw	r24, r26
 110:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 114:	4b 01       	movw	r8, r22
 116:	5c 01       	movw	r10, r24
 118:	c3 01       	movw	r24, r6
 11a:	b2 01       	movw	r22, r4
 11c:	28 eb       	ldi	r18, 0xB8	; 184
 11e:	3e e1       	ldi	r19, 0x1E	; 30
 120:	40 e5       	ldi	r20, 0x50	; 80
 122:	53 e4       	ldi	r21, 0x43	; 67
 124:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 128:	9b 01       	movw	r18, r22
 12a:	ac 01       	movw	r20, r24
 12c:	c5 01       	movw	r24, r10
 12e:	b4 01       	movw	r22, r8
 130:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 134:	20 e0       	ldi	r18, 0x00	; 0
 136:	30 e0       	ldi	r19, 0x00	; 0
 138:	40 e8       	ldi	r20, 0x80	; 128
 13a:	5b e3       	ldi	r21, 0x3B	; 59
 13c:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 140:	25 e7       	ldi	r18, 0x75	; 117
 142:	33 e9       	ldi	r19, 0x93	; 147
 144:	47 e0       	ldi	r20, 0x07	; 7
 146:	53 e4       	ldi	r21, 0x43	; 67
 148:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 14c:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 150:	46 2e       	mov	r4, r22
 152:	87 2e       	mov	r8, r23
		b = (int) (( 298.082 * Y + 516.412 * Cb                ) / 256 - 276.836);
 154:	c7 01       	movw	r24, r14
 156:	b6 01       	movw	r22, r12
 158:	2e e5       	ldi	r18, 0x5E	; 94
 15a:	3a e1       	ldi	r19, 0x1A	; 26
 15c:	41 e0       	ldi	r20, 0x01	; 1
 15e:	54 e4       	ldi	r21, 0x44	; 68
 160:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 164:	9b 01       	movw	r18, r22
 166:	ac 01       	movw	r20, r24
 168:	f8 01       	movw	r30, r16
 16a:	b1 01       	movw	r22, r2
 16c:	8f 2f       	mov	r24, r31
 16e:	9e 2f       	mov	r25, r30
 170:	a7 2f       	mov	r26, r23
 172:	b6 2f       	mov	r27, r22
 174:	bc 01       	movw	r22, r24
 176:	cd 01       	movw	r24, r26
 178:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 17c:	20 e0       	ldi	r18, 0x00	; 0
 17e:	30 e0       	ldi	r19, 0x00	; 0
 180:	40 e8       	ldi	r20, 0x80	; 128
 182:	5b e3       	ldi	r21, 0x3B	; 59
 184:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 188:	22 e0       	ldi	r18, 0x02	; 2
 18a:	3b e6       	ldi	r19, 0x6B	; 107
 18c:	4a e8       	ldi	r20, 0x8A	; 138
 18e:	53 e4       	ldi	r21, 0x43	; 67
 190:	0e 94 00 00 	call	0	; 0x0 <color2rgb>
 194:	0e 94 00 00 	call	0	; 0x0 <color2rgb>

		r = CLAMP(r,0,255);
 198:	2b 81       	ldd	r18, Y+3	; 0x03
 19a:	3c 81       	ldd	r19, Y+4	; 0x04
 19c:	2f 3f       	cpi	r18, 0xFF	; 255
 19e:	31 05       	cpc	r19, r1
 1a0:	01 f0       	breq	.+0      	; 0x1a2 <color2rgb+0x1a2>
 1a2:	04 f0       	brlt	.+0      	; 0x1a4 <color2rgb+0x1a4>
 1a4:	2f ef       	ldi	r18, 0xFF	; 255
 1a6:	30 e0       	ldi	r19, 0x00	; 0
		g = CLAMP(g,0,255);
 1a8:	84 2d       	mov	r24, r4
 1aa:	98 2d       	mov	r25, r8
 1ac:	8f 3f       	cpi	r24, 0xFF	; 255
 1ae:	91 05       	cpc	r25, r1
 1b0:	01 f0       	breq	.+0      	; 0x1b2 <color2rgb+0x1b2>
 1b2:	04 f0       	brlt	.+0      	; 0x1b4 <color2rgb+0x1b4>
 1b4:	8f ef       	ldi	r24, 0xFF	; 255
 1b6:	90 e0       	ldi	r25, 0x00	; 0
		b = CLAMP(b,0,255);
 1b8:	ab 01       	movw	r20, r22
 1ba:	6f 3f       	cpi	r22, 0xFF	; 255
 1bc:	71 05       	cpc	r23, r1
 1be:	01 f0       	breq	.+0      	; 0x1c0 <color2rgb+0x1c0>
 1c0:	04 f0       	brlt	.+0      	; 0x1c2 <color2rgb+0x1c2>
 1c2:	4f ef       	ldi	r20, 0xFF	; 255
 1c4:	50 e0       	ldi	r21, 0x00	; 0

COLOR_RGB* color2rgb(const COLOR * src, COLOR* dest);		// Convert the color to RGB
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest);		// Convert the color to YUV

static __inline__ void colorSetRGB(COLOR* color, uint8_t r, uint8_t g, uint8_t b ){
	color->colorSpace = RGB;
 1c6:	e9 81       	ldd	r30, Y+1	; 0x01
 1c8:	fa 81       	ldd	r31, Y+2	; 0x02
 1ca:	10 82       	st	Z, r1
		colorSetRGB(dest,r,g,b);
 1cc:	37 ff       	sbrs	r19, 7
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <color2rgb+0x1d0>
 1d0:	20 e0       	ldi	r18, 0x00	; 0
 1d2:	30 e0       	ldi	r19, 0x00	; 0
 1d4:	e9 81       	ldd	r30, Y+1	; 0x01
 1d6:	fa 81       	ldd	r31, Y+2	; 0x02
 1d8:	21 83       	std	Z+1, r18	; 0x01
 1da:	97 ff       	sbrs	r25, 7
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <color2rgb+0x1de>
 1de:	80 e0       	ldi	r24, 0x00	; 0
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	e9 81       	ldd	r30, Y+1	; 0x01
 1e4:	fa 81       	ldd	r31, Y+2	; 0x02
 1e6:	82 83       	std	Z+2, r24	; 0x02
 1e8:	57 ff       	sbrs	r21, 7
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <color2rgb+0x1ec>
 1ec:	40 e0       	ldi	r20, 0x00	; 0
 1ee:	50 e0       	ldi	r21, 0x00	; 0
 1f0:	e9 81       	ldd	r30, Y+1	; 0x01
 1f2:	fa 81       	ldd	r31, Y+2	; 0x02
 1f4:	43 83       	std	Z+3, r20	; 0x03
		break;
		}
	}
	return &dest->bands.rgb;
 1f6:	89 81       	ldd	r24, Y+1	; 0x01
 1f8:	9a 81       	ldd	r25, Y+2	; 0x02
 1fa:	01 96       	adiw	r24, 0x01	; 1
}
 1fc:	0f 90       	pop	r0
 1fe:	0f 90       	pop	r0
 200:	0f 90       	pop	r0
 202:	0f 90       	pop	r0
 204:	df 91       	pop	r29
 206:	cf 91       	pop	r28
 208:	1f 91       	pop	r17
 20a:	0f 91       	pop	r16
 20c:	ff 90       	pop	r15
 20e:	ef 90       	pop	r14
 210:	df 90       	pop	r13
 212:	cf 90       	pop	r12
 214:	bf 90       	pop	r11
 216:	af 90       	pop	r10
 218:	9f 90       	pop	r9
 21a:	8f 90       	pop	r8
 21c:	7f 90       	pop	r7
 21e:	6f 90       	pop	r6
 220:	5f 90       	pop	r5
 222:	4f 90       	pop	r4
 224:	3f 90       	pop	r3
 226:	2f 90       	pop	r2
 228:	08 95       	ret

color2.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000027c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002b0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002b0  2**0
                  ALLOC
  3 .debug_info   0000025b  00000000  00000000  000002b0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000014c  00000000  00000000  0000050b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000253  00000000  00000000  00000657  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000008aa  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000a2  00000000  00000000  000008ca  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000128  00000000  00000000  0000096c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000084  00000000  00000000  00000a94  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <color2yuv>:
 */
#include "color.h"
#include <string.h>		// for memcpy

// Convert the color to YUV
COLOR_YUV* color2yuv(const COLOR * src, COLOR* dest){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	00 d0       	rcall	.+0      	; 0x26 <color2yuv+0x26>
  26:	00 d0       	rcall	.+0      	; 0x28 <color2yuv+0x28>
  28:	00 d0       	rcall	.+0      	; 0x2a <color2yuv+0x2a>
  2a:	cd b7       	in	r28, 0x3d	; 61
  2c:	de b7       	in	r29, 0x3e	; 62
  2e:	6c 01       	movw	r12, r24
  30:	8b 01       	movw	r16, r22
	switch(src->colorSpace){
  32:	fc 01       	movw	r30, r24
  34:	80 81       	ld	r24, Z
  36:	88 23       	and	r24, r24
  38:	01 f0       	breq	.+0      	; 0x3a <color2yuv+0x3a>
  3a:	81 30       	cpi	r24, 0x01	; 1
  3c:	01 f0       	breq	.+0      	; 0x3e <color2yuv+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <color2yuv+0x40>
	case YUV:
		// Nothing to do
		if(src != dest){
  40:	c6 16       	cp	r12, r22
  42:	d7 06       	cpc	r13, r23
  44:	01 f4       	brne	.+0      	; 0x46 <color2yuv+0x46>
  46:	00 c0       	rjmp	.+0      	; 0x48 <color2yuv+0x48>
			memcpy(dest, src, sizeof(COLOR));
  48:	80 81       	ld	r24, Z
  4a:	91 81       	ldd	r25, Z+1	; 0x01
  4c:	a2 81       	ldd	r26, Z+2	; 0x02
  4e:	b3 81       	ldd	r27, Z+3	; 0x03
  50:	fb 01       	movw	r30, r22
  52:	80 83       	st	Z, r24
  54:	91 83       	std	Z+1, r25	; 0x01
  56:	a2 83       	std	Z+2, r26	; 0x02
  58:	b3 83       	std	Z+3, r27	; 0x03
  5a:	00 c0       	rjmp	.+0      	; 0x5c <color2yuv+0x5c>
			Y  =  16 + 1/256 * (  65.738 * R'd + 129.057 * G'd +  25.064 * B'd)
			Cb = 128 + 1/256 * (- 37.945 * R'd -  74.494 * G'd + 112.439 * B'd)
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
  5c:	f6 01       	movw	r30, r12
  5e:	61 81       	ldd	r22, Z+1	; 0x01
			int g = src->bands.rgb.g;
			int b = src->bands.rgb.b;


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  60:	70 e0       	ldi	r23, 0x00	; 0
  62:	80 e0       	ldi	r24, 0x00	; 0
  64:	90 e0       	ldi	r25, 0x00	; 0
  66:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  6a:	4b 01       	movw	r8, r22
  6c:	5c 01       	movw	r10, r24
			Cb = 128 + 1/256 * (- 37.945 * R'd -  74.494 * G'd + 112.439 * B'd)
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
			int g = src->bands.rgb.g;
  6e:	f6 01       	movw	r30, r12
  70:	62 81       	ldd	r22, Z+2	; 0x02
			int b = src->bands.rgb.b;


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  72:	70 e0       	ldi	r23, 0x00	; 0
  74:	80 e0       	ldi	r24, 0x00	; 0
  76:	90 e0       	ldi	r25, 0x00	; 0
  78:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  7c:	2b 01       	movw	r4, r22
  7e:	3c 01       	movw	r6, r24
			Cr = 128 + 1/256 * ( 112.439 * R'd -  94.154 * G'd -  18.285 * B'd)
			*/

			int r = src->bands.rgb.r;
			int g = src->bands.rgb.g;
			int b = src->bands.rgb.b;
  80:	f6 01       	movw	r30, r12
  82:	63 81       	ldd	r22, Z+3	; 0x03


			int y =  16.0 + 1.0/256.0 * (  65.738 * r + 129.057 * g +  25.064 * b);
  84:	70 e0       	ldi	r23, 0x00	; 0
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	90 e0       	ldi	r25, 0x00	; 0
  8a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  8e:	69 83       	std	Y+1, r22	; 0x01
  90:	7a 83       	std	Y+2, r23	; 0x02
  92:	8b 83       	std	Y+3, r24	; 0x03
  94:	9c 83       	std	Y+4, r25	; 0x04
  96:	c5 01       	movw	r24, r10
  98:	b4 01       	movw	r22, r8
  9a:	2b ed       	ldi	r18, 0xDB	; 219
  9c:	39 e7       	ldi	r19, 0x79	; 121
  9e:	43 e8       	ldi	r20, 0x83	; 131
  a0:	52 e4       	ldi	r21, 0x42	; 66
  a2:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  a6:	6b 01       	movw	r12, r22
  a8:	7c 01       	movw	r14, r24
  aa:	c3 01       	movw	r24, r6
  ac:	b2 01       	movw	r22, r4
  ae:	28 e9       	ldi	r18, 0x98	; 152
  b0:	3e e0       	ldi	r19, 0x0E	; 14
  b2:	41 e0       	ldi	r20, 0x01	; 1
  b4:	53 e4       	ldi	r21, 0x43	; 67
  b6:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  ba:	9b 01       	movw	r18, r22
  bc:	ac 01       	movw	r20, r24
  be:	c7 01       	movw	r24, r14
  c0:	b6 01       	movw	r22, r12
  c2:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  c6:	6b 01       	movw	r12, r22
  c8:	7c 01       	movw	r14, r24
  ca:	69 81       	ldd	r22, Y+1	; 0x01
  cc:	7a 81       	ldd	r23, Y+2	; 0x02
  ce:	8b 81       	ldd	r24, Y+3	; 0x03
  d0:	9c 81       	ldd	r25, Y+4	; 0x04
  d2:	22 e1       	ldi	r18, 0x12	; 18
  d4:	33 e8       	ldi	r19, 0x83	; 131
  d6:	48 ec       	ldi	r20, 0xC8	; 200
  d8:	51 e4       	ldi	r21, 0x41	; 65
  da:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  de:	9b 01       	movw	r18, r22
  e0:	ac 01       	movw	r20, r24
  e2:	c7 01       	movw	r24, r14
  e4:	b6 01       	movw	r22, r12
  e6:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  ea:	20 e0       	ldi	r18, 0x00	; 0
  ec:	30 e0       	ldi	r19, 0x00	; 0
  ee:	40 e8       	ldi	r20, 0x80	; 128
  f0:	5b e3       	ldi	r21, 0x3B	; 59
  f2:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
  f6:	20 e0       	ldi	r18, 0x00	; 0
  f8:	30 e0       	ldi	r19, 0x00	; 0
  fa:	40 e8       	ldi	r20, 0x80	; 128
  fc:	51 e4       	ldi	r21, 0x41	; 65
  fe:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 102:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 106:	36 2e       	mov	r3, r22
 108:	27 2e       	mov	r2, r23
			int u = 128.0 + 1.0/256.0 * (- 37.945 * r -  74.494 * g + 112.439 * b);
 10a:	c5 01       	movw	r24, r10
 10c:	b4 01       	movw	r22, r8
 10e:	2e ea       	ldi	r18, 0xAE	; 174
 110:	37 ec       	ldi	r19, 0xC7	; 199
 112:	47 e1       	ldi	r20, 0x17	; 23
 114:	52 ec       	ldi	r21, 0xC2	; 194
 116:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 11a:	6b 01       	movw	r12, r22
 11c:	7c 01       	movw	r14, r24
 11e:	c3 01       	movw	r24, r6
 120:	b2 01       	movw	r22, r4
 122:	2e ee       	ldi	r18, 0xEE	; 238
 124:	3c ef       	ldi	r19, 0xFC	; 252
 126:	44 e9       	ldi	r20, 0x94	; 148
 128:	52 e4       	ldi	r21, 0x42	; 66
 12a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 12e:	9b 01       	movw	r18, r22
 130:	ac 01       	movw	r20, r24
 132:	c7 01       	movw	r24, r14
 134:	b6 01       	movw	r22, r12
 136:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 13a:	6b 01       	movw	r12, r22
 13c:	7c 01       	movw	r14, r24
 13e:	69 81       	ldd	r22, Y+1	; 0x01
 140:	7a 81       	ldd	r23, Y+2	; 0x02
 142:	8b 81       	ldd	r24, Y+3	; 0x03
 144:	9c 81       	ldd	r25, Y+4	; 0x04
 146:	25 ec       	ldi	r18, 0xC5	; 197
 148:	30 ee       	ldi	r19, 0xE0	; 224
 14a:	40 ee       	ldi	r20, 0xE0	; 224
 14c:	52 e4       	ldi	r21, 0x42	; 66
 14e:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 152:	9b 01       	movw	r18, r22
 154:	ac 01       	movw	r20, r24
 156:	c7 01       	movw	r24, r14
 158:	b6 01       	movw	r22, r12
 15a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 15e:	20 e0       	ldi	r18, 0x00	; 0
 160:	30 e0       	ldi	r19, 0x00	; 0
 162:	40 e8       	ldi	r20, 0x80	; 128
 164:	5b e3       	ldi	r21, 0x3B	; 59
 166:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 16a:	20 e0       	ldi	r18, 0x00	; 0
 16c:	30 e0       	ldi	r19, 0x00	; 0
 16e:	40 e0       	ldi	r20, 0x00	; 0
 170:	53 e4       	ldi	r21, 0x43	; 67
 172:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 176:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 17a:	6d 83       	std	Y+5, r22	; 0x05
 17c:	7e 83       	std	Y+6, r23	; 0x06
			int v = 128.0 + 1.0/256.0 * ( 112.439 * r -  94.154 * g -  18.285 * b);
 17e:	c5 01       	movw	r24, r10
 180:	b4 01       	movw	r22, r8
 182:	25 ec       	ldi	r18, 0xC5	; 197
 184:	30 ee       	ldi	r19, 0xE0	; 224
 186:	40 ee       	ldi	r20, 0xE0	; 224
 188:	52 e4       	ldi	r21, 0x42	; 66
 18a:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 18e:	6b 01       	movw	r12, r22
 190:	7c 01       	movw	r14, r24
 192:	c3 01       	movw	r24, r6
 194:	b2 01       	movw	r22, r4
 196:	29 ed       	ldi	r18, 0xD9	; 217
 198:	3e e4       	ldi	r19, 0x4E	; 78
 19a:	4c eb       	ldi	r20, 0xBC	; 188
 19c:	52 e4       	ldi	r21, 0x42	; 66
 19e:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1a2:	9b 01       	movw	r18, r22
 1a4:	ac 01       	movw	r20, r24
 1a6:	c7 01       	movw	r24, r14
 1a8:	b6 01       	movw	r22, r12
 1aa:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1ae:	6b 01       	movw	r12, r22
 1b0:	7c 01       	movw	r14, r24
 1b2:	69 81       	ldd	r22, Y+1	; 0x01
 1b4:	7a 81       	ldd	r23, Y+2	; 0x02
 1b6:	8b 81       	ldd	r24, Y+3	; 0x03
 1b8:	9c 81       	ldd	r25, Y+4	; 0x04
 1ba:	2e ea       	ldi	r18, 0xAE	; 174
 1bc:	37 e4       	ldi	r19, 0x47	; 71
 1be:	42 e9       	ldi	r20, 0x92	; 146
 1c0:	51 e4       	ldi	r21, 0x41	; 65
 1c2:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1c6:	9b 01       	movw	r18, r22
 1c8:	ac 01       	movw	r20, r24
 1ca:	c7 01       	movw	r24, r14
 1cc:	b6 01       	movw	r22, r12
 1ce:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1d2:	20 e0       	ldi	r18, 0x00	; 0
 1d4:	30 e0       	ldi	r19, 0x00	; 0
 1d6:	40 e8       	ldi	r20, 0x80	; 128
 1d8:	5b e3       	ldi	r21, 0x3B	; 59
 1da:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1de:	20 e0       	ldi	r18, 0x00	; 0
 1e0:	30 e0       	ldi	r19, 0x00	; 0
 1e2:	40 e0       	ldi	r20, 0x00	; 0
 1e4:	53 e4       	ldi	r21, 0x43	; 67
 1e6:	0e 94 00 00 	call	0	; 0x0 <color2yuv>
 1ea:	0e 94 00 00 	call	0	; 0x0 <color2yuv>

			y = CLAMP(y,0,255);
 1ee:	23 2d       	mov	r18, r3
 1f0:	32 2d       	mov	r19, r2
 1f2:	2f 3f       	cpi	r18, 0xFF	; 255
 1f4:	31 05       	cpc	r19, r1
 1f6:	01 f0       	breq	.+0      	; 0x1f8 <color2yuv+0x1f8>
 1f8:	04 f0       	brlt	.+0      	; 0x1fa <color2yuv+0x1fa>
 1fa:	2f ef       	ldi	r18, 0xFF	; 255
 1fc:	30 e0       	ldi	r19, 0x00	; 0
			u = CLAMP(u,0,255);
 1fe:	8d 81       	ldd	r24, Y+5	; 0x05
 200:	9e 81       	ldd	r25, Y+6	; 0x06
 202:	8f 3f       	cpi	r24, 0xFF	; 255
 204:	91 05       	cpc	r25, r1
 206:	01 f0       	breq	.+0      	; 0x208 <color2yuv+0x208>
 208:	04 f0       	brlt	.+0      	; 0x20a <color2yuv+0x20a>
 20a:	8f ef       	ldi	r24, 0xFF	; 255
 20c:	90 e0       	ldi	r25, 0x00	; 0
			v = CLAMP(v,0,255);
 20e:	ab 01       	movw	r20, r22
 210:	6f 3f       	cpi	r22, 0xFF	; 255
 212:	71 05       	cpc	r23, r1
 214:	01 f0       	breq	.+0      	; 0x216 <color2yuv+0x216>
 216:	04 f0       	brlt	.+0      	; 0x218 <color2yuv+0x218>
 218:	4f ef       	ldi	r20, 0xFF	; 255
 21a:	50 e0       	ldi	r21, 0x00	; 0
	color->bands.rgb.g = g;
	color->bands.rgb.b = b;
}

static __inline__ void colorSetYUV(COLOR* color, uint8_t y, uint8_t u, uint8_t v ){
	color->colorSpace = YUV;
 21c:	61 e0       	ldi	r22, 0x01	; 1
 21e:	f8 01       	movw	r30, r16
 220:	60 83       	st	Z, r22

			// Convert rgb to yuv
			colorSetYUV(dest,y,u,v);
 222:	37 ff       	sbrs	r19, 7
 224:	00 c0       	rjmp	.+0      	; 0x226 <color2yuv+0x226>
 226:	20 e0       	ldi	r18, 0x00	; 0
 228:	30 e0       	ldi	r19, 0x00	; 0
 22a:	f8 01       	movw	r30, r16
 22c:	21 83       	std	Z+1, r18	; 0x01
 22e:	97 ff       	sbrs	r25, 7
 230:	00 c0       	rjmp	.+0      	; 0x232 <color2yuv+0x232>
 232:	80 e0       	ldi	r24, 0x00	; 0
 234:	90 e0       	ldi	r25, 0x00	; 0
 236:	f8 01       	movw	r30, r16
 238:	82 83       	std	Z+2, r24	; 0x02
 23a:	57 ff       	sbrs	r21, 7
 23c:	00 c0       	rjmp	.+0      	; 0x23e <color2yuv+0x23e>
 23e:	40 e0       	ldi	r20, 0x00	; 0
 240:	50 e0       	ldi	r21, 0x00	; 0
 242:	f8 01       	movw	r30, r16
 244:	43 83       	std	Z+3, r20	; 0x03
			break;
		}
	}
	return &dest->bands.yuv;
 246:	c8 01       	movw	r24, r16
 248:	01 96       	adiw	r24, 0x01	; 1

}
 24a:	26 96       	adiw	r28, 0x06	; 6
 24c:	0f b6       	in	r0, 0x3f	; 63
 24e:	f8 94       	cli
 250:	de bf       	out	0x3e, r29	; 62
 252:	0f be       	out	0x3f, r0	; 63
 254:	cd bf       	out	0x3d, r28	; 61
 256:	df 91       	pop	r29
 258:	cf 91       	pop	r28
 25a:	1f 91       	pop	r17
 25c:	0f 91       	pop	r16
 25e:	ff 90       	pop	r15
 260:	ef 90       	pop	r14
 262:	df 90       	pop	r13
 264:	cf 90       	pop	r12
 266:	bf 90       	pop	r11
 268:	af 90       	pop	r10
 26a:	9f 90       	pop	r9
 26c:	8f 90       	pop	r8
 26e:	7f 90       	pop	r7
 270:	6f 90       	pop	r6
 272:	5f 90       	pop	r5
 274:	4f 90       	pop	r4
 276:	3f 90       	pop	r3
 278:	2f 90       	pop	r2
 27a:	08 95       	ret

color3.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000a0  2**0
                  ALLOC
  3 .debug_info   000001c5  00000000  00000000  000000a0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000ec  00000000  00000000  00000265  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000048  00000000  00000000  00000351  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000399  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000a9  00000000  00000000  000003b9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000122  00000000  00000000  00000462  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000024  00000000  00000000  00000584  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <colorEquals>:
 *      Author: Clive Webster
 */
#include "color.h"

// Test if two colors are identical
boolean colorEquals(const COLOR* c1, const COLOR* c2){
   0:	fc 01       	movw	r30, r24
   2:	db 01       	movw	r26, r22
	if(c1 == c2){
   4:	86 17       	cp	r24, r22
   6:	97 07       	cpc	r25, r23
   8:	01 f0       	breq	.+0      	; 0xa <colorEquals+0xa>
		return TRUE;
	}

	if(c1->colorSpace != c2->colorSpace){
   a:	80 81       	ld	r24, Z
   c:	9c 91       	ld	r25, X
   e:	89 17       	cp	r24, r25
  10:	01 f4       	brne	.+0      	; 0x12 <colorEquals+0x12>
	}

	boolean rtn = FALSE;
	if(c1->colorSpace == RGB){
		// RGB
		if(c1->bands.rgb.r == c2->bands.rgb.r &&
  12:	91 81       	ldd	r25, Z+1	; 0x01
	if(c1->colorSpace != c2->colorSpace){
		return FALSE;
	}

	boolean rtn = FALSE;
	if(c1->colorSpace == RGB){
  14:	88 23       	and	r24, r24
  16:	01 f4       	brne	.+0      	; 0x18 <colorEquals+0x18>
		// RGB
		if(c1->bands.rgb.r == c2->bands.rgb.r &&
  18:	11 96       	adiw	r26, 0x01	; 1
  1a:	8c 91       	ld	r24, X
  1c:	11 97       	sbiw	r26, 0x01	; 1
  1e:	98 17       	cp	r25, r24
  20:	01 f4       	brne	.+0      	; 0x22 <colorEquals+0x22>
  22:	92 81       	ldd	r25, Z+2	; 0x02
  24:	12 96       	adiw	r26, 0x02	; 2
  26:	8c 91       	ld	r24, X
  28:	12 97       	sbiw	r26, 0x02	; 2
  2a:	98 17       	cp	r25, r24
  2c:	01 f4       	brne	.+0      	; 0x2e <colorEquals+0x2e>
		   c1->bands.rgb.g == c2->bands.rgb.g &&
  2e:	93 81       	ldd	r25, Z+3	; 0x03
  30:	13 96       	adiw	r26, 0x03	; 3
  32:	8c 91       	ld	r24, X
  34:	13 97       	sbiw	r26, 0x03	; 3
  36:	98 17       	cp	r25, r24
  38:	01 f4       	brne	.+0      	; 0x3a <colorEquals+0x3a>
  3a:	00 c0       	rjmp	.+0      	; 0x3c <colorEquals+0x3c>
		   c1->bands.rgb.b == c2->bands.rgb.b){
			rtn = TRUE;
		}
	}else{
		// YUV
		if(c1->bands.yuv.y == c2->bands.yuv.y &&
  3c:	11 96       	adiw	r26, 0x01	; 1
  3e:	8c 91       	ld	r24, X
  40:	11 97       	sbiw	r26, 0x01	; 1
  42:	98 17       	cp	r25, r24
  44:	01 f4       	brne	.+0      	; 0x46 <colorEquals+0x46>
  46:	92 81       	ldd	r25, Z+2	; 0x02
  48:	12 96       	adiw	r26, 0x02	; 2
  4a:	8c 91       	ld	r24, X
  4c:	12 97       	sbiw	r26, 0x02	; 2
  4e:	98 17       	cp	r25, r24
  50:	01 f4       	brne	.+0      	; 0x52 <colorEquals+0x52>
		   c1->bands.yuv.u == c2->bands.yuv.u &&
  52:	93 81       	ldd	r25, Z+3	; 0x03
  54:	13 96       	adiw	r26, 0x03	; 3
  56:	8c 91       	ld	r24, X
  58:	13 97       	sbiw	r26, 0x03	; 3
  5a:	98 17       	cp	r25, r24
  5c:	01 f4       	brne	.+0      	; 0x5e <colorEquals+0x5e>
  5e:	00 c0       	rjmp	.+0      	; 0x60 <colorEquals+0x60>
	if(c1->colorSpace == RGB){
		// RGB
		if(c1->bands.rgb.r == c2->bands.rgb.r &&
		   c1->bands.rgb.g == c2->bands.rgb.g &&
		   c1->bands.rgb.b == c2->bands.rgb.b){
			rtn = TRUE;
  60:	8f ef       	ldi	r24, 0xFF	; 255
  62:	08 95       	ret

	if(c1->colorSpace != c2->colorSpace){
		return FALSE;
	}

	boolean rtn = FALSE;
  64:	80 e0       	ldi	r24, 0x00	; 0
  66:	08 95       	ret
	}else{
		// YUV
		if(c1->bands.yuv.y == c2->bands.yuv.y &&
		   c1->bands.yuv.u == c2->bands.yuv.u &&
		   c1->bands.yuv.v == c2->bands.yuv.v){
			rtn = TRUE;
  68:	8f ef       	ldi	r24, 0xFF	; 255
		}
	}
	return rtn;
}
  6a:	08 95       	ret

color_dump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000a2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000d6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000d6  2**0
                  ALLOC
  3 .progmem.data 0000001c  00000000  00000000  000000d6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000018c  00000000  00000000  000000f2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000000cc  00000000  00000000  0000027e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000057  00000000  00000000  0000034a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000003a1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000008a  00000000  00000000  000003c1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000011b  00000000  00000000  0000044b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000030  00000000  00000000  00000568  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <colorDump>:
 *      Author: Clive Webster
 */
#include "color.h"
#include "rprintf.h"

void colorDump(const COLOR* color){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	fc 01       	movw	r30, r24
	switch(color->colorSpace){
   6:	80 81       	ld	r24, Z
   8:	88 23       	and	r24, r24
   a:	01 f0       	breq	.+0      	; 0xc <colorDump+0xc>
   c:	81 30       	cpi	r24, 0x01	; 1
   e:	01 f0       	breq	.+0      	; 0x10 <colorDump+0x10>
  10:	00 c0       	rjmp	.+0      	; 0x12 <colorDump+0x12>
  12:	00 c0       	rjmp	.+0      	; 0x14 <colorDump+0x14>
	case RGB:
		rprintf("RGB(%d,%d,%d)",(int)(color->bands.rgb.r), (int)(color->bands.rgb.g), (int)(color->bands.rgb.b));
  14:	2d b7       	in	r18, 0x3d	; 61
  16:	3e b7       	in	r19, 0x3e	; 62
  18:	29 50       	subi	r18, 0x09	; 9
  1a:	30 40       	sbci	r19, 0x00	; 0
  1c:	0f b6       	in	r0, 0x3f	; 63
  1e:	f8 94       	cli
  20:	3e bf       	out	0x3e, r19	; 62
  22:	0f be       	out	0x3f, r0	; 63
  24:	2d bf       	out	0x3d, r18	; 61
  26:	ad b7       	in	r26, 0x3d	; 61
  28:	be b7       	in	r27, 0x3e	; 62
  2a:	11 96       	adiw	r26, 0x01	; 1
  2c:	81 e0       	ldi	r24, 0x01	; 1
  2e:	cd b7       	in	r28, 0x3d	; 61
  30:	de b7       	in	r29, 0x3e	; 62
  32:	89 83       	std	Y+1, r24	; 0x01
  34:	80 e0       	ldi	r24, 0x00	; 0
  36:	90 e0       	ldi	r25, 0x00	; 0
  38:	00 c0       	rjmp	.+0      	; 0x3a <colorDump+0x3a>
		break;
	case YUV:
		rprintf("YUV(%d,%d,%d)",(int)(color->bands.yuv.y), (int)(color->bands.yuv.u), (int)(color->bands.yuv.v));
  3a:	cd b7       	in	r28, 0x3d	; 61
  3c:	de b7       	in	r29, 0x3e	; 62
  3e:	29 97       	sbiw	r28, 0x09	; 9
  40:	0f b6       	in	r0, 0x3f	; 63
  42:	f8 94       	cli
  44:	de bf       	out	0x3e, r29	; 62
  46:	0f be       	out	0x3f, r0	; 63
  48:	cd bf       	out	0x3d, r28	; 61
  4a:	ad b7       	in	r26, 0x3d	; 61
  4c:	be b7       	in	r27, 0x3e	; 62
  4e:	11 96       	adiw	r26, 0x01	; 1
  50:	89 83       	std	Y+1, r24	; 0x01
  52:	80 e0       	ldi	r24, 0x00	; 0
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	12 96       	adiw	r26, 0x02	; 2
  58:	9c 93       	st	X, r25
  5a:	8e 93       	st	-X, r24
  5c:	11 97       	sbiw	r26, 0x01	; 1
  5e:	81 81       	ldd	r24, Z+1	; 0x01
  60:	13 96       	adiw	r26, 0x03	; 3
  62:	8c 93       	st	X, r24
  64:	13 97       	sbiw	r26, 0x03	; 3
  66:	14 96       	adiw	r26, 0x04	; 4
  68:	1c 92       	st	X, r1
  6a:	14 97       	sbiw	r26, 0x04	; 4
  6c:	82 81       	ldd	r24, Z+2	; 0x02
  6e:	15 96       	adiw	r26, 0x05	; 5
  70:	8c 93       	st	X, r24
  72:	15 97       	sbiw	r26, 0x05	; 5
  74:	16 96       	adiw	r26, 0x06	; 6
  76:	1c 92       	st	X, r1
  78:	16 97       	sbiw	r26, 0x06	; 6
  7a:	83 81       	ldd	r24, Z+3	; 0x03
  7c:	17 96       	adiw	r26, 0x07	; 7
  7e:	8c 93       	st	X, r24
  80:	17 97       	sbiw	r26, 0x07	; 7
  82:	18 96       	adiw	r26, 0x08	; 8
  84:	1c 92       	st	X, r1
  86:	0e 94 00 00 	call	0	; 0x0 <colorDump>
		break;
  8a:	2d b7       	in	r18, 0x3d	; 61
  8c:	3e b7       	in	r19, 0x3e	; 62
  8e:	27 5f       	subi	r18, 0xF7	; 247
  90:	3f 4f       	sbci	r19, 0xFF	; 255
  92:	0f b6       	in	r0, 0x3f	; 63
  94:	f8 94       	cli
  96:	3e bf       	out	0x3e, r19	; 62
  98:	0f be       	out	0x3f, r0	; 63
  9a:	2d bf       	out	0x3d, r18	; 61
	}
}
  9c:	df 91       	pop	r29
  9e:	cf 91       	pop	r28
  a0:	08 95       	ret

core.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000060  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000094  2**0
                  ALLOC
  3 .text.startup 00000076  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .debug_info   00000674  00000000  00000000  0000010a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001ae  00000000  00000000  0000077e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000002b2  00000000  00000000  0000092c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000028  00000000  00000000  00000bde  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00000c06  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_line   000000eb  00000000  00000000  00000c1e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    0000032f  00000000  00000000  00000d09  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000064  00000000  00000000  00001038  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <breathe>:
#include "core.h"
#include "timer.h"


void breathe(void){
	INTERRUPTABLE_SECTION{
   0:	8f b7       	in	r24, 0x3f	; 63
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
   2:	78 94       	sei
	...
		nop();
		nop();
		nop();
		nop();
		nop();
		nop();
  10:	00 00       	nop
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  12:	8f bf       	out	0x3f, r24	; 63
	}
}
  14:	08 95       	ret

00000016 <__portMaskSet>:
}



void __portMaskSet(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  16:	fc 01       	movw	r30, r24
  18:	25 91       	lpm	r18, Z+
  1a:	34 91       	lpm	r19, Z
	register PIN  mask    = pgm_read_byte(&pm->mask);
  1c:	02 96       	adiw	r24, 0x02	; 2
  1e:	fc 01       	movw	r30, r24
  20:	84 91       	lpm	r24, Z
	_SFR_MEM8(port) |= mask;
  22:	d9 01       	movw	r26, r18
  24:	9c 91       	ld	r25, X
  26:	98 2b       	or	r25, r24
  28:	9c 93       	st	X, r25
}
  2a:	08 95       	ret

0000002c <__portMaskGet>:

boolean __portMaskGet(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  2c:	fc 01       	movw	r30, r24
  2e:	25 91       	lpm	r18, Z+
  30:	34 91       	lpm	r19, Z
	register PIN  mask    = pgm_read_byte(&pm->mask);
  32:	02 96       	adiw	r24, 0x02	; 2
  34:	fc 01       	movw	r30, r24
  36:	84 91       	lpm	r24, Z
	return (_SFR_MEM8(port) & mask) ? TRUE : FALSE;
  38:	d9 01       	movw	r26, r18
  3a:	9c 91       	ld	r25, X
  3c:	98 23       	and	r25, r24
  3e:	01 f0       	breq	.+0      	; 0x40 <__portMaskGet+0x14>
  40:	8f ef       	ldi	r24, 0xFF	; 255
  42:	08 95       	ret
  44:	80 e0       	ldi	r24, 0x00	; 0
}
  46:	08 95       	ret

00000048 <__portMaskClear>:

void __portMaskClear(const PORT_MASK* pm){
	register PORT port    = pgm_read_word(&pm->port);
  48:	fc 01       	movw	r30, r24
  4a:	25 91       	lpm	r18, Z+
  4c:	34 91       	lpm	r19, Z
	register PIN  mask = pgm_read_byte(&pm->mask);
  4e:	02 96       	adiw	r24, 0x02	; 2
  50:	fc 01       	movw	r30, r24
  52:	84 91       	lpm	r24, Z
	_SFR_MEM8(port) &= ~mask;
  54:	d9 01       	movw	r26, r18
  56:	9c 91       	ld	r25, X
  58:	80 95       	com	r24
  5a:	98 23       	and	r25, r24
  5c:	9c 93       	st	X, r25
}
  5e:	08 95       	ret

Disassembly of section .text.startup:

00000000 <main>:
	TICK_COUNT loopStart;
	TICK_COUNT delay;


	// Configure the states of the initial ports according to the system ie axon.h
	configure_ports();
   0:	0e 94 00 00 	call	0	; 0x0 <main>
	registerLED();
   4:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the general timers
	initTimers();
   8:	0e 94 00 00 	call	0	; 0x0 <main>
//		uartInit(&(Uarts[i]) ,UART_DEFAULT_BAUD_RATE);
//	}


	// Initialise the hardware declared by the board
	sysInitHardware();
   c:	0e 94 00 00 	call	0	; 0x0 <main>
	// Initialise the hardware declared by the application
	appInitHardware();
  10:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the heartbeat with whatever is left
	__clockInit();
  14:	0e 94 00 00 	call	0	; 0x0 <main>

	// Initialise the software
	loopStart = clockGetus();
  18:	0e 94 00 00 	call	0	; 0x0 <main>
  1c:	6b 01       	movw	r12, r22
  1e:	7c 01       	movw	r14, r24
	delay = appInitSoftware(loopStart);
  20:	0e 94 00 00 	call	0	; 0x0 <main>
  24:	4b 01       	movw	r8, r22
  26:	5c 01       	movw	r10, r24
}


//  This is the main loop for the application
int main(void){
	LOOP_COUNT loopCount=0;
  28:	44 24       	eor	r4, r4
  2a:	55 24       	eor	r5, r5
  2c:	32 01       	movw	r6, r4
	// Initialise the software
	loopStart = clockGetus();
	delay = appInitSoftware(loopStart);

	do{
		breathe();
  2e:	0e 94 00 00 	call	0	; 0x0 <main>
		if(delay!=0){
  32:	81 14       	cp	r8, r1
  34:	91 04       	cpc	r9, r1
  36:	a1 04       	cpc	r10, r1
  38:	b1 04       	cpc	r11, r1
  3a:	01 f4       	brne	.+0      	; 0x3c <main+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <main+0x3e>
			while(!clockHasElapsed(loopStart,delay)){
				// Allow interrupts to breathe
				breathe();
  3e:	0e 94 00 00 	call	0	; 0x0 <main>
	delay = appInitSoftware(loopStart);

	do{
		breathe();
		if(delay!=0){
			while(!clockHasElapsed(loopStart,delay)){
  42:	c7 01       	movw	r24, r14
  44:	b6 01       	movw	r22, r12
  46:	a5 01       	movw	r20, r10
  48:	94 01       	movw	r18, r8
  4a:	0e 94 00 00 	call	0	; 0x0 <main>
  4e:	88 23       	and	r24, r24
  50:	01 f0       	breq	.+0      	; 0x52 <main+0x52>
				// Allow interrupts to breathe
				breathe();
			}
		}
		loopStart = clockGetus();
  52:	0e 94 00 00 	call	0	; 0x0 <main>
  56:	6b 01       	movw	r12, r22
  58:	7c 01       	movw	r14, r24
		delay = appControl(++loopCount,loopStart);
  5a:	08 94       	sec
  5c:	41 1c       	adc	r4, r1
  5e:	51 1c       	adc	r5, r1
  60:	61 1c       	adc	r6, r1
  62:	71 1c       	adc	r7, r1
  64:	c3 01       	movw	r24, r6
  66:	b2 01       	movw	r22, r4
  68:	a7 01       	movw	r20, r14
  6a:	96 01       	movw	r18, r12
  6c:	0e 94 00 00 	call	0	; 0x0 <main>
  70:	4b 01       	movw	r8, r22
  72:	5c 01       	movw	r10, r24
	}while(1);
  74:	00 c0       	rjmp	.+0      	; 0x76 <__portMaskClear+0x2e>

core_interp.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000080  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000b4  2**0
                  ALLOC
  3 .debug_info   00000109  00000000  00000000  000000b4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000007b  00000000  00000000  000001bd  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001ed  00000000  00000000  00000238  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000425  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000007e  00000000  00000000  00000445  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000106  00000000  00000000  000004c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000060  00000000  00000000  000005cc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <interpolate>:
*   maxVal - the maximum that 'value' can be
*   minRtn - the return value if 'value = minVal'
*   maxRtn - the return value if 'value = maxVal'
*   return a value in the range minRtn to maxRtn
*/
int16_t interpolate(int16_t value, int16_t minVal, int16_t maxVal, int16_t minRtn, int16_t maxRtn){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	5b 01       	movw	r10, r22
  1a:	ea 01       	movw	r28, r20
  1c:	49 01       	movw	r8, r18
	register int32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
  1e:	02 1b       	sub	r16, r18
  20:	13 0b       	sbc	r17, r19
  22:	68 01       	movw	r12, r16
  24:	ee 24       	eor	r14, r14
  26:	d7 fc       	sbrc	r13, 7
  28:	e0 94       	com	r14
  2a:	fe 2c       	mov	r15, r14
	lValRange = maxVal - minVal;
	lRelVal = value - minVal;
  2c:	9c 01       	movw	r18, r24
  2e:	26 1b       	sub	r18, r22
  30:	37 0b       	sbc	r19, r23
  32:	44 27       	eor	r20, r20
  34:	37 fd       	sbrc	r19, 7
  36:	40 95       	com	r20
  38:	54 2f       	mov	r21, r20
	lRtnRange =  minRtn + ( lRtnRange * lRelVal / lValRange );
  3a:	c7 01       	movw	r24, r14
  3c:	b6 01       	movw	r22, r12
  3e:	0e 94 00 00 	call	0	; 0x0 <interpolate>
	register int32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
	lValRange = maxVal - minVal;
  42:	ca 19       	sub	r28, r10
  44:	db 09       	sbc	r29, r11
  46:	9e 01       	movw	r18, r28
  48:	44 27       	eor	r20, r20
  4a:	37 fd       	sbrc	r19, 7
  4c:	40 95       	com	r20
  4e:	54 2f       	mov	r21, r20
	lRelVal = value - minVal;
	lRtnRange =  minRtn + ( lRtnRange * lRelVal / lValRange );
  50:	0e 94 00 00 	call	0	; 0x0 <interpolate>
  54:	aa 24       	eor	r10, r10
  56:	97 fc       	sbrc	r9, 7
  58:	a0 94       	com	r10
  5a:	ba 2c       	mov	r11, r10
  5c:	82 0e       	add	r8, r18
  5e:	93 1e       	adc	r9, r19
  60:	a4 1e       	adc	r10, r20
  62:	b5 1e       	adc	r11, r21
	return (int16_t)lRtnRange;
}
  64:	c4 01       	movw	r24, r8
  66:	df 91       	pop	r29
  68:	cf 91       	pop	r28
  6a:	1f 91       	pop	r17
  6c:	0f 91       	pop	r16
  6e:	ff 90       	pop	r15
  70:	ef 90       	pop	r14
  72:	df 90       	pop	r13
  74:	cf 90       	pop	r12
  76:	bf 90       	pop	r11
  78:	af 90       	pop	r10
  7a:	9f 90       	pop	r9
  7c:	8f 90       	pop	r8
  7e:	08 95       	ret

core_interpU.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000007a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ae  2**0
                  ALLOC
  3 .debug_info   0000011f  00000000  00000000  000000ae  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000007b  00000000  00000000  000001cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000001ad  00000000  00000000  00000248  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000003f5  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000083  00000000  00000000  00000415  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000011a  00000000  00000000  00000498  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000060  00000000  00000000  000005b4  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <interpolateU>:
*   maxVal - the maximum that 'value' can be
*   minRtn - the return value if 'value = minVal'
*   maxRtn - the return value if 'value = maxVal'
*   return a value in the range minRtn to maxRtn
*/
uint16_t interpolateU(int16_t value, int16_t minVal, int16_t maxVal, uint16_t minRtn, uint16_t maxRtn){
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	cf 92       	push	r12
   a:	df 92       	push	r13
   c:	ef 92       	push	r14
   e:	ff 92       	push	r15
  10:	0f 93       	push	r16
  12:	1f 93       	push	r17
  14:	cf 93       	push	r28
  16:	df 93       	push	r29
  18:	4b 01       	movw	r8, r22
  1a:	ea 01       	movw	r28, r20
  1c:	59 01       	movw	r10, r18
	register uint32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
  1e:	02 1b       	sub	r16, r18
  20:	13 0b       	sbc	r17, r19
  22:	68 01       	movw	r12, r16
  24:	ee 24       	eor	r14, r14
  26:	ff 24       	eor	r15, r15
	lValRange = maxVal - minVal;
	lRelVal = value - minVal;
  28:	9c 01       	movw	r18, r24
  2a:	26 1b       	sub	r18, r22
  2c:	37 0b       	sbc	r19, r23
  2e:	44 27       	eor	r20, r20
  30:	37 fd       	sbrc	r19, 7
  32:	40 95       	com	r20
  34:	54 2f       	mov	r21, r20

	// Break into smaller operations - as doing in one statement gives wrong answers
	lRelVal *= lRtnRange;
  36:	c7 01       	movw	r24, r14
  38:	b6 01       	movw	r22, r12
  3a:	0e 94 00 00 	call	0	; 0x0 <interpolateU>
	lRelVal /= lValRange;

	lRtnRange =  minRtn + lRelVal;
  3e:	65 01       	movw	r12, r10
  40:	ee 24       	eor	r14, r14
  42:	ff 24       	eor	r15, r15
	register uint32_t  lRtnRange;
	register int32_t lValRange;
	register int32_t lRelVal;

	lRtnRange = maxRtn - minRtn;
	lValRange = maxVal - minVal;
  44:	c8 19       	sub	r28, r8
  46:	d9 09       	sbc	r29, r9
  48:	9e 01       	movw	r18, r28
  4a:	44 27       	eor	r20, r20
  4c:	37 fd       	sbrc	r19, 7
  4e:	40 95       	com	r20
  50:	54 2f       	mov	r21, r20
	lRelVal = value - minVal;

	// Break into smaller operations - as doing in one statement gives wrong answers
	lRelVal *= lRtnRange;
	lRelVal /= lValRange;
  52:	0e 94 00 00 	call	0	; 0x0 <interpolateU>

	lRtnRange =  minRtn + lRelVal;
  56:	c2 0e       	add	r12, r18
  58:	d3 1e       	adc	r13, r19
  5a:	e4 1e       	adc	r14, r20
  5c:	f5 1e       	adc	r15, r21

	return (uint16_t)lRtnRange;
}
  5e:	c6 01       	movw	r24, r12
  60:	df 91       	pop	r29
  62:	cf 91       	pop	r28
  64:	1f 91       	pop	r17
  66:	0f 91       	pop	r16
  68:	ff 90       	pop	r15
  6a:	ef 90       	pop	r14
  6c:	df 90       	pop	r13
  6e:	cf 90       	pop	r12
  70:	bf 90       	pop	r11
  72:	af 90       	pop	r10
  74:	9f 90       	pop	r9
  76:	8f 90       	pop	r8
  78:	08 95       	ret

core_isqrt.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000094  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000c8  2**0
                  ALLOC
  3 .debug_info   000000c4  00000000  00000000  000000c8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000006c  00000000  00000000  0000018c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000010e  00000000  00000000  000001f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000306  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000085  00000000  00000000  00000326  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000c2  00000000  00000000  000003ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  00000470  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <isqrt>:
 *  Perform an integer square root without requiring the floating point library
 *
 */
#include "core.h"

uint32_t isqrt(uint32_t x){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	ab 01       	movw	r20, r22
   e:	bc 01       	movw	r22, r24
  10:	e0 e1       	ldi	r30, 0x10	; 16
  12:	f0 e0       	ldi	r31, 0x00	; 0
	  register uint32_t xr;  // result register
	  register uint32_t q2;  // scan-bit register
	  register uint8_t  f;   // flag (one bit)

	  xr = 0;                     // clear result
	  q2 = 0x40000000L;           // higest possible result bit
  14:	c1 2c       	mov	r12, r1
  16:	d1 2c       	mov	r13, r1
  18:	e1 2c       	mov	r14, r1
  1a:	20 e4       	ldi	r18, 0x40	; 64
  1c:	f2 2e       	mov	r15, r18
uint32_t isqrt(uint32_t x){
	  register uint32_t xr;  // result register
	  register uint32_t q2;  // scan-bit register
	  register uint8_t  f;   // flag (one bit)

	  xr = 0;                     // clear result
  1e:	00 e0       	ldi	r16, 0x00	; 0
  20:	10 e0       	ldi	r17, 0x00	; 0
  22:	20 e0       	ldi	r18, 0x00	; 0
  24:	30 e0       	ldi	r19, 0x00	; 0
	  q2 = 0x40000000L;           // higest possible result bit
	  do
	  {
	    if((xr + q2) <= x)
  26:	d7 01       	movw	r26, r14
  28:	c6 01       	movw	r24, r12
  2a:	80 0f       	add	r24, r16
  2c:	91 1f       	adc	r25, r17
  2e:	a2 1f       	adc	r26, r18
  30:	b3 1f       	adc	r27, r19
  32:	48 17       	cp	r20, r24
  34:	59 07       	cpc	r21, r25
  36:	6a 07       	cpc	r22, r26
  38:	7b 07       	cpc	r23, r27
  3a:	00 f0       	brcs	.+0      	; 0x3c <isqrt+0x3c>
	    {
	      x -= xr + q2;
  3c:	48 1b       	sub	r20, r24
  3e:	59 0b       	sbc	r21, r25
  40:	6a 0b       	sbc	r22, r26
  42:	7b 0b       	sbc	r23, r27
	      f = 1;                  // set flag
  44:	81 e0       	ldi	r24, 0x01	; 1
  46:	00 c0       	rjmp	.+0      	; 0x48 <isqrt+0x48>
	    }
	    else{
	      f = 0;                  // clear flag
  48:	80 e0       	ldi	r24, 0x00	; 0
	    }
	    xr >>= 1;
  4a:	36 95       	lsr	r19
  4c:	27 95       	ror	r18
  4e:	17 95       	ror	r17
  50:	07 95       	ror	r16
	    if(f){
  52:	88 23       	and	r24, r24
  54:	01 f0       	breq	.+0      	; 0x56 <isqrt+0x56>
	      xr += q2;               // test flag
  56:	0c 0d       	add	r16, r12
  58:	1d 1d       	adc	r17, r13
  5a:	2e 1d       	adc	r18, r14
  5c:	3f 1d       	adc	r19, r15
	    }
	  } while(q2 >>= 2);          // shift twice
  5e:	82 e0       	ldi	r24, 0x02	; 2
  60:	f6 94       	lsr	r15
  62:	e7 94       	ror	r14
  64:	d7 94       	ror	r13
  66:	c7 94       	ror	r12
  68:	8a 95       	dec	r24
  6a:	01 f4       	brne	.+0      	; 0x6c <isqrt+0x6c>
  6c:	31 97       	sbiw	r30, 0x01	; 1
  6e:	01 f4       	brne	.+0      	; 0x70 <isqrt+0x70>
	  if(xr < x){
  70:	04 17       	cp	r16, r20
  72:	15 07       	cpc	r17, r21
  74:	26 07       	cpc	r18, r22
  76:	37 07       	cpc	r19, r23
  78:	00 f4       	brcc	.+0      	; 0x7a <isqrt+0x7a>
	    return xr +1;             // add for rounding
  7a:	0f 5f       	subi	r16, 0xFF	; 255
  7c:	1f 4f       	sbci	r17, 0xFF	; 255
  7e:	2f 4f       	sbci	r18, 0xFF	; 255
  80:	3f 4f       	sbci	r19, 0xFF	; 255
	  }
	  else{
	    return xr;
	  }

}
  82:	b8 01       	movw	r22, r16
  84:	c9 01       	movw	r24, r18
  86:	1f 91       	pop	r17
  88:	0f 91       	pop	r16
  8a:	ff 90       	pop	r15
  8c:	ef 90       	pop	r14
  8e:	df 90       	pop	r13
  90:	cf 90       	pop	r12
  92:	08 95       	ret

fraction32.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000a0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000d4  2**0
                  ALLOC
  3 .debug_info   000001b0  00000000  00000000  000000d4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000a1  00000000  00000000  00000284  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000022d  00000000  00000000  00000325  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000552  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000009d  00000000  00000000  00000572  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000118  00000000  00000000  0000060f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  00000728  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <fraction32>:

// Value is the value to multiply by the fraction
// Fraction is the fraction (in Progmem) where the first element is the integer element to the left of
// the decimal point, and the remainding elements are the divisors where 0 denotes the end of the list
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
   0:	ef 92       	push	r14
   2:	ff 92       	push	r15
   4:	0f 93       	push	r16
   6:	1f 93       	push	r17
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	eb 01       	movw	r28, r22
	int32_t rtn = 0;
	if(value != 0){
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f4       	brne	.+0      	; 0x12 <fraction32+0x12>
  12:	00 c0       	rjmp	.+0      	; 0x14 <fraction32+0x14>
		boolean isNeg = FALSE;

		// The unsigned value
		uint16_t absValue;

		if(value<0){
  14:	97 ff       	sbrs	r25, 7
  16:	00 c0       	rjmp	.+0      	; 0x18 <fraction32+0x18>
			int32_t tmp = value;
  18:	aa 27       	eor	r26, r26
  1a:	97 fd       	sbrc	r25, 7
  1c:	a0 95       	com	r26
  1e:	ba 2f       	mov	r27, r26
			tmp = 0 - tmp;
  20:	ee 24       	eor	r14, r14
  22:	ff 24       	eor	r15, r15
  24:	87 01       	movw	r16, r14
  26:	e8 1a       	sub	r14, r24
  28:	f9 0a       	sbc	r15, r25
  2a:	0a 0b       	sbc	r16, r26
  2c:	1b 0b       	sbc	r17, r27
			absValue=tmp;
			isNeg=TRUE;
  2e:	4f ef       	ldi	r20, 0xFF	; 255
  30:	00 c0       	rjmp	.+0      	; 0x32 <fraction32+0x32>
		}else{
			absValue = value;
  32:	7c 01       	movw	r14, r24
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
	int32_t rtn = 0;
	if(value != 0){
		uint16_t term;
		boolean isNeg = FALSE;
  34:	40 e0       	ldi	r20, 0x00	; 0
		}else{
			absValue = value;
		}

		// first parameter is whole number
		rtn = ((uint16_t)(pgm_read_word(fraction))) * absValue;
  36:	fe 01       	movw	r30, r28
  38:	85 91       	lpm	r24, Z+
  3a:	94 91       	lpm	r25, Z
  3c:	8e 9d       	mul	r24, r14
  3e:	80 01       	movw	r16, r0
  40:	8f 9d       	mul	r24, r15
  42:	10 0d       	add	r17, r0
  44:	9e 9d       	mul	r25, r14
  46:	10 0d       	add	r17, r0
  48:	11 24       	eor	r1, r1
  4a:	20 e0       	ldi	r18, 0x00	; 0
  4c:	30 e0       	ldi	r19, 0x00	; 0

		// Remainder are the fraction
		do{
			fraction++;
  4e:	22 96       	adiw	r28, 0x02	; 2

			term= ( (uint16_t)(pgm_read_word(fraction) ));
  50:	fe 01       	movw	r30, r28
  52:	65 91       	lpm	r22, Z+
  54:	74 91       	lpm	r23, Z
			if(term != 0){
  56:	61 15       	cp	r22, r1
  58:	71 05       	cpc	r23, r1
  5a:	01 f0       	breq	.+0      	; 0x5c <fraction32+0x5c>
				uint16_t frac = absValue / term;
  5c:	c7 01       	movw	r24, r14
  5e:	0e 94 00 00 	call	0	; 0x0 <fraction32>
				rtn += frac;
  62:	cb 01       	movw	r24, r22
  64:	a0 e0       	ldi	r26, 0x00	; 0
  66:	b0 e0       	ldi	r27, 0x00	; 0
  68:	08 0f       	add	r16, r24
  6a:	19 1f       	adc	r17, r25
  6c:	2a 1f       	adc	r18, r26
  6e:	3b 1f       	adc	r19, r27
  70:	00 c0       	rjmp	.+0      	; 0x72 <fraction32+0x72>
			}
		}while(term!=0);

		if(isNeg){
  72:	44 23       	and	r20, r20
  74:	01 f0       	breq	.+0      	; 0x76 <fraction32+0x76>
			rtn = -rtn;
  76:	30 95       	com	r19
  78:	20 95       	com	r18
  7a:	10 95       	com	r17
  7c:	01 95       	neg	r16
  7e:	1f 4f       	sbci	r17, 0xFF	; 255
  80:	2f 4f       	sbci	r18, 0xFF	; 255
  82:	3f 4f       	sbci	r19, 0xFF	; 255
  84:	00 c0       	rjmp	.+0      	; 0x86 <fraction32+0x86>
// Value is the value to multiply by the fraction
// Fraction is the fraction (in Progmem) where the first element is the integer element to the left of
// the decimal point, and the remainding elements are the divisors where 0 denotes the end of the list
// So multiply the value 10 by 3.5 then fraction32(10, (3,2,0} ) ie (val*3)+(val/2)
int32_t fraction32(int16_t value, const uint16_t * fraction ){
	int32_t rtn = 0;
  86:	00 e0       	ldi	r16, 0x00	; 0
  88:	10 e0       	ldi	r17, 0x00	; 0
  8a:	20 e0       	ldi	r18, 0x00	; 0
  8c:	30 e0       	ldi	r19, 0x00	; 0
			rtn = -rtn;
		}

	}
	return rtn;
}
  8e:	b8 01       	movw	r22, r16
  90:	c9 01       	movw	r24, r18
  92:	df 91       	pop	r29
  94:	cf 91       	pop	r28
  96:	1f 91       	pop	r17
  98:	0f 91       	pop	r16
  9a:	ff 90       	pop	r15
  9c:	ef 90       	pop	r14
  9e:	08 95       	ret

i2cBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000436  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000046a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000046a  2**0
                  ALLOC
  3 .debug_info   00000ad4  00000000  00000000  0000046a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000022d  00000000  00000000  00000f3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00001223  00000000  00000000  0000116b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000238e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  000023ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001ac  00000000  00000000  000023de  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000002d4  00000000  00000000  0000258a  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000214  00000000  00000000  00002860  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <i2cAbstractBusInit>:

#include "errors.h"


//--- Helper methods to redirect the call to the correct bus -----
void i2cAbstractBusInit(I2C_ABSTRACT_BUS* i2c){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
	if(i2c && !i2c->initialised){
   8:	00 97       	sbiw	r24, 0x00	; 0
   a:	01 f4       	brne	.+0      	; 0xc <i2cAbstractBusInit+0xc>
   c:	00 c0       	rjmp	.+0      	; 0xe <i2cAbstractBusInit+0xe>
   e:	8d 81       	ldd	r24, Y+5	; 0x05
  10:	88 23       	and	r24, r24
  12:	01 f0       	breq	.+0      	; 0x14 <i2cAbstractBusInit+0x14>
  14:	00 c0       	rjmp	.+0      	; 0x16 <i2cAbstractBusInit+0x16>
		const I2C_CLASS* class = i2c->class;
  16:	38 81       	ld	r19, Y
  18:	19 81       	ldd	r17, Y+1	; 0x01

		// Put each device on this bus
		for(uint8_t i=0; i<i2c->numDevices;i++){
  1a:	00 c0       	rjmp	.+0      	; 0x1c <i2cAbstractBusInit+0x1c>
			I2C_DEVICE* device = (I2C_DEVICE*)pgm_read_word(&i2c->devices[i]);
  1c:	6a 81       	ldd	r22, Y+2	; 0x02
  1e:	7b 81       	ldd	r23, Y+3	; 0x03
  20:	e8 2f       	mov	r30, r24
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	ee 0f       	add	r30, r30
  26:	ff 1f       	adc	r31, r31
  28:	e6 0f       	add	r30, r22
  2a:	f7 1f       	adc	r31, r23
  2c:	45 91       	lpm	r20, Z+
  2e:	54 91       	lpm	r21, Z
  30:	da 01       	movw	r26, r20
			if(device){
  32:	10 97       	sbiw	r26, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <i2cAbstractBusInit+0x36>

				// Check for address conflicts
				for(uint8_t j=i+1; j<i2c->numDevices;j++){
  36:	98 2f       	mov	r25, r24
  38:	00 c0       	rjmp	.+0      	; 0x3a <i2cAbstractBusInit+0x3a>
					I2C_DEVICE* other = (I2C_DEVICE*)pgm_read_word(&i2c->devices[j]);
  3a:	e9 2f       	mov	r30, r25
  3c:	f0 e0       	ldi	r31, 0x00	; 0
  3e:	ee 0f       	add	r30, r30
  40:	ff 1f       	adc	r31, r31
  42:	e6 0f       	add	r30, r22
  44:	f7 1f       	adc	r31, r23
  46:	45 91       	lpm	r20, Z+
  48:	54 91       	lpm	r21, Z
  4a:	fa 01       	movw	r30, r20
					if(other){
  4c:	30 97       	sbiw	r30, 0x00	; 0
  4e:	01 f0       	breq	.+0      	; 0x50 <i2cAbstractBusInit+0x50>
						if(device->addr == other->addr){
  50:	12 96       	adiw	r26, 0x02	; 2
  52:	5c 91       	ld	r21, X
  54:	12 97       	sbiw	r26, 0x02	; 2
  56:	42 81       	ldd	r20, Z+2	; 0x02
  58:	54 17       	cp	r21, r20
  5a:	01 f4       	brne	.+0      	; 0x5c <i2cAbstractBusInit+0x5c>
							setError(I2C_DUP_ADDR);
  5c:	81 ee       	ldi	r24, 0xE1	; 225
  5e:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
							return;
  62:	00 c0       	rjmp	.+0      	; 0x64 <i2cAbstractBusInit+0x64>
		for(uint8_t i=0; i<i2c->numDevices;i++){
			I2C_DEVICE* device = (I2C_DEVICE*)pgm_read_word(&i2c->devices[i]);
			if(device){

				// Check for address conflicts
				for(uint8_t j=i+1; j<i2c->numDevices;j++){
  64:	9f 5f       	subi	r25, 0xFF	; 255
  66:	92 17       	cp	r25, r18
  68:	01 f4       	brne	.+0      	; 0x6a <i2cAbstractBusInit+0x6a>
							return;
						}
					}
				}

				device->bus = i2c;
  6a:	11 96       	adiw	r26, 0x01	; 1
  6c:	dc 93       	st	X, r29
  6e:	ce 93       	st	-X, r28
void i2cAbstractBusInit(I2C_ABSTRACT_BUS* i2c){
	if(i2c && !i2c->initialised){
		const I2C_CLASS* class = i2c->class;

		// Put each device on this bus
		for(uint8_t i=0; i<i2c->numDevices;i++){
  70:	8f 5f       	subi	r24, 0xFF	; 255
  72:	2c 81       	ldd	r18, Y+4	; 0x04
  74:	82 17       	cp	r24, r18
  76:	00 f0       	brcs	.+0      	; 0x78 <i2cAbstractBusInit+0x78>
				device->bus = i2c;
			}
		}

		// Call the initialisation method for the actual class
		void (*fn)(I2C_ABSTRACT_BUS*) = (void (*)(I2C_ABSTRACT_BUS*))pgm_read_word(&class->init);
  78:	e3 2f       	mov	r30, r19
  7a:	f1 2f       	mov	r31, r17
  7c:	85 91       	lpm	r24, Z+
  7e:	94 91       	lpm	r25, Z
  80:	fc 01       	movw	r30, r24
		if(fn){
  82:	00 97       	sbiw	r24, 0x00	; 0
  84:	01 f0       	breq	.+0      	; 0x86 <i2cAbstractBusInit+0x86>
			fn(i2c);						// initialise the bus
  86:	ce 01       	movw	r24, r28
  88:	09 95       	icall
		}
		i2c->initialised = TRUE;
  8a:	8f ef       	ldi	r24, 0xFF	; 255
  8c:	8d 83       	std	Y+5, r24	; 0x05
	}
}
  8e:	df 91       	pop	r29
  90:	cf 91       	pop	r28
  92:	1f 91       	pop	r17
  94:	08 95       	ret

00000096 <i2cStop>:

void 	i2cStop(const I2C_ABSTRACT_BUS* i2c){
	if(i2c){
  96:	00 97       	sbiw	r24, 0x00	; 0
  98:	01 f0       	breq	.+0      	; 0x9a <i2cStop+0x4>
		if(i2c->initialised){
  9a:	dc 01       	movw	r26, r24
  9c:	15 96       	adiw	r26, 0x05	; 5
  9e:	2c 91       	ld	r18, X
  a0:	15 97       	sbiw	r26, 0x05	; 5
  a2:	22 23       	and	r18, r18
  a4:	01 f0       	breq	.+0      	; 0xa6 <i2cStop+0x10>
			const I2C_CLASS* class = i2c->class;
			void (*fn)(const I2C_ABSTRACT_BUS*) =
					(void (*)(const I2C_ABSTRACT_BUS*))pgm_read_word(&class->stop);
  a6:	ed 91       	ld	r30, X+
  a8:	fc 91       	ld	r31, X
  aa:	34 96       	adiw	r30, 0x04	; 4
  ac:	25 91       	lpm	r18, Z+
  ae:	34 91       	lpm	r19, Z
			fn(i2c); 	// call the stop method
  b0:	f9 01       	movw	r30, r18
  b2:	09 95       	icall
  b4:	08 95       	ret
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
  b6:	80 ee       	ldi	r24, 0xE0	; 224
  b8:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
  bc:	08 95       	ret

000000be <i2cGet>:
	}
}

uint8_t i2cGet(const I2C_ABSTRACT_BUS* i2c, boolean isLastByte){
	uint8_t rtn = 0;
	if(i2c){
  be:	00 97       	sbiw	r24, 0x00	; 0
  c0:	01 f0       	breq	.+0      	; 0xc2 <i2cGet+0x4>
		if(i2c->initialised){
  c2:	dc 01       	movw	r26, r24
  c4:	15 96       	adiw	r26, 0x05	; 5
  c6:	2c 91       	ld	r18, X
  c8:	15 97       	sbiw	r26, 0x05	; 5
  ca:	22 23       	and	r18, r18
  cc:	01 f0       	breq	.+0      	; 0xce <i2cGet+0x10>
			const I2C_CLASS* class = i2c->class;
			uint8_t (*fn)(const I2C_ABSTRACT_BUS*, boolean) =
					(uint8_t (*)(const I2C_ABSTRACT_BUS*,boolean))pgm_read_word(&class->get);
  ce:	ed 91       	ld	r30, X+
  d0:	fc 91       	ld	r31, X
  d2:	36 96       	adiw	r30, 0x06	; 6
  d4:	25 91       	lpm	r18, Z+
  d6:	34 91       	lpm	r19, Z
			rtn = fn(i2c, isLastByte); 	// call the get method
  d8:	f9 01       	movw	r30, r18
  da:	09 95       	icall
  dc:	08 95       	ret
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
  de:	80 ee       	ldi	r24, 0xE0	; 224
  e0:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
		}
	}
}

uint8_t i2cGet(const I2C_ABSTRACT_BUS* i2c, boolean isLastByte){
	uint8_t rtn = 0;
  e4:	80 e0       	ldi	r24, 0x00	; 0
  e6:	08 95       	ret
  e8:	80 e0       	ldi	r24, 0x00	; 0
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
		}
	}
	return rtn;
}
  ea:	08 95       	ret

000000ec <i2cPut>:
boolean i2cPut(const I2C_ABSTRACT_BUS* i2c, uint8_t b){
	boolean rtn = FALSE;
	if(i2c){
  ec:	00 97       	sbiw	r24, 0x00	; 0
  ee:	01 f0       	breq	.+0      	; 0xf0 <i2cPut+0x4>
		if(i2c->initialised){
  f0:	dc 01       	movw	r26, r24
  f2:	15 96       	adiw	r26, 0x05	; 5
  f4:	2c 91       	ld	r18, X
  f6:	15 97       	sbiw	r26, 0x05	; 5
  f8:	22 23       	and	r18, r18
  fa:	01 f0       	breq	.+0      	; 0xfc <i2cPut+0x10>
			const I2C_CLASS* class = i2c->class;
			boolean (*fn)(const I2C_ABSTRACT_BUS*, uint8_t) =
					(boolean (*)(const I2C_ABSTRACT_BUS*,uint8_t))pgm_read_word(&class->put);
  fc:	ed 91       	ld	r30, X+
  fe:	fc 91       	ld	r31, X
 100:	38 96       	adiw	r30, 0x08	; 8
 102:	25 91       	lpm	r18, Z+
 104:	34 91       	lpm	r19, Z
			rtn = fn(i2c, b); 	// call the put method
 106:	f9 01       	movw	r30, r18
 108:	09 95       	icall
 10a:	08 95       	ret
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
 10c:	80 ee       	ldi	r24, 0xE0	; 224
 10e:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
		}
	}
	return rtn;
}
boolean i2cPut(const I2C_ABSTRACT_BUS* i2c, uint8_t b){
	boolean rtn = FALSE;
 112:	80 e0       	ldi	r24, 0x00	; 0
 114:	08 95       	ret
 116:	80 e0       	ldi	r24, 0x00	; 0
		}else{
			setError(I2C_BUS_NOT_INITIALIZED);
		}
	}
	return rtn;
}
 118:	08 95       	ret

0000011a <i2cStart>:

boolean  i2cStart(const I2C_DEVICE* device, boolean writeMode){
	boolean rtn = FALSE;
	if(device){
 11a:	00 97       	sbiw	r24, 0x00	; 0
 11c:	01 f0       	breq	.+0      	; 0x11e <i2cStart+0x4>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 11e:	dc 01       	movw	r26, r24
 120:	ed 91       	ld	r30, X+
 122:	fc 91       	ld	r31, X
 124:	11 97       	sbiw	r26, 0x01	; 1
		if(i2c){
 126:	30 97       	sbiw	r30, 0x00	; 0
 128:	01 f0       	breq	.+0      	; 0x12a <i2cStart+0x10>
			if(i2c->initialised){
 12a:	25 81       	ldd	r18, Z+5	; 0x05
 12c:	22 23       	and	r18, r18
 12e:	01 f0       	breq	.+0      	; 0x130 <i2cStart+0x16>
				const I2C_CLASS* class = i2c->class;
				boolean	 (*fn)(const I2C_DEVICE*,boolean) =
						(boolean (*)(const I2C_DEVICE*,boolean))pgm_read_word(&class->start);
 130:	01 90       	ld	r0, Z+
 132:	f0 81       	ld	r31, Z
 134:	e0 2d       	mov	r30, r0
 136:	32 96       	adiw	r30, 0x02	; 2
 138:	25 91       	lpm	r18, Z+
 13a:	34 91       	lpm	r19, Z
				rtn = fn(device,writeMode); 	// start
 13c:	f9 01       	movw	r30, r18
 13e:	09 95       	icall
 140:	08 95       	ret
			}else{
				setError(I2C_BUS_NOT_INITIALIZED);
 142:	80 ee       	ldi	r24, 0xE0	; 224
 144:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
	}
	return rtn;
}

boolean  i2cStart(const I2C_DEVICE* device, boolean writeMode){
	boolean rtn = FALSE;
 148:	80 e0       	ldi	r24, 0x00	; 0
 14a:	08 95       	ret
 14c:	80 e0       	ldi	r24, 0x00	; 0
				setError(I2C_BUS_NOT_INITIALIZED);
			}
		}
	}
	return rtn;
}
 14e:	08 95       	ret

00000150 <i2cAbstractSetBitrate>:

void 	i2cAbstractSetBitrate(I2C_ABSTRACT_BUS* i2c,uint16_t bitrateKHz){
	if(i2c){
 150:	00 97       	sbiw	r24, 0x00	; 0
 152:	01 f0       	breq	.+0      	; 0x154 <i2cAbstractSetBitrate+0x4>

		const I2C_CLASS* class = i2c->class;

		// Call the  method for the actual class
		void (*fn)(const I2C_ABSTRACT_BUS*,uint16_t) = (void (*)(const I2C_ABSTRACT_BUS*,uint16_t))pgm_read_word(&class->speed);
 154:	dc 01       	movw	r26, r24
 156:	ed 91       	ld	r30, X+
 158:	fc 91       	ld	r31, X
 15a:	11 97       	sbiw	r26, 0x01	; 1
 15c:	3a 96       	adiw	r30, 0x0a	; 10
 15e:	25 91       	lpm	r18, Z+
 160:	34 91       	lpm	r19, Z
 162:	f9 01       	movw	r30, r18
		if(fn){
 164:	30 97       	sbiw	r30, 0x00	; 0
 166:	01 f0       	breq	.+0      	; 0x168 <i2cAbstractSetBitrate+0x18>
			fn(i2c,bitrateKHz);						// initialise the bus
 168:	09 95       	icall
 16a:	08 95       	ret

0000016c <i2cMasterReceive>:
}


// --- High level routines ----

boolean i2cMasterReceive(const I2C_DEVICE* device, size_t length, uint8_t *data){
 16c:	df 92       	push	r13
 16e:	ef 92       	push	r14
 170:	ff 92       	push	r15
 172:	0f 93       	push	r16
 174:	1f 93       	push	r17
 176:	cf 93       	push	r28
 178:	df 93       	push	r29
 17a:	eb 01       	movw	r28, r22
 17c:	8a 01       	movw	r16, r20
	boolean ack = FALSE;
	if(device){
 17e:	00 97       	sbiw	r24, 0x00	; 0
 180:	01 f0       	breq	.+0      	; 0x182 <i2cMasterReceive+0x16>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 182:	fc 01       	movw	r30, r24
 184:	e0 80       	ld	r14, Z
 186:	f1 80       	ldd	r15, Z+1	; 0x01
		ack = i2cStart(device,FALSE);
 188:	60 e0       	ldi	r22, 0x00	; 0
 18a:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 18e:	d8 2e       	mov	r13, r24
		if(ack){
 190:	88 23       	and	r24, r24
 192:	01 f0       	breq	.+0      	; 0x194 <i2cMasterReceive+0x28>
 194:	00 c0       	rjmp	.+0      	; 0x196 <i2cMasterReceive+0x2a>
			// receive data bytes
			while(length--){
 196:	21 97       	sbiw	r28, 0x01	; 1
				*data++ = i2cGet(i2c, (length) ? FALSE : TRUE);
 198:	01 f0       	breq	.+0      	; 0x19a <i2cMasterReceive+0x2e>
 19a:	60 e0       	ldi	r22, 0x00	; 0
 19c:	00 c0       	rjmp	.+0      	; 0x19e <i2cMasterReceive+0x32>
 19e:	6f ef       	ldi	r22, 0xFF	; 255
 1a0:	c7 01       	movw	r24, r14
 1a2:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 1a6:	f8 01       	movw	r30, r16
 1a8:	81 93       	st	Z+, r24
 1aa:	8f 01       	movw	r16, r30
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,FALSE);
		if(ack){
			// receive data bytes
			while(length--){
 1ac:	20 97       	sbiw	r28, 0x00	; 0
 1ae:	01 f4       	brne	.+0      	; 0x1b0 <i2cMasterReceive+0x44>
				*data++ = i2cGet(i2c, (length) ? FALSE : TRUE);
			}
		}
		i2cStop(i2c);											// Send stop bit
 1b0:	c7 01       	movw	r24, r14
 1b2:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <i2cMasterReceive+0x4c>


// --- High level routines ----

boolean i2cMasterReceive(const I2C_DEVICE* device, size_t length, uint8_t *data){
	boolean ack = FALSE;
 1b8:	dd 24       	eor	r13, r13
			}
		}
		i2cStop(i2c);											// Send stop bit
	}
	return ack;
}
 1ba:	8d 2d       	mov	r24, r13
 1bc:	df 91       	pop	r29
 1be:	cf 91       	pop	r28
 1c0:	1f 91       	pop	r17
 1c2:	0f 91       	pop	r16
 1c4:	ff 90       	pop	r15
 1c6:	ef 90       	pop	r14
 1c8:	df 90       	pop	r13
 1ca:	08 95       	ret

000001cc <i2cMasterSend>:

boolean i2cMasterSend(const I2C_DEVICE* device, size_t length, const uint8_t *data){
 1cc:	df 92       	push	r13
 1ce:	ef 92       	push	r14
 1d0:	ff 92       	push	r15
 1d2:	0f 93       	push	r16
 1d4:	1f 93       	push	r17
 1d6:	cf 93       	push	r28
 1d8:	df 93       	push	r29
 1da:	eb 01       	movw	r28, r22
 1dc:	8a 01       	movw	r16, r20
	boolean ack = FALSE;
	if(device){
 1de:	00 97       	sbiw	r24, 0x00	; 0
 1e0:	01 f0       	breq	.+0      	; 0x1e2 <i2cMasterSend+0x16>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 1e2:	fc 01       	movw	r30, r24
 1e4:	e0 80       	ld	r14, Z
 1e6:	f1 80       	ldd	r15, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 1e8:	6f ef       	ldi	r22, 0xFF	; 255
 1ea:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 1ee:	d8 2e       	mov	r13, r24
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <i2cMasterSend+0x26>
		if(ack){
			// send the data
			while(ack && length--){
				ack &= i2cPut(i2c,*data++);
 1f2:	f8 01       	movw	r30, r16
 1f4:	61 91       	ld	r22, Z+
 1f6:	8f 01       	movw	r16, r30
 1f8:	c7 01       	movw	r24, r14
 1fa:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 1fe:	d8 22       	and	r13, r24
 200:	21 97       	sbiw	r28, 0x01	; 1
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && length--){
 202:	dd 20       	and	r13, r13
 204:	01 f0       	breq	.+0      	; 0x206 <i2cMasterSend+0x3a>
 206:	20 97       	sbiw	r28, 0x00	; 0
 208:	01 f4       	brne	.+0      	; 0x20a <i2cMasterSend+0x3e>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 20a:	c7 01       	movw	r24, r14
 20c:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 210:	00 c0       	rjmp	.+0      	; 0x212 <i2cMasterSend+0x46>
	}
	return ack;
}

boolean i2cMasterSend(const I2C_DEVICE* device, size_t length, const uint8_t *data){
	boolean ack = FALSE;
 212:	dd 24       	eor	r13, r13
			}
		}
		i2cStop(i2c);
	}
	return ack;
}
 214:	8d 2d       	mov	r24, r13
 216:	df 91       	pop	r29
 218:	cf 91       	pop	r28
 21a:	1f 91       	pop	r17
 21c:	0f 91       	pop	r16
 21e:	ff 90       	pop	r15
 220:	ef 90       	pop	r14
 222:	df 90       	pop	r13
 224:	08 95       	ret

00000226 <i2cMasterTransfer>:


boolean i2cMasterTransfer(const I2C_DEVICE* device, size_t wlen, const uint8_t *wdata, size_t rlen, uint8_t * rdata){
 226:	6f 92       	push	r6
 228:	7f 92       	push	r7
 22a:	8f 92       	push	r8
 22c:	9f 92       	push	r9
 22e:	af 92       	push	r10
 230:	bf 92       	push	r11
 232:	cf 92       	push	r12
 234:	df 92       	push	r13
 236:	ef 92       	push	r14
 238:	ff 92       	push	r15
 23a:	0f 93       	push	r16
 23c:	1f 93       	push	r17
 23e:	cf 93       	push	r28
 240:	df 93       	push	r29
 242:	7c 01       	movw	r14, r24
 244:	5b 01       	movw	r10, r22
 246:	3a 01       	movw	r6, r20
 248:	e9 01       	movw	r28, r18
 24a:	48 01       	movw	r8, r16
	boolean ack = false;
	if(device){
 24c:	00 97       	sbiw	r24, 0x00	; 0
 24e:	01 f0       	breq	.+0      	; 0x250 <i2cMasterTransfer+0x2a>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 250:	fc 01       	movw	r30, r24
 252:	c0 80       	ld	r12, Z
 254:	d1 80       	ldd	r13, Z+1	; 0x01

		// Write the data
		ack = i2cStart(device,TRUE);
 256:	6f ef       	ldi	r22, 0xFF	; 255
 258:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 25c:	18 2f       	mov	r17, r24
 25e:	00 c0       	rjmp	.+0      	; 0x260 <i2cMasterTransfer+0x3a>
		if(ack){
			// send the data
			while(ack && wlen--){
				ack &= i2cPut(i2c,*wdata++);
 260:	f3 01       	movw	r30, r6
 262:	61 91       	ld	r22, Z+
 264:	3f 01       	movw	r6, r30
 266:	c6 01       	movw	r24, r12
 268:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 26c:	18 23       	and	r17, r24
 26e:	08 94       	sec
 270:	a1 08       	sbc	r10, r1
 272:	b1 08       	sbc	r11, r1

		// Write the data
		ack = i2cStart(device,TRUE);
		if(ack){
			// send the data
			while(ack && wlen--){
 274:	11 23       	and	r17, r17
 276:	01 f0       	breq	.+0      	; 0x278 <i2cMasterTransfer+0x52>
 278:	a1 14       	cp	r10, r1
 27a:	b1 04       	cpc	r11, r1
 27c:	01 f4       	brne	.+0      	; 0x27e <i2cMasterTransfer+0x58>
 27e:	00 c0       	rjmp	.+0      	; 0x280 <i2cMasterTransfer+0x5a>
			ack = i2cStart(device,FALSE);	// repeated start
		}
		if(ack){
			// Read the data
			while(rlen--){
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
 280:	10 e0       	ldi	r17, 0x00	; 0
 282:	00 c0       	rjmp	.+0      	; 0x284 <i2cMasterTransfer+0x5e>
		if(ack){
			ack = i2cStart(device,FALSE);	// repeated start
		}
		if(ack){
			// Read the data
			while(rlen--){
 284:	21 97       	sbiw	r28, 0x01	; 1
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
 286:	01 f0       	breq	.+0      	; 0x288 <i2cMasterTransfer+0x62>
 288:	60 e0       	ldi	r22, 0x00	; 0
 28a:	00 c0       	rjmp	.+0      	; 0x28c <i2cMasterTransfer+0x66>
 28c:	6f ef       	ldi	r22, 0xFF	; 255
 28e:	c6 01       	movw	r24, r12
 290:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 294:	f4 01       	movw	r30, r8
 296:	81 93       	st	Z+, r24
 298:	4f 01       	movw	r8, r30
		if(ack){
			ack = i2cStart(device,FALSE);	// repeated start
		}
		if(ack){
			// Read the data
			while(rlen--){
 29a:	20 97       	sbiw	r28, 0x00	; 0
 29c:	01 f4       	brne	.+0      	; 0x29e <i2cMasterTransfer+0x78>
				*rdata++ = i2cGet(i2c, (rlen) ? FALSE : TRUE);
			}
		}

		// Stop
		i2cStop(i2c);
 29e:	c6 01       	movw	r24, r12
 2a0:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 2a4:	00 c0       	rjmp	.+0      	; 0x2a6 <i2cMasterTransfer+0x80>
	return ack;
}


boolean i2cMasterTransfer(const I2C_DEVICE* device, size_t wlen, const uint8_t *wdata, size_t rlen, uint8_t * rdata){
	boolean ack = false;
 2a6:	10 e0       	ldi	r17, 0x00	; 0

		// Stop
		i2cStop(i2c);
	}
	return ack;
}
 2a8:	81 2f       	mov	r24, r17
 2aa:	df 91       	pop	r29
 2ac:	cf 91       	pop	r28
 2ae:	1f 91       	pop	r17
 2b0:	0f 91       	pop	r16
 2b2:	ff 90       	pop	r15
 2b4:	ef 90       	pop	r14
 2b6:	df 90       	pop	r13
 2b8:	cf 90       	pop	r12
 2ba:	bf 90       	pop	r11
 2bc:	af 90       	pop	r10
 2be:	9f 90       	pop	r9
 2c0:	8f 90       	pop	r8
 2c2:	7f 90       	pop	r7
 2c4:	6f 90       	pop	r6
 2c6:	08 95       	ret
			}
		}

		// Read the response
		if(ack){
			ack = i2cStart(device,FALSE);	// repeated start
 2c8:	c7 01       	movw	r24, r14
 2ca:	60 e0       	ldi	r22, 0x00	; 0
 2cc:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 2d0:	18 2f       	mov	r17, r24
		}
		if(ack){
 2d2:	88 23       	and	r24, r24
 2d4:	01 f4       	brne	.+0      	; 0x2d6 <i2cMasterTransfer+0xb0>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <i2cMasterSendWithPrefix>

000002d8 <i2cMasterSendWithPrefix>:
		i2cStop(i2c);
	}
	return ack;
}

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
 2d8:	8f 92       	push	r8
 2da:	9f 92       	push	r9
 2dc:	af 92       	push	r10
 2de:	bf 92       	push	r11
 2e0:	cf 92       	push	r12
 2e2:	df 92       	push	r13
 2e4:	ef 92       	push	r14
 2e6:	ff 92       	push	r15
 2e8:	0f 93       	push	r16
 2ea:	1f 93       	push	r17
 2ec:	cf 93       	push	r28
 2ee:	df 93       	push	r29
 2f0:	6b 01       	movw	r12, r22
 2f2:	4a 01       	movw	r8, r20
 2f4:	79 01       	movw	r14, r18
 2f6:	58 01       	movw	r10, r16
	boolean ack = FALSE;
	if(device){
 2f8:	00 97       	sbiw	r24, 0x00	; 0
 2fa:	01 f0       	breq	.+0      	; 0x2fc <i2cMasterSendWithPrefix+0x24>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 2fc:	fc 01       	movw	r30, r24
 2fe:	c0 81       	ld	r28, Z
 300:	d1 81       	ldd	r29, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 302:	6f ef       	ldi	r22, 0xFF	; 255
 304:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 308:	18 2f       	mov	r17, r24
		if(ack){
 30a:	88 23       	and	r24, r24
 30c:	01 f4       	brne	.+0      	; 0x30e <i2cMasterSendWithPrefix+0x36>
 30e:	00 c0       	rjmp	.+0      	; 0x310 <i2cMasterSendWithPrefix+0x38>
			// Put the first block of data
			while(ack && prefixLen--){
				ack &= i2cPut(i2c,*prefix++);
 310:	f4 01       	movw	r30, r8
 312:	61 91       	ld	r22, Z+
 314:	4f 01       	movw	r8, r30
 316:	ce 01       	movw	r24, r28
 318:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 31c:	18 23       	and	r17, r24
 31e:	08 94       	sec
 320:	c1 08       	sbc	r12, r1
 322:	d1 08       	sbc	r13, r1
	if(device){
		const I2C_ABSTRACT_BUS* i2c = device->bus;
		ack = i2cStart(device,TRUE);
		if(ack){
			// Put the first block of data
			while(ack && prefixLen--){
 324:	11 23       	and	r17, r17
 326:	01 f0       	breq	.+0      	; 0x328 <i2cMasterSendWithPrefix+0x50>
 328:	c1 14       	cp	r12, r1
 32a:	d1 04       	cpc	r13, r1
 32c:	01 f4       	brne	.+0      	; 0x32e <i2cMasterSendWithPrefix+0x56>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <i2cMasterSendWithPrefix+0x58>
				ack &= i2cPut(i2c,*prefix++);
			}

			// send the second block of data
			while(ack && length--){
 330:	08 94       	sec
 332:	e1 08       	sbc	r14, r1
 334:	f1 08       	sbc	r15, r1
				ack &= i2cPut(i2c,*data++);
 336:	f5 01       	movw	r30, r10
 338:	61 91       	ld	r22, Z+
 33a:	5f 01       	movw	r10, r30
 33c:	ce 01       	movw	r24, r28
 33e:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 342:	18 23       	and	r17, r24
			while(ack && prefixLen--){
				ack &= i2cPut(i2c,*prefix++);
			}

			// send the second block of data
			while(ack && length--){
 344:	11 23       	and	r17, r17
 346:	01 f0       	breq	.+0      	; 0x348 <i2cMasterSendWithPrefix+0x70>
 348:	e1 14       	cp	r14, r1
 34a:	f1 04       	cpc	r15, r1
 34c:	01 f4       	brne	.+0      	; 0x34e <i2cMasterSendWithPrefix+0x76>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 34e:	ce 01       	movw	r24, r28
 350:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 354:	00 c0       	rjmp	.+0      	; 0x356 <i2cMasterSendWithPrefix+0x7e>
	}
	return ack;
}

boolean i2cMasterSendWithPrefix(const I2C_DEVICE* device, size_t prefixLen, const uint8_t* prefix, size_t length, const uint8_t* data){
	boolean ack = FALSE;
 356:	10 e0       	ldi	r17, 0x00	; 0
		}
		i2cStop(i2c);
	}
	return ack;

}
 358:	81 2f       	mov	r24, r17
 35a:	df 91       	pop	r29
 35c:	cf 91       	pop	r28
 35e:	1f 91       	pop	r17
 360:	0f 91       	pop	r16
 362:	ff 90       	pop	r15
 364:	ef 90       	pop	r14
 366:	df 90       	pop	r13
 368:	cf 90       	pop	r12
 36a:	bf 90       	pop	r11
 36c:	af 90       	pop	r10
 36e:	9f 90       	pop	r9
 370:	8f 90       	pop	r8
 372:	08 95       	ret

00000374 <i2cMasterWriteRegisters>:


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
 374:	cf 92       	push	r12
 376:	df 92       	push	r13
 378:	ef 92       	push	r14
 37a:	ff 92       	push	r15
 37c:	0f 93       	push	r16
 37e:	1f 93       	push	r17
 380:	cf 93       	push	r28
 382:	df 93       	push	r29
 384:	16 2f       	mov	r17, r22
 386:	7a 01       	movw	r14, r20
 388:	69 01       	movw	r12, r18
	boolean ack = FALSE;
	if(device){
 38a:	00 97       	sbiw	r24, 0x00	; 0
 38c:	01 f0       	breq	.+0      	; 0x38e <i2cMasterWriteRegisters+0x1a>
		const I2C_ABSTRACT_BUS* i2c = device->bus;
 38e:	fc 01       	movw	r30, r24
 390:	c0 81       	ld	r28, Z
 392:	d1 81       	ldd	r29, Z+1	; 0x01
		ack = i2cStart(device,TRUE);
 394:	6f ef       	ldi	r22, 0xFF	; 255
 396:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 39a:	08 2f       	mov	r16, r24
		if(ack){
 39c:	88 23       	and	r24, r24
 39e:	01 f0       	breq	.+0      	; 0x3a0 <i2cMasterWriteRegisters+0x2c>
			// Put the first register number
			ack &= i2cPut(i2c,startReg);
 3a0:	ce 01       	movw	r24, r28
 3a2:	61 2f       	mov	r22, r17
 3a4:	00 c0       	rjmp	.+0      	; 0x3a6 <i2cMasterWriteRegisters+0x32>

			// send the data
			while(ack && numBytes--){
 3a6:	08 94       	sec
 3a8:	e1 08       	sbc	r14, r1
 3aa:	f1 08       	sbc	r15, r1
				ack &= i2cPut(i2c,*data++);
 3ac:	f6 01       	movw	r30, r12
 3ae:	61 91       	ld	r22, Z+
 3b0:	6f 01       	movw	r12, r30
 3b2:	ce 01       	movw	r24, r28
 3b4:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 3b8:	08 23       	and	r16, r24
		if(ack){
			// Put the first register number
			ack &= i2cPut(i2c,startReg);

			// send the data
			while(ack && numBytes--){
 3ba:	01 f0       	breq	.+0      	; 0x3bc <i2cMasterWriteRegisters+0x48>
 3bc:	e1 14       	cp	r14, r1
 3be:	f1 04       	cpc	r15, r1
 3c0:	01 f4       	brne	.+0      	; 0x3c2 <i2cMasterWriteRegisters+0x4e>
				ack &= i2cPut(i2c,*data++);
			}
		}
		i2cStop(i2c);
 3c2:	ce 01       	movw	r24, r28
 3c4:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
 3c8:	00 c0       	rjmp	.+0      	; 0x3ca <i2cMasterWriteRegisters+0x56>
}


// Implement shorthand versions for any kind of i2c bus
boolean i2cMasterWriteRegisters(const I2C_DEVICE* device,uint8_t startReg, size_t numBytes, const uint8_t* data){
	boolean ack = FALSE;
 3ca:	00 e0       	ldi	r16, 0x00	; 0
			}
		}
		i2cStop(i2c);
	}
	return ack;
}
 3cc:	80 2f       	mov	r24, r16
 3ce:	df 91       	pop	r29
 3d0:	cf 91       	pop	r28
 3d2:	1f 91       	pop	r17
 3d4:	0f 91       	pop	r16
 3d6:	ff 90       	pop	r15
 3d8:	ef 90       	pop	r14
 3da:	df 90       	pop	r13
 3dc:	cf 90       	pop	r12
 3de:	08 95       	ret

000003e0 <i2cMasterReadRegisters>:

boolean i2cMasterReadRegisters(const I2C_DEVICE* device, uint8_t startReg, size_t numBytes, uint8_t* response){
 3e0:	0f 93       	push	r16
 3e2:	1f 93       	push	r17
 3e4:	cf 93       	push	r28
 3e6:	df 93       	push	r29
 3e8:	0f 92       	push	r0
 3ea:	cd b7       	in	r28, 0x3d	; 61
 3ec:	de b7       	in	r29, 0x3e	; 62
 3ee:	69 83       	std	Y+1, r22	; 0x01
 3f0:	fa 01       	movw	r30, r20
 3f2:	89 01       	movw	r16, r18
	return i2cMasterTransfer(device, 1, &startReg, numBytes, response);
 3f4:	61 e0       	ldi	r22, 0x01	; 1
 3f6:	70 e0       	ldi	r23, 0x00	; 0
 3f8:	ae 01       	movw	r20, r28
 3fa:	4f 5f       	subi	r20, 0xFF	; 255
 3fc:	5f 4f       	sbci	r21, 0xFF	; 255
 3fe:	9f 01       	movw	r18, r30
 400:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
}
 404:	0f 90       	pop	r0
 406:	df 91       	pop	r29
 408:	cf 91       	pop	r28
 40a:	1f 91       	pop	r17
 40c:	0f 91       	pop	r16
 40e:	08 95       	ret

00000410 <i2cMasterWriteRegister>:
boolean i2cMasterWriteRegister(const I2C_DEVICE* device, uint8_t reg, uint8_t value){
 410:	cf 93       	push	r28
 412:	df 93       	push	r29
 414:	00 d0       	rcall	.+0      	; 0x416 <i2cMasterWriteRegister+0x6>
 416:	cd b7       	in	r28, 0x3d	; 61
 418:	de b7       	in	r29, 0x3e	; 62
	uint8_t data[2] = {reg,value};
 41a:	69 83       	std	Y+1, r22	; 0x01
 41c:	4a 83       	std	Y+2, r20	; 0x02
	return i2cMasterSend(device, sizeof(data), data);
 41e:	62 e0       	ldi	r22, 0x02	; 2
 420:	70 e0       	ldi	r23, 0x00	; 0
 422:	ae 01       	movw	r20, r28
 424:	4f 5f       	subi	r20, 0xFF	; 255
 426:	5f 4f       	sbci	r21, 0xFF	; 255
 428:	0e 94 00 00 	call	0	; 0x0 <i2cAbstractBusInit>
}
 42c:	0f 90       	pop	r0
 42e:	0f 90       	pop	r0
 430:	df 91       	pop	r29
 432:	cf 91       	pop	r28
 434:	08 95       	ret

i2cHwBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000162  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000196  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000196  2**0
                  ALLOC
  3 .text.startup 00000018  00000000  00000000  00000196  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .ctors        00000002  00000000  00000000  000001ae  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  5 .progmem.data 0000000c  00000000  00000000  000001b0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  6 .debug_info   00000478  00000000  00000000  000001bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_abbrev 00000188  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000025f  00000000  00000000  000007bc  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_aranges 00000028  00000000  00000000  00000a1b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_ranges 00000018  00000000  00000000  00000a43  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 11 .debug_line   000000fb  00000000  00000000  00000a5b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 12 .debug_str    00000258  00000000  00000000  00000b56  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000000b4  00000000  00000000  00000db0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <speed>:
static void speed(const I2C_ABSTRACT_BUS* bus,uint16_t bitrateKHz){
	// TWBR x 4pow(TWPS) = ((cpudiv1000/ bitrateKHz) - 16) /2
	uint16_t bitrate_div;

	// calculate bitrate division
	bitrate_div = cpu_speed_div_1000 / bitrateKHz;
   0:	80 91 00 00 	lds	r24, 0x0000
   4:	90 91 00 00 	lds	r25, 0x0000
   8:	0e 94 00 00 	call	0	; 0x0 <speed>

	if(bitrate_div >= 16){
   c:	60 31       	cpi	r22, 0x10	; 16
   e:	71 05       	cpc	r23, r1
  10:	00 f0       	brcs	.+0      	; 0x12 <speed+0x12>
		bitrate_div = (bitrate_div-16)/2;
  12:	60 51       	subi	r22, 0x10	; 16
  14:	70 40       	sbci	r23, 0x00	; 0
  16:	76 95       	lsr	r23
  18:	67 95       	ror	r22
  1a:	00 c0       	rjmp	.+0      	; 0x1c <speed+0x1c>
	}else{
		bitrate_div=0;
  1c:	60 e0       	ldi	r22, 0x00	; 0
  1e:	70 e0       	ldi	r23, 0x00	; 0
	}

	// Turn prescaler off by default
	#ifdef TWPS0
		cbi(TWSR, TWPS0);
  20:	80 91 b9 00 	lds	r24, 0x00B9
  24:	8e 7f       	andi	r24, 0xFE	; 254
  26:	80 93 b9 00 	sts	0x00B9, r24
	#endif
	#ifdef TWPS1
		cbi(TWSR, TWPS1);
  2a:	80 91 b9 00 	lds	r24, 0x00B9
  2e:	8d 7f       	andi	r24, 0xFD	; 253
  30:	80 93 b9 00 	sts	0x00B9, r24
	#endif

	// Check if need to use the prescaler
	#ifdef TWPS0
	if(bitrate_div > 255){
  34:	6f 3f       	cpi	r22, 0xFF	; 255
  36:	71 05       	cpc	r23, r1
  38:	01 f0       	breq	.+0      	; 0x3a <speed+0x3a>
  3a:	00 f0       	brcs	.+0      	; 0x3c <speed+0x3c>
		sbi(TWSR, TWPS0);
  3c:	80 91 b9 00 	lds	r24, 0x00B9
  40:	81 60       	ori	r24, 0x01	; 1
  42:	80 93 b9 00 	sts	0x00B9, r24
		bitrate_div /= 4;
  46:	76 95       	lsr	r23
  48:	67 95       	ror	r22
  4a:	76 95       	lsr	r23
  4c:	67 95       	ror	r22
	}
	#endif
	#ifdef TWPS1
	if(bitrate_div > 255){
  4e:	6f 3f       	cpi	r22, 0xFF	; 255
  50:	71 05       	cpc	r23, r1
  52:	01 f0       	breq	.+0      	; 0x54 <speed+0x54>
  54:	00 f0       	brcs	.+0      	; 0x56 <speed+0x56>
		sbi(TWSR, TWPS1);
  56:	80 91 b9 00 	lds	r24, 0x00B9
  5a:	82 60       	ori	r24, 0x02	; 2
  5c:	80 93 b9 00 	sts	0x00B9, r24
		bitrate_div /= 16;
  60:	84 e0       	ldi	r24, 0x04	; 4
  62:	76 95       	lsr	r23
  64:	67 95       	ror	r22
  66:	8a 95       	dec	r24
  68:	01 f4       	brne	.+0      	; 0x6a <speed+0x6a>
	}
	#endif

	// Cannot prescale it on some devices - so just go as slow as possible
	if(bitrate_div > 255){
  6a:	6f 3f       	cpi	r22, 0xFF	; 255
  6c:	71 05       	cpc	r23, r1
  6e:	01 f0       	breq	.+0      	; 0x70 <speed+0x70>
  70:	00 f0       	brcs	.+0      	; 0x72 <speed+0x72>
		bitrate_div = 255;
  72:	6f ef       	ldi	r22, 0xFF	; 255
  74:	70 e0       	ldi	r23, 0x00	; 0
	}

	outb(TWBR, (uint8_t)(bitrate_div) );
  76:	60 93 b8 00 	sts	0x00B8, r22
}
  7a:	08 95       	ret

0000007c <init>:
//	sei();
}

static void init(I2C_ABSTRACT_BUS* bus){
	// set i2c bit rate to 100KHz
	speed(bus,100);
  7c:	64 e6       	ldi	r22, 0x64	; 100
  7e:	70 e0       	ldi	r23, 0x00	; 0
  80:	0e 94 00 00 	call	0	; 0x0 <speed>
}
  84:	08 95       	ret

00000086 <i2cWaitForComplete>:

static inline void i2cWaitForComplete(void){
	// wait for i2c interface to complete operation
	while( !(inb(TWCR) & BV(TWINT)) );
  86:	80 91 bc 00 	lds	r24, 0x00BC
  8a:	87 ff       	sbrs	r24, 7
  8c:	00 c0       	rjmp	.+0      	; 0x8e <i2cWaitForComplete+0x8>
}
  8e:	08 95       	ret

00000090 <getByte>:

static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	// begin receive over i2c
	if( isLastByte ){
		// ackFlag = FALSE: NACK the received data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  90:	80 91 bc 00 	lds	r24, 0x00BC
  94:	8f 70       	andi	r24, 0x0F	; 15
	while( !(inb(TWCR) & BV(TWINT)) );
}

static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	// begin receive over i2c
	if( isLastByte ){
  96:	66 23       	and	r22, r22
  98:	01 f0       	breq	.+0      	; 0x9a <getByte+0xa>
		// ackFlag = FALSE: NACK the received data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  9a:	80 68       	ori	r24, 0x80	; 128
  9c:	00 c0       	rjmp	.+0      	; 0x9e <getByte+0xe>
	}else{
		// ackFlag = TRUE: ACK the recevied data
		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
  9e:	80 6c       	ori	r24, 0xC0	; 192
  a0:	80 93 bc 00 	sts	0x00BC, r24
	}
	i2cWaitForComplete();
  a4:	0e 94 00 00 	call	0	; 0x0 <speed>
	return inb(TWDR);
  a8:	80 91 bb 00 	lds	r24, 0x00BB
}
  ac:	08 95       	ret

000000ae <putByte>:


static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t data){
	// save data to the TWDR
	outb(TWDR, data);
  ae:	60 93 bb 00 	sts	0x00BB, r22
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
  b2:	80 91 bc 00 	lds	r24, 0x00BC
  b6:	8f 70       	andi	r24, 0x0F	; 15
  b8:	80 68       	ori	r24, 0x80	; 128
  ba:	80 93 bc 00 	sts	0x00BC, r24

	i2cWaitForComplete();
  be:	0e 94 00 00 	call	0	; 0x0 <speed>

	uint8_t got = inb(TWSR) & TWSR_STATUS_MASK;	// get the status
  c2:	80 91 b9 00 	lds	r24, 0x00B9
  c6:	88 7f       	andi	r24, 0xF8	; 248

    return( (got == TW_MT_DATA_ACK) ? TRUE : FALSE );
  c8:	88 32       	cpi	r24, 0x28	; 40
  ca:	01 f4       	brne	.+0      	; 0xcc <putByte+0x1e>
  cc:	8f ef       	ldi	r24, 0xFF	; 255
  ce:	08 95       	ret
  d0:	80 e0       	ldi	r24, 0x00	; 0

}
  d2:	08 95       	ret

000000d4 <start>:

static boolean start(const I2C_DEVICE* device, boolean writeMode){
  d4:	ef 92       	push	r14
  d6:	ff 92       	push	r15
  d8:	1f 93       	push	r17
  da:	cf 93       	push	r28
  dc:	df 93       	push	r29
  de:	0f 92       	push	r0
  e0:	cd b7       	in	r28, 0x3d	; 61
  e2:	de b7       	in	r29, 0x3e	; 62
  e4:	7c 01       	movw	r14, r24
	uint8_t expect;
	if(writeMode){
  e6:	66 23       	and	r22, r22
  e8:	01 f0       	breq	.+0      	; 0xea <start+0x16>
		i2cState = I2C_MASTER_TX;
  ea:	82 e0       	ldi	r24, 0x02	; 2
  ec:	80 93 00 00 	sts	0x0000, r24
		expect = TW_MT_SLA_ACK;
  f0:	18 e1       	ldi	r17, 0x18	; 24
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <start+0x20>
	}else{
		i2cState = I2C_MASTER_RX;
  f4:	83 e0       	ldi	r24, 0x03	; 3
  f6:	80 93 00 00 	sts	0x0000, r24
		expect = TW_MR_SLA_ACK;
  fa:	10 e4       	ldi	r17, 0x40	; 64
	}

	// send start condition
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
  fc:	80 91 bc 00 	lds	r24, 0x00BC
 100:	8f 70       	andi	r24, 0x0F	; 15
 102:	80 6a       	ori	r24, 0xA0	; 160
 104:	80 93 bc 00 	sts	0x00BC, r24
	i2cWaitForComplete();
 108:	69 83       	std	Y+1, r22	; 0x01
 10a:	0e 94 00 00 	call	0	; 0x0 <speed>

	// Send the device addr and direction
	uint8_t addr = device->addr;
 10e:	f7 01       	movw	r30, r14
 110:	82 81       	ldd	r24, Z+2	; 0x02
	if(writeMode==FALSE){
 112:	69 81       	ldd	r22, Y+1	; 0x01
 114:	66 23       	and	r22, r22
 116:	01 f4       	brne	.+0      	; 0x118 <start+0x44>
		addr |= 1;
 118:	81 60       	ori	r24, 0x01	; 1
 11a:	00 c0       	rjmp	.+0      	; 0x11c <start+0x48>
	}else{
		addr &= 0xfe;
 11c:	8e 7f       	andi	r24, 0xFE	; 254
	}
	outb(TWDR, addr);
 11e:	80 93 bb 00 	sts	0x00BB, r24
	// begin send
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 122:	80 91 bc 00 	lds	r24, 0x00BC
 126:	8f 70       	andi	r24, 0x0F	; 15
 128:	80 68       	ori	r24, 0x80	; 128
 12a:	80 93 bc 00 	sts	0x00BC, r24
	i2cWaitForComplete();
 12e:	0e 94 00 00 	call	0	; 0x0 <speed>

	uint8_t got = inb(TWSR) & TWSR_STATUS_MASK;	// get the status
 132:	80 91 b9 00 	lds	r24, 0x00B9
 136:	88 7f       	andi	r24, 0xF8	; 248
    return( (got == expect) ? TRUE : FALSE );
 138:	81 17       	cp	r24, r17
 13a:	01 f4       	brne	.+0      	; 0x13c <start+0x68>
 13c:	8f ef       	ldi	r24, 0xFF	; 255
 13e:	00 c0       	rjmp	.+0      	; 0x140 <start+0x6c>
 140:	80 e0       	ldi	r24, 0x00	; 0

}
 142:	0f 90       	pop	r0
 144:	df 91       	pop	r29
 146:	cf 91       	pop	r28
 148:	1f 91       	pop	r17
 14a:	ff 90       	pop	r15
 14c:	ef 90       	pop	r14
 14e:	08 95       	ret

00000150 <stop>:

static void stop(const I2C_ABSTRACT_BUS* bus){
	// transmit stop condition
	// leave with TWEA on for slave receiving
	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
 150:	ec eb       	ldi	r30, 0xBC	; 188
 152:	f0 e0       	ldi	r31, 0x00	; 0
 154:	80 81       	ld	r24, Z
 156:	8f 70       	andi	r24, 0x0F	; 15
 158:	80 6d       	ori	r24, 0xD0	; 208
 15a:	80 83       	st	Z, r24
	i2cState = I2C_IDLE;
 15c:	10 92 00 00 	sts	0x0000, r1
}
 160:	08 95       	ret

Disassembly of section .text.startup:

00000000 <_private_i2cMasterInit>:

// Initialiase I2C hardware
void __attribute__ ((constructor)) _private_i2cMasterInit(void){

	// Make the 2 wires into inputs
	cbi(SCL_DDR,SCL_PIN);
   0:	50 98       	cbi	0x0a, 0	; 10
	cbi(SDA_DDR,SDA_PIN);
   2:	51 98       	cbi	0x0a, 1	; 10
	// and turn on the pullups
	sbi(SCL_PORT,SCL_PIN);
   4:	58 9a       	sbi	0x0b, 0	; 11
	sbi(SDA_PORT,SDA_PIN);
   6:	59 9a       	sbi	0x0b, 1	; 11


	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
   8:	ec eb       	ldi	r30, 0xBC	; 188
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	84 60       	ori	r24, 0x04	; 4
  10:	80 83       	st	Z, r24

	// set state
	i2cState = I2C_IDLE;
  12:	10 92 00 00 	sts	0x0000, r1
//	sbi(TWCR, TWIE);
//	sbi(TWCR, TWEA);

	// enable interrupts
//	sei();
}
  16:	08 95       	ret

i2cSwBus.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000214  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000248  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000248  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000248  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000008ef  00000000  00000000  00000254  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000235  00000000  00000000  00000b43  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000049f  00000000  00000000  00000d78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001217  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   0000013f  00000000  00000000  00001237  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000003a8  00000000  00000000  00001376  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000118  00000000  00000000  00001720  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <halfDelay>:
	pin_make_output(i2c->sda,FALSE);
}

// Wait for at least 5uS
static void halfDelay(){
	delay_us(5);
   0:	65 e0       	ldi	r22, 0x05	; 5
   2:	70 e0       	ldi	r23, 0x00	; 0
   4:	80 e0       	ldi	r24, 0x00	; 0
   6:	90 e0       	ldi	r25, 0x00	; 0
   8:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}
   c:	08 95       	ret

0000000e <sda_high.isra.0>:
	}while(pin_is_low(i2c->scl));
}

// Make the data line high
static void sda_high(const I2C_SOFTWARE_BUS* i2c){
	pin_make_input(i2c->sda,FALSE);			// Assumes external resistor (works)
   e:	60 e0       	ldi	r22, 0x00	; 0
  10:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}
  14:	08 95       	ret

00000016 <scl_high.isra.3>:
#include "i2cBus.h"
#include "iopin.h"
#include "timer.h"

// Make the clock high
static void scl_high(const I2C_SOFTWARE_BUS* i2c){
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	ec 01       	movw	r28, r24
	do{
		pin_make_input(i2c->scl,FALSE);		// Assumes external resistor (works)
  1c:	88 81       	ld	r24, Y
  1e:	99 81       	ldd	r25, Y+1	; 0x01
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	}while(pin_is_low(i2c->scl));
  26:	88 81       	ld	r24, Y
  28:	99 81       	ldd	r25, Y+1	; 0x01
  2a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  2e:	88 23       	and	r24, r24
  30:	01 f0       	breq	.+0      	; 0x32 <scl_high.isra.3+0x1c>
}
  32:	df 91       	pop	r29
  34:	cf 91       	pop	r28
  36:	08 95       	ret

00000038 <init>:
	halfDelay();
	sda_high(i2c);
	halfDelay();
}

static void init(I2C_ABSTRACT_BUS* bus){
  38:	cf 93       	push	r28
  3a:	df 93       	push	r29
  3c:	ec 01       	movw	r28, r24
	const I2C_SOFTWARE_BUS* i2c = (I2C_SOFTWARE_BUS*)bus;

	// Make both pins high
	sda_high(i2c);
  3e:	88 85       	ldd	r24, Y+8	; 0x08
  40:	99 85       	ldd	r25, Y+9	; 0x09
  42:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
  46:	ce 01       	movw	r24, r28
  48:	06 96       	adiw	r24, 0x06	; 6
  4a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}
  4e:	df 91       	pop	r29
  50:	cf 91       	pop	r28
  52:	08 95       	ret

00000054 <putByte>:
	return rtn;
}

// Put a byte across the wire
// Return true if the slave acknowledges
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
  54:	ef 92       	push	r14
  56:	ff 92       	push	r15
  58:	0f 93       	push	r16
  5a:	1f 93       	push	r17
  5c:	cf 93       	push	r28
  5e:	df 93       	push	r29
  60:	ec 01       	movw	r28, r24
  62:	e6 2e       	mov	r14, r22
  64:	28 e0       	ldi	r18, 0x08	; 8
  66:	f2 2e       	mov	r15, r18
}



// Expose this implementation to the linker
const I2C_CLASS c_sw_i2c = MAKE_I2C_CLASS(&init, &start,&stop, &getByte, &putByte, null);
  68:	8c 01       	movw	r16, r24
  6a:	0a 5f       	subi	r16, 0xFA	; 250
  6c:	1f 4f       	sbci	r17, 0xFF	; 255
  6e:	88 85       	ldd	r24, Y+8	; 0x08
  70:	99 85       	ldd	r25, Y+9	; 0x09
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;

	for(i=7; i>=0; i--){
		if( b & 0x80 ){
  72:	e7 fe       	sbrs	r14, 7
  74:	00 c0       	rjmp	.+0      	; 0x76 <putByte+0x22>
			sda_high(i2c);
  76:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  7a:	00 c0       	rjmp	.+0      	; 0x7c <putByte+0x28>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
  7c:	60 e0       	ldi	r22, 0x00	; 0
  7e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		if( b & 0x80 ){
			sda_high(i2c);
		}else{
			sda_low(i2c);
		}
		scl_high(i2c);
  82:	c8 01       	movw	r24, r16
  84:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		b <<= 1;
  88:	ee 0c       	add	r14, r14
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
  8a:	8e 81       	ldd	r24, Y+6	; 0x06
  8c:	9f 81       	ldd	r25, Y+7	; 0x07
  8e:	60 e0       	ldi	r22, 0x00	; 0
  90:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  94:	fa 94       	dec	r15
// Return true if the slave acknowledges
static boolean putByte(const I2C_ABSTRACT_BUS* bus, uint8_t b){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;

	for(i=7; i>=0; i--){
  96:	01 f4       	brne	.+0      	; 0x98 <putByte+0x44>
}


// Return true if the slave acknowledges
static boolean getAck(const I2C_SOFTWARE_BUS* i2c){
	sda_high(i2c);	// allow slave to drive sda
  98:	88 85       	ldd	r24, Y+8	; 0x08
  9a:	99 85       	ldd	r25, Y+9	; 0x09
  9c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
  a0:	c8 01       	movw	r24, r16
  a2:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
  a6:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	boolean rtn = pin_is_low(i2c->sda);
  aa:	88 85       	ldd	r24, Y+8	; 0x08
  ac:	99 85       	ldd	r25, Y+9	; 0x09
  ae:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  b2:	08 2f       	mov	r16, r24
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
  b4:	8e 81       	ldd	r24, Y+6	; 0x06
  b6:	9f 81       	ldd	r25, Y+7	; 0x07
  b8:	60 e0       	ldi	r22, 0x00	; 0
  ba:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
// Return true if the slave acknowledges
static boolean getAck(const I2C_SOFTWARE_BUS* i2c){
	sda_high(i2c);	// allow slave to drive sda
	scl_high(i2c);
	halfDelay();
	boolean rtn = pin_is_low(i2c->sda);
  be:	81 e0       	ldi	r24, 0x01	; 1
  c0:	01 11       	cpse	r16, r1
  c2:	80 e0       	ldi	r24, 0x00	; 0
		scl_high(i2c);
		b <<= 1;
		scl_low(i2c);
	}
	return getAck(i2c);						// return ACK value
}
  c4:	df 91       	pop	r29
  c6:	cf 91       	pop	r28
  c8:	1f 91       	pop	r17
  ca:	0f 91       	pop	r16
  cc:	ff 90       	pop	r15
  ce:	ef 90       	pop	r14
  d0:	08 95       	ret

000000d2 <getByte>:
	}
	return rtn;
}


static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
  d2:	df 92       	push	r13
  d4:	ef 92       	push	r14
  d6:	ff 92       	push	r15
  d8:	0f 93       	push	r16
  da:	1f 93       	push	r17
  dc:	cf 93       	push	r28
  de:	df 93       	push	r29
  e0:	ec 01       	movw	r28, r24
  e2:	e6 2e       	mov	r14, r22
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
  e4:	88 85       	ldd	r24, Y+8	; 0x08
  e6:	99 85       	ldd	r25, Y+9	; 0x09
  e8:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
  ec:	38 e0       	ldi	r19, 0x08	; 8
  ee:	d3 2e       	mov	r13, r19


static uint8_t getByte(const I2C_ABSTRACT_BUS* bus, boolean isLastByte){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;
  f0:	ff 24       	eor	r15, r15
}



// Expose this implementation to the linker
const I2C_CLASS c_sw_i2c = MAKE_I2C_CLASS(&init, &start,&stop, &getByte, &putByte, null);
  f2:	8e 01       	movw	r16, r28
  f4:	0a 5f       	subi	r16, 0xFA	; 250
  f6:	1f 4f       	sbci	r17, 0xFF	; 255
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
	for(i=7; i>=0; i--){
		b <<= 1;
  f8:	ff 0c       	add	r15, r15
		scl_high(i2c);
  fa:	c8 01       	movw	r24, r16
  fc:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
 100:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		if(pin_is_high(i2c->sda)){
 104:	88 85       	ldd	r24, Y+8	; 0x08
 106:	99 85       	ldd	r25, Y+9	; 0x09
 108:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 10c:	88 23       	and	r24, r24
 10e:	01 f0       	breq	.+0      	; 0x110 <getByte+0x3e>
			b |= 1;
 110:	81 e0       	ldi	r24, 0x01	; 1
 112:	f8 2a       	or	r15, r24
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 114:	8e 81       	ldd	r24, Y+6	; 0x06
 116:	9f 81       	ldd	r25, Y+7	; 0x07
 118:	60 e0       	ldi	r22, 0x00	; 0
 11a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		if(pin_is_high(i2c->sda)){
			b |= 1;
		}
		scl_low(i2c);
		halfDelay();
 11e:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 122:	da 94       	dec	r13
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	int8_t i;
	uint8_t b = 0;

	sda_high(i2c);
	for(i=7; i>=0; i--){
 124:	01 f4       	brne	.+0      	; 0x126 <getByte+0x54>
 126:	8e 01       	movw	r16, r28
 128:	0a 5f       	subi	r16, 0xFA	; 250
 12a:	1f 4f       	sbci	r17, 0xFF	; 255
 12c:	88 85       	ldd	r24, Y+8	; 0x08
 12e:	99 85       	ldd	r25, Y+9	; 0x09
		scl_low(i2c);
		halfDelay();
	}

	// Put the ACK
	if(isLastByte){
 130:	ee 20       	and	r14, r14
 132:	01 f0       	breq	.+0      	; 0x134 <getByte+0x62>
		sda_high(i2c);
 134:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 138:	00 c0       	rjmp	.+0      	; 0x13a <getByte+0x68>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 13a:	60 e0       	ldi	r22, 0x00	; 0
 13c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	if(isLastByte){
		sda_high(i2c);
	}else{
		sda_low(i2c);
	}
	scl_high(i2c);
 140:	c8 01       	movw	r24, r16
 142:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay(i2c);
 146:	ce 01       	movw	r24, r28
 148:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 14c:	8e 81       	ldd	r24, Y+6	; 0x06
 14e:	9f 81       	ldd	r25, Y+7	; 0x07
 150:	60 e0       	ldi	r22, 0x00	; 0
 152:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		sda_low(i2c);
	}
	scl_high(i2c);
	halfDelay(i2c);
	scl_low(i2c);
	sda_high(i2c);
 156:	88 85       	ldd	r24, Y+8	; 0x08
 158:	99 85       	ldd	r25, Y+9	; 0x09
 15a:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

	return b;						// return received byte
}
 15e:	8f 2d       	mov	r24, r15
 160:	df 91       	pop	r29
 162:	cf 91       	pop	r28
 164:	1f 91       	pop	r17
 166:	0f 91       	pop	r16
 168:	ff 90       	pop	r15
 16a:	ef 90       	pop	r14
 16c:	df 90       	pop	r13
 16e:	08 95       	ret

00000170 <stop>:

// Send the stop
static void stop(const I2C_ABSTRACT_BUS* bus){
 170:	cf 93       	push	r28
 172:	df 93       	push	r29
 174:	ec 01       	movw	r28, r24
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 176:	88 85       	ldd	r24, Y+8	; 0x08
 178:	99 85       	ldd	r25, Y+9	; 0x09
 17a:	60 e0       	ldi	r22, 0x00	; 0
 17c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

// Send the stop
static void stop(const I2C_ABSTRACT_BUS* bus){
	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)bus;
	sda_low(i2c);
	halfDelay();
 180:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	scl_high(i2c);
 184:	ce 01       	movw	r24, r28
 186:	06 96       	adiw	r24, 0x06	; 6
 188:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
 18c:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	sda_high(i2c);
 190:	88 85       	ldd	r24, Y+8	; 0x08
 192:	99 85       	ldd	r25, Y+9	; 0x09
 194:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	halfDelay();
 198:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}
 19c:	df 91       	pop	r29
 19e:	cf 91       	pop	r28
 1a0:	08 95       	ret

000001a2 <start>:
	return getAck(i2c);						// return ACK value
}

// Send the start and address
// return TRUE if acknowledged
static boolean start(const I2C_DEVICE* device, boolean writeMode){
 1a2:	ff 92       	push	r15
 1a4:	0f 93       	push	r16
 1a6:	1f 93       	push	r17
 1a8:	cf 93       	push	r28
 1aa:	df 93       	push	r29
 1ac:	8c 01       	movw	r16, r24
 1ae:	f6 2e       	mov	r15, r22
	boolean rtn = FALSE;

	const I2C_SOFTWARE_BUS* i2c = (const I2C_SOFTWARE_BUS*)(device->bus);
 1b0:	fc 01       	movw	r30, r24
 1b2:	c0 81       	ld	r28, Z
 1b4:	d1 81       	ldd	r29, Z+1	; 0x01
	if(i2c){
 1b6:	20 97       	sbiw	r28, 0x00	; 0
 1b8:	01 f0       	breq	.+0      	; 0x1ba <start+0x18>
		sda_high(i2c);
 1ba:	88 85       	ldd	r24, Y+8	; 0x08
 1bc:	99 85       	ldd	r25, Y+9	; 0x09
 1be:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
 1c2:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		scl_high(i2c);
 1c6:	ce 01       	movw	r24, r28
 1c8:	06 96       	adiw	r24, 0x06	; 6
 1ca:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
 1ce:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
	pin_make_output(i2c->scl,FALSE);
}

// Make the data line low
static void sda_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->sda,FALSE);
 1d2:	88 85       	ldd	r24, Y+8	; 0x08
 1d4:	99 85       	ldd	r25, Y+9	; 0x09
 1d6:	60 e0       	ldi	r22, 0x00	; 0
 1d8:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();
		scl_high(i2c);
		halfDelay();

		sda_low(i2c);
		halfDelay();
 1dc:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
}


// Make the clock low
static void scl_low(const I2C_SOFTWARE_BUS* i2c){
	pin_make_output(i2c->scl,FALSE);
 1e0:	8e 81       	ldd	r24, Y+6	; 0x06
 1e2:	9f 81       	ldd	r25, Y+7	; 0x07
 1e4:	60 e0       	ldi	r22, 0x00	; 0
 1e6:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
		halfDelay();

		sda_low(i2c);
		halfDelay();
		scl_low(i2c);
		halfDelay();
 1ea:	0e 94 00 00 	call	0	; 0x0 <halfDelay>

		// Send the device addr and direction
		uint8_t addr = device->addr & 0xfe;
 1ee:	f8 01       	movw	r30, r16
 1f0:	62 81       	ldd	r22, Z+2	; 0x02
 1f2:	6e 7f       	andi	r22, 0xFE	; 254
		if(writeMode==FALSE){
 1f4:	ff 20       	and	r15, r15
 1f6:	01 f4       	brne	.+0      	; 0x1f8 <start+0x56>
			addr |= 1;
 1f8:	61 60       	ori	r22, 0x01	; 1
		}
		rtn = putByte(device->bus, addr);
 1fa:	f8 01       	movw	r30, r16
 1fc:	80 81       	ld	r24, Z
 1fe:	91 81       	ldd	r25, Z+1	; 0x01
 200:	0e 94 00 00 	call	0	; 0x0 <halfDelay>
 204:	00 c0       	rjmp	.+0      	; 0x206 <start+0x64>
}

// Send the start and address
// return TRUE if acknowledged
static boolean start(const I2C_DEVICE* device, boolean writeMode){
	boolean rtn = FALSE;
 206:	80 e0       	ldi	r24, 0x00	; 0
			addr |= 1;
		}
		rtn = putByte(device->bus, addr);
	}
	return rtn;
}
 208:	df 91       	pop	r29
 20a:	cf 91       	pop	r28
 20c:	1f 91       	pop	r17
 20e:	0f 91       	pop	r16
 210:	ff 90       	pop	r15
 212:	08 95       	ret

i2c_slave.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000009e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  0000009e  2**0
                  ALLOC
  3 .debug_info   000002ef  00000000  00000000  0000009e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000014c  00000000  00000000  0000038d  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000053  00000000  00000000  000004d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000052c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000010c  00000000  00000000  0000054c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000234  00000000  00000000  00000658  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  0000088c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <i2cSlaveSetReceiveHandler>:
static cBuffer* txBuffer;
static void (*i2cSlaveReceive)(cBuffer* data);
static void (*i2cSlaveTransmit)(cBuffer* data);

void i2cSlaveSetReceiveHandler(void (*i2cSlaveRx_func)(cBuffer* data)){
	CRITICAL_SECTION{
   0:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
   2:	f8 94       	cli
		i2cSlaveReceive = i2cSlaveRx_func;
   4:	90 93 00 00 	sts	0x0000, r25
   8:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
   c:	2f bf       	out	0x3f, r18	; 63
	}
}
   e:	08 95       	ret

00000010 <i2cSlaveSetTransmitHandler>:
void i2cSlaveSetTransmitHandler(void (*i2cSlaveTx_func)(cBuffer* data)){
	CRITICAL_SECTION{
  10:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  12:	f8 94       	cli
		i2cSlaveTransmit = i2cSlaveTx_func;
  14:	90 93 00 00 	sts	0x0000, r25
  18:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  1c:	2f bf       	out	0x3f, r18	; 63
	}
}
  1e:	08 95       	ret

00000020 <i2cSlaveInit>:

void i2cSlaveInit(uint8_t deviceAddr, boolean generalCall, cBuffer* rx, cBuffer* tx){
	// Make the 2 wires into inputs
	cbi(SCL_DDR,SCL_PIN);
  20:	50 98       	cbi	0x0a, 0	; 10
	cbi(SDA_DDR,SDA_PIN);
  22:	51 98       	cbi	0x0a, 1	; 10

	// Save the buffer addresses
	rxBuffer = rx;
  24:	50 93 00 00 	sts	0x0000, r21
  28:	40 93 00 00 	sts	0x0000, r20
	txBuffer = tx;
  2c:	30 93 00 00 	sts	0x0000, r19
  30:	20 93 00 00 	sts	0x0000, r18
	// set i2c bit rate to 100KHz
	// not for slaves as their bit rate is set by the master
//	i2cMasterSetBitrate(100);

	// enable TWI (two-wire interface)
	sbi(TWCR, TWEN);
  34:	90 91 bc 00 	lds	r25, 0x00BC
  38:	94 60       	ori	r25, 0x04	; 4
  3a:	90 93 bc 00 	sts	0x00BC, r25

	// set state
	i2cState = I2C_IDLE;
  3e:	10 92 00 00 	sts	0x0000, r1

	// enable TWI interrupt and slave address ACK
	sbi(TWCR, TWIE);
  42:	90 91 bc 00 	lds	r25, 0x00BC
  46:	91 60       	ori	r25, 0x01	; 1
  48:	90 93 bc 00 	sts	0x00BC, r25
	sbi(TWCR, TWEA);
  4c:	90 91 bc 00 	lds	r25, 0x00BC
  50:	90 64       	ori	r25, 0x40	; 64
  52:	90 93 bc 00 	sts	0x00BC, r25

	// Set the device address
	outb(TWAR, ((deviceAddr&0xFE) | (generalCall?1:0)) );
  56:	91 e0       	ldi	r25, 0x01	; 1
  58:	66 23       	and	r22, r22
  5a:	01 f4       	brne	.+0      	; 0x5c <i2cSlaveInit+0x3c>
  5c:	90 e0       	ldi	r25, 0x00	; 0
  5e:	8e 7f       	andi	r24, 0xFE	; 254
  60:	89 2b       	or	r24, r25
  62:	80 93 ba 00 	sts	0x00BA, r24

	// enable interrupts
	sei();
  66:	78 94       	sei

}
  68:	08 95       	ret

iopin.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001e6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000021a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000021a  2**0
                  ALLOC
  3 .debug_info   000008d0  00000000  00000000  0000021a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000016c  00000000  00000000  00000aea  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000881  00000000  00000000  00000c56  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000014d7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  000014f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000000e0  00000000  00000000  00001527  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000177  00000000  00000000  00001607  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000a0  00000000  00000000  00001780  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_high>:
/******************************************************

	Set a port pin to high

******************************************************/
void pin_high(const IOPin* io){
   0:	9c 01       	movw	r18, r24
	if(io){
   2:	00 97       	sbiw	r24, 0x00	; 0
   4:	01 f0       	breq	.+0      	; 0x6 <pin_high+0x6>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
   6:	fc 01       	movw	r30, r24
   8:	45 91       	lpm	r20, Z+
   a:	54 91       	lpm	r21, Z
   c:	ca 01       	movw	r24, r20
		PORT port = pgm_read_word(&portDef->port);
   e:	fa 01       	movw	r30, r20
  10:	45 91       	lpm	r20, Z+
  12:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  14:	02 96       	adiw	r24, 0x02	; 2
  16:	fc 01       	movw	r30, r24
  18:	85 91       	lpm	r24, Z+
  1a:	94 91       	lpm	r25, Z
		PIN mask = pgm_read_byte(&io->pin);
  1c:	2e 5f       	subi	r18, 0xFE	; 254
  1e:	3f 4f       	sbci	r19, 0xFF	; 255
  20:	f9 01       	movw	r30, r18
  22:	24 91       	lpm	r18, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  24:	dc 01       	movw	r26, r24
  26:	8c 91       	ld	r24, X
  28:	82 23       	and	r24, r18
  2a:	01 f0       	breq	.+0      	; 0x2c <pin_high+0x2c>
			CRITICAL_SECTION_START;
  2c:	9f b7       	in	r25, 0x3f	; 63
  2e:	f8 94       	cli
			// set the bit
			_SFR_MEM8(port) |= mask;
  30:	da 01       	movw	r26, r20
  32:	8c 91       	ld	r24, X
  34:	82 2b       	or	r24, r18
  36:	8c 93       	st	X, r24
			CRITICAL_SECTION_END;
  38:	9f bf       	out	0x3f, r25	; 63
			// Allow any output to be reflected on the input pin
			nop();
  3a:	00 00       	nop
  3c:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  3e:	87 ef       	ldi	r24, 0xF7	; 247
  40:	0e 94 00 00 	call	0	; 0x0 <pin_high>
  44:	08 95       	ret

00000046 <pin_low>:
/******************************************************

	Set a port pin to low

******************************************************/
void pin_low(const IOPin* io){
  46:	9c 01       	movw	r18, r24
	if(io){
  48:	00 97       	sbiw	r24, 0x00	; 0
  4a:	01 f0       	breq	.+0      	; 0x4c <pin_low+0x6>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  4c:	fc 01       	movw	r30, r24
  4e:	45 91       	lpm	r20, Z+
  50:	54 91       	lpm	r21, Z
  52:	ca 01       	movw	r24, r20
		PORT port = pgm_read_word(&portDef->port);
  54:	fa 01       	movw	r30, r20
  56:	45 91       	lpm	r20, Z+
  58:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  5a:	02 96       	adiw	r24, 0x02	; 2
  5c:	fc 01       	movw	r30, r24
  5e:	85 91       	lpm	r24, Z+
  60:	94 91       	lpm	r25, Z
		PIN mask = pgm_read_byte(&io->pin);
  62:	2e 5f       	subi	r18, 0xFE	; 254
  64:	3f 4f       	sbci	r19, 0xFF	; 255
  66:	f9 01       	movw	r30, r18
  68:	24 91       	lpm	r18, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  6a:	dc 01       	movw	r26, r24
  6c:	8c 91       	ld	r24, X
  6e:	82 23       	and	r24, r18
  70:	01 f0       	breq	.+0      	; 0x72 <pin_low+0x2c>
			CRITICAL_SECTION_START;
  72:	9f b7       	in	r25, 0x3f	; 63
  74:	f8 94       	cli
			// clear the bit
			_SFR_MEM8(port) &= ~mask;
  76:	da 01       	movw	r26, r20
  78:	8c 91       	ld	r24, X
  7a:	20 95       	com	r18
  7c:	82 23       	and	r24, r18
  7e:	8c 93       	st	X, r24
			CRITICAL_SECTION_END;
  80:	9f bf       	out	0x3f, r25	; 63
			// Allow any output to be reflected on the input pin
			nop();
  82:	00 00       	nop
  84:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  86:	87 ef       	ldi	r24, 0xF7	; 247
  88:	0e 94 00 00 	call	0	; 0x0 <pin_high>
  8c:	08 95       	ret

0000008e <pin_toggle>:
	if high then make low
	eg
	pin_toggle(B2); // Toggle PortB pin 2

******************************************************/
void pin_toggle(const IOPin* io) {
  8e:	9c 01       	movw	r18, r24
	if(io){
  90:	00 97       	sbiw	r24, 0x00	; 0
  92:	01 f0       	breq	.+0      	; 0x94 <pin_toggle+0x6>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  94:	fc 01       	movw	r30, r24
  96:	45 91       	lpm	r20, Z+
  98:	54 91       	lpm	r21, Z
  9a:	ca 01       	movw	r24, r20
		PORT port = pgm_read_word(&portDef->port);
  9c:	fa 01       	movw	r30, r20
  9e:	45 91       	lpm	r20, Z+
  a0:	54 91       	lpm	r21, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
  a2:	02 96       	adiw	r24, 0x02	; 2
  a4:	fc 01       	movw	r30, r24
  a6:	85 91       	lpm	r24, Z+
  a8:	94 91       	lpm	r25, Z
		PIN mask = pgm_read_byte(&io->pin);
  aa:	2e 5f       	subi	r18, 0xFE	; 254
  ac:	3f 4f       	sbci	r19, 0xFF	; 255
  ae:	f9 01       	movw	r30, r18
  b0:	24 91       	lpm	r18, Z

		// make sure its an output
		if(_SFR_MEM8(ddr) & mask){
  b2:	dc 01       	movw	r26, r24
  b4:	8c 91       	ld	r24, X
  b6:	82 23       	and	r24, r18
  b8:	01 f0       	breq	.+0      	; 0xba <pin_toggle+0x2c>
			CRITICAL_SECTION_START;
  ba:	9f b7       	in	r25, 0x3f	; 63
  bc:	f8 94       	cli
			// toggle the bit
			_SFR_MEM8(port) ^= mask;
  be:	da 01       	movw	r26, r20
  c0:	8c 91       	ld	r24, X
  c2:	82 27       	eor	r24, r18
  c4:	8c 93       	st	X, r24
			CRITICAL_SECTION_END;
  c6:	9f bf       	out	0x3f, r25	; 63
			// Allow any output to be reflected on the input pin
			nop();
  c8:	00 00       	nop
  ca:	08 95       	ret
		}else{
			setError(PIN_SET_ON_INPUT);
  cc:	87 ef       	ldi	r24, 0xF7	; 247
  ce:	0e 94 00 00 	call	0	; 0x0 <pin_high>
  d2:	08 95       	ret

000000d4 <pin_is_high>:
	Read the value of an I/O pin and
	return TRUE if it is high or FALSE if low

******************************************************/
boolean pin_is_high(const IOPin* io){
	if(io){
  d4:	00 97       	sbiw	r24, 0x00	; 0
  d6:	01 f0       	breq	.+0      	; 0xd8 <pin_is_high+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
  d8:	fc 01       	movw	r30, r24
  da:	25 91       	lpm	r18, Z+
  dc:	34 91       	lpm	r19, Z
		PORT pin = pgm_read_word(&portDef->pin);
  de:	2c 5f       	subi	r18, 0xFC	; 252
  e0:	3f 4f       	sbci	r19, 0xFF	; 255
  e2:	f9 01       	movw	r30, r18
  e4:	25 91       	lpm	r18, Z+
  e6:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
  e8:	02 96       	adiw	r24, 0x02	; 2
  ea:	fc 01       	movw	r30, r24
  ec:	84 91       	lpm	r24, Z

		return  (_SFR_MEM8(pin) & mask) ? TRUE : FALSE;
  ee:	d9 01       	movw	r26, r18
  f0:	9c 91       	ld	r25, X
  f2:	98 23       	and	r25, r24
  f4:	01 f0       	breq	.+0      	; 0xf6 <pin_is_high+0x22>
  f6:	8f ef       	ldi	r24, 0xFF	; 255
  f8:	08 95       	ret
	}
	return FALSE;
  fa:	80 e0       	ldi	r24, 0x00	; 0
  fc:	08 95       	ret
	if(io){
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
		PORT pin = pgm_read_word(&portDef->pin);
		PIN mask = pgm_read_byte(&io->pin);

		return  (_SFR_MEM8(pin) & mask) ? TRUE : FALSE;
  fe:	80 e0       	ldi	r24, 0x00	; 0
	}
	return FALSE;
}
 100:	08 95       	ret

00000102 <pin_set>:
	Set an output pin high or low
	eg
	pin_set(B2, TRUE); // To set PortB pin 2 high
******************************************************/
void pin_set(const IOPin* io, boolean val){
	if(val){
 102:	66 23       	and	r22, r22
 104:	01 f0       	breq	.+0      	; 0x106 <pin_set+0x4>
		pin_high(io);
 106:	0e 94 00 00 	call	0	; 0x0 <pin_high>
 10a:	08 95       	ret
	}else{
		pin_low(io);
 10c:	0e 94 00 00 	call	0	; 0x0 <pin_high>
 110:	08 95       	ret

00000112 <pin_make_input>:
	a pullup resistor (TRUE/FALSE)

	ie pin_make_input(B2, TRUE); // to  make B2 an input with pullup
******************************************************/
void pin_make_input(const IOPin* io, boolean pullup){
	if(io){
 112:	00 97       	sbiw	r24, 0x00	; 0
 114:	01 f0       	breq	.+0      	; 0x116 <pin_make_input+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 116:	fc 01       	movw	r30, r24
 118:	45 91       	lpm	r20, Z+
 11a:	54 91       	lpm	r21, Z
 11c:	9a 01       	movw	r18, r20
		PORT ddr = pgm_read_word(&portDef->ddr);
 11e:	fa 01       	movw	r30, r20
 120:	32 96       	adiw	r30, 0x02	; 2
 122:	45 91       	lpm	r20, Z+
 124:	54 91       	lpm	r21, Z
		PORT port = pgm_read_word(&portDef->port);
 126:	f9 01       	movw	r30, r18
 128:	25 91       	lpm	r18, Z+
 12a:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
 12c:	02 96       	adiw	r24, 0x02	; 2
 12e:	fc 01       	movw	r30, r24
 130:	84 91       	lpm	r24, Z

		CRITICAL_SECTION_START;
 132:	7f b7       	in	r23, 0x3f	; 63
 134:	f8 94       	cli
			// Clear pin in DDR
			_SFR_MEM8(ddr) &= ~ mask;	// make an input pin
 136:	da 01       	movw	r26, r20
 138:	9c 91       	ld	r25, X
 13a:	48 2f       	mov	r20, r24
 13c:	40 95       	com	r20
 13e:	94 23       	and	r25, r20
 140:	9c 93       	st	X, r25

			if(pullup){
				_SFR_MEM8(port) |= mask; // turn on pullup if needed
 142:	f9 01       	movw	r30, r18

		CRITICAL_SECTION_START;
			// Clear pin in DDR
			_SFR_MEM8(ddr) &= ~ mask;	// make an input pin

			if(pullup){
 144:	66 23       	and	r22, r22
 146:	01 f0       	breq	.+0      	; 0x148 <pin_make_input+0x36>
				_SFR_MEM8(port) |= mask; // turn on pullup if needed
 148:	90 81       	ld	r25, Z
 14a:	98 2b       	or	r25, r24
 14c:	90 83       	st	Z, r25
 14e:	00 c0       	rjmp	.+0      	; 0x150 <pin_make_input+0x3e>
			}else{
				_SFR_MEM8(port) &= ~ mask;	 // turn off pullup
 150:	80 81       	ld	r24, Z
 152:	84 23       	and	r24, r20
 154:	80 83       	st	Z, r24
			}
		CRITICAL_SECTION_END;
 156:	7f bf       	out	0x3f, r23	; 63
 158:	08 95       	ret

0000015a <pin_make_output>:
/******************************************************

	Set the pin as an output pin

******************************************************/
void pin_make_output(const IOPin* io, boolean val){
 15a:	cf 93       	push	r28
 15c:	df 93       	push	r29
 15e:	ac 01       	movw	r20, r24
	if(io){
 160:	00 97       	sbiw	r24, 0x00	; 0
 162:	01 f0       	breq	.+0      	; 0x164 <pin_make_output+0xa>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 164:	fc 01       	movw	r30, r24
 166:	85 91       	lpm	r24, Z+
 168:	94 91       	lpm	r25, Z
 16a:	9c 01       	movw	r18, r24
		PORT ddr = pgm_read_word(&portDef->ddr);
 16c:	fc 01       	movw	r30, r24
 16e:	32 96       	adiw	r30, 0x02	; 2
 170:	85 91       	lpm	r24, Z+
 172:	94 91       	lpm	r25, Z
 174:	a8 2f       	mov	r26, r24
 176:	79 2f       	mov	r23, r25
		PORT port = pgm_read_word(&portDef->port);
 178:	f9 01       	movw	r30, r18
 17a:	85 91       	lpm	r24, Z+
 17c:	94 91       	lpm	r25, Z
		PIN mask = pgm_read_byte(&io->pin);
 17e:	4e 5f       	subi	r20, 0xFE	; 254
 180:	5f 4f       	sbci	r21, 0xFF	; 255
 182:	fa 01       	movw	r30, r20
 184:	44 91       	lpm	r20, Z

		CRITICAL_SECTION_START;
 186:	2f b7       	in	r18, 0x3f	; 63
 188:	f8 94       	cli
			if(val){
 18a:	66 23       	and	r22, r22
 18c:	01 f0       	breq	.+0      	; 0x18e <pin_make_output+0x34>
				_SFR_MEM8(port) |= mask;
 18e:	c8 2f       	mov	r28, r24
 190:	d9 2f       	mov	r29, r25
 192:	88 81       	ld	r24, Y
 194:	84 2b       	or	r24, r20
 196:	00 c0       	rjmp	.+0      	; 0x198 <pin_make_output+0x3e>
			}else{
				_SFR_MEM8(port) &= ~ mask;
 198:	c8 2f       	mov	r28, r24
 19a:	d9 2f       	mov	r29, r25
 19c:	88 81       	ld	r24, Y
 19e:	94 2f       	mov	r25, r20
 1a0:	90 95       	com	r25
 1a2:	89 23       	and	r24, r25
 1a4:	88 83       	st	Y, r24
			}
			_SFR_MEM8(ddr) |= mask;	// make an output pin
 1a6:	ca 2f       	mov	r28, r26
 1a8:	d7 2f       	mov	r29, r23
 1aa:	88 81       	ld	r24, Y
 1ac:	84 2b       	or	r24, r20
 1ae:	88 83       	st	Y, r24
		CRITICAL_SECTION_END;
 1b0:	2f bf       	out	0x3f, r18	; 63
	}
}
 1b2:	df 91       	pop	r29
 1b4:	cf 91       	pop	r28
 1b6:	08 95       	ret

000001b8 <pin_is_output>:


******************************************************/

boolean pin_is_output(const IOPin* io){
	if(io){
 1b8:	00 97       	sbiw	r24, 0x00	; 0
 1ba:	01 f0       	breq	.+0      	; 0x1bc <pin_is_output+0x4>
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
 1bc:	fc 01       	movw	r30, r24
 1be:	25 91       	lpm	r18, Z+
 1c0:	34 91       	lpm	r19, Z
		PORT ddr = pgm_read_word(&portDef->ddr);
 1c2:	2e 5f       	subi	r18, 0xFE	; 254
 1c4:	3f 4f       	sbci	r19, 0xFF	; 255
 1c6:	f9 01       	movw	r30, r18
 1c8:	25 91       	lpm	r18, Z+
 1ca:	34 91       	lpm	r19, Z
		PIN mask = pgm_read_byte(&io->pin);
 1cc:	02 96       	adiw	r24, 0x02	; 2
 1ce:	fc 01       	movw	r30, r24
 1d0:	84 91       	lpm	r24, Z

		return (_SFR_MEM8(ddr) & mask) ? TRUE : FALSE;
 1d2:	d9 01       	movw	r26, r18
 1d4:	9c 91       	ld	r25, X
 1d6:	98 23       	and	r25, r24
 1d8:	01 f0       	breq	.+0      	; 0x1da <pin_is_output+0x22>
 1da:	8f ef       	ldi	r24, 0xFF	; 255
 1dc:	08 95       	ret
	}
	return FALSE;
 1de:	80 e0       	ldi	r24, 0x00	; 0
 1e0:	08 95       	ret
	if(io){
		const IOPort* portDef = (const IOPort*)pgm_read_word(&io->port);
		PORT ddr = pgm_read_word(&portDef->ddr);
		PIN mask = pgm_read_byte(&io->pin);

		return (_SFR_MEM8(ddr) & mask) ? TRUE : FALSE;
 1e2:	80 e0       	ldi	r24, 0x00	; 0
	}
	return FALSE;
}
 1e4:	08 95       	ret

iopin_pulseIn.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000062  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000096  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000096  2**0
                  ALLOC
  3 .debug_info   00000438  00000000  00000000  00000096  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000145  00000000  00000000  000004ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000120  00000000  00000000  00000613  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000733  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000af  00000000  00000000  00000753  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000002ba  00000000  00000000  00000802  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000048  00000000  00000000  00000abc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_pulseIn>:
 *      Author: Clive Webster
 */
#include "iopin.h"
#include "timer.h"

TICK_COUNT pin_pulseIn(const IOPin* pin, boolean activeHigh){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	8c 01       	movw	r16, r24
  10:	c6 2f       	mov	r28, r22
	TICK_COUNT start;
	TICK_COUNT end;
	TICK_COUNT duration;

	pin_make_input(pin,FALSE);				// Switch pin to INPUT with no pull up
  12:	60 e0       	ldi	r22, 0x00	; 0
  14:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
	while(pin_get(pin)==activeHigh);		// Loop until the the pin goes inactive
  18:	c8 01       	movw	r24, r16
  1a:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  1e:	8c 17       	cp	r24, r28
  20:	01 f0       	breq	.+0      	; 0x22 <pin_pulseIn+0x22>
	while(pin_get(pin)!=activeHigh);		// Loop until the the pin goes active
  22:	c8 01       	movw	r24, r16
  24:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  28:	8c 17       	cp	r24, r28
  2a:	01 f4       	brne	.+0      	; 0x2c <pin_pulseIn+0x2c>
	start = clockGetus();					// Get the start time
  2c:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  30:	6b 01       	movw	r12, r22
  32:	7c 01       	movw	r14, r24
	while(pin_get(pin)==activeHigh);		// Loop until the the pin goes inactive
  34:	c8 01       	movw	r24, r16
  36:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  3a:	8c 17       	cp	r24, r28
  3c:	01 f0       	breq	.+0      	; 0x3e <pin_pulseIn+0x3e>
	end = clockGetus();						// Get the end time
  3e:	0e 94 00 00 	call	0	; 0x0 <pin_pulseIn>
  42:	8b 01       	movw	r16, r22
  44:	9c 01       	movw	r18, r24

	duration = end - start;					// Get the duration in uS
  46:	0c 19       	sub	r16, r12
  48:	1d 09       	sbc	r17, r13
  4a:	2e 09       	sbc	r18, r14
  4c:	3f 09       	sbc	r19, r15
	return duration;
}
  4e:	b8 01       	movw	r22, r16
  50:	c9 01       	movw	r24, r18
  52:	cf 91       	pop	r28
  54:	1f 91       	pop	r17
  56:	0f 91       	pop	r16
  58:	ff 90       	pop	r15
  5a:	ef 90       	pop	r14
  5c:	df 90       	pop	r13
  5e:	cf 90       	pop	r12
  60:	08 95       	ret

iopin_pulseOut.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000050  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000084  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000084  2**0
                  ALLOC
  3 .debug_info   00000415  00000000  00000000  00000084  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000125  00000000  00000000  00000499  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000d2  00000000  00000000  000005be  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000690  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000bd  00000000  00000000  000006b0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000002ad  00000000  00000000  0000076d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000044  00000000  00000000  00000a1c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pin_pulseOut>:
 *      Author: Clive Webster
 */
#include "iopin.h"
#include "timer.h"

void pin_pulseOut(const IOPin* pin, TICK_COUNT us, boolean activeHigh){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	cf 93       	push	r28
   a:	df 93       	push	r29
   c:	ec 01       	movw	r28, r24
   e:	6a 01       	movw	r12, r20
  10:	7b 01       	movw	r14, r22
	pin_make_output(pin,(activeHigh)
  12:	22 23       	and	r18, r18
  14:	01 f0       	breq	.+0      	; 0x16 <pin_pulseOut+0x16>
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	00 c0       	rjmp	.+0      	; 0x1a <pin_pulseOut+0x1a>
  1a:	6f ef       	ldi	r22, 0xFF	; 255
  1c:	ce 01       	movw	r24, r28
  1e:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
			? FALSE : TRUE);				// Make it an output pin with the inactive state
	delay_us(2);							// wait a bit
  22:	62 e0       	ldi	r22, 0x02	; 2
  24:	70 e0       	ldi	r23, 0x00	; 0
  26:	80 e0       	ldi	r24, 0x00	; 0
  28:	90 e0       	ldi	r25, 0x00	; 0
  2a:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	pin_toggle(pin);						// Bring pin to active state
  2e:	ce 01       	movw	r24, r28
  30:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	delay_us(us);       					// Wait for duration
  34:	c7 01       	movw	r24, r14
  36:	b6 01       	movw	r22, r12
  38:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
	pin_toggle(pin);						// Bring pin to inactive state
  3c:	ce 01       	movw	r24, r28
  3e:	0e 94 00 00 	call	0	; 0x0 <pin_pulseOut>
}
  42:	df 91       	pop	r29
  44:	cf 91       	pop	r28
  46:	ff 90       	pop	r15
  48:	ef 90       	pop	r14
  4a:	df 90       	pop	r13
  4c:	cf 90       	pop	r12
  4e:	08 95       	ret

led.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000042  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000076  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000076  2**0
                  ALLOC
  3 .debug_info   000001d2  00000000  00000000  00000076  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000107  00000000  00000000  00000248  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000082  00000000  00000000  0000034f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000003d1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   0000008e  00000000  00000000  000003f1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000121  00000000  00000000  0000047f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000034  00000000  00000000  000005a0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <LED_set>:
#include "led.h"

// Create the status LED
LED statusLED; // All empty MAKE_LED(null,FALSE);

void LED_set(LED* led,	boolean value){
   0:	1f 93       	push	r17
   2:	cf 93       	push	r28
   4:	df 93       	push	r29
   6:	ec 01       	movw	r28, r24
   8:	16 2f       	mov	r17, r22
	if(led->pin){
   a:	88 81       	ld	r24, Y
   c:	99 81       	ldd	r25, Y+1	; 0x01
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <LED_set+0x12>

		if(!led->activeHigh){
  12:	2a 81       	ldd	r18, Y+2	; 0x02
  14:	20 fd       	sbrc	r18, 0
  16:	00 c0       	rjmp	.+0      	; 0x18 <LED_set+0x18>
		 	value=!value;
  18:	31 e0       	ldi	r19, 0x01	; 1
  1a:	61 11       	cpse	r22, r1
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	13 2f       	mov	r17, r19
		}

		if(!led->initialised){
  20:	21 fd       	sbrc	r18, 1
  22:	00 c0       	rjmp	.+0      	; 0x24 <LED_set+0x24>
			pin_make_output(led->pin,value);
  24:	61 2f       	mov	r22, r17
  26:	0e 94 00 00 	call	0	; 0x0 <LED_set>
			led->initialised=TRUE;
  2a:	8a 81       	ldd	r24, Y+2	; 0x02
  2c:	82 60       	ori	r24, 0x02	; 2
  2e:	8a 83       	std	Y+2, r24	; 0x02
		}
		pin_set(led->pin,value);
  30:	88 81       	ld	r24, Y
  32:	99 81       	ldd	r25, Y+1	; 0x01
  34:	61 2f       	mov	r22, r17
  36:	0e 94 00 00 	call	0	; 0x0 <LED_set>
	}
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	1f 91       	pop	r17
  40:	08 95       	ret

motorPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000033c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000370  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000370  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  00000370  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00000932  00000000  00000000  00000374  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000254  00000000  00000000  00000ca6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000005ff  00000000  00000000  00000efa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000014f9  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000058  00000000  00000000  00001519  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000139  00000000  00000000  00001571  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000624  00000000  00000000  000016aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000e4  00000000  00000000  00001cd0  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
   a:	fc 01       	movw	r30, r24
   c:	84 81       	ldd	r24, Z+4	; 0x04
   e:	95 81       	ldd	r25, Z+5	; 0x05
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin to start/stop sending PWM
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  26:	0f 90       	pop	r0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

0000002e <setSpeed>:
#include "iopin.h"
#include "timer.h"
#include "core.h"

// Call back - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2e:	cf 92       	push	r12
  30:	df 92       	push	r13
  32:	ef 92       	push	r14
  34:	ff 92       	push	r15
  36:	0f 93       	push	r16
  38:	1f 93       	push	r17
  3a:	cf 93       	push	r28
  3c:	df 93       	push	r29
  3e:	0f 92       	push	r0
  40:	cd b7       	in	r28, 0x3d	; 61
  42:	de b7       	in	r29, 0x3e	; 62
  44:	7c 01       	movw	r14, r24
	MOTOR* motor = (MOTOR*)actuator;
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
  46:	fc 01       	movw	r30, r24
  48:	84 81       	ldd	r24, Z+4	; 0x04
  4a:	95 81       	ldd	r25, Z+5	; 0x05
  4c:	69 83       	std	Y+1, r22	; 0x01
  4e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  52:	6c 01       	movw	r12, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  54:	fc 01       	movw	r30, r24
  56:	32 96       	adiw	r30, 0x02	; 2
  58:	e4 91       	lpm	r30, Z
  5a:	f0 e0       	ldi	r31, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
  5c:	2c e2       	ldi	r18, 0x2C	; 44
  5e:	30 e0       	ldi	r19, 0x00	; 0
  60:	e2 9f       	mul	r30, r18
  62:	c0 01       	movw	r24, r0
  64:	e3 9f       	mul	r30, r19
  66:	90 0d       	add	r25, r0
  68:	f2 9f       	mul	r31, r18
  6a:	90 0d       	add	r25, r0
  6c:	11 24       	eor	r1, r1
	uint16_t top = timerGetTOP(timer);
  6e:	80 50       	subi	r24, 0x00	; 0
  70:	90 40       	sbci	r25, 0x00	; 0
  72:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  76:	8c 01       	movw	r16, r24

	// New compare threshold
	uint16_t delay=0;

	if( speed > 0 ){
  78:	69 81       	ldd	r22, Y+1	; 0x01
  7a:	16 16       	cp	r1, r22
  7c:	04 f4       	brge	.+0      	; 0x7e <setSpeed+0x50>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MAX, 0 , top);
  7e:	86 2f       	mov	r24, r22
  80:	99 27       	eor	r25, r25
  82:	87 fd       	sbrc	r24, 7
  84:	90 95       	com	r25
  86:	60 e0       	ldi	r22, 0x00	; 0
  88:	70 e0       	ldi	r23, 0x00	; 0
  8a:	4f e7       	ldi	r20, 0x7F	; 127
  8c:	50 e0       	ldi	r21, 0x00	; 0
  8e:	20 e0       	ldi	r18, 0x00	; 0
  90:	30 e0       	ldi	r19, 0x00	; 0
  92:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  96:	8c 01       	movw	r16, r24

		// Set direction1 high, direction2 low
		pin_make_output(motor->direction1,TRUE);
  98:	f7 01       	movw	r30, r14
  9a:	86 81       	ldd	r24, Z+6	; 0x06
  9c:	97 81       	ldd	r25, Z+7	; 0x07
  9e:	6f ef       	ldi	r22, 0xFF	; 255
  a0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,FALSE);
  a4:	f7 01       	movw	r30, r14
  a6:	80 85       	ldd	r24, Z+8	; 0x08
  a8:	91 85       	ldd	r25, Z+9	; 0x09
  aa:	60 e0       	ldi	r22, 0x00	; 0
  ac:	00 c0       	rjmp	.+0      	; 0xae <setSpeed+0x80>
	}else if(speed < 0){
  ae:	66 23       	and	r22, r22
  b0:	01 f0       	breq	.+0      	; 0xb2 <setSpeed+0x84>
		delay = interpolateU(speed, 0, DRIVE_SPEED_MIN,  0 , top);
  b2:	86 2f       	mov	r24, r22
  b4:	99 27       	eor	r25, r25
  b6:	87 fd       	sbrc	r24, 7
  b8:	90 95       	com	r25
  ba:	60 e0       	ldi	r22, 0x00	; 0
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	41 e8       	ldi	r20, 0x81	; 129
  c0:	5f ef       	ldi	r21, 0xFF	; 255
  c2:	20 e0       	ldi	r18, 0x00	; 0
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  ca:	8c 01       	movw	r16, r24

		// Set direction1 low, direction2 high low
		pin_make_output(motor->direction1,FALSE);
  cc:	f7 01       	movw	r30, r14
  ce:	86 81       	ldd	r24, Z+6	; 0x06
  d0:	97 81       	ldd	r25, Z+7	; 0x07
  d2:	60 e0       	ldi	r22, 0x00	; 0
  d4:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		pin_make_output(motor->direction2,TRUE);
  d8:	f7 01       	movw	r30, r14
  da:	80 85       	ldd	r24, Z+8	; 0x08
  dc:	91 85       	ldd	r25, Z+9	; 0x09
  de:	6f ef       	ldi	r22, 0xFF	; 255
  e0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <setSpeed+0xb8>
	}else{
		// brake

		if(motor->direction2){
  e6:	f7 01       	movw	r30, r14
  e8:	20 85       	ldd	r18, Z+8	; 0x08
  ea:	31 85       	ldd	r19, Z+9	; 0x09
  ec:	86 81       	ldd	r24, Z+6	; 0x06
  ee:	97 81       	ldd	r25, Z+7	; 0x07
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  f0:	60 e0       	ldi	r22, 0x00	; 0
		pin_make_output(motor->direction1,FALSE);
		pin_make_output(motor->direction2,TRUE);
	}else{
		// brake

		if(motor->direction2){
  f2:	21 15       	cp	r18, r1
  f4:	31 05       	cpc	r19, r1
  f6:	01 f0       	breq	.+0      	; 0xf8 <setSpeed+0xca>
			// There are two direction pins - so set both to same value
			pin_make_output(motor->direction1,FALSE);
  f8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2,FALSE);
  fc:	f7 01       	movw	r30, r14
  fe:	80 85       	ldd	r24, Z+8	; 0x08
 100:	91 85       	ldd	r25, Z+9	; 0x09
 102:	60 e0       	ldi	r22, 0x00	; 0
 104:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 108:	00 c0       	rjmp	.+0      	; 0x10a <setSpeed+0xdc>
		}else{
			// Only has one direction pin
			// Set direction1 to an input with no pullup ie disconnect
			pin_make_input(motor->direction1,FALSE);
 10a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
	const TimerCompare* channel = compareFromIOPin(motor->pwm);
	const Timer* timer = compareGetTimer(channel);
	uint16_t top = timerGetTOP(timer);

	// New compare threshold
	uint16_t delay=0;
 10e:	00 e0       	ldi	r16, 0x00	; 0
 110:	10 e0       	ldi	r17, 0x00	; 0
			pin_make_input(motor->direction1,FALSE);
		}
	}

	// Change the duty cycle
	compareSetThreshold(channel,delay);
 112:	c6 01       	movw	r24, r12
 114:	b8 01       	movw	r22, r16
 116:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
 11a:	0f 90       	pop	r0
 11c:	df 91       	pop	r29
 11e:	cf 91       	pop	r28
 120:	1f 91       	pop	r17
 122:	0f 91       	pop	r16
 124:	ff 90       	pop	r15
 126:	ef 90       	pop	r14
 128:	df 90       	pop	r13
 12a:	cf 90       	pop	r12
 12c:	08 95       	ret

0000012e <motorPWMInit>:
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 12e:	2f 92       	push	r2
 130:	3f 92       	push	r3
 132:	4f 92       	push	r4
 134:	5f 92       	push	r5
 136:	6f 92       	push	r6
 138:	7f 92       	push	r7
 13a:	8f 92       	push	r8
 13c:	9f 92       	push	r9
 13e:	af 92       	push	r10
 140:	bf 92       	push	r11
 142:	cf 92       	push	r12
 144:	df 92       	push	r13
 146:	ef 92       	push	r14
 148:	ff 92       	push	r15
 14a:	0f 93       	push	r16
 14c:	1f 93       	push	r17
 14e:	cf 93       	push	r28
 150:	df 93       	push	r29
 152:	cd b7       	in	r28, 0x3d	; 61
 154:	de b7       	in	r29, 0x3e	; 62
 156:	2d 97       	sbiw	r28, 0x0d	; 13
 158:	0f b6       	in	r0, 0x3f	; 63
 15a:	f8 94       	cli
 15c:	de bf       	out	0x3e, r29	; 62
 15e:	0f be       	out	0x3f, r0	; 63
 160:	cd bf       	out	0x3d, r28	; 61
 162:	1c 01       	movw	r2, r24
	uint32_t deciHertz = freq * 10;
 164:	cb 01       	movw	r24, r22
 166:	ba 01       	movw	r22, r20
 168:	2a e0       	ldi	r18, 0x0A	; 10
 16a:	30 e0       	ldi	r19, 0x00	; 0
 16c:	40 e0       	ldi	r20, 0x00	; 0
 16e:	50 e0       	ldi	r21, 0x00	; 0
 170:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 174:	6e 83       	std	Y+6, r22	; 0x06
 176:	7f 83       	std	Y+7, r23	; 0x07
 178:	88 87       	std	Y+8, r24	; 0x08
 17a:	99 87       	std	Y+9, r25	; 0x09
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 17c:	f1 01       	movw	r30, r2
 17e:	82 81       	ldd	r24, Z+2	; 0x02
 180:	44 24       	eor	r4, r4
 182:	55 24       	eor	r5, r5
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 184:	90 e0       	ldi	r25, 0x00	; 0
 186:	9c 01       	movw	r18, r24
 188:	21 50       	subi	r18, 0x01	; 1
 18a:	30 40       	sbci	r19, 0x00	; 0
 18c:	3b 87       	std	Y+11, r19	; 0x0b
 18e:	2a 87       	std	Y+10, r18	; 0x0a
 190:	fc 01       	movw	r30, r24
 192:	e1 50       	subi	r30, 0x01	; 1
 194:	f0 48       	sbci	r31, 0x80	; 128
 196:	fd 87       	std	Y+13, r31	; 0x0d
 198:	ec 87       	std	Y+12, r30	; 0x0c
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 19a:	00 c0       	rjmp	.+0      	; 0x19c <motorPWMInit+0x6e>
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 19c:	8c 85       	ldd	r24, Y+12	; 0x0c
 19e:	9d 85       	ldd	r25, Y+13	; 0x0d
 1a0:	84 19       	sub	r24, r4
 1a2:	95 09       	sbc	r25, r5
 1a4:	88 0f       	add	r24, r24
 1a6:	99 1f       	adc	r25, r25
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
		MOTOR* motor = (MOTOR*)pgm_read_word(&driver->motors[i]);
 1a8:	f1 01       	movw	r30, r2
 1aa:	20 81       	ld	r18, Z
 1ac:	31 81       	ldd	r19, Z+1	; 0x01
 1ae:	28 0f       	add	r18, r24
 1b0:	39 1f       	adc	r19, r25
 1b2:	f9 01       	movw	r30, r18
 1b4:	85 91       	lpm	r24, Z+
 1b6:	94 91       	lpm	r25, Z
 1b8:	4c 01       	movw	r8, r24

		// Find the PWM timer compare channel for the output pin
		const TimerCompare* channel = compareFromIOPin(motor->pwm);
 1ba:	fc 01       	movw	r30, r24
 1bc:	84 81       	ldd	r24, Z+4	; 0x04
 1be:	95 81       	ldd	r25, Z+5	; 0x05
 1c0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1c4:	3c 01       	movw	r6, r24
		if(channel==null){
 1c6:	00 97       	sbiw	r24, 0x00	; 0
 1c8:	01 f4       	brne	.+0      	; 0x1ca <motorPWMInit+0x9c>
			setError(PWM_PIN_NOT_AVAILABLE);
 1ca:	84 ef       	ldi	r24, 0xF4	; 244
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <motorPWMInit+0xa0>
			continue;
		}
		if(compareIsInUse(channel)){
 1ce:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1d2:	88 23       	and	r24, r24
 1d4:	01 f0       	breq	.+0      	; 0x1d6 <motorPWMInit+0xa8>
			setError(PWM_PIN_IN_USE);
 1d6:	83 ef       	ldi	r24, 0xF3	; 243
 1d8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			continue;
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <motorPWMInit+0xb0>
 1de:	f3 01       	movw	r30, r6
 1e0:	32 96       	adiw	r30, 0x02	; 2
 1e2:	e4 91       	lpm	r30, Z
 1e4:	f0 e0       	ldi	r31, 0x00	; 0

		TIMER_MODE mode;
		uint16_t icr;
		uint16_t prescaler;

		const Timer* timer = compareGetTimer(channel);
 1e6:	2c e2       	ldi	r18, 0x2C	; 44
 1e8:	30 e0       	ldi	r19, 0x00	; 0
 1ea:	e2 9f       	mul	r30, r18
 1ec:	50 01       	movw	r10, r0
 1ee:	e3 9f       	mul	r30, r19
 1f0:	b0 0c       	add	r11, r0
 1f2:	f2 9f       	mul	r31, r18
 1f4:	b0 0c       	add	r11, r0
 1f6:	11 24       	eor	r1, r1
 1f8:	80 e0       	ldi	r24, 0x00	; 0
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	a8 0e       	add	r10, r24
 1fe:	b9 1e       	adc	r11, r25

		// Find the best PWM setting for 10kHz, with 128 steps
		boolean valid = timerCalcPwm(timer, deciHertz, 128, &mode, &icr, &prescaler);
 200:	c5 01       	movw	r24, r10
 202:	4e 81       	ldd	r20, Y+6	; 0x06
 204:	5f 81       	ldd	r21, Y+7	; 0x07
 206:	68 85       	ldd	r22, Y+8	; 0x08
 208:	79 85       	ldd	r23, Y+9	; 0x09
 20a:	20 e8       	ldi	r18, 0x80	; 128
 20c:	30 e0       	ldi	r19, 0x00	; 0
 20e:	8e 01       	movw	r16, r28
 210:	0f 5f       	subi	r16, 0xFF	; 255
 212:	1f 4f       	sbci	r17, 0xFF	; 255
 214:	a4 e0       	ldi	r26, 0x04	; 4
 216:	ea 2e       	mov	r14, r26
 218:	f1 2c       	mov	r15, r1
 21a:	ec 0e       	add	r14, r28
 21c:	fd 1e       	adc	r15, r29
 21e:	b2 e0       	ldi	r27, 0x02	; 2
 220:	cb 2e       	mov	r12, r27
 222:	d1 2c       	mov	r13, r1
 224:	cc 0e       	add	r12, r28
 226:	dd 1e       	adc	r13, r29
 228:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 22c:	f5 01       	movw	r30, r10
 22e:	34 96       	adiw	r30, 0x04	; 4

		if(!valid){
 230:	88 23       	and	r24, r24
 232:	01 f4       	brne	.+0      	; 0x234 <motorPWMInit+0x106>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 234:	85 91       	lpm	r24, Z+
 236:	94 91       	lpm	r25, Z
 238:	fc 01       	movw	r30, r24
 23a:	80 81       	ld	r24, Z
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	87 70       	andi	r24, 0x07	; 7
 240:	90 70       	andi	r25, 0x00	; 0
 242:	00 97       	sbiw	r24, 0x00	; 0
 244:	01 f0       	breq	.+0      	; 0x246 <motorPWMInit+0x118>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 246:	82 ef       	ldi	r24, 0xF2	; 242
 248:	00 c0       	rjmp	.+0      	; 0x24a <motorPWMInit+0x11c>
 24a:	83 ee       	ldi	r24, 0xE3	; 227
 24c:	00 c0       	rjmp	.+0      	; 0x24e <motorPWMInit+0x120>
 24e:	85 91       	lpm	r24, Z+
 250:	94 91       	lpm	r25, Z
 252:	fc 01       	movw	r30, r24
 254:	80 81       	ld	r24, Z
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	87 70       	andi	r24, 0x07	; 7
 25a:	90 70       	andi	r25, 0x00	; 0
 25c:	00 97       	sbiw	r24, 0x00	; 0
 25e:	01 f4       	brne	.+0      	; 0x260 <motorPWMInit+0x132>
 260:	00 c0       	rjmp	.+0      	; 0x262 <motorPWMInit+0x134>
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
				if(modeIsICR(mode)){
					// Set the ICR
					PORT icrPort = pgm_read_word(&timer->pgm_icr);
 262:	f5 01       	movw	r30, r10
 264:	7f 96       	adiw	r30, 0x1f	; 31
 266:	85 91       	lpm	r24, Z+
 268:	94 91       	lpm	r25, Z
					_SFR_MEM16(icrPort)=icr;
 26a:	fc 01       	movw	r30, r24
 26c:	8c 81       	ldd	r24, Y+4	; 0x04
 26e:	9d 81       	ldd	r25, Y+5	; 0x05
 270:	91 83       	std	Z+1, r25	; 0x01
 272:	80 83       	st	Z, r24
				}
			}

			// Connect motor to driver
			motor->actuator.class = &c_motors;
 274:	20 e0       	ldi	r18, 0x00	; 0
 276:	30 e0       	ldi	r19, 0x00	; 0
 278:	f4 01       	movw	r30, r8
 27a:	31 83       	std	Z+1, r19	; 0x01
 27c:	20 83       	st	Z, r18

			// Make sure the motor pin is an output pin
			pin_make_output(motor->pwm, FALSE);
 27e:	84 81       	ldd	r24, Z+4	; 0x04
 280:	95 81       	ldd	r25, Z+5	; 0x05
 282:	60 e0       	ldi	r22, 0x00	; 0
 284:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Make sure the direction pin is set as an output pin
			pin_make_output(motor->direction1, FALSE);
 288:	f4 01       	movw	r30, r8
 28a:	86 81       	ldd	r24, Z+6	; 0x06
 28c:	97 81       	ldd	r25, Z+7	; 0x07
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			pin_make_output(motor->direction2, FALSE);
 294:	f4 01       	movw	r30, r8
 296:	80 85       	ldd	r24, Z+8	; 0x08
 298:	91 85       	ldd	r25, Z+9	; 0x09
 29a:	60 e0       	ldi	r22, 0x00	; 0
 29c:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Mark the channel as in use
			compareAttach(channel,&nullTimerCompareCallback,0,null);
 2a0:	c3 01       	movw	r24, r6
 2a2:	60 e0       	ldi	r22, 0x00	; 0
 2a4:	70 e0       	ldi	r23, 0x00	; 0
 2a6:	40 e0       	ldi	r20, 0x00	; 0
 2a8:	50 e0       	ldi	r21, 0x00	; 0
 2aa:	20 e0       	ldi	r18, 0x00	; 0
 2ac:	30 e0       	ldi	r19, 0x00	; 0
 2ae:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescaler);
 2b2:	6a 81       	ldd	r22, Y+2	; 0x02
 2b4:	7b 81       	ldd	r23, Y+3	; 0x03
 2b6:	c5 01       	movw	r24, r10
 2b8:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Start off braking
			act_setSpeed(motor,DRIVE_SPEED_BRAKE);
 2bc:	c4 01       	movw	r24, r8
 2be:	60 e0       	ldi	r22, 0x00	; 0
 2c0:	0e 94 00 00 	call	0	; 0x0 <setConnected>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
 2c4:	c4 01       	movw	r24, r8
 2c6:	6f ef       	ldi	r22, 0xFF	; 255
 2c8:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 2cc:	08 94       	sec
 2ce:	41 1c       	adc	r4, r1
 2d0:	51 1c       	adc	r5, r1
const static __ACTUATOR_DRIVER_CLASS c_motors = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,&setConnected);

// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void motorPWMInit(MOTOR_DRIVER* driver, uint32_t freq){
 2d2:	8a 85       	ldd	r24, Y+10	; 0x0a
 2d4:	9b 85       	ldd	r25, Y+11	; 0x0b
 2d6:	84 19       	sub	r24, r4
 2d8:	95 09       	sbc	r25, r5
	uint32_t deciHertz = freq * 10;
	// Make sure each servo is set as an output
	for(int i= driver->num_motors-1;i>=0;i--){
 2da:	ff ef       	ldi	r31, 0xFF	; 255
 2dc:	8f 3f       	cpi	r24, 0xFF	; 255
 2de:	9f 07       	cpc	r25, r31
 2e0:	01 f0       	breq	.+0      	; 0x2e2 <motorPWMInit+0x1b4>
 2e2:	00 c0       	rjmp	.+0      	; 0x2e4 <motorPWMInit+0x1b6>
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <motorPWMInit+0x1b8>
			// There is no PWM setting that is valid
			setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
		}else{
			// Lets set up the PWM
			if(!timerIsInUse(timer)){
				timerSetMode(timer,mode);
 2e6:	c5 01       	movw	r24, r10
 2e8:	69 81       	ldd	r22, Y+1	; 0x01
 2ea:	0e 94 00 00 	call	0	; 0x0 <setConnected>
				if(modeIsICR(mode)){
 2ee:	81 e0       	ldi	r24, 0x01	; 1
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	09 80       	ldd	r0, Y+1	; 0x01
 2f4:	00 c0       	rjmp	.+0      	; 0x2f6 <motorPWMInit+0x1c8>
 2f6:	88 0f       	add	r24, r24
 2f8:	99 1f       	adc	r25, r25
 2fa:	0a 94       	dec	r0
 2fc:	02 f4       	brpl	.+0      	; 0x2fe <motorPWMInit+0x1d0>
 2fe:	80 70       	andi	r24, 0x00	; 0
 300:	95 75       	andi	r25, 0x55	; 85
 302:	00 97       	sbiw	r24, 0x00	; 0
 304:	01 f0       	breq	.+0      	; 0x306 <motorPWMInit+0x1d8>
 306:	00 c0       	rjmp	.+0      	; 0x308 <motorPWMInit+0x1da>
 308:	00 c0       	rjmp	.+0      	; 0x30a <motorPWMInit+0x1dc>

			// Indicate the motor is connected
			act_setConnected(motor,TRUE);
		}
	}
}
 30a:	2d 96       	adiw	r28, 0x0d	; 13
 30c:	0f b6       	in	r0, 0x3f	; 63
 30e:	f8 94       	cli
 310:	de bf       	out	0x3e, r29	; 62
 312:	0f be       	out	0x3f, r0	; 63
 314:	cd bf       	out	0x3d, r28	; 61
 316:	df 91       	pop	r29
 318:	cf 91       	pop	r28
 31a:	1f 91       	pop	r17
 31c:	0f 91       	pop	r16
 31e:	ff 90       	pop	r15
 320:	ef 90       	pop	r14
 322:	df 90       	pop	r13
 324:	cf 90       	pop	r12
 326:	bf 90       	pop	r11
 328:	af 90       	pop	r10
 32a:	9f 90       	pop	r9
 32c:	8f 90       	pop	r8
 32e:	7f 90       	pop	r7
 330:	6f 90       	pop	r6
 332:	5f 90       	pop	r5
 334:	4f 90       	pop	r4
 336:	3f 90       	pop	r3
 338:	2f 90       	pop	r2
 33a:	08 95       	ret

pid.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000039a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003ce  2**0
                  ALLOC
  3 .debug_info   00000630  00000000  00000000  000003ce  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001f7  00000000  00000000  000009fe  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000364  00000000  00000000  00000bf5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000f59  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000106  00000000  00000000  00000f79  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000036a  00000000  00000000  0000107f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000094  00000000  00000000  000013ec  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pidSetTarget>:
#include "pid.h"
#include "timer.h"

// Update the PID with the desired target position - the setPoint
void pidSetTarget(PID* pid,float setPoint){
	CRITICAL_SECTION_START;					//Just in case PID is used in interrupts
   0:	2f b7       	in	r18, 0x3f	; 63
   2:	f8 94       	cli
	pid->setPoint = setPoint; 				//set goal
   4:	fc 01       	movw	r30, r24
   6:	41 a3       	std	Z+33, r20	; 0x21
   8:	52 a3       	std	Z+34, r21	; 0x22
   a:	63 a3       	std	Z+35, r22	; 0x23
   c:	74 a3       	std	Z+36, r23	; 0x24
	CRITICAL_SECTION_END;
   e:	2f bf       	out	0x3f, r18	; 63
}
  10:	08 95       	ret

00000012 <pidSetActual>:

// Update the PID with the actual position and return the new output
float pidSetActual(PID* pid,float actual){
  12:	2f 92       	push	r2
  14:	3f 92       	push	r3
  16:	4f 92       	push	r4
  18:	5f 92       	push	r5
  1a:	6f 92       	push	r6
  1c:	7f 92       	push	r7
  1e:	8f 92       	push	r8
  20:	9f 92       	push	r9
  22:	af 92       	push	r10
  24:	bf 92       	push	r11
  26:	cf 92       	push	r12
  28:	df 92       	push	r13
  2a:	ef 92       	push	r14
  2c:	ff 92       	push	r15
  2e:	0f 93       	push	r16
  30:	1f 93       	push	r17
  32:	cf 93       	push	r28
  34:	df 93       	push	r29
  36:	cd b7       	in	r28, 0x3d	; 61
  38:	de b7       	in	r29, 0x3e	; 62
  3a:	27 97       	sbiw	r28, 0x07	; 7
  3c:	0f b6       	in	r0, 0x3f	; 63
  3e:	f8 94       	cli
  40:	de bf       	out	0x3e, r29	; 62
  42:	0f be       	out	0x3f, r0	; 63
  44:	cd bf       	out	0x3d, r28	; 61
  46:	9f 83       	std	Y+7, r25	; 0x07
  48:	8e 83       	std	Y+6, r24	; 0x06
  4a:	6a 01       	movw	r12, r20
  4c:	7b 01       	movw	r14, r22

	// Find time difference since last call
	TICK_COUNT dt;

	if(g_heartbeat){
  4e:	80 91 00 00 	lds	r24, 0x0000
  52:	90 91 00 00 	lds	r25, 0x0000
  56:	00 97       	sbiw	r24, 0x00	; 0
  58:	01 f0       	breq	.+0      	; 0x5a <pidSetActual+0x48>
		// We have got a timer
		TICK_COUNT now = clockGetus();
  5a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  5e:	dc 01       	movw	r26, r24
  60:	cb 01       	movw	r24, r22
	 	dt = now - pid->lastTime;
  62:	ee 81       	ldd	r30, Y+6	; 0x06
  64:	ff 81       	ldd	r31, Y+7	; 0x07
  66:	41 a5       	ldd	r20, Z+41	; 0x29
  68:	52 a5       	ldd	r21, Z+42	; 0x2a
  6a:	63 a5       	ldd	r22, Z+43	; 0x2b
  6c:	74 a5       	ldd	r23, Z+44	; 0x2c
  6e:	8c 01       	movw	r16, r24
  70:	9d 01       	movw	r18, r26
  72:	04 1b       	sub	r16, r20
  74:	15 0b       	sbc	r17, r21
  76:	26 0b       	sbc	r18, r22
  78:	37 0b       	sbc	r19, r23
  7a:	09 83       	std	Y+1, r16	; 0x01
  7c:	1a 83       	std	Y+2, r17	; 0x02
  7e:	2b 83       	std	Y+3, r18	; 0x03
  80:	3c 83       	std	Y+4, r19	; 0x04
		pid->lastTime = now;
  82:	81 a7       	std	Z+41, r24	; 0x29
  84:	92 a7       	std	Z+42, r25	; 0x2a
  86:	a3 a7       	std	Z+43, r26	; 0x2b
  88:	b4 a7       	std	Z+44, r27	; 0x2c
  8a:	00 c0       	rjmp	.+0      	; 0x8c <pidSetActual+0x7a>
	}else{
		// There is no timer - so assume called every 10ms
		dt = (TICK_COUNT)10000;
  8c:	00 e1       	ldi	r16, 0x10	; 16
  8e:	17 e2       	ldi	r17, 0x27	; 39
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	09 83       	std	Y+1, r16	; 0x01
  96:	1a 83       	std	Y+2, r17	; 0x02
  98:	2b 83       	std	Y+3, r18	; 0x03
  9a:	3c 83       	std	Y+4, r19	; 0x04
	}
	
	float target;
	CRITICAL_SECTION{
  9c:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  9e:	f8 94       	cli
		target = pid->setPoint;
  a0:	ae 81       	ldd	r26, Y+6	; 0x06
  a2:	bf 81       	ldd	r27, Y+7	; 0x07
  a4:	91 96       	adiw	r26, 0x21	; 33
  a6:	6d 91       	ld	r22, X+
  a8:	7d 91       	ld	r23, X+
  aa:	8d 91       	ld	r24, X+
  ac:	9c 91       	ld	r25, X
  ae:	94 97       	sbiw	r26, 0x24	; 36
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  b0:	2f bf       	out	0x3f, r18	; 63
	}
	float error =  target - actual;  		//find error
  b2:	a7 01       	movw	r20, r14
  b4:	96 01       	movw	r18, r12
  b6:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  ba:	8b 01       	movw	r16, r22
  bc:	f8 2e       	mov	r15, r24
  be:	e9 2e       	mov	r14, r25

	//if circular control system, check for and handle wrap around
	if (pid->isCircular){
  c0:	ee 81       	ldd	r30, Y+6	; 0x06
  c2:	ff 81       	ldd	r31, Y+7	; 0x07
  c4:	84 8d       	ldd	r24, Z+28	; 0x1c
  c6:	88 23       	and	r24, r24
  c8:	01 f4       	brne	.+0      	; 0xca <pidSetActual+0xb8>
  ca:	00 c0       	rjmp	.+0      	; 0xcc <pidSetActual+0xba>
		float spanDiv2 = pid->inSpan / 2;
  cc:	84 84       	ldd	r8, Z+12	; 0x0c
  ce:	95 84       	ldd	r9, Z+13	; 0x0d
  d0:	a6 84       	ldd	r10, Z+14	; 0x0e
  d2:	b7 84       	ldd	r11, Z+15	; 0x0f
  d4:	c5 01       	movw	r24, r10
  d6:	b4 01       	movw	r22, r8
  d8:	20 e0       	ldi	r18, 0x00	; 0
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	40 e0       	ldi	r20, 0x00	; 0
  de:	5f e3       	ldi	r21, 0x3F	; 63
  e0:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
  e4:	46 2f       	mov	r20, r22
  e6:	57 2f       	mov	r21, r23
  e8:	68 2f       	mov	r22, r24
  ea:	79 2f       	mov	r23, r25
  ec:	2a 01       	movw	r4, r20
  ee:	3b 01       	movw	r6, r22
		if (error < -spanDiv2){
  f0:	a3 01       	movw	r20, r6
  f2:	92 01       	movw	r18, r4
  f4:	50 58       	subi	r21, 0x80	; 128
  f6:	b7 01       	movw	r22, r14
  f8:	80 2f       	mov	r24, r16
  fa:	91 2f       	mov	r25, r17
  fc:	a7 2f       	mov	r26, r23
  fe:	b6 2f       	mov	r27, r22
 100:	bc 01       	movw	r22, r24
 102:	cd 01       	movw	r24, r26
 104:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 108:	87 ff       	sbrs	r24, 7
 10a:	00 c0       	rjmp	.+0      	; 0x10c <pidSetActual+0xfa>
			error += pid->inSpan;
 10c:	97 01       	movw	r18, r14
 10e:	80 2f       	mov	r24, r16
 110:	91 2f       	mov	r25, r17
 112:	a3 2f       	mov	r26, r19
 114:	b2 2f       	mov	r27, r18
 116:	bc 01       	movw	r22, r24
 118:	cd 01       	movw	r24, r26
 11a:	a5 01       	movw	r20, r10
 11c:	94 01       	movw	r18, r8
 11e:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 122:	8b 01       	movw	r16, r22
 124:	f8 2e       	mov	r15, r24
 126:	e9 2e       	mov	r14, r25
		}
  		if (error > spanDiv2){
 128:	97 01       	movw	r18, r14
 12a:	80 2f       	mov	r24, r16
 12c:	91 2f       	mov	r25, r17
 12e:	a3 2f       	mov	r26, r19
 130:	be 2d       	mov	r27, r14
 132:	bc 01       	movw	r22, r24
 134:	cd 01       	movw	r24, r26
 136:	a3 01       	movw	r20, r6
 138:	92 01       	movw	r18, r4
 13a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 13e:	18 16       	cp	r1, r24
 140:	04 f4       	brge	.+0      	; 0x142 <pidSetActual+0x130>
  			error -= pid->inSpan;
 142:	97 01       	movw	r18, r14
 144:	80 2f       	mov	r24, r16
 146:	91 2f       	mov	r25, r17
 148:	a3 2f       	mov	r26, r19
 14a:	be 2d       	mov	r27, r14
 14c:	bc 01       	movw	r22, r24
 14e:	cd 01       	movw	r24, r26
 150:	a5 01       	movw	r20, r10
 152:	94 01       	movw	r18, r8
 154:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 158:	8b 01       	movw	r16, r22
 15a:	f8 2e       	mov	r15, r24
 15c:	e9 2e       	mov	r14, r25
  		}
	}
	pid->prevError = error;				// save error for next go around
 15e:	97 01       	movw	r18, r14
 160:	80 2f       	mov	r24, r16
 162:	91 2f       	mov	r25, r17
 164:	a3 2f       	mov	r26, r19
 166:	be 2d       	mov	r27, r14
 168:	ee 81       	ldd	r30, Y+6	; 0x06
 16a:	ff 81       	ldd	r31, Y+7	; 0x07
 16c:	85 a3       	std	Z+37, r24	; 0x25
 16e:	96 a3       	std	Z+38, r25	; 0x26
 170:	a7 a3       	std	Z+39, r26	; 0x27
 172:	b0 a7       	std	Z+40, r27	; 0x28

	//sum the errors for integral and clamp to limit
	pid->integral += error;
 174:	bc 01       	movw	r22, r24
 176:	cd 01       	movw	r24, r26
 178:	25 8d       	ldd	r18, Z+29	; 0x1d
 17a:	36 8d       	ldd	r19, Z+30	; 0x1e
 17c:	47 8d       	ldd	r20, Z+31	; 0x1f
 17e:	50 a1       	ldd	r21, Z+32	; 0x20
 180:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 184:	d6 2e       	mov	r13, r22
 186:	c7 2e       	mov	r12, r23
 188:	78 2e       	mov	r7, r24
 18a:	69 2e       	mov	r6, r25
	pid->integral = CLAMP( pid->integral, -(pid->iLimit), pid->iLimit);
 18c:	ae 81       	ldd	r26, Y+6	; 0x06
 18e:	bf 81       	ldd	r27, Y+7	; 0x07
 190:	58 96       	adiw	r26, 0x18	; 24
 192:	8d 90       	ld	r8, X+
 194:	9d 90       	ld	r9, X+
 196:	ad 90       	ld	r10, X+
 198:	bc 90       	ld	r11, X
 19a:	5b 97       	sbiw	r26, 0x1b	; 27
 19c:	b1 e0       	ldi	r27, 0x01	; 1
 19e:	bd 83       	std	Y+5, r27	; 0x05
 1a0:	a6 01       	movw	r20, r12
 1a2:	93 01       	movw	r18, r6
 1a4:	85 2f       	mov	r24, r21
 1a6:	94 2f       	mov	r25, r20
 1a8:	a3 2f       	mov	r26, r19
 1aa:	b2 2f       	mov	r27, r18
 1ac:	bc 01       	movw	r22, r24
 1ae:	cd 01       	movw	r24, r26
 1b0:	a5 01       	movw	r20, r10
 1b2:	94 01       	movw	r18, r8
 1b4:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 1b8:	87 fd       	sbrc	r24, 7
 1ba:	00 c0       	rjmp	.+0      	; 0x1bc <pidSetActual+0x1aa>
 1bc:	1d 82       	std	Y+5, r1	; 0x05
 1be:	78 2d       	mov	r23, r8
 1c0:	69 2d       	mov	r22, r9
 1c2:	9a 2d       	mov	r25, r10
 1c4:	8b 2d       	mov	r24, r11
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <pidSetActual+0x1b6>
 1c8:	b6 01       	movw	r22, r12
 1ca:	c3 01       	movw	r24, r6
 1cc:	14 01       	movw	r2, r8
 1ce:	25 01       	movw	r4, r10
 1d0:	57 fa       	bst	r5, 7
 1d2:	50 94       	com	r5
 1d4:	57 f8       	bld	r5, 7
 1d6:	50 94       	com	r5
 1d8:	ab 01       	movw	r20, r22
 1da:	9c 01       	movw	r18, r24
 1dc:	85 2f       	mov	r24, r21
 1de:	96 2f       	mov	r25, r22
 1e0:	a3 2f       	mov	r26, r19
 1e2:	b2 2f       	mov	r27, r18
 1e4:	bc 01       	movw	r22, r24
 1e6:	cd 01       	movw	r24, r26
 1e8:	a2 01       	movw	r20, r4
 1ea:	91 01       	movw	r18, r2
 1ec:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 1f0:	18 16       	cp	r1, r24
 1f2:	04 f4       	brge	.+0      	; 0x1f4 <pidSetActual+0x1e2>
 1f4:	ed 81       	ldd	r30, Y+5	; 0x05
 1f6:	ee 23       	and	r30, r30
 1f8:	01 f0       	breq	.+0      	; 0x1fa <pidSetActual+0x1e8>
 1fa:	96 01       	movw	r18, r12
 1fc:	c3 01       	movw	r24, r6
 1fe:	83 2e       	mov	r8, r19
 200:	9c 2c       	mov	r9, r12
 202:	a9 2e       	mov	r10, r25
 204:	b6 2c       	mov	r11, r6
 206:	00 c0       	rjmp	.+0      	; 0x208 <pidSetActual+0x1f6>
 208:	52 01       	movw	r10, r4
 20a:	41 01       	movw	r8, r2
 20c:	ae 81       	ldd	r26, Y+6	; 0x06
 20e:	bf 81       	ldd	r27, Y+7	; 0x07
 210:	5d 96       	adiw	r26, 0x1d	; 29
 212:	8d 92       	st	X+, r8
 214:	9d 92       	st	X+, r9
 216:	ad 92       	st	X+, r10
 218:	bc 92       	st	X, r11
 21a:	90 97       	sbiw	r26, 0x20	; 32


	//find slope of error over time
	float derivative = (error - pid->prevError) / dt;

	float out = (pid->kP * error) + (pid->kI * pid->integral) + (pid->kD * derivative);
 21c:	97 01       	movw	r18, r14
 21e:	80 2f       	mov	r24, r16
 220:	91 2f       	mov	r25, r17
 222:	a3 2f       	mov	r26, r19
 224:	be 2d       	mov	r27, r14
 226:	bc 01       	movw	r22, r24
 228:	cd 01       	movw	r24, r26
 22a:	ee 81       	ldd	r30, Y+6	; 0x06
 22c:	ff 81       	ldd	r31, Y+7	; 0x07
 22e:	20 81       	ld	r18, Z
 230:	31 81       	ldd	r19, Z+1	; 0x01
 232:	42 81       	ldd	r20, Z+2	; 0x02
 234:	53 81       	ldd	r21, Z+3	; 0x03
 236:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 23a:	2b 01       	movw	r4, r22
 23c:	3c 01       	movw	r6, r24
 23e:	c5 01       	movw	r24, r10
 240:	b4 01       	movw	r22, r8
 242:	ae 81       	ldd	r26, Y+6	; 0x06
 244:	bf 81       	ldd	r27, Y+7	; 0x07
 246:	14 96       	adiw	r26, 0x04	; 4
 248:	2d 91       	ld	r18, X+
 24a:	3d 91       	ld	r19, X+
 24c:	4d 91       	ld	r20, X+
 24e:	5c 91       	ld	r21, X
 250:	17 97       	sbiw	r26, 0x07	; 7
 252:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 256:	9b 01       	movw	r18, r22
 258:	ac 01       	movw	r20, r24
 25a:	c3 01       	movw	r24, r6
 25c:	b2 01       	movw	r22, r4
 25e:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 262:	2b 01       	movw	r4, r22
 264:	3c 01       	movw	r6, r24
	pid->integral += error;
	pid->integral = CLAMP( pid->integral, -(pid->iLimit), pid->iLimit);


	//find slope of error over time
	float derivative = (error - pid->prevError) / dt;
 266:	97 01       	movw	r18, r14
 268:	80 2f       	mov	r24, r16
 26a:	91 2f       	mov	r25, r17
 26c:	a3 2f       	mov	r26, r19
 26e:	be 2d       	mov	r27, r14
 270:	bc 01       	movw	r22, r24
 272:	cd 01       	movw	r24, r26
 274:	a7 01       	movw	r20, r14
 276:	25 2f       	mov	r18, r21
 278:	3b 2f       	mov	r19, r27
 27a:	a9 01       	movw	r20, r18
 27c:	98 01       	movw	r18, r16
 27e:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 282:	4b 01       	movw	r8, r22
 284:	5c 01       	movw	r10, r24
 286:	69 81       	ldd	r22, Y+1	; 0x01
 288:	7a 81       	ldd	r23, Y+2	; 0x02
 28a:	8b 81       	ldd	r24, Y+3	; 0x03
 28c:	9c 81       	ldd	r25, Y+4	; 0x04
 28e:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 292:	9b 01       	movw	r18, r22
 294:	ac 01       	movw	r20, r24
 296:	c5 01       	movw	r24, r10
 298:	b4 01       	movw	r22, r8
 29a:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>

	float out = (pid->kP * error) + (pid->kI * pid->integral) + (pid->kD * derivative);
 29e:	ee 81       	ldd	r30, Y+6	; 0x06
 2a0:	ff 81       	ldd	r31, Y+7	; 0x07
 2a2:	20 85       	ldd	r18, Z+8	; 0x08
 2a4:	31 85       	ldd	r19, Z+9	; 0x09
 2a6:	42 85       	ldd	r20, Z+10	; 0x0a
 2a8:	53 85       	ldd	r21, Z+11	; 0x0b
 2aa:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 2ae:	9b 01       	movw	r18, r22
 2b0:	ac 01       	movw	r20, r24
 2b2:	c3 01       	movw	r24, r6
 2b4:	b2 01       	movw	r22, r4
 2b6:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 2ba:	d6 2e       	mov	r13, r22
 2bc:	c7 2e       	mov	r12, r23
 2be:	78 2e       	mov	r7, r24
 2c0:	69 2e       	mov	r6, r25

	//compare output to limits
	out = CLAMP(out, pid->outMin, pid->outMax);
 2c2:	ae 81       	ldd	r26, Y+6	; 0x06
 2c4:	bf 81       	ldd	r27, Y+7	; 0x07
 2c6:	50 96       	adiw	r26, 0x10	; 16
 2c8:	0c 91       	ld	r16, X
 2ca:	50 97       	sbiw	r26, 0x10	; 16
 2cc:	51 96       	adiw	r26, 0x11	; 17
 2ce:	1c 91       	ld	r17, X
 2d0:	51 97       	sbiw	r26, 0x11	; 17
 2d2:	52 96       	adiw	r26, 0x12	; 18
 2d4:	fc 90       	ld	r15, X
 2d6:	52 97       	sbiw	r26, 0x12	; 18
 2d8:	53 96       	adiw	r26, 0x13	; 19
 2da:	ec 90       	ld	r14, X
 2dc:	33 24       	eor	r3, r3
 2de:	33 94       	inc	r3
 2e0:	a6 01       	movw	r20, r12
 2e2:	93 01       	movw	r18, r6
 2e4:	85 2f       	mov	r24, r21
 2e6:	94 2f       	mov	r25, r20
 2e8:	a3 2f       	mov	r26, r19
 2ea:	b2 2f       	mov	r27, r18
 2ec:	bc 01       	movw	r22, r24
 2ee:	cd 01       	movw	r24, r26
 2f0:	97 01       	movw	r18, r14
 2f2:	80 2e       	mov	r8, r16
 2f4:	91 2e       	mov	r9, r17
 2f6:	a3 2e       	mov	r10, r19
 2f8:	b2 2e       	mov	r11, r18
 2fa:	a5 01       	movw	r20, r10
 2fc:	94 01       	movw	r18, r8
 2fe:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 302:	87 fd       	sbrc	r24, 7
 304:	00 c0       	rjmp	.+0      	; 0x306 <pidSetActual+0x2f4>
 306:	33 24       	eor	r3, r3
 308:	70 2f       	mov	r23, r16
 30a:	61 2f       	mov	r22, r17
 30c:	c7 01       	movw	r24, r14
 30e:	00 c0       	rjmp	.+0      	; 0x310 <pidSetActual+0x2fe>
 310:	b6 01       	movw	r22, r12
 312:	c3 01       	movw	r24, r6
 314:	ee 81       	ldd	r30, Y+6	; 0x06
 316:	ff 81       	ldd	r31, Y+7	; 0x07
 318:	24 88       	ldd	r2, Z+20	; 0x14
 31a:	55 88       	ldd	r5, Z+21	; 0x15
 31c:	46 88       	ldd	r4, Z+22	; 0x16
 31e:	f7 89       	ldd	r31, Z+23	; 0x17
 320:	f9 83       	std	Y+1, r31	; 0x01
 322:	ab 01       	movw	r20, r22
 324:	9c 01       	movw	r18, r24
 326:	85 2f       	mov	r24, r21
 328:	96 2f       	mov	r25, r22
 32a:	a3 2f       	mov	r26, r19
 32c:	b2 2f       	mov	r27, r18
 32e:	bc 01       	movw	r22, r24
 330:	cd 01       	movw	r24, r26
 332:	82 2c       	mov	r8, r2
 334:	95 2c       	mov	r9, r5
 336:	a4 2c       	mov	r10, r4
 338:	bf 2e       	mov	r11, r31
 33a:	a5 01       	movw	r20, r10
 33c:	94 01       	movw	r18, r8
 33e:	0e 94 00 00 	call	0	; 0x0 <pidSetTarget>
 342:	18 16       	cp	r1, r24
 344:	04 f4       	brge	.+0      	; 0x346 <pidSetActual+0x334>
 346:	33 20       	and	r3, r3
 348:	01 f0       	breq	.+0      	; 0x34a <pidSetActual+0x338>
 34a:	0d 2d       	mov	r16, r13
 34c:	1c 2d       	mov	r17, r12
 34e:	73 01       	movw	r14, r6
 350:	00 c0       	rjmp	.+0      	; 0x352 <pidSetActual+0x340>
 352:	02 2d       	mov	r16, r2
 354:	15 2d       	mov	r17, r5
 356:	f4 2c       	mov	r15, r4
 358:	e9 80       	ldd	r14, Y+1	; 0x01



	return out;

}
 35a:	97 01       	movw	r18, r14
 35c:	80 2f       	mov	r24, r16
 35e:	91 2f       	mov	r25, r17
 360:	a3 2f       	mov	r26, r19
 362:	be 2d       	mov	r27, r14
 364:	bc 01       	movw	r22, r24
 366:	cd 01       	movw	r24, r26
 368:	27 96       	adiw	r28, 0x07	; 7
 36a:	0f b6       	in	r0, 0x3f	; 63
 36c:	f8 94       	cli
 36e:	de bf       	out	0x3e, r29	; 62
 370:	0f be       	out	0x3f, r0	; 63
 372:	cd bf       	out	0x3d, r28	; 61
 374:	df 91       	pop	r29
 376:	cf 91       	pop	r28
 378:	1f 91       	pop	r17
 37a:	0f 91       	pop	r16
 37c:	ff 90       	pop	r15
 37e:	ef 90       	pop	r14
 380:	df 90       	pop	r13
 382:	cf 90       	pop	r12
 384:	bf 90       	pop	r11
 386:	af 90       	pop	r10
 388:	9f 90       	pop	r9
 38a:	8f 90       	pop	r8
 38c:	7f 90       	pop	r7
 38e:	6f 90       	pop	r6
 390:	5f 90       	pop	r5
 392:	4f 90       	pop	r4
 394:	3f 90       	pop	r3
 396:	2f 90       	pop	r2
 398:	08 95       	ret

pinChange.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000358  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000038c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000038c  2**0
                  ALLOC
  3 .debug_info   00000414  00000000  00000000  0000038c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000190  00000000  00000000  000007a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000005fe  00000000  00000000  00000930  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000f2e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000f3  00000000  00000000  00000f4e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000001ee  00000000  00000000  00001041  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001c8  00000000  00000000  00001230  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__io_to_pc_index>:
#include "pinChange.h"
#include <avr/interrupt.h>


// Convert an IOPin to the PCINT it uses or -1 if it doesn't have one
int __io_to_pc_index(const IOPin* io){
   0:	ac 01       	movw	r20, r24
	for(int i=0; i<NUM_PCINT_PINS;i++){
   2:	a0 91 00 00 	lds	r26, 0x0000
   6:	b0 e0       	ldi	r27, 0x00	; 0
   8:	20 e0       	ldi	r18, 0x00	; 0
   a:	30 e0       	ldi	r19, 0x00	; 0
   c:	00 c0       	rjmp	.+0      	; 0xe <__io_to_pc_index+0xe>
		const IOPin* aPin = (const IOPin*)pgm_read_word(&PCINT_PINS[i]);
   e:	f9 01       	movw	r30, r18
  10:	ee 0f       	add	r30, r30
  12:	ff 1f       	adc	r31, r31
  14:	e0 50       	subi	r30, 0x00	; 0
  16:	f0 40       	sbci	r31, 0x00	; 0
  18:	65 91       	lpm	r22, Z+
  1a:	74 91       	lpm	r23, Z
  1c:	cb 01       	movw	r24, r22
		if(aPin!=null && aPin==io){
  1e:	00 97       	sbiw	r24, 0x00	; 0
  20:	01 f0       	breq	.+0      	; 0x22 <__io_to_pc_index+0x22>
  22:	64 17       	cp	r22, r20
  24:	75 07       	cpc	r23, r21
  26:	01 f0       	breq	.+0      	; 0x28 <__io_to_pc_index+0x28>
#include <avr/interrupt.h>


// Convert an IOPin to the PCINT it uses or -1 if it doesn't have one
int __io_to_pc_index(const IOPin* io){
	for(int i=0; i<NUM_PCINT_PINS;i++){
  28:	2f 5f       	subi	r18, 0xFF	; 255
  2a:	3f 4f       	sbci	r19, 0xFF	; 255
  2c:	2a 17       	cp	r18, r26
  2e:	3b 07       	cpc	r19, r27
  30:	04 f0       	brlt	.+0      	; 0x32 <__io_to_pc_index+0x32>
		const IOPin* aPin = (const IOPin*)pgm_read_word(&PCINT_PINS[i]);
		if(aPin!=null && aPin==io){
			return i;
		}
	}
	return -1;
  32:	2f ef       	ldi	r18, 0xFF	; 255
  34:	3f ef       	ldi	r19, 0xFF	; 255
}
  36:	c9 01       	movw	r24, r18
  38:	08 95       	ret

0000003a <pin_change_attach>:

void pin_change_attach(const IOPin* io,PinChangeCallback callback, void* data){
  3a:	af 92       	push	r10
  3c:	bf 92       	push	r11
  3e:	cf 92       	push	r12
  40:	df 92       	push	r13
  42:	ef 92       	push	r14
  44:	ff 92       	push	r15
  46:	0f 93       	push	r16
  48:	1f 93       	push	r17
  4a:	cf 93       	push	r28
  4c:	df 93       	push	r29
  4e:	7c 01       	movw	r14, r24
  50:	5b 01       	movw	r10, r22
  52:	6a 01       	movw	r12, r20
	cli();
  54:	f8 94       	cli
	int inx = __io_to_pc_index(io);
  56:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  5a:	8c 01       	movw	r16, r24
	if(inx==-1){
  5c:	8f ef       	ldi	r24, 0xFF	; 255
  5e:	0f 3f       	cpi	r16, 0xFF	; 255
  60:	18 07       	cpc	r17, r24
  62:	01 f4       	brne	.+0      	; 0x64 <pin_change_attach+0x2a>
		setError(PIN_HAS_NO_PCINT);
  64:	8c ee       	ldi	r24, 0xEC	; 236
  66:	00 c0       	rjmp	.+0      	; 0x68 <pin_change_attach+0x2e>
	}else if(pcCallbacks[inx].callback!=null){
  68:	e8 01       	movw	r28, r16
  6a:	cc 0f       	add	r28, r28
  6c:	dd 1f       	adc	r29, r29
  6e:	cc 0f       	add	r28, r28
  70:	dd 1f       	adc	r29, r29
  72:	c0 0f       	add	r28, r16
  74:	d1 1f       	adc	r29, r17
  76:	c0 50       	subi	r28, 0x00	; 0
  78:	d0 40       	sbci	r29, 0x00	; 0
  7a:	88 81       	ld	r24, Y
  7c:	99 81       	ldd	r25, Y+1	; 0x01
  7e:	00 97       	sbiw	r24, 0x00	; 0
  80:	01 f0       	breq	.+0      	; 0x82 <pin_change_attach+0x48>
		setError(PIN_HAS_CALLBACK);
  82:	8b ee       	ldi	r24, 0xEB	; 235
  84:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  88:	00 c0       	rjmp	.+0      	; 0x8a <pin_change_attach+0x50>
	}else{
		pcCallbacks[inx].callback = callback;
  8a:	b9 82       	std	Y+1, r11	; 0x01
  8c:	a8 82       	st	Y, r10
		pcCallbacks[inx].data = data;
  8e:	db 82       	std	Y+3, r13	; 0x03
  90:	ca 82       	std	Y+2, r12	; 0x02
		pcCallbacks[inx].lastValue = pin_is_high(io);
  92:	c7 01       	movw	r24, r14
  94:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
  98:	8c 83       	std	Y+4, r24	; 0x04
		if(inx<=7){
  9a:	08 30       	cpi	r16, 0x08	; 8
  9c:	11 05       	cpc	r17, r1
  9e:	04 f4       	brge	.+0      	; 0xa0 <pin_change_attach+0x66>
#ifdef PCMSK0
			PCMSK0 |= BV(inx);		// enable iterrupts for this pin
  a0:	20 91 6b 00 	lds	r18, 0x006B
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	90 e0       	ldi	r25, 0x00	; 0
  a8:	00 c0       	rjmp	.+0      	; 0xaa <pin_change_attach+0x70>
  aa:	88 0f       	add	r24, r24
  ac:	99 1f       	adc	r25, r25
  ae:	0a 95       	dec	r16
  b0:	02 f4       	brpl	.+0      	; 0xb2 <pin_change_attach+0x78>
  b2:	28 2b       	or	r18, r24
  b4:	20 93 6b 00 	sts	0x006B, r18
			PCICR  |= BV(PCIE0);	// enable iterrupts for PCINT0..7
  b8:	80 91 68 00 	lds	r24, 0x0068
  bc:	81 60       	ori	r24, 0x01	; 1
  be:	00 c0       	rjmp	.+0      	; 0xc0 <pin_change_attach+0x86>
#endif
#ifdef PCMSK1
		}else if(inx<=15){
  c0:	00 31       	cpi	r16, 0x10	; 16
  c2:	11 05       	cpc	r17, r1
  c4:	04 f4       	brge	.+0      	; 0xc6 <pin_change_attach+0x8c>
			PCMSK1 |= BV((inx & 7));// enable iterrupts for this pin
  c6:	20 91 6c 00 	lds	r18, 0x006C
  ca:	07 70       	andi	r16, 0x07	; 7
  cc:	10 70       	andi	r17, 0x00	; 0
  ce:	81 e0       	ldi	r24, 0x01	; 1
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <pin_change_attach+0x9a>
  d4:	88 0f       	add	r24, r24
  d6:	99 1f       	adc	r25, r25
  d8:	0a 95       	dec	r16
  da:	02 f4       	brpl	.+0      	; 0xdc <pin_change_attach+0xa2>
  dc:	28 2b       	or	r18, r24
  de:	20 93 6c 00 	sts	0x006C, r18
			PCICR  |= BV(PCIE1);	// enable iterrupts for PCINT8..15
  e2:	80 91 68 00 	lds	r24, 0x0068
  e6:	82 60       	ori	r24, 0x02	; 2
  e8:	00 c0       	rjmp	.+0      	; 0xea <pin_change_attach+0xb0>
#endif
#ifdef PCMSK2
		}else if(inx<=23){
  ea:	08 31       	cpi	r16, 0x18	; 24
  ec:	11 05       	cpc	r17, r1
  ee:	04 f4       	brge	.+0      	; 0xf0 <pin_change_attach+0xb6>
			PCMSK2 |= BV((inx & 7));// enable iterrupts for this pin
  f0:	20 91 6d 00 	lds	r18, 0x006D
  f4:	07 70       	andi	r16, 0x07	; 7
  f6:	10 70       	andi	r17, 0x00	; 0
  f8:	81 e0       	ldi	r24, 0x01	; 1
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	00 c0       	rjmp	.+0      	; 0xfe <pin_change_attach+0xc4>
  fe:	88 0f       	add	r24, r24
 100:	99 1f       	adc	r25, r25
 102:	0a 95       	dec	r16
 104:	02 f4       	brpl	.+0      	; 0x106 <pin_change_attach+0xcc>
 106:	28 2b       	or	r18, r24
 108:	20 93 6d 00 	sts	0x006D, r18
			PCICR  |= BV(PCIE2);	// enable iterrupts for PCINT16...23
 10c:	80 91 68 00 	lds	r24, 0x0068
 110:	84 60       	ori	r24, 0x04	; 4
 112:	80 93 68 00 	sts	0x0068, r24
			PCMSK3 |= BV((inx & 7));// enable iterrupts for this pin
			PCICR  |= BV(PCIE3);	// enable iterrupts for PCINT24..31
#endif
		}
	}
	sei();						// make sure interrupts are enabled
 116:	78 94       	sei
}
 118:	df 91       	pop	r29
 11a:	cf 91       	pop	r28
 11c:	1f 91       	pop	r17
 11e:	0f 91       	pop	r16
 120:	ff 90       	pop	r15
 122:	ef 90       	pop	r14
 124:	df 90       	pop	r13
 126:	cf 90       	pop	r12
 128:	bf 90       	pop	r11
 12a:	af 90       	pop	r10
 12c:	08 95       	ret

0000012e <pin_change_dettach>:

void pin_change_dettach(const IOPin* io){
 12e:	cf 93       	push	r28
	CRITICAL_SECTION_START;
 130:	cf b7       	in	r28, 0x3f	; 63
 132:	f8 94       	cli
	int inx = __io_to_pc_index(io);
 134:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
	if(inx!=-1){
 138:	2f ef       	ldi	r18, 0xFF	; 255
 13a:	8f 3f       	cpi	r24, 0xFF	; 255
 13c:	92 07       	cpc	r25, r18
 13e:	01 f4       	brne	.+0      	; 0x140 <pin_change_dettach+0x12>
 140:	00 c0       	rjmp	.+0      	; 0x142 <pin_change_dettach+0x14>
		pcCallbacks[inx].callback = null;
 142:	fc 01       	movw	r30, r24
 144:	ee 0f       	add	r30, r30
 146:	ff 1f       	adc	r31, r31
 148:	ee 0f       	add	r30, r30
 14a:	ff 1f       	adc	r31, r31
 14c:	e8 0f       	add	r30, r24
 14e:	f9 1f       	adc	r31, r25
 150:	e0 50       	subi	r30, 0x00	; 0
 152:	f0 40       	sbci	r31, 0x00	; 0
 154:	11 82       	std	Z+1, r1	; 0x01
 156:	10 82       	st	Z, r1
		pcCallbacks[inx].data = null;
 158:	13 82       	std	Z+3, r1	; 0x03
 15a:	12 82       	std	Z+2, r1	; 0x02
		if(inx<=7){
 15c:	88 30       	cpi	r24, 0x08	; 8
 15e:	91 05       	cpc	r25, r1
 160:	04 f4       	brge	.+0      	; 0x162 <pin_change_dettach+0x34>
#ifdef PCMSK0
			PCMSK0 &= ~BV(inx);		// disable iterrupts for this pin
 162:	90 91 6b 00 	lds	r25, 0x006B
 166:	21 e0       	ldi	r18, 0x01	; 1
 168:	30 e0       	ldi	r19, 0x00	; 0
 16a:	00 c0       	rjmp	.+0      	; 0x16c <pin_change_dettach+0x3e>
 16c:	22 0f       	add	r18, r18
 16e:	33 1f       	adc	r19, r19
 170:	8a 95       	dec	r24
 172:	02 f4       	brpl	.+0      	; 0x174 <pin_change_dettach+0x46>
 174:	20 95       	com	r18
 176:	29 23       	and	r18, r25
 178:	20 93 6b 00 	sts	0x006B, r18
 17c:	00 c0       	rjmp	.+0      	; 0x17e <pin_change_dettach+0x50>
#endif
#ifdef PCMSK1
		}else if(inx<=15){
 17e:	80 31       	cpi	r24, 0x10	; 16
 180:	91 05       	cpc	r25, r1
 182:	04 f4       	brge	.+0      	; 0x184 <pin_change_dettach+0x56>
			PCMSK1 &= ~BV((inx & 7));// disable iterrupts for this pin
 184:	40 91 6c 00 	lds	r20, 0x006C
 188:	87 70       	andi	r24, 0x07	; 7
 18a:	90 70       	andi	r25, 0x00	; 0
 18c:	21 e0       	ldi	r18, 0x01	; 1
 18e:	30 e0       	ldi	r19, 0x00	; 0
 190:	00 c0       	rjmp	.+0      	; 0x192 <pin_change_dettach+0x64>
 192:	22 0f       	add	r18, r18
 194:	33 1f       	adc	r19, r19
 196:	8a 95       	dec	r24
 198:	02 f4       	brpl	.+0      	; 0x19a <pin_change_dettach+0x6c>
 19a:	20 95       	com	r18
 19c:	24 23       	and	r18, r20
 19e:	20 93 6c 00 	sts	0x006C, r18
 1a2:	00 c0       	rjmp	.+0      	; 0x1a4 <pin_change_dettach+0x76>
#endif
#ifdef PCMSK2
		}else if(inx<=23){
 1a4:	88 31       	cpi	r24, 0x18	; 24
 1a6:	91 05       	cpc	r25, r1
 1a8:	04 f4       	brge	.+0      	; 0x1aa <pin_change_dettach+0x7c>
			PCMSK2 &= ~BV((inx & 7));// disable iterrupts for this pin
 1aa:	40 91 6d 00 	lds	r20, 0x006D
 1ae:	87 70       	andi	r24, 0x07	; 7
 1b0:	90 70       	andi	r25, 0x00	; 0
 1b2:	21 e0       	ldi	r18, 0x01	; 1
 1b4:	30 e0       	ldi	r19, 0x00	; 0
 1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <pin_change_dettach+0x8a>
 1b8:	22 0f       	add	r18, r18
 1ba:	33 1f       	adc	r19, r19
 1bc:	8a 95       	dec	r24
 1be:	02 f4       	brpl	.+0      	; 0x1c0 <pin_change_dettach+0x92>
 1c0:	20 95       	com	r18
 1c2:	24 23       	and	r18, r20
 1c4:	20 93 6d 00 	sts	0x006D, r18
		}else if(inx<=31){
			PCMSK3 &= ~BV((inx & 7));// disable iterrupts for this pin
#endif
		}
	}
	CRITICAL_SECTION_END;
 1c8:	cf bf       	out	0x3f, r28	; 63
}
 1ca:	cf 91       	pop	r28
 1cc:	08 95       	ret

000001ce <pin_change_service>:

void pin_change_service(int inx, uint8_t mask){
 1ce:	af 92       	push	r10
 1d0:	bf 92       	push	r11
 1d2:	cf 92       	push	r12
 1d4:	df 92       	push	r13
 1d6:	ff 92       	push	r15
 1d8:	0f 93       	push	r16
 1da:	1f 93       	push	r17
 1dc:	cf 93       	push	r28
 1de:	df 93       	push	r29
 1e0:	5c 01       	movw	r10, r24
 1e2:	f6 2e       	mov	r15, r22

	for(int i=0; i<8; i++,inx++){
 1e4:	cc 24       	eor	r12, r12
 1e6:	dd 24       	eor	r13, r13
		if(mask & 1){
 1e8:	f0 fe       	sbrs	r15, 0
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <pin_change_service+0x1e>
		}
	}
	CRITICAL_SECTION_END;
}

void pin_change_service(int inx, uint8_t mask){
 1ec:	c6 01       	movw	r24, r12
 1ee:	8a 0d       	add	r24, r10
 1f0:	9b 1d       	adc	r25, r11

	for(int i=0; i<8; i++,inx++){
		if(mask & 1){
			PIN_CHANGE* pc = &pcCallbacks[inx];
			const IOPin* io = (const IOPin*)pgm_read_word(&PCINT_PINS[inx]);
 1f2:	fc 01       	movw	r30, r24
 1f4:	ee 0f       	add	r30, r30
 1f6:	ff 1f       	adc	r31, r31
 1f8:	e0 50       	subi	r30, 0x00	; 0
 1fa:	f0 40       	sbci	r31, 0x00	; 0
 1fc:	25 91       	lpm	r18, Z+
 1fe:	34 91       	lpm	r19, Z
 200:	89 01       	movw	r16, r18
			if(io!=null && pc->callback!=null){
 202:	21 15       	cp	r18, r1
 204:	31 05       	cpc	r19, r1
 206:	01 f0       	breq	.+0      	; 0x208 <pin_change_service+0x3a>

void pin_change_service(int inx, uint8_t mask){

	for(int i=0; i<8; i++,inx++){
		if(mask & 1){
			PIN_CHANGE* pc = &pcCallbacks[inx];
 208:	ec 01       	movw	r28, r24
 20a:	cc 0f       	add	r28, r28
 20c:	dd 1f       	adc	r29, r29
 20e:	cc 0f       	add	r28, r28
 210:	dd 1f       	adc	r29, r29
 212:	c8 0f       	add	r28, r24
 214:	d9 1f       	adc	r29, r25
 216:	c0 50       	subi	r28, 0x00	; 0
 218:	d0 40       	sbci	r29, 0x00	; 0
			const IOPin* io = (const IOPin*)pgm_read_word(&PCINT_PINS[inx]);
			if(io!=null && pc->callback!=null){
 21a:	88 81       	ld	r24, Y
 21c:	99 81       	ldd	r25, Y+1	; 0x01
 21e:	00 97       	sbiw	r24, 0x00	; 0
 220:	01 f0       	breq	.+0      	; 0x222 <pin_change_service+0x54>
				boolean newVal = pin_get(io);
 222:	c8 01       	movw	r24, r16
 224:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
 228:	68 2f       	mov	r22, r24
				if(newVal != pc->lastValue){
 22a:	8c 81       	ldd	r24, Y+4	; 0x04
 22c:	68 17       	cp	r22, r24
 22e:	01 f0       	breq	.+0      	; 0x230 <pin_change_service+0x62>
					// The value has changed
					pc->callback(io,newVal,pc->data); 		// call the callback routine
 230:	e8 81       	ld	r30, Y
 232:	f9 81       	ldd	r31, Y+1	; 0x01
 234:	4a 81       	ldd	r20, Y+2	; 0x02
 236:	5b 81       	ldd	r21, Y+3	; 0x03
 238:	c8 01       	movw	r24, r16
 23a:	09 95       	icall
					pc->lastValue = pin_get(io);	// set the last value
 23c:	c8 01       	movw	r24, r16
 23e:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
 242:	8c 83       	std	Y+4, r24	; 0x04
				}
			}
		}
		mask>>=1;
 244:	f6 94       	lsr	r15
	CRITICAL_SECTION_END;
}

void pin_change_service(int inx, uint8_t mask){

	for(int i=0; i<8; i++,inx++){
 246:	08 94       	sec
 248:	c1 1c       	adc	r12, r1
 24a:	d1 1c       	adc	r13, r1
 24c:	88 e0       	ldi	r24, 0x08	; 8
 24e:	c8 16       	cp	r12, r24
 250:	d1 04       	cpc	r13, r1
 252:	01 f4       	brne	.+0      	; 0x254 <pin_change_service+0x86>
				}
			}
		}
		mask>>=1;
	}
}
 254:	df 91       	pop	r29
 256:	cf 91       	pop	r28
 258:	1f 91       	pop	r17
 25a:	0f 91       	pop	r16
 25c:	ff 90       	pop	r15
 25e:	df 90       	pop	r13
 260:	cf 90       	pop	r12
 262:	bf 90       	pop	r11
 264:	af 90       	pop	r10
 266:	08 95       	ret

00000268 <__vector_9>:

#ifdef PCINT0_vect
ISR(PCINT0_vect){
 268:	1f 92       	push	r1
 26a:	0f 92       	push	r0
 26c:	0f b6       	in	r0, 0x3f	; 63
 26e:	0f 92       	push	r0
 270:	11 24       	eor	r1, r1
 272:	2f 93       	push	r18
 274:	3f 93       	push	r19
 276:	4f 93       	push	r20
 278:	5f 93       	push	r21
 27a:	6f 93       	push	r22
 27c:	7f 93       	push	r23
 27e:	8f 93       	push	r24
 280:	9f 93       	push	r25
 282:	af 93       	push	r26
 284:	bf 93       	push	r27
 286:	ef 93       	push	r30
 288:	ff 93       	push	r31
	// Handle it
	pin_change_service(0,PCMSK0);
 28a:	60 91 6b 00 	lds	r22, 0x006B
 28e:	80 e0       	ldi	r24, 0x00	; 0
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 296:	ff 91       	pop	r31
 298:	ef 91       	pop	r30
 29a:	bf 91       	pop	r27
 29c:	af 91       	pop	r26
 29e:	9f 91       	pop	r25
 2a0:	8f 91       	pop	r24
 2a2:	7f 91       	pop	r23
 2a4:	6f 91       	pop	r22
 2a6:	5f 91       	pop	r21
 2a8:	4f 91       	pop	r20
 2aa:	3f 91       	pop	r19
 2ac:	2f 91       	pop	r18
 2ae:	0f 90       	pop	r0
 2b0:	0f be       	out	0x3f, r0	; 63
 2b2:	0f 90       	pop	r0
 2b4:	1f 90       	pop	r1
 2b6:	18 95       	reti

000002b8 <__vector_10>:
#endif

#ifdef PCINT1_vect
ISR(PCINT1_vect){
 2b8:	1f 92       	push	r1
 2ba:	0f 92       	push	r0
 2bc:	0f b6       	in	r0, 0x3f	; 63
 2be:	0f 92       	push	r0
 2c0:	11 24       	eor	r1, r1
 2c2:	2f 93       	push	r18
 2c4:	3f 93       	push	r19
 2c6:	4f 93       	push	r20
 2c8:	5f 93       	push	r21
 2ca:	6f 93       	push	r22
 2cc:	7f 93       	push	r23
 2ce:	8f 93       	push	r24
 2d0:	9f 93       	push	r25
 2d2:	af 93       	push	r26
 2d4:	bf 93       	push	r27
 2d6:	ef 93       	push	r30
 2d8:	ff 93       	push	r31
	// Handle it
	pin_change_service(8,PCMSK1);
 2da:	60 91 6c 00 	lds	r22, 0x006C
 2de:	88 e0       	ldi	r24, 0x08	; 8
 2e0:	90 e0       	ldi	r25, 0x00	; 0
 2e2:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 2e6:	ff 91       	pop	r31
 2e8:	ef 91       	pop	r30
 2ea:	bf 91       	pop	r27
 2ec:	af 91       	pop	r26
 2ee:	9f 91       	pop	r25
 2f0:	8f 91       	pop	r24
 2f2:	7f 91       	pop	r23
 2f4:	6f 91       	pop	r22
 2f6:	5f 91       	pop	r21
 2f8:	4f 91       	pop	r20
 2fa:	3f 91       	pop	r19
 2fc:	2f 91       	pop	r18
 2fe:	0f 90       	pop	r0
 300:	0f be       	out	0x3f, r0	; 63
 302:	0f 90       	pop	r0
 304:	1f 90       	pop	r1
 306:	18 95       	reti

00000308 <__vector_11>:
#endif

#ifdef PCINT2_vect
ISR(PCINT2_vect){
 308:	1f 92       	push	r1
 30a:	0f 92       	push	r0
 30c:	0f b6       	in	r0, 0x3f	; 63
 30e:	0f 92       	push	r0
 310:	11 24       	eor	r1, r1
 312:	2f 93       	push	r18
 314:	3f 93       	push	r19
 316:	4f 93       	push	r20
 318:	5f 93       	push	r21
 31a:	6f 93       	push	r22
 31c:	7f 93       	push	r23
 31e:	8f 93       	push	r24
 320:	9f 93       	push	r25
 322:	af 93       	push	r26
 324:	bf 93       	push	r27
 326:	ef 93       	push	r30
 328:	ff 93       	push	r31
	// Handle it
	pin_change_service(16,PCMSK2);
 32a:	60 91 6d 00 	lds	r22, 0x006D
 32e:	80 e1       	ldi	r24, 0x10	; 16
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	0e 94 00 00 	call	0	; 0x0 <__io_to_pc_index>
}
 336:	ff 91       	pop	r31
 338:	ef 91       	pop	r30
 33a:	bf 91       	pop	r27
 33c:	af 91       	pop	r26
 33e:	9f 91       	pop	r25
 340:	8f 91       	pop	r24
 342:	7f 91       	pop	r23
 344:	6f 91       	pop	r22
 346:	5f 91       	pop	r21
 348:	4f 91       	pop	r20
 34a:	3f 91       	pop	r19
 34c:	2f 91       	pop	r18
 34e:	0f 90       	pop	r0
 350:	0f be       	out	0x3f, r0	; 63
 352:	0f 90       	pop	r0
 354:	1f 90       	pop	r1
 356:	18 95       	reti

pwm.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000322  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000356  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000356  2**0
                  ALLOC
  3 .debug_info   000009d9  00000000  00000000  00000356  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000240  00000000  00000000  00000d2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000008dd  00000000  00000000  00000f6f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000184c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  0000186c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000012d  00000000  00000000  0000189c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000602  00000000  00000000  000019c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000134  00000000  00000000  00001fcc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <pwmSetDutyCycle>:
#include "pwm.h"
#include "timer.h"
//#include "core.h"

// Set the duty cycle
void pwmSetDutyCycle(const IOPin* pin, DUTY_CYCLE duty){
   0:	ff 92       	push	r15
   2:	0f 93       	push	r16
   4:	1f 93       	push	r17
   6:	cf 93       	push	r28
   8:	df 93       	push	r29
   a:	f6 2e       	mov	r15, r22
	const TimerCompare* channel = compareFromIOPin(pin);
   c:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  10:	ec 01       	movw	r28, r24
	if(channel){
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <pwmSetDutyCycle+0x16>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  16:	fc 01       	movw	r30, r24
  18:	32 96       	adiw	r30, 0x02	; 2
  1a:	e4 91       	lpm	r30, Z
  1c:	f0 e0       	ldi	r31, 0x00	; 0
		const Timer* timer = compareGetTimer(channel);
  1e:	2c e2       	ldi	r18, 0x2C	; 44
  20:	30 e0       	ldi	r19, 0x00	; 0
  22:	e2 9f       	mul	r30, r18
  24:	c0 01       	movw	r24, r0
  26:	e3 9f       	mul	r30, r19
  28:	90 0d       	add	r25, r0
  2a:	f2 9f       	mul	r31, r18
  2c:	90 0d       	add	r25, r0
  2e:	11 24       	eor	r1, r1
		uint32_t top = timerGetTOP(timer);
  30:	80 50       	subi	r24, 0x00	; 0
  32:	90 40       	sbci	r25, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  38:	8c 01       	movw	r16, r24
		// duty => x
		// x = (top * duty) / 100
//		top *= duty;
//		top /= 100;
//		uint16_t delay =  top;
		uint16_t delay = interpolateU(duty, 0,100, 0,top);
  3a:	8f 2d       	mov	r24, r15
  3c:	85 36       	cpi	r24, 0x65	; 101
  3e:	00 f0       	brcs	.+0      	; 0x40 <pwmSetDutyCycle+0x40>
  40:	84 e6       	ldi	r24, 0x64	; 100
  42:	90 e0       	ldi	r25, 0x00	; 0
  44:	60 e0       	ldi	r22, 0x00	; 0
  46:	70 e0       	ldi	r23, 0x00	; 0
  48:	44 e6       	ldi	r20, 0x64	; 100
  4a:	50 e0       	ldi	r21, 0x00	; 0
  4c:	20 e0       	ldi	r18, 0x00	; 0
  4e:	30 e0       	ldi	r19, 0x00	; 0
  50:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  54:	bc 01       	movw	r22, r24

		// Change the duty cycle
		compareSetThreshold(channel,delay);
  56:	ce 01       	movw	r24, r28
  58:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	}
}
  5c:	df 91       	pop	r29
  5e:	cf 91       	pop	r28
  60:	1f 91       	pop	r17
  62:	0f 91       	pop	r16
  64:	ff 90       	pop	r15
  66:	08 95       	ret

00000068 <pwmGetDutyCycle>:

DUTY_CYCLE pwmGetDutyCycle(const IOPin* pin){
  68:	0f 93       	push	r16
  6a:	1f 93       	push	r17
  6c:	cf 93       	push	r28
  6e:	df 93       	push	r29
	DUTY_CYCLE rtn = 0;

	const TimerCompare* channel = compareFromIOPin(pin);
  70:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  74:	ec 01       	movw	r28, r24
	if(channel){
  76:	00 97       	sbiw	r24, 0x00	; 0
  78:	01 f0       	breq	.+0      	; 0x7a <pwmGetDutyCycle+0x12>
  7a:	fc 01       	movw	r30, r24
  7c:	32 96       	adiw	r30, 0x02	; 2
  7e:	e4 91       	lpm	r30, Z
  80:	f0 e0       	ldi	r31, 0x00	; 0
		const Timer* timer = compareGetTimer(channel);
  82:	2c e2       	ldi	r18, 0x2C	; 44
  84:	30 e0       	ldi	r19, 0x00	; 0
  86:	e2 9f       	mul	r30, r18
  88:	c0 01       	movw	r24, r0
  8a:	e3 9f       	mul	r30, r19
  8c:	90 0d       	add	r25, r0
  8e:	f2 9f       	mul	r31, r18
  90:	90 0d       	add	r25, r0
  92:	11 24       	eor	r1, r1
		uint32_t top = timerGetTOP(timer);
  94:	80 50       	subi	r24, 0x00	; 0
  96:	90 40       	sbci	r25, 0x00	; 0
  98:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  9c:	8c 01       	movw	r16, r24
		uint32_t duty = compareGetThreshold(channel);
  9e:	ce 01       	movw	r24, r28
  a0:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  a4:	bc 01       	movw	r22, r24
  a6:	80 e0       	ldi	r24, 0x00	; 0
  a8:	90 e0       	ldi	r25, 0x00	; 0
		// top => 100
		// duty => x
		// x = (100 * duty) / top
		duty *= 100;
  aa:	24 e6       	ldi	r18, 0x64	; 100
  ac:	30 e0       	ldi	r19, 0x00	; 0
  ae:	40 e0       	ldi	r20, 0x00	; 0
  b0:	50 e0       	ldi	r21, 0x00	; 0
  b2:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	DUTY_CYCLE rtn = 0;

	const TimerCompare* channel = compareFromIOPin(pin);
	if(channel){
		const Timer* timer = compareGetTimer(channel);
		uint32_t top = timerGetTOP(timer);
  b6:	98 01       	movw	r18, r16
  b8:	40 e0       	ldi	r20, 0x00	; 0
  ba:	50 e0       	ldi	r21, 0x00	; 0
		uint32_t duty = compareGetThreshold(channel);
		// top => 100
		// duty => x
		// x = (100 * duty) / top
		duty *= 100;
		duty /= top;
  bc:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
		rtn = duty;
  c0:	82 2f       	mov	r24, r18
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <pwmGetDutyCycle+0x5c>
		compareSetThreshold(channel,delay);
	}
}

DUTY_CYCLE pwmGetDutyCycle(const IOPin* pin){
	DUTY_CYCLE rtn = 0;
  c4:	80 e0       	ldi	r24, 0x00	; 0
		duty /= top;
		rtn = duty;
	}

	return rtn;
}
  c6:	df 91       	pop	r29
  c8:	cf 91       	pop	r28
  ca:	1f 91       	pop	r17
  cc:	0f 91       	pop	r16
  ce:	08 95       	ret

000000d0 <pwmOff>:

// Turn PWM off for the given pin
void pwmOff(const IOPin* pin){
  d0:	cf 93       	push	r28
  d2:	df 93       	push	r29
	const TimerCompare* channel = compareFromIOPin(pin);
  d4:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
  d8:	ec 01       	movw	r28, r24
	if(channel){
  da:	00 97       	sbiw	r24, 0x00	; 0
  dc:	01 f0       	breq	.+0      	; 0xde <pwmOff+0xe>
		compareDetach(channel);
  de:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
  e2:	ce 01       	movw	r24, r28
  e4:	60 e0       	ldi	r22, 0x00	; 0
  e6:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	}
}
  ea:	df 91       	pop	r29
  ec:	cf 91       	pop	r28
  ee:	08 95       	ret

000000f0 <pwmInitDeciHertz>:
	}
	return valid;
}

// Set up PWM on the given pin
boolean pwmInitDeciHertz(const IOPin* pin, uint32_t deciHertz, DUTY_CYCLE duty, uint32_t* actualDeciHertz){
  f0:	3f 92       	push	r3
  f2:	4f 92       	push	r4
  f4:	5f 92       	push	r5
  f6:	6f 92       	push	r6
  f8:	7f 92       	push	r7
  fa:	8f 92       	push	r8
  fc:	9f 92       	push	r9
  fe:	af 92       	push	r10
 100:	bf 92       	push	r11
 102:	cf 92       	push	r12
 104:	df 92       	push	r13
 106:	ef 92       	push	r14
 108:	ff 92       	push	r15
 10a:	0f 93       	push	r16
 10c:	1f 93       	push	r17
 10e:	cf 93       	push	r28
 110:	df 93       	push	r29
 112:	00 d0       	rcall	.+0      	; 0x114 <pwmInitDeciHertz+0x24>
 114:	00 d0       	rcall	.+0      	; 0x116 <pwmInitDeciHertz+0x26>
 116:	0f 92       	push	r0
 118:	cd b7       	in	r28, 0x3d	; 61
 11a:	de b7       	in	r29, 0x3e	; 62
 11c:	3c 01       	movw	r6, r24
 11e:	6a 01       	movw	r12, r20
 120:	7b 01       	movw	r14, r22
 122:	32 2e       	mov	r3, r18
 124:	28 01       	movw	r4, r16
	boolean rtn = FALSE;
	const TimerCompare* channel = compareFromIOPin(pin);
 126:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 12a:	4c 01       	movw	r8, r24

	if(channel==null){
 12c:	00 97       	sbiw	r24, 0x00	; 0
 12e:	01 f4       	brne	.+0      	; 0x130 <pwmInitDeciHertz+0x40>
		setError(PWM_PIN_NOT_AVAILABLE);
 130:	84 ef       	ldi	r24, 0xF4	; 244
 132:	00 c0       	rjmp	.+0      	; 0x134 <pwmInitDeciHertz+0x44>
	}else{
		// The pin is valid
		if(compareIsInUse(channel)){
 134:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 138:	88 23       	and	r24, r24
 13a:	01 f0       	breq	.+0      	; 0x13c <pwmInitDeciHertz+0x4c>
			setError(PWM_PIN_IN_USE);
 13c:	83 ef       	ldi	r24, 0xF3	; 243
 13e:	00 c0       	rjmp	.+0      	; 0x140 <pwmInitDeciHertz+0x50>
 140:	f4 01       	movw	r30, r8
 142:	32 96       	adiw	r30, 0x02	; 2
 144:	e4 91       	lpm	r30, Z
 146:	f0 e0       	ldi	r31, 0x00	; 0
			// The pin is valid and available
			TIMER_MODE mode;
			uint16_t icr;
			uint16_t prescaler;

			const Timer* timer = compareGetTimer(channel);
 148:	8c e2       	ldi	r24, 0x2C	; 44
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	e8 9f       	mul	r30, r24
 14e:	50 01       	movw	r10, r0
 150:	e9 9f       	mul	r30, r25
 152:	b0 0c       	add	r11, r0
 154:	f8 9f       	mul	r31, r24
 156:	b0 0c       	add	r11, r0
 158:	11 24       	eor	r1, r1
 15a:	80 e0       	ldi	r24, 0x00	; 0
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	a8 0e       	add	r10, r24
 160:	b9 1e       	adc	r11, r25

			// Find the best PWM setting
			boolean valid = timerCalcPwm(timer, deciHertz, 100, &mode, &icr, &prescaler);
 162:	c5 01       	movw	r24, r10
 164:	b7 01       	movw	r22, r14
 166:	a6 01       	movw	r20, r12
 168:	24 e6       	ldi	r18, 0x64	; 100
 16a:	30 e0       	ldi	r19, 0x00	; 0
 16c:	8e 01       	movw	r16, r28
 16e:	0f 5f       	subi	r16, 0xFF	; 255
 170:	1f 4f       	sbci	r17, 0xFF	; 255
 172:	a4 e0       	ldi	r26, 0x04	; 4
 174:	ea 2e       	mov	r14, r26
 176:	f1 2c       	mov	r15, r1
 178:	ec 0e       	add	r14, r28
 17a:	fd 1e       	adc	r15, r29
 17c:	b2 e0       	ldi	r27, 0x02	; 2
 17e:	cb 2e       	mov	r12, r27
 180:	d1 2c       	mov	r13, r1
 182:	cc 0e       	add	r12, r28
 184:	dd 1e       	adc	r13, r29
 186:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 18a:	f5 01       	movw	r30, r10
 18c:	34 96       	adiw	r30, 0x04	; 4

			if(!valid){
 18e:	88 23       	and	r24, r24
 190:	01 f4       	brne	.+0      	; 0x192 <pwmInitDeciHertz+0xa2>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 192:	85 91       	lpm	r24, Z+
 194:	94 91       	lpm	r25, Z
 196:	fc 01       	movw	r30, r24
 198:	80 81       	ld	r24, Z
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	87 70       	andi	r24, 0x07	; 7
 19e:	90 70       	andi	r25, 0x00	; 0
 1a0:	00 97       	sbiw	r24, 0x00	; 0
 1a2:	01 f0       	breq	.+0      	; 0x1a4 <pwmInitDeciHertz+0xb4>
				// There is no PWM setting that is valid
				setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
 1a4:	82 ef       	ldi	r24, 0xF2	; 242
 1a6:	00 c0       	rjmp	.+0      	; 0x1a8 <pwmInitDeciHertz+0xb8>
 1a8:	83 ee       	ldi	r24, 0xE3	; 227
 1aa:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
	return valid;
}

// Set up PWM on the given pin
boolean pwmInitDeciHertz(const IOPin* pin, uint32_t deciHertz, DUTY_CYCLE duty, uint32_t* actualDeciHertz){
	boolean rtn = FALSE;
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <pwmInitDeciHertz+0xc2>
 1b2:	85 91       	lpm	r24, Z+
 1b4:	94 91       	lpm	r25, Z
 1b6:	fc 01       	movw	r30, r24
 1b8:	80 81       	ld	r24, Z
 1ba:	90 e0       	ldi	r25, 0x00	; 0
 1bc:	87 70       	andi	r24, 0x07	; 7
 1be:	90 70       	andi	r25, 0x00	; 0
 1c0:	00 97       	sbiw	r24, 0x00	; 0
 1c2:	01 f4       	brne	.+0      	; 0x1c4 <pwmInitDeciHertz+0xd4>
 1c4:	00 c0       	rjmp	.+0      	; 0x1c6 <pwmInitDeciHertz+0xd6>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 1c6:	f5 01       	movw	r30, r10
 1c8:	a5 91       	lpm	r26, Z+
 1ca:	b4 91       	lpm	r27, Z
						PORT icrPort = pgm_read_word(&timer->pgm_icr);
						_SFR_MEM16(icrPort)=icr;
					}
				}else{
					// Can't change the prescaler so just use the existing
					prescaler = timerGetPrescaler(timer);
 1cc:	8d 91       	ld	r24, X+
 1ce:	9c 91       	ld	r25, X
 1d0:	11 97       	sbiw	r26, 0x01	; 1
 1d2:	9b 83       	std	Y+3, r25	; 0x03
 1d4:	8a 83       	std	Y+2, r24	; 0x02
 1d6:	00 c0       	rjmp	.+0      	; 0x1d8 <pwmInitDeciHertz+0xe8>
				// Lets set up the PWM
				if(!timerIsInUse(timer)){
					timerSetMode(timer,mode);
					if(modeIsICR(mode)){
						// Set the ICR
						PORT icrPort = pgm_read_word(&timer->pgm_icr);
 1d8:	f5 01       	movw	r30, r10
 1da:	7f 96       	adiw	r30, 0x1f	; 31
 1dc:	85 91       	lpm	r24, Z+
 1de:	94 91       	lpm	r25, Z
						_SFR_MEM16(icrPort)=icr;
 1e0:	fc 01       	movw	r30, r24
 1e2:	8c 81       	ldd	r24, Y+4	; 0x04
 1e4:	9d 81       	ldd	r25, Y+5	; 0x05
 1e6:	91 83       	std	Z+1, r25	; 0x01
 1e8:	80 83       	st	Z, r24
					// Can't change the prescaler so just use the existing
					prescaler = timerGetPrescaler(timer);
				}

				// Mark the channel as in use
				compareAttach(channel,&nullTimerCompareCallback,0,null);
 1ea:	c4 01       	movw	r24, r8
 1ec:	60 e0       	ldi	r22, 0x00	; 0
 1ee:	70 e0       	ldi	r23, 0x00	; 0
 1f0:	40 e0       	ldi	r20, 0x00	; 0
 1f2:	50 e0       	ldi	r21, 0x00	; 0
 1f4:	20 e0       	ldi	r18, 0x00	; 0
 1f6:	30 e0       	ldi	r19, 0x00	; 0
 1f8:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn the pin into an output, low
				pin_make_output(pin, FALSE);
 1fc:	c3 01       	movw	r24, r6
 1fe:	60 e0       	ldi	r22, 0x00	; 0
 200:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn on the PWM pin output
				compareSetOutputMode(channel, CHANNEL_MODE_NON_INVERTING);
 204:	c4 01       	movw	r24, r8
 206:	62 e0       	ldi	r22, 0x02	; 2
 208:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Turn on the timer
				timerSetPrescaler(timer,prescaler);
 20c:	6a 81       	ldd	r22, Y+2	; 0x02
 20e:	7b 81       	ldd	r23, Y+3	; 0x03
 210:	c5 01       	movw	r24, r10
 212:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Set the initial duty cycle
				pwmSetDutyCycle(pin,duty);
 216:	c3 01       	movw	r24, r6
 218:	63 2d       	mov	r22, r3
 21a:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>

				// Set the return value
				if(actualDeciHertz){
 21e:	41 14       	cp	r4, r1
 220:	51 04       	cpc	r5, r1
 222:	01 f0       	breq	.+0      	; 0x224 <pwmInitDeciHertz+0x134>
					*actualDeciHertz = TimerGetPwmDeciHertz(timer);
 224:	c5 01       	movw	r24, r10
 226:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 22a:	dc 01       	movw	r26, r24
 22c:	cb 01       	movw	r24, r22
 22e:	f2 01       	movw	r30, r4
 230:	80 83       	st	Z, r24
 232:	91 83       	std	Z+1, r25	; 0x01
 234:	a2 83       	std	Z+2, r26	; 0x02
 236:	b3 83       	std	Z+3, r27	; 0x03
				}

				rtn = TRUE;
 238:	8f ef       	ldi	r24, 0xFF	; 255
			}

		}
	}
	return rtn;
}
 23a:	0f 90       	pop	r0
 23c:	0f 90       	pop	r0
 23e:	0f 90       	pop	r0
 240:	0f 90       	pop	r0
 242:	0f 90       	pop	r0
 244:	df 91       	pop	r29
 246:	cf 91       	pop	r28
 248:	1f 91       	pop	r17
 24a:	0f 91       	pop	r16
 24c:	ff 90       	pop	r15
 24e:	ef 90       	pop	r14
 250:	df 90       	pop	r13
 252:	cf 90       	pop	r12
 254:	bf 90       	pop	r11
 256:	af 90       	pop	r10
 258:	9f 90       	pop	r9
 25a:	8f 90       	pop	r8
 25c:	7f 90       	pop	r7
 25e:	6f 90       	pop	r6
 260:	5f 90       	pop	r5
 262:	4f 90       	pop	r4
 264:	3f 90       	pop	r3
 266:	08 95       	ret
				// There is no PWM setting that is valid
				setError( (timerIsInUse(timer)) ? PWM_TIMER_IN_USE : TIMER_HAS_NO_PWM );
			}else{
				// Lets set up the PWM
				if(!timerIsInUse(timer)){
					timerSetMode(timer,mode);
 268:	c5 01       	movw	r24, r10
 26a:	69 81       	ldd	r22, Y+1	; 0x01
 26c:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
					if(modeIsICR(mode)){
 270:	81 e0       	ldi	r24, 0x01	; 1
 272:	90 e0       	ldi	r25, 0x00	; 0
 274:	09 80       	ldd	r0, Y+1	; 0x01
 276:	00 c0       	rjmp	.+0      	; 0x278 <pwmInitDeciHertz+0x188>
 278:	88 0f       	add	r24, r24
 27a:	99 1f       	adc	r25, r25
 27c:	0a 94       	dec	r0
 27e:	02 f4       	brpl	.+0      	; 0x280 <pwmInitDeciHertz+0x190>
 280:	80 70       	andi	r24, 0x00	; 0
 282:	95 75       	andi	r25, 0x55	; 85
 284:	00 97       	sbiw	r24, 0x00	; 0
 286:	01 f0       	breq	.+0      	; 0x288 <pwmInitDeciHertz+0x198>
 288:	00 c0       	rjmp	.+0      	; 0x28a <pwmInitDeciHertz+0x19a>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <pwmInitHertz>

0000028c <pwmInitHertz>:
		compareDetach(channel);
		compareSetOutputMode(channel, CHANNEL_MODE_DISCONNECT);
	}
}

boolean pwmInitHertz(const IOPin* pin, uint32_t hertz, DUTY_CYCLE duty, uint32_t* actualHertz){
 28c:	8f 92       	push	r8
 28e:	9f 92       	push	r9
 290:	af 92       	push	r10
 292:	bf 92       	push	r11
 294:	cf 92       	push	r12
 296:	df 92       	push	r13
 298:	ef 92       	push	r14
 29a:	ff 92       	push	r15
 29c:	0f 93       	push	r16
 29e:	1f 93       	push	r17
 2a0:	cf 93       	push	r28
 2a2:	5c 01       	movw	r10, r24
 2a4:	6a 01       	movw	r12, r20
 2a6:	7b 01       	movw	r14, r22
 2a8:	c2 2f       	mov	r28, r18
 2aa:	48 01       	movw	r8, r16
	uint32_t deciHertz;
	deciHertz = hertz * 10;
 2ac:	cb 01       	movw	r24, r22
 2ae:	ba 01       	movw	r22, r20
 2b0:	2a e0       	ldi	r18, 0x0A	; 10
 2b2:	30 e0       	ldi	r19, 0x00	; 0
 2b4:	40 e0       	ldi	r20, 0x00	; 0
 2b6:	50 e0       	ldi	r21, 0x00	; 0
 2b8:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2bc:	ab 01       	movw	r20, r22
 2be:	bc 01       	movw	r22, r24
	// Check for overflow
	if(deciHertz < hertz){
 2c0:	4c 15       	cp	r20, r12
 2c2:	5d 05       	cpc	r21, r13
 2c4:	6e 05       	cpc	r22, r14
 2c6:	7f 05       	cpc	r23, r15
 2c8:	00 f4       	brcc	.+0      	; 0x2ca <pwmInitHertz+0x3e>
		deciHertz = PWM_FASTEST;
 2ca:	4f ef       	ldi	r20, 0xFF	; 255
 2cc:	5f ef       	ldi	r21, 0xFF	; 255
 2ce:	6f ef       	ldi	r22, 0xFF	; 255
 2d0:	7f ef       	ldi	r23, 0xFF	; 255
	}

	// Now do it
	boolean valid = pwmInitDeciHertz(pin, deciHertz, duty, actualHertz);
 2d2:	c5 01       	movw	r24, r10
 2d4:	2c 2f       	mov	r18, r28
 2d6:	84 01       	movw	r16, r8
 2d8:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2dc:	c8 2f       	mov	r28, r24

	if(valid==TRUE && actualHertz!=null){
 2de:	8f 3f       	cpi	r24, 0xFF	; 255
 2e0:	01 f4       	brne	.+0      	; 0x2e2 <pwmInitHertz+0x56>
 2e2:	81 14       	cp	r8, r1
 2e4:	91 04       	cpc	r9, r1
 2e6:	01 f0       	breq	.+0      	; 0x2e8 <pwmInitHertz+0x5c>
		*actualHertz = *actualHertz /10;
 2e8:	f4 01       	movw	r30, r8
 2ea:	60 81       	ld	r22, Z
 2ec:	71 81       	ldd	r23, Z+1	; 0x01
 2ee:	82 81       	ldd	r24, Z+2	; 0x02
 2f0:	93 81       	ldd	r25, Z+3	; 0x03
 2f2:	2a e0       	ldi	r18, 0x0A	; 10
 2f4:	30 e0       	ldi	r19, 0x00	; 0
 2f6:	40 e0       	ldi	r20, 0x00	; 0
 2f8:	50 e0       	ldi	r21, 0x00	; 0
 2fa:	0e 94 00 00 	call	0	; 0x0 <pwmSetDutyCycle>
 2fe:	f4 01       	movw	r30, r8
 300:	20 83       	st	Z, r18
 302:	31 83       	std	Z+1, r19	; 0x01
 304:	42 83       	std	Z+2, r20	; 0x02
 306:	53 83       	std	Z+3, r21	; 0x03
	}
	return valid;
}
 308:	8c 2f       	mov	r24, r28
 30a:	cf 91       	pop	r28
 30c:	1f 91       	pop	r17
 30e:	0f 91       	pop	r16
 310:	ff 90       	pop	r15
 312:	ef 90       	pop	r14
 314:	df 90       	pop	r13
 316:	cf 90       	pop	r12
 318:	bf 90       	pop	r11
 31a:	af 90       	pop	r10
 31c:	9f 90       	pop	r9
 31e:	8f 90       	pop	r8
 320:	08 95       	ret

rprintf.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b8  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000002  00000000  00000000  000000ec  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  000000ee  2**0
                  ALLOC
  3 .progmem.data 00000011  00000000  00000000  000000ee  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000329  00000000  00000000  000000ff  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000019c  00000000  00000000  00000428  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000241  00000000  00000000  000005c4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000805  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   000000ec  00000000  00000000  00000825  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000019b  00000000  00000000  00000911  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000c4  00000000  00000000  00000aac  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfIgnore>:
const char PROGMEM HexChars[] = "0123456789ABCDEF";


MAKE_WRITER(rprintfIgnore){
	return byte;
}
   0:	08 95       	ret

00000002 <rprintfInit>:

// you must call this function once and supply the character output
// routine before using other functions in this library
Writer rprintfInit(Writer putchar_func){
	Writer rtn;
	CRITICAL_SECTION{
   2:	4f b7       	in	r20, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
   4:	f8 94       	cli
		rtn = rputchar;
   6:	20 91 00 00 	lds	r18, 0x0000
   a:	30 91 00 00 	lds	r19, 0x0000
		rputchar = putchar_func;
   e:	90 93 00 00 	sts	0x0000, r25
  12:	80 93 00 00 	sts	0x0000, r24
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  16:	4f bf       	out	0x3f, r20	; 63
	}
	return rtn;
}
  18:	c9 01       	movw	r24, r18
  1a:	08 95       	ret

0000001c <rprintfChar>:


// send a character/byte to the current output device
void rprintfChar(uint8_t c)
{
  1c:	cf 93       	push	r28
  1e:	c8 2f       	mov	r28, r24
	// do LF -> CR/LF translation
	if(c == '\n')
  20:	8a 30       	cpi	r24, 0x0A	; 10
  22:	01 f4       	brne	.+0      	; 0x24 <rprintfChar+0x8>
		rputchar('\r');
  24:	e0 91 00 00 	lds	r30, 0x0000
  28:	f0 91 00 00 	lds	r31, 0x0000
  2c:	8d e0       	ldi	r24, 0x0D	; 13
  2e:	09 95       	icall
	// send character
	rputchar(c);
  30:	e0 91 00 00 	lds	r30, 0x0000
  34:	f0 91 00 00 	lds	r31, 0x0000
  38:	8c 2f       	mov	r24, r28
  3a:	09 95       	icall
}
  3c:	cf 91       	pop	r28
  3e:	08 95       	ret

00000040 <rprintfCharN>:

void rprintfCharN(uint8_t c, size_t repeat){
  40:	1f 93       	push	r17
  42:	cf 93       	push	r28
  44:	df 93       	push	r29
  46:	18 2f       	mov	r17, r24
  48:	eb 01       	movw	r28, r22
	while(repeat-- > 0){
  4a:	00 c0       	rjmp	.+0      	; 0x4c <rprintfCharN+0xc>
		rprintfChar(c);
  4c:	81 2f       	mov	r24, r17
  4e:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
  52:	21 97       	sbiw	r28, 0x01	; 1
	// send character
	rputchar(c);
}

void rprintfCharN(uint8_t c, size_t repeat){
	while(repeat-- > 0){
  54:	20 97       	sbiw	r28, 0x00	; 0
  56:	01 f4       	brne	.+0      	; 0x58 <rprintfCharN+0x18>
		rprintfChar(c);
	}
}
  58:	df 91       	pop	r29
  5a:	cf 91       	pop	r28
  5c:	1f 91       	pop	r17
  5e:	08 95       	ret

00000060 <rprintfStr>:


// prints a null-terminated string stored in RAM
void rprintfStr(char str[])
{
  60:	cf 93       	push	r28
  62:	df 93       	push	r29
	// send a string stored in RAM
	if(str){
  64:	00 97       	sbiw	r24, 0x00	; 0
  66:	01 f0       	breq	.+0      	; 0x68 <rprintfStr+0x8>
  68:	ec 01       	movw	r28, r24
  6a:	00 c0       	rjmp	.+0      	; 0x6c <rprintfStr+0xc>
		// print the string until a null-terminator
		while (*str)
			rprintfChar(*str++);
  6c:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
void rprintfStr(char str[])
{
	// send a string stored in RAM
	if(str){
		// print the string until a null-terminator
		while (*str)
  70:	89 91       	ld	r24, Y+
  72:	88 23       	and	r24, r24
  74:	01 f4       	brne	.+0      	; 0x76 <rprintfStr+0x16>
			rprintfChar(*str++);
	}
}
  76:	df 91       	pop	r29
  78:	cf 91       	pop	r28
  7a:	08 95       	ret

0000007c <rprintfProgStr>:


// prints a null-terminated string stored in program ROM
void rprintfProgStr(const prog_char str[])
{
  7c:	cf 93       	push	r28
  7e:	df 93       	push	r29
  80:	ec 01       	movw	r28, r24
	if(str){
  82:	00 97       	sbiw	r24, 0x00	; 0
  84:	01 f4       	brne	.+0      	; 0x86 <rprintfProgStr+0xa>
  86:	00 c0       	rjmp	.+0      	; 0x88 <rprintfProgStr+0xc>
		// print a string stored in program memory
		register char c;

		// print the string until the null-terminator
		while((c = pgm_read_byte(str++)))
			rprintfChar(c);
  88:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
	if(str){
		// print a string stored in program memory
		register char c;

		// print the string until the null-terminator
		while((c = pgm_read_byte(str++)))
  8c:	fe 01       	movw	r30, r28
  8e:	22 96       	adiw	r28, 0x02	; 2
  90:	84 91       	lpm	r24, Z
  92:	88 23       	and	r24, r24
  94:	01 f4       	brne	.+0      	; 0x96 <rprintfProgStr+0x1a>
			rprintfChar(c);
	}
}
  96:	df 91       	pop	r29
  98:	cf 91       	pop	r28
  9a:	08 95       	ret

0000009c <rprintfCRLF>:
void rprintfCRLF(void)
{
	// print CR/LF
	//rprintfChar('\r');
	// LF -> CR/LF translation built-in to rprintfChar()
	rprintfChar('\n');
  9c:	8a e0       	ldi	r24, 0x0A	; 10
  9e:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
}
  a2:	08 95       	ret

000000a4 <rprintfu04>:

// prints an unsigned 4-bit number in hex (1 digit)
void rprintfu04(uint8_t data)
{
	// print 4-bit hex value
	rprintfChar(hexchar(data));
  a4:	e8 2f       	mov	r30, r24
  a6:	f0 e0       	ldi	r31, 0x00	; 0
  a8:	ef 70       	andi	r30, 0x0F	; 15
  aa:	f0 70       	andi	r31, 0x00	; 0
  ac:	e0 50       	subi	r30, 0x00	; 0
  ae:	f0 40       	sbci	r31, 0x00	; 0
  b0:	84 91       	lpm	r24, Z
  b2:	0e 94 00 00 	call	0	; 0x0 <rprintfIgnore>
}
  b6:	08 95       	ret

rprintfHexDump.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000178  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001ac  2**0
                  ALLOC
  3 .progmem.data 00000042  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000118  00000000  00000000  000001ee  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000000a6  00000000  00000000  00000306  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000257  00000000  00000000  000003ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000603  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00000623  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000000e5  00000000  00000000  0000063b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000000e1  00000000  00000000  00000720  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000088  00000000  00000000  00000804  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfMemoryDump>:

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	9f 92       	push	r9
   a:	af 92       	push	r10
   c:	bf 92       	push	r11
   e:	cf 92       	push	r12
  10:	df 92       	push	r13
  12:	ef 92       	push	r14
  14:	ff 92       	push	r15
  16:	0f 93       	push	r16
  18:	1f 93       	push	r17
  1a:	cf 93       	push	r28
  1c:	df 93       	push	r29
  1e:	7c 01       	movw	r14, r24
  20:	eb 01       	movw	r28, r22
  22:	5a 01       	movw	r10, r20
    int x;
    int c;
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
  24:	00 d0       	rcall	.+0      	; 0x26 <rprintfMemoryDump+0x26>
  26:	0f 92       	push	r0
  28:	81 e0       	ldi	r24, 0x01	; 1
  2a:	ed b7       	in	r30, 0x3d	; 61
  2c:	fe b7       	in	r31, 0x3e	; 62
  2e:	81 83       	std	Z+1, r24	; 0x01
  30:	80 e0       	ldi	r24, 0x00	; 0
  32:	90 e0       	ldi	r25, 0x00	; 0
  34:	93 83       	std	Z+3, r25	; 0x03
  36:	82 83       	std	Z+2, r24	; 0x02
  38:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    rprintfCharN('-',72); rprintfCRLF();
  3c:	0f 90       	pop	r0
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	8d e2       	ldi	r24, 0x2D	; 45
  44:	68 e4       	ldi	r22, 0x48	; 72
  46:	70 e0       	ldi	r23, 0x00	; 0
  48:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  4c:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  50:	95 01       	movw	r18, r10
  52:	94 e0       	ldi	r25, 0x04	; 4
  54:	36 95       	lsr	r19
  56:	27 95       	ror	r18
  58:	9a 95       	dec	r25
  5a:	01 f4       	brne	.+0      	; 0x5c <rprintfMemoryDump+0x5c>
  5c:	a9 01       	movw	r20, r18
  5e:	4f 5f       	subi	r20, 0xFF	; 255
  60:	5f 4f       	sbci	r21, 0xFF	; 255

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  62:	ec 0e       	add	r14, r28
  64:	fd 1e       	adc	r15, r29
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  66:	c5 01       	movw	r24, r10
  68:	8f 70       	andi	r24, 0x0F	; 15
  6a:	90 70       	andi	r25, 0x00	; 0

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  6c:	00 97       	sbiw	r24, 0x00	; 0
  6e:	01 f0       	breq	.+0      	; 0x70 <rprintfMemoryDump+0x70>
  70:	94 2f       	mov	r25, r20
  72:	85 2f       	mov	r24, r21
  74:	00 c0       	rjmp	.+0      	; 0x76 <rprintfMemoryDump+0x76>
  76:	92 2f       	mov	r25, r18
  78:	83 2f       	mov	r24, r19
  7a:	69 2e       	mov	r6, r25
  7c:	78 2e       	mov	r7, r24
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  7e:	00 e0       	ldi	r16, 0x00	; 0
  80:	10 e0       	ldi	r17, 0x00	; 0
  82:	cc 24       	eor	r12, r12
  84:	dd 24       	eor	r13, r13
    	int line16 = line * 16;
    	rprintfu16(line16);
        rprintf("| ");
  86:	99 24       	eor	r9, r9
  88:	93 94       	inc	r9
  8a:	80 e0       	ldi	r24, 0x00	; 0
  8c:	48 2e       	mov	r4, r24
  8e:	80 e0       	ldi	r24, 0x00	; 0
  90:	58 2e       	mov	r5, r24
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
  92:	00 c0       	rjmp	.+0      	; 0x94 <rprintfMemoryDump+0x94>
    	int line16 = line * 16;
    	rprintfu16(line16);
  94:	c8 01       	movw	r24, r16
  96:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
        rprintf("| ");
  9a:	00 d0       	rcall	.+0      	; 0x9c <rprintfMemoryDump+0x9c>
  9c:	0f 92       	push	r0
  9e:	ed b7       	in	r30, 0x3d	; 61
  a0:	fe b7       	in	r31, 0x3e	; 62
  a2:	91 82       	std	Z+1, r9	; 0x01
  a4:	53 82       	std	Z+3, r5	; 0x03
  a6:	42 82       	std	Z+2, r4	; 0x02
  a8:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  ac:	0f 90       	pop	r0
  ae:	0f 90       	pop	r0
  b0:	0f 90       	pop	r0

        // put hex values
        for(x = 0; x < 16; x++){
  b2:	c0 e0       	ldi	r28, 0x00	; 0
  b4:	d0 e0       	ldi	r29, 0x00	; 0
            if(x + line16 < len){
  b6:	ce 01       	movw	r24, r28
  b8:	80 0f       	add	r24, r16
  ba:	91 1f       	adc	r25, r17
  bc:	8a 15       	cp	r24, r10
  be:	9b 05       	cpc	r25, r11
  c0:	00 f4       	brcc	.+0      	; 0xc2 <rprintfMemoryDump+0xc2>

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
  c2:	f7 01       	movw	r30, r14
  c4:	ec 0f       	add	r30, r28
  c6:	fd 1f       	adc	r31, r29

        // put hex values
        for(x = 0; x < 16; x++){
            if(x + line16 < len){
                c = b[off + x + line16];
                rprintfu08(c);
  c8:	80 81       	ld	r24, Z
  ca:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
                rprintfChar(' ');
  ce:	80 e2       	ldi	r24, 0x20	; 32
  d0:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <rprintfMemoryDump+0xd6>
            }else{
                rprintfCharN(' ',3);
  d6:	80 e2       	ldi	r24, 0x20	; 32
  d8:	63 e0       	ldi	r22, 0x03	; 3
  da:	70 e0       	ldi	r23, 0x00	; 0
  dc:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    	int line16 = line * 16;
    	rprintfu16(line16);
        rprintf("| ");

        // put hex values
        for(x = 0; x < 16; x++){
  e0:	21 96       	adiw	r28, 0x01	; 1
  e2:	c0 31       	cpi	r28, 0x10	; 16
  e4:	d1 05       	cpc	r29, r1
  e6:	01 f4       	brne	.+0      	; 0xe8 <rprintfMemoryDump+0xe8>
                rprintfChar(' ');
            }else{
                rprintfCharN(' ',3);
            }
        }
        rprintfChar('|');rprintfChar(' ');
  e8:	8c e7       	ldi	r24, 0x7C	; 124
  ea:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
  ee:	80 e2       	ldi	r24, 0x20	; 32
  f0:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>

        // put ascii values
        for(x = 0; x < 16; x++){
  f4:	c0 e0       	ldi	r28, 0x00	; 0
  f6:	d0 e0       	ldi	r29, 0x00	; 0
            if(x + line16 < len){
  f8:	ce 01       	movw	r24, r28
  fa:	80 0f       	add	r24, r16
  fc:	91 1f       	adc	r25, r17
  fe:	8a 15       	cp	r24, r10
 100:	9b 05       	cpc	r25, r11
 102:	00 f4       	brcc	.+0      	; 0x104 <rprintfMemoryDump+0x104>

#include "rprintf.h"
#include "libdefs.h"


void rprintfMemoryDump(const void* data, size_t off, size_t len){
 104:	f7 01       	movw	r30, r14
 106:	ec 0f       	add	r30, r28
 108:	fd 1f       	adc	r31, r29
        rprintfChar('|');rprintfChar(' ');

        // put ascii values
        for(x = 0; x < 16; x++){
            if(x + line16 < len){
                c = b[off + x + line16];
 10a:	80 81       	ld	r24, Z
 10c:	28 2f       	mov	r18, r24
 10e:	30 e0       	ldi	r19, 0x00	; 0
                if((c > 0x1f) && (c < 0x7f)){
 110:	20 52       	subi	r18, 0x20	; 32
 112:	30 40       	sbci	r19, 0x00	; 0
 114:	2f 35       	cpi	r18, 0x5F	; 95
 116:	31 05       	cpc	r19, r1
 118:	00 f0       	brcs	.+0      	; 0x11a <rprintfMemoryDump+0x11a>
                	// ascii
                    rprintfChar((unsigned char)c);
                }else{
                	// non ascii
                	rprintfChar('.');
 11a:	8e e2       	ldi	r24, 0x2E	; 46
 11c:	00 c0       	rjmp	.+0      	; 0x11e <rprintfMemoryDump+0x11e>
                }
             }else{
             	rprintfChar(' ');
 11e:	80 e2       	ldi	r24, 0x20	; 32
 120:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
            }
        }
        rprintfChar('|');rprintfChar(' ');

        // put ascii values
        for(x = 0; x < 16; x++){
 124:	21 96       	adiw	r28, 0x01	; 1
 126:	c0 31       	cpi	r28, 0x10	; 16
 128:	d1 05       	cpc	r29, r1
 12a:	01 f4       	brne	.+0      	; 0x12c <rprintfMemoryDump+0x12c>
                }
             }else{
             	rprintfChar(' ');
             }
        }
        rprintfCRLF();
 12c:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
    int line;
    const uint8_t * b= (const uint8_t *)data;

    rprintf("ADDR|  0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F | ASCII\n");
    rprintfCharN('-',72); rprintfCRLF();
    for(line = 0; line < ((len % 16 != 0) ? (len / 16) + 1 : (len / 16)); line++){
 130:	08 94       	sec
 132:	c1 1c       	adc	r12, r1
 134:	d1 1c       	adc	r13, r1
 136:	80 e1       	ldi	r24, 0x10	; 16
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	e8 0e       	add	r14, r24
 13c:	f9 1e       	adc	r15, r25
 13e:	00 5f       	subi	r16, 0xF0	; 240
 140:	1f 4f       	sbci	r17, 0xFF	; 255
 142:	c6 14       	cp	r12, r6
 144:	d7 04       	cpc	r13, r7
 146:	01 f0       	breq	.+0      	; 0x148 <rprintfMemoryDump+0x148>
 148:	00 c0       	rjmp	.+0      	; 0x14a <rprintfMemoryDump+0x14a>
             	rprintfChar(' ');
             }
        }
        rprintfCRLF();
    }
    rprintfCharN('-',72); rprintfCRLF();
 14a:	8d e2       	ldi	r24, 0x2D	; 45
 14c:	68 e4       	ldi	r22, 0x48	; 72
 14e:	70 e0       	ldi	r23, 0x00	; 0
 150:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
 154:	0e 94 00 00 	call	0	; 0x0 <rprintfMemoryDump>
}
 158:	df 91       	pop	r29
 15a:	cf 91       	pop	r28
 15c:	1f 91       	pop	r17
 15e:	0f 91       	pop	r16
 160:	ff 90       	pop	r15
 162:	ef 90       	pop	r14
 164:	df 90       	pop	r13
 166:	cf 90       	pop	r12
 168:	bf 90       	pop	r11
 16a:	af 90       	pop	r10
 16c:	9f 90       	pop	r9
 16e:	7f 90       	pop	r7
 170:	6f 90       	pop	r6
 172:	5f 90       	pop	r5
 174:	4f 90       	pop	r4
 176:	08 95       	ret

rprintfStrLen.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000004a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000007e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000007e  2**0
                  ALLOC
  3 .debug_info   000000d0  00000000  00000000  0000007e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000008b  00000000  00000000  0000014e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000e1  00000000  00000000  000001d9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000002ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000095  00000000  00000000  000002da  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000ce  00000000  00000000  0000036f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000038  00000000  00000000  00000440  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfStrLen>:

// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], size_t start, size_t len)
{
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	9b 01       	movw	r18, r22
   a:	8a 01       	movw	r16, r20
	if(str){
   c:	00 97       	sbiw	r24, 0x00	; 0
   e:	01 f0       	breq	.+0      	; 0x10 <rprintfStrLen+0x10>


// prints a section of a string stored in RAM
// begins printing at position indicated by <start>
// prints number of characters indicated by <len>
void rprintfStrLen(char str[], size_t start, size_t len)
  10:	28 0f       	add	r18, r24
  12:	39 1f       	adc	r19, r25
  14:	ec 01       	movw	r28, r24
	if(str){
		register size_t i=0;

		// spin through characters up to requested start
		// keep going as long as there's no null
		while( (i++<start) && (*str) ){
  16:	82 17       	cp	r24, r18
  18:	93 07       	cpc	r25, r19
  1a:	01 f0       	breq	.+0      	; 0x1c <rprintfStrLen+0x1c>
  1c:	01 96       	adiw	r24, 0x01	; 1
  1e:	48 81       	ld	r20, Y
  20:	44 23       	and	r20, r20
  22:	01 f4       	brne	.+0      	; 0x24 <rprintfStrLen+0x24>
  24:	00 c0       	rjmp	.+0      	; 0x26 <rprintfStrLen+0x26>
		// then print exactly len characters
		while(len--)
		{
			// print data out of the string as long as we haven't reached a null yet
			// at the null, start printing spaces
			rprintfChar( (*str) ? *str++ : ' ');
  26:	88 81       	ld	r24, Y
  28:	88 23       	and	r24, r24
  2a:	01 f0       	breq	.+0      	; 0x2c <rprintfStrLen+0x2c>
  2c:	21 96       	adiw	r28, 0x01	; 1
  2e:	00 c0       	rjmp	.+0      	; 0x30 <rprintfStrLen+0x30>
  30:	80 e2       	ldi	r24, 0x20	; 32
  32:	0e 94 00 00 	call	0	; 0x0 <rprintfStrLen>
  36:	01 50       	subi	r16, 0x01	; 1
  38:	10 40       	sbci	r17, 0x00	; 0
		while( (i++<start) && (*str) ){
			str++;
		}

		// then print exactly len characters
		while(len--)
  3a:	01 15       	cp	r16, r1
  3c:	11 05       	cpc	r17, r1
  3e:	01 f4       	brne	.+0      	; 0x40 <rprintfStrLen+0x40>
			// print data out of the string as long as we haven't reached a null yet
			// at the null, start printing spaces
			rprintfChar( (*str) ? *str++ : ' ');
		}
	}
}
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	08 95       	ret

rprintfc.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005fa  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000006  00000000  00000000  0000062e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000029  00000000  00000000  00000634  2**0
                  ALLOC
  3 .debug_info   00000557  00000000  00000000  00000634  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000017b  00000000  00000000  00000b8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000d79  00000000  00000000  00000d06  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001a7f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000060  00000000  00000000  00001a9f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000002b8  00000000  00000000  00001aff  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000166  00000000  00000000  00001db7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000a4  00000000  00000000  00001f20  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <Isdigit>:
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
   0:	80 53       	subi	r24, 0x30	; 48
   2:	8a 30       	cpi	r24, 0x0A	; 10
   4:	00 f4       	brcc	.+0      	; 0x6 <Isdigit+0x6>
   6:	8f ef       	ldi	r24, 0xFF	; 255
   8:	08 95       	ret
   a:	80 e0       	ldi	r24, 0x00	; 0
}
   c:	08 95       	ret

0000000e <atoiRamRom>:

int atoiRamRom(boolean stringInRom, char *str)
{
	int num = 0;
   e:	fb 01       	movw	r30, r22
  10:	20 e0       	ldi	r18, 0x00	; 0
  12:	30 e0       	ldi	r19, 0x00	; 0

	while(Isdigit(READMEMBYTE(stringInRom,str)))
  14:	00 c0       	rjmp	.+0      	; 0x16 <atoiRamRom+0x8>
	{
		num *= 10;
		num += ((READMEMBYTE(stringInRom,str++)) - '0');
  16:	44 91       	lpm	r20, Z
  18:	00 c0       	rjmp	.+0      	; 0x1a <atoiRamRom+0xc>
  1a:	40 81       	ld	r20, Z
  1c:	50 e0       	ldi	r21, 0x00	; 0
  1e:	40 53       	subi	r20, 0x30	; 48
  20:	50 40       	sbci	r21, 0x00	; 0
  22:	9b 01       	movw	r18, r22
  24:	24 0f       	add	r18, r20
  26:	35 1f       	adc	r19, r21
  28:	31 96       	adiw	r30, 0x01	; 1

int atoiRamRom(boolean stringInRom, char *str)
{
	int num = 0;

	while(Isdigit(READMEMBYTE(stringInRom,str)))
  2a:	88 23       	and	r24, r24
  2c:	01 f0       	breq	.+0      	; 0x2e <atoiRamRom+0x20>
  2e:	94 91       	lpm	r25, Z
  30:	00 c0       	rjmp	.+0      	; 0x32 <atoiRamRom+0x24>
  32:	90 81       	ld	r25, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
  34:	90 53       	subi	r25, 0x30	; 48
  36:	9a 30       	cpi	r25, 0x0A	; 10
  38:	00 f4       	brcc	.+0      	; 0x3a <atoiRamRom+0x2c>
{
	int num = 0;

	while(Isdigit(READMEMBYTE(stringInRom,str)))
	{
		num *= 10;
  3a:	b9 01       	movw	r22, r18
  3c:	66 0f       	add	r22, r22
  3e:	77 1f       	adc	r23, r23
  40:	43 e0       	ldi	r20, 0x03	; 3
  42:	22 0f       	add	r18, r18
  44:	33 1f       	adc	r19, r19
  46:	4a 95       	dec	r20
  48:	01 f4       	brne	.+0      	; 0x4a <atoiRamRom+0x3c>
  4a:	62 0f       	add	r22, r18
  4c:	73 1f       	adc	r23, r19
		num += ((READMEMBYTE(stringInRom,str++)) - '0');
  4e:	88 23       	and	r24, r24
  50:	01 f4       	brne	.+0      	; 0x52 <atoiRamRom+0x44>
  52:	00 c0       	rjmp	.+0      	; 0x54 <atoiRamRom+0x46>
	}
	return num;
}
  54:	c9 01       	movw	r24, r18
  56:	08 95       	ret

00000058 <rprintf2RamRom>:
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
{
  58:	2f 92       	push	r2
  5a:	3f 92       	push	r3
  5c:	4f 92       	push	r4
  5e:	5f 92       	push	r5
  60:	6f 92       	push	r6
  62:	7f 92       	push	r7
  64:	8f 92       	push	r8
  66:	9f 92       	push	r9
  68:	af 92       	push	r10
  6a:	bf 92       	push	r11
  6c:	cf 92       	push	r12
  6e:	df 92       	push	r13
  70:	ef 92       	push	r14
  72:	ff 92       	push	r15
  74:	0f 93       	push	r16
  76:	1f 93       	push	r17
  78:	cf 93       	push	r28
  7a:	df 93       	push	r29
  7c:	00 d0       	rcall	.+0      	; 0x7e <rprintf2RamRom+0x26>
  7e:	cd b7       	in	r28, 0x3d	; 61
  80:	de b7       	in	r29, 0x3e	; 62
  82:	7f 88       	ldd	r7, Y+23	; 0x17
	register unsigned char pad = ' ';
	int flush_left = 0, f_width = 0, prec = INF, hash = 0, do_long = 0;
	int sign = 0;

	va_list ap;
	va_start(ap, sfmt);
  84:	7a e1       	ldi	r23, 0x1A	; 26
  86:	87 2e       	mov	r8, r23
  88:	91 2c       	mov	r9, r1
  8a:	8c 0e       	add	r8, r28
  8c:	9d 1e       	adc	r9, r29

	f = (unsigned char *) sfmt;
  8e:	c8 8c       	ldd	r12, Y+24	; 0x18
  90:	d9 8c       	ldd	r13, Y+25	; 0x19

	for (; READMEMBYTE(stringInRom,f); f++)
  92:	00 c0       	rjmp	.+0      	; 0x94 <rprintf2RamRom+0x3c>
	{
		if (READMEMBYTE(stringInRom,f) != '%')
  94:	d6 01       	movw	r26, r12
  96:	8c 91       	ld	r24, X
  98:	85 32       	cpi	r24, 0x25	; 37
  9a:	01 f0       	breq	.+0      	; 0x9c <rprintf2RamRom+0x44>
  9c:	00 c0       	rjmp	.+0      	; 0x9e <rprintf2RamRom+0x46>
			// then just output the char
			rprintfChar(READMEMBYTE(stringInRom,f));
		}
		else
		{
			f++;						// if we have a "%" then skip it
  9e:	f6 01       	movw	r30, r12
  a0:	31 96       	adiw	r30, 0x01	; 1
			if (READMEMBYTE(stringInRom,f) == '-')
  a2:	77 20       	and	r7, r7
  a4:	01 f0       	breq	.+0      	; 0xa6 <rprintf2RamRom+0x4e>
  a6:	84 91       	lpm	r24, Z
  a8:	00 c0       	rjmp	.+0      	; 0xaa <rprintf2RamRom+0x52>
  aa:	d6 01       	movw	r26, r12
  ac:	11 96       	adiw	r26, 0x01	; 1
  ae:	8c 91       	ld	r24, X
  b0:	11 97       	sbiw	r26, 0x01	; 1
  b2:	8d 32       	cpi	r24, 0x2D	; 45
  b4:	01 f4       	brne	.+0      	; 0xb6 <rprintf2RamRom+0x5e>
			{
				flush_left = 1;	// minus: flush left
				f++;
  b6:	f6 01       	movw	r30, r12
  b8:	32 96       	adiw	r30, 0x02	; 2
		else
		{
			f++;						// if we have a "%" then skip it
			if (READMEMBYTE(stringInRom,f) == '-')
			{
				flush_left = 1;	// minus: flush left
  ba:	21 e0       	ldi	r18, 0x01	; 1
  bc:	30 e0       	ldi	r19, 0x00	; 0
  be:	3a 83       	std	Y+2, r19	; 0x02
  c0:	29 83       	std	Y+1, r18	; 0x01
  c2:	00 c0       	rjmp	.+0      	; 0xc4 <rprintf2RamRom+0x6c>
			rprintfChar(READMEMBYTE(stringInRom,f));
		}
		else
		{
			f++;						// if we have a "%" then skip it
			if (READMEMBYTE(stringInRom,f) == '-')
  c4:	1a 82       	std	Y+2, r1	; 0x02
  c6:	19 82       	std	Y+1, r1	; 0x01
			{
				flush_left = 1;	// minus: flush left
				f++;
			}
            if (READMEMBYTE(stringInRom,f) == '0'
  c8:	77 20       	and	r7, r7
  ca:	01 f0       	breq	.+0      	; 0xcc <rprintf2RamRom+0x74>
  cc:	84 91       	lpm	r24, Z
  ce:	80 33       	cpi	r24, 0x30	; 48
  d0:	01 f4       	brne	.+0      	; 0xd2 <rprintf2RamRom+0x7a>
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <rprintf2RamRom+0x7c>
  d4:	80 81       	ld	r24, Z
  d6:	80 33       	cpi	r24, 0x30	; 48
  d8:	01 f4       	brne	.+0      	; 0xda <rprintf2RamRom+0x82>
  da:	00 c0       	rjmp	.+0      	; 0xdc <rprintf2RamRom+0x84>
				 || READMEMBYTE(stringInRom,f) == '.')
  dc:	8e 32       	cpi	r24, 0x2E	; 46
  de:	01 f0       	breq	.+0      	; 0xe0 <rprintf2RamRom+0x88>
  e0:	60 e2       	ldi	r22, 0x20	; 32
  e2:	66 2e       	mov	r6, r22
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <rprintf2RamRom+0x8e>
  e6:	8e 32       	cpi	r24, 0x2E	; 46
  e8:	01 f4       	brne	.+0      	; 0xea <rprintf2RamRom+0x92>
				{
					// padding with 0 rather than blank
					pad = '0';
					f++;
  ea:	31 96       	adiw	r30, 0x01	; 1
			}
            if (READMEMBYTE(stringInRom,f) == '0'
				 || READMEMBYTE(stringInRom,f) == '.')
				{
					// padding with 0 rather than blank
					pad = '0';
  ec:	50 e3       	ldi	r21, 0x30	; 48
  ee:	65 2e       	mov	r6, r21
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == '*')
  f0:	77 20       	and	r7, r7
  f2:	01 f0       	breq	.+0      	; 0xf4 <rprintf2RamRom+0x9c>
  f4:	94 91       	lpm	r25, Z
  f6:	81 e0       	ldi	r24, 0x01	; 1
  f8:	00 c0       	rjmp	.+0      	; 0xfa <rprintf2RamRom+0xa2>
			{
				flush_left = 1;	// minus: flush left
				f++;
			}
            if (READMEMBYTE(stringInRom,f) == '0'
				 || READMEMBYTE(stringInRom,f) == '.')
  fa:	40 e2       	ldi	r20, 0x20	; 32
  fc:	64 2e       	mov	r6, r20
				{
					// padding with 0 rather than blank
					pad = '0';
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == '*')
  fe:	81 e0       	ldi	r24, 0x01	; 1
 100:	90 81       	ld	r25, Z
 102:	9a 32       	cpi	r25, 0x2A	; 42
 104:	01 f0       	breq	.+0      	; 0x106 <rprintf2RamRom+0xae>
 106:	80 e0       	ldi	r24, 0x00	; 0
 108:	6f 01       	movw	r12, r30
 10a:	88 23       	and	r24, r24
 10c:	01 f0       	breq	.+0      	; 0x10e <rprintf2RamRom+0xb6>
				{	// field width
					f_width = va_arg(ap, int);
 10e:	d4 01       	movw	r26, r8
 110:	2d 90       	ld	r2, X+
 112:	3c 90       	ld	r3, X
 114:	11 97       	sbiw	r26, 0x01	; 1
					f++;
 116:	6f 01       	movw	r12, r30
 118:	08 94       	sec
 11a:	c1 1c       	adc	r12, r1
 11c:	d1 1c       	adc	r13, r1
					pad = '0';
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == '*')
				{	// field width
					f_width = va_arg(ap, int);
 11e:	e2 e0       	ldi	r30, 0x02	; 2
 120:	f0 e0       	ldi	r31, 0x00	; 0
 122:	8e 0e       	add	r8, r30
 124:	9f 1e       	adc	r9, r31
 126:	00 c0       	rjmp	.+0      	; 0x128 <rprintf2RamRom+0xd0>
					f++;
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
 128:	77 20       	and	r7, r7
 12a:	01 f0       	breq	.+0      	; 0x12c <rprintf2RamRom+0xd4>
 12c:	84 91       	lpm	r24, Z
 12e:	00 c0       	rjmp	.+0      	; 0x130 <rprintf2RamRom+0xd8>
 130:	80 81       	ld	r24, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 132:	80 53       	subi	r24, 0x30	; 48
 134:	8a 30       	cpi	r24, 0x0A	; 10
 136:	00 f4       	brcc	.+0      	; 0x138 <rprintf2RamRom+0xe0>
					f_width = va_arg(ap, int);
					f++;
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
 138:	87 2d       	mov	r24, r7
 13a:	bf 01       	movw	r22, r30
 13c:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 140:	1c 01       	movw	r2, r24
 142:	f6 01       	movw	r30, r12
					while (Isdigit(READMEMBYTE(stringInRom,f)))
 144:	77 20       	and	r7, r7
 146:	01 f0       	breq	.+0      	; 0x148 <rprintf2RamRom+0xf0>
 148:	84 91       	lpm	r24, Z
 14a:	00 c0       	rjmp	.+0      	; 0x14c <rprintf2RamRom+0xf4>
 14c:	80 81       	ld	r24, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 14e:	80 53       	subi	r24, 0x30	; 48
 150:	8a 30       	cpi	r24, 0x0A	; 10
 152:	00 f4       	brcc	.+0      	; 0x154 <rprintf2RamRom+0xfc>
            }
            else if (Isdigit(READMEMBYTE(stringInRom,f)))
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
 154:	31 96       	adiw	r30, 0x01	; 1
 156:	00 c0       	rjmp	.+0      	; 0x158 <rprintf2RamRom+0x100>
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 158:	22 24       	eor	r2, r2
 15a:	33 24       	eor	r3, r3
 15c:	00 c0       	rjmp	.+0      	; 0x15e <rprintf2RamRom+0x106>
 15e:	6f 01       	movw	r12, r30
				{
					f_width = atoiRamRom(stringInRom, (char *) f);
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
 160:	77 20       	and	r7, r7
 162:	01 f0       	breq	.+0      	; 0x164 <rprintf2RamRom+0x10c>
 164:	f6 01       	movw	r30, r12
 166:	84 91       	lpm	r24, Z
 168:	00 c0       	rjmp	.+0      	; 0x16a <rprintf2RamRom+0x112>
 16a:	d6 01       	movw	r26, r12
 16c:	8c 91       	ld	r24, X
 16e:	8e 32       	cpi	r24, 0x2E	; 46
 170:	01 f4       	brne	.+0      	; 0x172 <rprintf2RamRom+0x11a>
				{	// precision
					f++;
 172:	86 01       	movw	r16, r12
 174:	0f 5f       	subi	r16, 0xFF	; 255
 176:	1f 4f       	sbci	r17, 0xFF	; 255
					if (READMEMBYTE(stringInRom,f) == '*')
 178:	77 20       	and	r7, r7
 17a:	01 f0       	breq	.+0      	; 0x17c <rprintf2RamRom+0x124>
 17c:	f8 01       	movw	r30, r16
 17e:	84 91       	lpm	r24, Z
 180:	8a 32       	cpi	r24, 0x2A	; 42
 182:	01 f4       	brne	.+0      	; 0x184 <rprintf2RamRom+0x12c>
 184:	00 c0       	rjmp	.+0      	; 0x186 <rprintf2RamRom+0x12e>
 186:	d6 01       	movw	r26, r12
 188:	11 96       	adiw	r26, 0x01	; 1
 18a:	8c 91       	ld	r24, X
 18c:	11 97       	sbiw	r26, 0x01	; 1
 18e:	8a 32       	cpi	r24, 0x2A	; 42
 190:	01 f4       	brne	.+0      	; 0x192 <rprintf2RamRom+0x13a>
					{
						prec = va_arg(ap, int);
 192:	f4 01       	movw	r30, r8
 194:	40 80       	ld	r4, Z
 196:	51 80       	ldd	r5, Z+1	; 0x01
						f++;
 198:	22 e0       	ldi	r18, 0x02	; 2
 19a:	30 e0       	ldi	r19, 0x00	; 0
 19c:	c2 0e       	add	r12, r18
 19e:	d3 1e       	adc	r13, r19
            if (READMEMBYTE(stringInRom,f) == '.')
				{	// precision
					f++;
					if (READMEMBYTE(stringInRom,f) == '*')
					{
						prec = va_arg(ap, int);
 1a0:	82 0e       	add	r8, r18
 1a2:	93 1e       	adc	r9, r19
 1a4:	00 c0       	rjmp	.+0      	; 0x1a6 <rprintf2RamRom+0x14e>
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
 1a6:	d6 01       	movw	r26, r12
 1a8:	11 96       	adiw	r26, 0x01	; 1
 1aa:	8c 91       	ld	r24, X
 1ac:	11 97       	sbiw	r26, 0x01	; 1
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 1ae:	80 53       	subi	r24, 0x30	; 48
 1b0:	8a 30       	cpi	r24, 0x0A	; 10
 1b2:	00 f4       	brcc	.+0      	; 0x1b4 <rprintf2RamRom+0x15c>
						prec = va_arg(ap, int);
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
 1b4:	87 2d       	mov	r24, r7
 1b6:	b8 01       	movw	r22, r16
 1b8:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 1bc:	2c 01       	movw	r4, r24
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
				{	// precision
					f++;
 1be:	f8 01       	movw	r30, r16
						f++;
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
 1c0:	77 20       	and	r7, r7
 1c2:	01 f0       	breq	.+0      	; 0x1c4 <rprintf2RamRom+0x16c>
 1c4:	84 91       	lpm	r24, Z
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <rprintf2RamRom+0x170>
 1c8:	80 81       	ld	r24, Z
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 1ca:	80 53       	subi	r24, 0x30	; 48
 1cc:	8a 30       	cpi	r24, 0x0A	; 10
 1ce:	00 f4       	brcc	.+0      	; 0x1d0 <rprintf2RamRom+0x178>
					}
					else if (Isdigit(READMEMBYTE(stringInRom,f)))
					{
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
							f++;    // skip the digits
 1d0:	31 96       	adiw	r30, 0x01	; 1
 1d2:	00 c0       	rjmp	.+0      	; 0x1d4 <rprintf2RamRom+0x17c>
					while (Isdigit(READMEMBYTE(stringInRom,f)))
						f++;        // skip the digits
            }
            if (READMEMBYTE(stringInRom,f) == '.')
				{	// precision
					f++;
 1d4:	68 01       	movw	r12, r16
#define INF 40
static unsigned char buf[INF + 1];

boolean Isdigit(char c)
{
	return ((c >= '0') && (c <= '9')) ? TRUE : FALSE;
 1d6:	38 e2       	ldi	r19, 0x28	; 40
 1d8:	43 2e       	mov	r4, r19
 1da:	51 2c       	mov	r5, r1
 1dc:	00 c0       	rjmp	.+0      	; 0x1de <rprintf2RamRom+0x186>
 1de:	6f 01       	movw	r12, r30
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
 1e0:	77 20       	and	r7, r7
 1e2:	01 f0       	breq	.+0      	; 0x1e4 <rprintf2RamRom+0x18c>
 1e4:	f6 01       	movw	r30, r12
 1e6:	84 91       	lpm	r24, Z
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <rprintf2RamRom+0x192>
 1ea:	d6 01       	movw	r26, r12
 1ec:	8c 91       	ld	r24, X
 1ee:	83 32       	cpi	r24, 0x23	; 35
 1f0:	01 f4       	brne	.+0      	; 0x1f2 <rprintf2RamRom+0x19a>
				{	// alternate form
					hash = 1;
					f++;
 1f2:	08 94       	sec
 1f4:	c1 1c       	adc	r12, r1
 1f6:	d1 1c       	adc	r13, r1
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
				{	// alternate form
					hash = 1;
 1f8:	a1 e0       	ldi	r26, 0x01	; 1
 1fa:	b0 e0       	ldi	r27, 0x00	; 0
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <rprintf2RamRom+0x1a6>
						prec = atoiRamRom(stringInRom, (char *) f);
						while (Isdigit(READMEMBYTE(stringInRom,f)))
							f++;    // skip the digits
					}
				}
            if (READMEMBYTE(stringInRom,f) == '#')
 1fe:	a0 e0       	ldi	r26, 0x00	; 0
 200:	b0 e0       	ldi	r27, 0x00	; 0
				{	// alternate form
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
 202:	f6 01       	movw	r30, r12
 204:	77 20       	and	r7, r7
 206:	01 f0       	breq	.+0      	; 0x208 <rprintf2RamRom+0x1b0>
 208:	84 91       	lpm	r24, Z
 20a:	00 c0       	rjmp	.+0      	; 0x20c <rprintf2RamRom+0x1b4>
 20c:	80 81       	ld	r24, Z
 20e:	8c 36       	cpi	r24, 0x6C	; 108
 210:	01 f4       	brne	.+0      	; 0x212 <rprintf2RamRom+0x1ba>
				{	// long format
					do_long = 1;
					f++;
 212:	08 94       	sec
 214:	c1 1c       	adc	r12, r1
 216:	d1 1c       	adc	r13, r1
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
				{	// long format
					do_long = 1;
 218:	81 e0       	ldi	r24, 0x01	; 1
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	00 c0       	rjmp	.+0      	; 0x21e <rprintf2RamRom+0x1c6>
            if (READMEMBYTE(stringInRom,f) == '#')
				{	// alternate form
					hash = 1;
					f++;
            }
            if (READMEMBYTE(stringInRom,f) == 'l')
 21e:	80 e0       	ldi	r24, 0x00	; 0
 220:	90 e0       	ldi	r25, 0x00	; 0
				{	// long format
					do_long = 1;
					f++;
            }

				fmt = READMEMBYTE(stringInRom,f);
 222:	f6 01       	movw	r30, r12
 224:	77 20       	and	r7, r7
 226:	01 f0       	breq	.+0      	; 0x228 <rprintf2RamRom+0x1d0>
 228:	24 91       	lpm	r18, Z
 22a:	00 c0       	rjmp	.+0      	; 0x22c <rprintf2RamRom+0x1d4>
 22c:	20 81       	ld	r18, Z
 22e:	30 e0       	ldi	r19, 0x00	; 0
				bp = buf;
				switch (fmt) {		// do the formatting
 230:	2f 36       	cpi	r18, 0x6F	; 111
 232:	31 05       	cpc	r19, r1
 234:	01 f4       	brne	.+0      	; 0x236 <rprintf2RamRom+0x1de>
 236:	00 c0       	rjmp	.+0      	; 0x238 <rprintf2RamRom+0x1e0>
 238:	20 37       	cpi	r18, 0x70	; 112
 23a:	31 05       	cpc	r19, r1
 23c:	04 f4       	brge	.+0      	; 0x23e <rprintf2RamRom+0x1e6>
 23e:	23 36       	cpi	r18, 0x63	; 99
 240:	31 05       	cpc	r19, r1
 242:	01 f4       	brne	.+0      	; 0x244 <rprintf2RamRom+0x1ec>
 244:	00 c0       	rjmp	.+0      	; 0x246 <rprintf2RamRom+0x1ee>
 246:	24 36       	cpi	r18, 0x64	; 100
 248:	31 05       	cpc	r19, r1
 24a:	01 f0       	breq	.+0      	; 0x24c <rprintf2RamRom+0x1f4>
 24c:	25 32       	cpi	r18, 0x25	; 37
 24e:	31 05       	cpc	r19, r1
 250:	01 f0       	breq	.+0      	; 0x252 <rprintf2RamRom+0x1fa>
 252:	00 c0       	rjmp	.+0      	; 0x254 <rprintf2RamRom+0x1fc>
 254:	00 c0       	rjmp	.+0      	; 0x256 <rprintf2RamRom+0x1fe>
 256:	25 37       	cpi	r18, 0x75	; 117
 258:	31 05       	cpc	r19, r1
 25a:	01 f4       	brne	.+0      	; 0x25c <rprintf2RamRom+0x204>
 25c:	00 c0       	rjmp	.+0      	; 0x25e <rprintf2RamRom+0x206>
 25e:	28 37       	cpi	r18, 0x78	; 120
 260:	31 05       	cpc	r19, r1
 262:	01 f4       	brne	.+0      	; 0x264 <rprintf2RamRom+0x20c>
 264:	00 c0       	rjmp	.+0      	; 0x266 <rprintf2RamRom+0x20e>
 266:	23 37       	cpi	r18, 0x73	; 115
 268:	31 05       	cpc	r19, r1
 26a:	01 f0       	breq	.+0      	; 0x26c <rprintf2RamRom+0x214>
 26c:	00 c0       	rjmp	.+0      	; 0x26e <rprintf2RamRom+0x216>
 26e:	00 c0       	rjmp	.+0      	; 0x270 <rprintf2RamRom+0x218>
				case 'd':			// 'd' signed decimal
					if (do_long)
 270:	00 97       	sbiw	r24, 0x00	; 0
 272:	01 f0       	breq	.+0      	; 0x274 <rprintf2RamRom+0x21c>
						l = va_arg(ap, long);
 274:	f4 01       	movw	r30, r8
 276:	80 81       	ld	r24, Z
 278:	91 81       	ldd	r25, Z+1	; 0x01
 27a:	a2 81       	ldd	r26, Z+2	; 0x02
 27c:	b3 81       	ldd	r27, Z+3	; 0x03
 27e:	24 e0       	ldi	r18, 0x04	; 4
 280:	30 e0       	ldi	r19, 0x00	; 0
 282:	82 0e       	add	r8, r18
 284:	93 1e       	adc	r9, r19
 286:	00 c0       	rjmp	.+0      	; 0x288 <rprintf2RamRom+0x230>
					else
						l = (long) (va_arg(ap, int));
 288:	d4 01       	movw	r26, r8
 28a:	8d 91       	ld	r24, X+
 28c:	9c 91       	ld	r25, X
 28e:	aa 27       	eor	r26, r26
 290:	97 fd       	sbrc	r25, 7
 292:	a0 95       	com	r26
 294:	ba 2f       	mov	r27, r26
 296:	e2 e0       	ldi	r30, 0x02	; 2
 298:	f0 e0       	ldi	r31, 0x00	; 0
 29a:	8e 0e       	add	r8, r30
 29c:	9f 1e       	adc	r9, r31
					if (l < 0)
 29e:	b7 ff       	sbrs	r27, 7
 2a0:	00 c0       	rjmp	.+0      	; 0x2a2 <rprintf2RamRom+0x24a>
					{
						sign = 1;
						l = -l;
 2a2:	b0 95       	com	r27
 2a4:	a0 95       	com	r26
 2a6:	90 95       	com	r25
 2a8:	81 95       	neg	r24
 2aa:	9f 4f       	sbci	r25, 0xFF	; 255
 2ac:	af 4f       	sbci	r26, 0xFF	; 255
 2ae:	bf 4f       	sbci	r27, 0xFF	; 255
						l = va_arg(ap, long);
					else
						l = (long) (va_arg(ap, int));
					if (l < 0)
					{
						sign = 1;
 2b0:	21 e0       	ldi	r18, 0x01	; 1
 2b2:	e2 2e       	mov	r14, r18
 2b4:	f1 2c       	mov	r15, r1
 2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <rprintf2RamRom+0x260>
				case 'd':			// 'd' signed decimal
					if (do_long)
						l = va_arg(ap, long);
					else
						l = (long) (va_arg(ap, int));
					if (l < 0)
 2b8:	ee 24       	eor	r14, r14
 2ba:	ff 24       	eor	r15, r15
					{
						sign = 1;
						l = -l;
 2bc:	60 e0       	ldi	r22, 0x00	; 0
 2be:	70 e0       	ldi	r23, 0x00	; 0
 2c0:	8b 01       	movw	r16, r22
					}
					do	{
						*bp++ = l % 10 + '0';
 2c2:	bc 01       	movw	r22, r24
 2c4:	cd 01       	movw	r24, r26
 2c6:	2a e0       	ldi	r18, 0x0A	; 10
 2c8:	30 e0       	ldi	r19, 0x00	; 0
 2ca:	40 e0       	ldi	r20, 0x00	; 0
 2cc:	50 e0       	ldi	r21, 0x00	; 0
 2ce:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 2d2:	60 5d       	subi	r22, 0xD0	; 208
 2d4:	f8 01       	movw	r30, r16
 2d6:	61 93       	st	Z+, r22
 2d8:	bf 01       	movw	r22, r30
					} while ((l /= 10) > 0);
 2da:	c9 01       	movw	r24, r18
 2dc:	da 01       	movw	r26, r20
 2de:	18 16       	cp	r1, r24
 2e0:	19 06       	cpc	r1, r25
 2e2:	1a 06       	cpc	r1, r26
 2e4:	1b 06       	cpc	r1, r27
 2e6:	04 f0       	brlt	.+0      	; 0x2e8 <rprintf2RamRom+0x290>
 2e8:	5f 01       	movw	r10, r30
					if (sign)
 2ea:	e1 14       	cp	r14, r1
 2ec:	f1 04       	cpc	r15, r1
 2ee:	01 f0       	breq	.+0      	; 0x2f0 <rprintf2RamRom+0x298>
						*bp++ = '-';
 2f0:	ed e2       	ldi	r30, 0x2D	; 45
 2f2:	d8 01       	movw	r26, r16
 2f4:	11 96       	adiw	r26, 0x01	; 1
 2f6:	ec 93       	st	X, r30
 2f8:	11 97       	sbiw	r26, 0x01	; 1
 2fa:	92 e0       	ldi	r25, 0x02	; 2
 2fc:	a9 2e       	mov	r10, r25
 2fe:	b1 2c       	mov	r11, r1
 300:	a0 0e       	add	r10, r16
 302:	b1 1e       	adc	r11, r17
					f_width = f_width - (bp - buf);
 304:	00 e0       	ldi	r16, 0x00	; 0
 306:	10 e0       	ldi	r17, 0x00	; 0
 308:	0a 19       	sub	r16, r10
 30a:	1b 09       	sbc	r17, r11
 30c:	02 0d       	add	r16, r2
 30e:	13 1d       	adc	r17, r3
					if (!flush_left)
 310:	29 81       	ldd	r18, Y+1	; 0x01
 312:	3a 81       	ldd	r19, Y+2	; 0x02
 314:	21 15       	cp	r18, r1
 316:	31 05       	cpc	r19, r1
 318:	01 f4       	brne	.+0      	; 0x31a <rprintf2RamRom+0x2c2>
 31a:	78 01       	movw	r14, r16
 31c:	00 c0       	rjmp	.+0      	; 0x31e <rprintf2RamRom+0x2c6>
						while (f_width-- > 0)
							rprintfChar(pad);
 31e:	86 2d       	mov	r24, r6
 320:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 324:	08 94       	sec
 326:	e1 08       	sbc	r14, r1
 328:	f1 08       	sbc	r15, r1
					} while ((l /= 10) > 0);
					if (sign)
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
 32a:	1e 14       	cp	r1, r14
 32c:	1f 04       	cpc	r1, r15
 32e:	04 f0       	brlt	.+0      	; 0x330 <rprintf2RamRom+0x2d8>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 330:	98 01       	movw	r18, r16
 332:	21 50       	subi	r18, 0x01	; 1
 334:	30 40       	sbci	r19, 0x00	; 0
 336:	c8 01       	movw	r24, r16
 338:	17 ff       	sbrs	r17, 7
 33a:	00 c0       	rjmp	.+0      	; 0x33c <rprintf2RamRom+0x2e4>
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	89 01       	movw	r16, r18
 342:	08 1b       	sub	r16, r24
 344:	19 0b       	sbc	r17, r25
 346:	75 01       	movw	r14, r10
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 348:	00 c0       	rjmp	.+0      	; 0x34a <rprintf2RamRom+0x2f2>
						rprintfChar(*bp);
 34a:	d7 01       	movw	r26, r14
 34c:	8c 91       	ld	r24, X
 34e:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 352:	08 94       	sec
 354:	e1 08       	sbc	r14, r1
 356:	f1 08       	sbc	r15, r1
						*bp++ = '-';
					f_width = f_width - (bp - buf);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 358:	b0 e0       	ldi	r27, 0x00	; 0
 35a:	eb 16       	cp	r14, r27
 35c:	b0 e0       	ldi	r27, 0x00	; 0
 35e:	fb 06       	cpc	r15, r27
 360:	00 f4       	brcc	.+0      	; 0x362 <rprintf2RamRom+0x30a>
						rprintfChar(*bp);
					if (flush_left)
 362:	e9 81       	ldd	r30, Y+1	; 0x01
 364:	fa 81       	ldd	r31, Y+2	; 0x02
 366:	30 97       	sbiw	r30, 0x00	; 0
 368:	01 f4       	brne	.+0      	; 0x36a <rprintf2RamRom+0x312>
 36a:	00 c0       	rjmp	.+0      	; 0x36c <rprintf2RamRom+0x314>
 36c:	00 c0       	rjmp	.+0      	; 0x36e <rprintf2RamRom+0x316>
						while (f_width-- > 0)
							rprintfChar(' ');
 36e:	80 e2       	ldi	r24, 0x20	; 32
 370:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 374:	01 50       	subi	r16, 0x01	; 1
 376:	10 40       	sbci	r17, 0x00	; 0
						while (f_width-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
						rprintfChar(*bp);
					if (flush_left)
						while (f_width-- > 0)
 378:	10 16       	cp	r1, r16
 37a:	11 06       	cpc	r1, r17
 37c:	04 f0       	brlt	.+0      	; 0x37e <rprintf2RamRom+0x326>
 37e:	00 c0       	rjmp	.+0      	; 0x380 <rprintf2RamRom+0x328>
					break;
            case 'o':			// 'o' octal number
            case 'x':			// 'x' hex number
            case 'u':			// 'u' unsigned decimal
					if (do_long)
						u = va_arg(ap, unsigned long);
 380:	f4 01       	movw	r30, r8
							rprintfChar(' ');
					break;
            case 'o':			// 'o' octal number
            case 'x':			// 'x' hex number
            case 'u':			// 'u' unsigned decimal
					if (do_long)
 382:	00 97       	sbiw	r24, 0x00	; 0
 384:	01 f0       	breq	.+0      	; 0x386 <rprintf2RamRom+0x32e>
						u = va_arg(ap, unsigned long);
 386:	40 81       	ld	r20, Z
 388:	51 81       	ldd	r21, Z+1	; 0x01
 38a:	62 81       	ldd	r22, Z+2	; 0x02
 38c:	73 81       	ldd	r23, Z+3	; 0x03
 38e:	84 e0       	ldi	r24, 0x04	; 4
 390:	90 e0       	ldi	r25, 0x00	; 0
 392:	00 c0       	rjmp	.+0      	; 0x394 <rprintf2RamRom+0x33c>
					else
						u = (unsigned long) (va_arg(ap, unsigned));
 394:	80 81       	ld	r24, Z
 396:	91 81       	ldd	r25, Z+1	; 0x01
 398:	ac 01       	movw	r20, r24
 39a:	60 e0       	ldi	r22, 0x00	; 0
 39c:	70 e0       	ldi	r23, 0x00	; 0
 39e:	82 e0       	ldi	r24, 0x02	; 2
 3a0:	90 e0       	ldi	r25, 0x00	; 0
 3a2:	88 0e       	add	r8, r24
 3a4:	99 1e       	adc	r9, r25
					if (fmt == 'u')
 3a6:	25 37       	cpi	r18, 0x75	; 117
 3a8:	31 05       	cpc	r19, r1
 3aa:	01 f4       	brne	.+0      	; 0x3ac <rprintf2RamRom+0x354>
 3ac:	80 e0       	ldi	r24, 0x00	; 0
 3ae:	e8 2e       	mov	r14, r24
 3b0:	80 e0       	ldi	r24, 0x00	; 0
 3b2:	f8 2e       	mov	r15, r24
					{	// unsigned decimal
						do {
							*bp++ = u % 10 + '0';
 3b4:	cb 01       	movw	r24, r22
 3b6:	ba 01       	movw	r22, r20
 3b8:	2a e0       	ldi	r18, 0x0A	; 10
 3ba:	30 e0       	ldi	r19, 0x00	; 0
 3bc:	40 e0       	ldi	r20, 0x00	; 0
 3be:	50 e0       	ldi	r21, 0x00	; 0
 3c0:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 3c4:	f2 2f       	mov	r31, r18
 3c6:	e3 2f       	mov	r30, r19
 3c8:	9a 01       	movw	r18, r20
 3ca:	60 5d       	subi	r22, 0xD0	; 208
 3cc:	d7 01       	movw	r26, r14
 3ce:	6d 93       	st	X+, r22
 3d0:	7d 01       	movw	r14, r26
 3d2:	8d 01       	movw	r16, r26
						} while ((u /= 10) > 0);
 3d4:	4f 2f       	mov	r20, r31
 3d6:	5e 2f       	mov	r21, r30
 3d8:	b9 01       	movw	r22, r18
 3da:	41 15       	cp	r20, r1
 3dc:	51 05       	cpc	r21, r1
 3de:	61 05       	cpc	r22, r1
 3e0:	71 05       	cpc	r23, r1
 3e2:	01 f4       	brne	.+0      	; 0x3e4 <rprintf2RamRom+0x38c>
 3e4:	00 c0       	rjmp	.+0      	; 0x3e6 <rprintf2RamRom+0x38e>
					}
					else if (fmt == 'o')
 3e6:	2f 36       	cpi	r18, 0x6F	; 111
 3e8:	31 05       	cpc	r19, r1
 3ea:	01 f4       	brne	.+0      	; 0x3ec <rprintf2RamRom+0x394>
 3ec:	80 e0       	ldi	r24, 0x00	; 0
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	9c 01       	movw	r18, r24
 3f2:	c9 01       	movw	r24, r18
					{  // octal
						do {
							*bp++ = u % 8 + '0';
 3f4:	24 2f       	mov	r18, r20
 3f6:	27 70       	andi	r18, 0x07	; 7
 3f8:	20 5d       	subi	r18, 0xD0	; 208
 3fa:	fc 01       	movw	r30, r24
 3fc:	21 93       	st	Z+, r18
 3fe:	9f 01       	movw	r18, r30
						} while ((u /= 8) > 0);
 400:	03 e0       	ldi	r16, 0x03	; 3
 402:	76 95       	lsr	r23
 404:	67 95       	ror	r22
 406:	57 95       	ror	r21
 408:	47 95       	ror	r20
 40a:	0a 95       	dec	r16
 40c:	01 f4       	brne	.+0      	; 0x40e <rprintf2RamRom+0x3b6>
 40e:	41 15       	cp	r20, r1
 410:	51 05       	cpc	r21, r1
 412:	61 05       	cpc	r22, r1
 414:	71 05       	cpc	r23, r1
 416:	01 f4       	brne	.+0      	; 0x418 <rprintf2RamRom+0x3c0>
 418:	8f 01       	movw	r16, r30
 41a:	fc 01       	movw	r30, r24
						if (hash)
 41c:	10 97       	sbiw	r26, 0x00	; 0
 41e:	01 f0       	breq	.+0      	; 0x420 <rprintf2RamRom+0x3c8>
							*bp++ = '0';
 420:	b0 e3       	ldi	r27, 0x30	; 48
 422:	b1 83       	std	Z+1, r27	; 0x01
 424:	00 c0       	rjmp	.+0      	; 0x426 <rprintf2RamRom+0x3ce>
					}
					else if (fmt == 'x')
 426:	00 e0       	ldi	r16, 0x00	; 0
 428:	10 e0       	ldi	r17, 0x00	; 0
 42a:	28 37       	cpi	r18, 0x78	; 120
 42c:	31 05       	cpc	r19, r1
 42e:	01 f4       	brne	.+0      	; 0x430 <rprintf2RamRom+0x3d8>
 430:	f8 01       	movw	r30, r16
					{	// hex
						do {
							i = u % 16;
 432:	ca 01       	movw	r24, r20
 434:	8f 70       	andi	r24, 0x0F	; 15
 436:	90 70       	andi	r25, 0x00	; 0
 438:	9f 01       	movw	r18, r30
 43a:	2f 5f       	subi	r18, 0xFF	; 255
 43c:	3f 4f       	sbci	r19, 0xFF	; 255
							if (i < 10)
 43e:	8a 30       	cpi	r24, 0x0A	; 10
 440:	91 05       	cpc	r25, r1
 442:	04 f4       	brge	.+0      	; 0x444 <rprintf2RamRom+0x3ec>
								*bp++ = i + '0';
 444:	80 5d       	subi	r24, 0xD0	; 208
 446:	00 c0       	rjmp	.+0      	; 0x448 <rprintf2RamRom+0x3f0>
							else
								*bp++ = i - 10 + 'a';
 448:	89 5a       	subi	r24, 0xA9	; 169
 44a:	80 83       	st	Z, r24
 44c:	f9 01       	movw	r30, r18
						} while ((u /= 16) > 0);
 44e:	14 e0       	ldi	r17, 0x04	; 4
 450:	76 95       	lsr	r23
 452:	67 95       	ror	r22
 454:	57 95       	ror	r21
 456:	47 95       	ror	r20
 458:	1a 95       	dec	r17
 45a:	01 f4       	brne	.+0      	; 0x45c <rprintf2RamRom+0x404>
 45c:	41 15       	cp	r20, r1
 45e:	51 05       	cpc	r21, r1
 460:	61 05       	cpc	r22, r1
 462:	71 05       	cpc	r23, r1
 464:	01 f4       	brne	.+0      	; 0x466 <rprintf2RamRom+0x40e>
 466:	89 01       	movw	r16, r18
 468:	f9 01       	movw	r30, r18
						if (hash)
 46a:	10 97       	sbiw	r26, 0x00	; 0
 46c:	01 f0       	breq	.+0      	; 0x46e <rprintf2RamRom+0x416>
						{
							*bp++ = 'x';
 46e:	28 e7       	ldi	r18, 0x78	; 120
 470:	20 83       	st	Z, r18
							*bp++ = '0';
 472:	30 e3       	ldi	r19, 0x30	; 48
 474:	31 83       	std	Z+1, r19	; 0x01
 476:	8f 01       	movw	r16, r30
 478:	0e 5f       	subi	r16, 0xFE	; 254
 47a:	1f 4f       	sbci	r17, 0xFF	; 255
						}
					}
					i = f_width - (bp - buf);
 47c:	60 e0       	ldi	r22, 0x00	; 0
 47e:	e6 2e       	mov	r14, r22
 480:	60 e0       	ldi	r22, 0x00	; 0
 482:	f6 2e       	mov	r15, r22
 484:	e0 1a       	sub	r14, r16
 486:	f1 0a       	sbc	r15, r17
 488:	e2 0c       	add	r14, r2
 48a:	f3 1c       	adc	r15, r3
					if (!flush_left)
 48c:	89 81       	ldd	r24, Y+1	; 0x01
 48e:	9a 81       	ldd	r25, Y+2	; 0x02
 490:	00 97       	sbiw	r24, 0x00	; 0
 492:	01 f4       	brne	.+0      	; 0x494 <rprintf2RamRom+0x43c>
 494:	57 01       	movw	r10, r14
 496:	00 c0       	rjmp	.+0      	; 0x498 <rprintf2RamRom+0x440>
						while (i-- > 0)
							rprintfChar(pad);
 498:	86 2d       	mov	r24, r6
 49a:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 49e:	08 94       	sec
 4a0:	a1 08       	sbc	r10, r1
 4a2:	b1 08       	sbc	r11, r1
							*bp++ = '0';
						}
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
 4a4:	1a 14       	cp	r1, r10
 4a6:	1b 04       	cpc	r1, r11
 4a8:	04 f0       	brlt	.+0      	; 0x4aa <rprintf2RamRom+0x452>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 4aa:	97 01       	movw	r18, r14
 4ac:	21 50       	subi	r18, 0x01	; 1
 4ae:	30 40       	sbci	r19, 0x00	; 0
 4b0:	c7 01       	movw	r24, r14
 4b2:	f7 fe       	sbrs	r15, 7
 4b4:	00 c0       	rjmp	.+0      	; 0x4b6 <rprintf2RamRom+0x45e>
 4b6:	80 e0       	ldi	r24, 0x00	; 0
 4b8:	90 e0       	ldi	r25, 0x00	; 0
 4ba:	79 01       	movw	r14, r18
 4bc:	e8 1a       	sub	r14, r24
 4be:	f9 0a       	sbc	r15, r25
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 4c0:	00 c0       	rjmp	.+0      	; 0x4c2 <rprintf2RamRom+0x46a>
						rprintfChar((int) (*bp));
 4c2:	d8 01       	movw	r26, r16
 4c4:	8c 91       	ld	r24, X
 4c6:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 4ca:	01 50       	subi	r16, 0x01	; 1
 4cc:	10 40       	sbci	r17, 0x00	; 0
					}
					i = f_width - (bp - buf);
					if (!flush_left)
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
 4ce:	b0 e0       	ldi	r27, 0x00	; 0
 4d0:	00 30       	cpi	r16, 0x00	; 0
 4d2:	1b 07       	cpc	r17, r27
 4d4:	00 f4       	brcc	.+0      	; 0x4d6 <rprintf2RamRom+0x47e>
						rprintfChar((int) (*bp));
					if (flush_left)
 4d6:	e9 81       	ldd	r30, Y+1	; 0x01
 4d8:	fa 81       	ldd	r31, Y+2	; 0x02
 4da:	30 97       	sbiw	r30, 0x00	; 0
 4dc:	01 f4       	brne	.+0      	; 0x4de <rprintf2RamRom+0x486>
 4de:	00 c0       	rjmp	.+0      	; 0x4e0 <rprintf2RamRom+0x488>
 4e0:	87 01       	movw	r16, r14
 4e2:	00 c0       	rjmp	.+0      	; 0x4e4 <rprintf2RamRom+0x48c>
						while (i-- > 0)
							rprintfChar(' ');
 4e4:	80 e2       	ldi	r24, 0x20	; 32
 4e6:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 4ea:	01 50       	subi	r16, 0x01	; 1
 4ec:	10 40       	sbci	r17, 0x00	; 0
						while (i-- > 0)
							rprintfChar(pad);
					for (bp--; bp >= buf; bp--)
						rprintfChar((int) (*bp));
					if (flush_left)
						while (i-- > 0)
 4ee:	10 16       	cp	r1, r16
 4f0:	11 06       	cpc	r1, r17
 4f2:	04 f0       	brlt	.+0      	; 0x4f4 <rprintf2RamRom+0x49c>
 4f4:	00 c0       	rjmp	.+0      	; 0x4f6 <rprintf2RamRom+0x49e>
							rprintfChar(' ');
					break;
            case 'c':			// 'c' character
					i = va_arg(ap, int);
 4f6:	84 01       	movw	r16, r8
 4f8:	0e 5f       	subi	r16, 0xFE	; 254
 4fa:	1f 4f       	sbci	r17, 0xFF	; 255
					rprintfChar((int) (i));
 4fc:	d4 01       	movw	r26, r8
 4fe:	8c 91       	ld	r24, X
 500:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
					if (flush_left)
						while (i-- > 0)
							rprintfChar(' ');
					break;
            case 'c':			// 'c' character
					i = va_arg(ap, int);
 504:	48 01       	movw	r8, r16
					rprintfChar((int) (i));
					break;
 506:	00 c0       	rjmp	.+0      	; 0x508 <rprintf2RamRom+0x4b0>
            case 's':			// 's' string
					bp = va_arg(ap, unsigned char *);
 508:	f4 01       	movw	r30, r8
 50a:	22 e0       	ldi	r18, 0x02	; 2
 50c:	30 e0       	ldi	r19, 0x00	; 0
 50e:	82 0e       	add	r8, r18
 510:	93 1e       	adc	r9, r19
 512:	a0 80       	ld	r10, Z
 514:	b1 80       	ldd	r11, Z+1	; 0x01
					if (!bp)
 516:	a1 14       	cp	r10, r1
 518:	b1 04       	cpc	r11, r1
 51a:	01 f4       	brne	.+0      	; 0x51c <rprintf2RamRom+0x4c4>
						bp = (unsigned char *) "(nil)";
 51c:	50 e0       	ldi	r21, 0x00	; 0
 51e:	a5 2e       	mov	r10, r21
 520:	50 e0       	ldi	r21, 0x00	; 0
 522:	b5 2e       	mov	r11, r21
					f_width = f_width - strlen((char *) bp);
 524:	f5 01       	movw	r30, r10
 526:	01 90       	ld	r0, Z+
 528:	00 20       	and	r0, r0
 52a:	01 f4       	brne	.+0      	; 0x52c <rprintf2RamRom+0x4d4>
 52c:	31 97       	sbiw	r30, 0x01	; 1
 52e:	ea 19       	sub	r30, r10
 530:	fb 09       	sbc	r31, r11
 532:	81 01       	movw	r16, r2
 534:	0e 1b       	sub	r16, r30
 536:	1f 0b       	sbc	r17, r31
 538:	78 01       	movw	r14, r16
					if (!flush_left)
 53a:	89 81       	ldd	r24, Y+1	; 0x01
 53c:	9a 81       	ldd	r25, Y+2	; 0x02
 53e:	00 97       	sbiw	r24, 0x00	; 0
 540:	01 f0       	breq	.+0      	; 0x542 <rprintf2RamRom+0x4ea>
 542:	00 c0       	rjmp	.+0      	; 0x544 <rprintf2RamRom+0x4ec>
						while (f_width-- > 0)
							rprintfChar(pad);
 544:	86 2d       	mov	r24, r6
 546:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 54a:	01 50       	subi	r16, 0x01	; 1
 54c:	10 40       	sbci	r17, 0x00	; 0
					bp = va_arg(ap, unsigned char *);
					if (!bp)
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
 54e:	10 16       	cp	r1, r16
 550:	11 06       	cpc	r1, r17
 552:	04 f0       	brlt	.+0      	; 0x554 <rprintf2RamRom+0x4fc>
// %x - hex
// %c - character
// %s - strings
// and the width,precision,padding modifiers
// **this printf does not support floating point numbers
int rprintf2RamRom(unsigned char stringInRom, const char *sfmt, ...)
 554:	97 01       	movw	r18, r14
 556:	21 50       	subi	r18, 0x01	; 1
 558:	30 40       	sbci	r19, 0x00	; 0
 55a:	c7 01       	movw	r24, r14
 55c:	f7 fe       	sbrs	r15, 7
 55e:	00 c0       	rjmp	.+0      	; 0x560 <rprintf2RamRom+0x508>
 560:	80 e0       	ldi	r24, 0x00	; 0
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	79 01       	movw	r14, r18
 566:	e8 1a       	sub	r14, r24
 568:	f9 0a       	sbc	r15, r25
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (i = 0; *bp && i < prec; i++)
 56a:	00 e0       	ldi	r16, 0x00	; 0
 56c:	10 e0       	ldi	r17, 0x00	; 0
 56e:	00 c0       	rjmp	.+0      	; 0x570 <rprintf2RamRom+0x518>
					{
						rprintfChar(*bp);
 570:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
						bp = (unsigned char *) "(nil)";
					f_width = f_width - strlen((char *) bp);
					if (!flush_left)
						while (f_width-- > 0)
							rprintfChar(pad);
					for (i = 0; *bp && i < prec; i++)
 574:	0f 5f       	subi	r16, 0xFF	; 255
 576:	1f 4f       	sbci	r17, 0xFF	; 255
 578:	d5 01       	movw	r26, r10
 57a:	8d 91       	ld	r24, X+
 57c:	5d 01       	movw	r10, r26
 57e:	88 23       	and	r24, r24
 580:	01 f0       	breq	.+0      	; 0x582 <rprintf2RamRom+0x52a>
 582:	04 15       	cp	r16, r4
 584:	15 05       	cpc	r17, r5
 586:	04 f0       	brlt	.+0      	; 0x588 <rprintf2RamRom+0x530>
					{
						rprintfChar(*bp);
						bp++;
					}
					if (flush_left)
 588:	e9 81       	ldd	r30, Y+1	; 0x01
 58a:	fa 81       	ldd	r31, Y+2	; 0x02
 58c:	30 97       	sbiw	r30, 0x00	; 0
 58e:	01 f0       	breq	.+0      	; 0x590 <rprintf2RamRom+0x538>
 590:	87 01       	movw	r16, r14
 592:	00 c0       	rjmp	.+0      	; 0x594 <rprintf2RamRom+0x53c>
						while (f_width-- > 0)
							rprintfChar(' ');
 594:	80 e2       	ldi	r24, 0x20	; 32
 596:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
 59a:	01 50       	subi	r16, 0x01	; 1
 59c:	10 40       	sbci	r17, 0x00	; 0
					{
						rprintfChar(*bp);
						bp++;
					}
					if (flush_left)
						while (f_width-- > 0)
 59e:	10 16       	cp	r1, r16
 5a0:	11 06       	cpc	r1, r17
 5a2:	04 f0       	brlt	.+0      	; 0x5a4 <rprintf2RamRom+0x54c>
 5a4:	00 c0       	rjmp	.+0      	; 0x5a6 <rprintf2RamRom+0x54e>
							rprintfChar(' ');
					break;
            case '%':			// '%' character
					rprintfChar('%');
 5a6:	85 e2       	ldi	r24, 0x25	; 37
 5a8:	0e 94 00 00 	call	0	; 0x0 <Isdigit>
	va_list ap;
	va_start(ap, sfmt);

	f = (unsigned char *) sfmt;

	for (; READMEMBYTE(stringInRom,f); f++)
 5ac:	08 94       	sec
 5ae:	c1 1c       	adc	r12, r1
 5b0:	d1 1c       	adc	r13, r1
 5b2:	77 20       	and	r7, r7
 5b4:	01 f0       	breq	.+0      	; 0x5b6 <rprintf2RamRom+0x55e>
 5b6:	f6 01       	movw	r30, r12
 5b8:	84 91       	lpm	r24, Z
 5ba:	88 23       	and	r24, r24
 5bc:	01 f0       	breq	.+0      	; 0x5be <rprintf2RamRom+0x566>
 5be:	00 c0       	rjmp	.+0      	; 0x5c0 <rprintf2RamRom+0x568>
 5c0:	00 c0       	rjmp	.+0      	; 0x5c2 <rprintf2RamRom+0x56a>
 5c2:	d6 01       	movw	r26, r12
 5c4:	8c 91       	ld	r24, X
 5c6:	88 23       	and	r24, r24
 5c8:	01 f0       	breq	.+0      	; 0x5ca <rprintf2RamRom+0x572>
 5ca:	00 c0       	rjmp	.+0      	; 0x5cc <rprintf2RamRom+0x574>
		}
	}

	va_end(ap);
	return 0;
}
 5cc:	80 e0       	ldi	r24, 0x00	; 0
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	0f 90       	pop	r0
 5d2:	0f 90       	pop	r0
 5d4:	df 91       	pop	r29
 5d6:	cf 91       	pop	r28
 5d8:	1f 91       	pop	r17
 5da:	0f 91       	pop	r16
 5dc:	ff 90       	pop	r15
 5de:	ef 90       	pop	r14
 5e0:	df 90       	pop	r13
 5e2:	cf 90       	pop	r12
 5e4:	bf 90       	pop	r11
 5e6:	af 90       	pop	r10
 5e8:	9f 90       	pop	r9
 5ea:	8f 90       	pop	r8
 5ec:	7f 90       	pop	r7
 5ee:	6f 90       	pop	r6
 5f0:	5f 90       	pop	r5
 5f2:	4f 90       	pop	r4
 5f4:	3f 90       	pop	r3
 5f6:	2f 90       	pop	r2
 5f8:	08 95       	ret

rprintff.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001d2  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000206  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000206  2**0
                  ALLOC
  3 .debug_info   000000eb  00000000  00000000  00000206  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000007d  00000000  00000000  000002f1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000293  00000000  00000000  0000036e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000601  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000076  00000000  00000000  00000621  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000ec  00000000  00000000  00000697  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000007c  00000000  00000000  00000784  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfFloat>:
#include "libdefs.h"
#include <stdarg.h>

// floating-point print
void rprintfFloat(char numDigits, double x)
{
   0:	3f 92       	push	r3
   2:	4f 92       	push	r4
   4:	5f 92       	push	r5
   6:	6f 92       	push	r6
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
  1e:	cf 93       	push	r28
  20:	df 93       	push	r29
  22:	38 2e       	mov	r3, r24
  24:	6a 01       	movw	r12, r20
  26:	7b 01       	movw	r14, r22
	unsigned char negative;
	unsigned char i, digit;
	double place = 1.0;

	// save sign
	negative = (x<0);
  28:	cb 01       	movw	r24, r22
  2a:	ba 01       	movw	r22, r20
  2c:	20 e0       	ldi	r18, 0x00	; 0
  2e:	30 e0       	ldi	r19, 0x00	; 0
  30:	40 e0       	ldi	r20, 0x00	; 0
  32:	50 e0       	ldi	r21, 0x00	; 0
  34:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  38:	68 2e       	mov	r6, r24
  3a:	66 1c       	adc	r6, r6
  3c:	66 24       	eor	r6, r6
  3e:	66 1c       	adc	r6, r6
	// convert to absolute value
	x = (x>0)?(x):(-x);
  40:	c7 01       	movw	r24, r14
  42:	b6 01       	movw	r22, r12
  44:	20 e0       	ldi	r18, 0x00	; 0
  46:	30 e0       	ldi	r19, 0x00	; 0
  48:	40 e0       	ldi	r20, 0x00	; 0
  4a:	50 e0       	ldi	r21, 0x00	; 0
  4c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  50:	18 16       	cp	r1, r24
  52:	04 f0       	brlt	.+0      	; 0x54 <rprintfFloat+0x54>
  54:	f7 fa       	bst	r15, 7
  56:	f0 94       	com	r15
  58:	f7 f8       	bld	r15, 7
  5a:	f0 94       	com	r15
#include "libdefs.h"
#include <stdarg.h>

// floating-point print
void rprintfFloat(char numDigits, double x)
{
  5c:	9f e0       	ldi	r25, 0x0F	; 15
  5e:	79 2e       	mov	r7, r25
	unsigned char firstplace = FALSE;
	unsigned char negative;
	unsigned char i, digit;
	double place = 1.0;
  60:	00 e0       	ldi	r16, 0x00	; 0
  62:	10 e0       	ldi	r17, 0x00	; 0
  64:	d0 e8       	ldi	r29, 0x80	; 128
  66:	cf e3       	ldi	r28, 0x3F	; 63
	x = (x>0)?(x):(-x);

	// find starting digit place
	for(i=0; i<15; i++)
	{
		if((x/place) < 10.0)
  68:	c7 01       	movw	r24, r14
  6a:	b6 01       	movw	r22, r12
  6c:	9e 01       	movw	r18, r28
  6e:	80 2e       	mov	r8, r16
  70:	91 2e       	mov	r9, r17
  72:	a3 2e       	mov	r10, r19
  74:	bc 2e       	mov	r11, r28
  76:	a5 01       	movw	r20, r10
  78:	94 01       	movw	r18, r8
  7a:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  7e:	20 e0       	ldi	r18, 0x00	; 0
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	40 e2       	ldi	r20, 0x20	; 32
  84:	51 e4       	ldi	r21, 0x41	; 65
  86:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  8a:	87 fd       	sbrc	r24, 7
  8c:	00 c0       	rjmp	.+0      	; 0x8e <rprintfFloat+0x8e>
			break;
		else
			place *= 10.0;
  8e:	9e 01       	movw	r18, r28
  90:	80 2f       	mov	r24, r16
  92:	91 2f       	mov	r25, r17
  94:	a3 2f       	mov	r26, r19
  96:	bc 2f       	mov	r27, r28
  98:	bc 01       	movw	r22, r24
  9a:	cd 01       	movw	r24, r26
  9c:	20 e0       	ldi	r18, 0x00	; 0
  9e:	30 e0       	ldi	r19, 0x00	; 0
  a0:	40 e2       	ldi	r20, 0x20	; 32
  a2:	51 e4       	ldi	r21, 0x41	; 65
  a4:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  a8:	8b 01       	movw	r16, r22
  aa:	d8 2f       	mov	r29, r24
  ac:	c9 2f       	mov	r28, r25
  ae:	7a 94       	dec	r7
	negative = (x<0);
	// convert to absolute value
	x = (x>0)?(x):(-x);

	// find starting digit place
	for(i=0; i<15; i++)
  b0:	01 f4       	brne	.+0      	; 0xb2 <rprintfFloat+0xb2>
			break;
		else
			place *= 10.0;
	}
	// print polarity character
	if(negative)
  b2:	66 20       	and	r6, r6
  b4:	01 f0       	breq	.+0      	; 0xb6 <rprintfFloat+0xb6>
		rprintfChar('-');
  b6:	8d e2       	ldi	r24, 0x2D	; 45
  b8:	00 c0       	rjmp	.+0      	; 0xba <rprintfFloat+0xba>
	else
		rprintfChar('+');
  ba:	8b e2       	ldi	r24, 0x2B	; 43
  bc:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
		}
		else
			rprintfChar(' ');
  c0:	66 24       	eor	r6, r6
  c2:	77 24       	eor	r7, r7
  c4:	00 c0       	rjmp	.+0      	; 0xc6 <rprintfFloat+0xc6>
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
	{
		digit = (x/place);
  c6:	c7 01       	movw	r24, r14
  c8:	b6 01       	movw	r22, r12
  ca:	9e 01       	movw	r18, r28
  cc:	80 2e       	mov	r8, r16
  ce:	91 2e       	mov	r9, r17
  d0:	a3 2e       	mov	r10, r19
  d2:	bc 2e       	mov	r11, r28
  d4:	a5 01       	movw	r20, r10
  d6:	94 01       	movw	r18, r8
  d8:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  dc:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
  e0:	86 2e       	mov	r8, r22

		if(digit | firstplace | (place == 1.0))
  e2:	76 2a       	or	r7, r22
  e4:	47 2c       	mov	r4, r7
  e6:	55 24       	eor	r5, r5
  e8:	81 e0       	ldi	r24, 0x01	; 1
  ea:	a8 2e       	mov	r10, r24
  ec:	b1 2c       	mov	r11, r1
  ee:	9e 01       	movw	r18, r28
  f0:	80 2f       	mov	r24, r16
  f2:	91 2f       	mov	r25, r17
  f4:	a3 2f       	mov	r26, r19
  f6:	bc 2f       	mov	r27, r28
  f8:	bc 01       	movw	r22, r24
  fa:	cd 01       	movw	r24, r26
  fc:	20 e0       	ldi	r18, 0x00	; 0
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	40 e8       	ldi	r20, 0x80	; 128
 102:	5f e3       	ldi	r21, 0x3F	; 63
 104:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 108:	88 23       	and	r24, r24
 10a:	01 f0       	breq	.+0      	; 0x10c <rprintfFloat+0x10c>
 10c:	aa 24       	eor	r10, r10
 10e:	bb 24       	eor	r11, r11
 110:	c2 01       	movw	r24, r4
 112:	8a 29       	or	r24, r10
 114:	9b 29       	or	r25, r11
 116:	00 97       	sbiw	r24, 0x00	; 0
 118:	01 f0       	breq	.+0      	; 0x11a <rprintfFloat+0x11a>
		{
			firstplace = TRUE;
			rprintfChar(digit+0x30);
 11a:	88 2d       	mov	r24, r8
 11c:	80 5d       	subi	r24, 0xD0	; 208
 11e:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
	{
		digit = (x/place);

		if(digit | firstplace | (place == 1.0))
		{
			firstplace = TRUE;
 122:	77 24       	eor	r7, r7
 124:	7a 94       	dec	r7
 126:	00 c0       	rjmp	.+0      	; 0x128 <rprintfFloat+0x128>
			rprintfChar(digit+0x30);
		}
		else
			rprintfChar(' ');
 128:	80 e2       	ldi	r24, 0x20	; 32
 12a:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 12e:	77 24       	eor	r7, r7

		if(place == 1.0)
 130:	9e 01       	movw	r18, r28
 132:	80 2f       	mov	r24, r16
 134:	91 2f       	mov	r25, r17
 136:	a3 2f       	mov	r26, r19
 138:	bc 2f       	mov	r27, r28
 13a:	bc 01       	movw	r22, r24
 13c:	cd 01       	movw	r24, r26
 13e:	20 e0       	ldi	r18, 0x00	; 0
 140:	30 e0       	ldi	r19, 0x00	; 0
 142:	40 e8       	ldi	r20, 0x80	; 128
 144:	5f e3       	ldi	r21, 0x3F	; 63
 146:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 14a:	88 23       	and	r24, r24
 14c:	01 f4       	brne	.+0      	; 0x14e <rprintfFloat+0x14e>
		{
			rprintfChar('.');
 14e:	8e e2       	ldi	r24, 0x2E	; 46
 150:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
		}

		x -= (digit*place);
 154:	68 2d       	mov	r22, r8
 156:	70 e0       	ldi	r23, 0x00	; 0
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	90 e0       	ldi	r25, 0x00	; 0
 15c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 160:	9e 01       	movw	r18, r28
 162:	80 2e       	mov	r8, r16
 164:	91 2e       	mov	r9, r17
 166:	a3 2e       	mov	r10, r19
 168:	bc 2e       	mov	r11, r28
 16a:	a5 01       	movw	r20, r10
 16c:	94 01       	movw	r18, r8
 16e:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 172:	9b 01       	movw	r18, r22
 174:	ac 01       	movw	r20, r24
 176:	c7 01       	movw	r24, r14
 178:	b6 01       	movw	r22, r12
 17a:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 17e:	c6 2e       	mov	r12, r22
 180:	d7 2e       	mov	r13, r23
 182:	e8 2e       	mov	r14, r24
 184:	f9 2e       	mov	r15, r25
		place /= 10.0;
 186:	9e 01       	movw	r18, r28
 188:	80 2f       	mov	r24, r16
 18a:	91 2f       	mov	r25, r17
 18c:	a3 2f       	mov	r26, r19
 18e:	bc 2f       	mov	r27, r28
 190:	bc 01       	movw	r22, r24
 192:	cd 01       	movw	r24, r26
 194:	20 e0       	ldi	r18, 0x00	; 0
 196:	30 e0       	ldi	r19, 0x00	; 0
 198:	40 e2       	ldi	r20, 0x20	; 32
 19a:	51 e4       	ldi	r21, 0x41	; 65
 19c:	0e 94 00 00 	call	0	; 0x0 <rprintfFloat>
 1a0:	8b 01       	movw	r16, r22
 1a2:	d8 2f       	mov	r29, r24
 1a4:	c9 2f       	mov	r28, r25
		rprintfChar('-');
	else
		rprintfChar('+');

	// print digits
	for(i=0; i<numDigits; i++)
 1a6:	63 94       	inc	r6
 1a8:	63 14       	cp	r6, r3
 1aa:	01 f0       	breq	.+0      	; 0x1ac <rprintfFloat+0x1ac>
 1ac:	00 c0       	rjmp	.+0      	; 0x1ae <rprintfFloat+0x1ae>
		}

		x -= (digit*place);
		place /= 10.0;
	}
}
 1ae:	df 91       	pop	r29
 1b0:	cf 91       	pop	r28
 1b2:	1f 91       	pop	r17
 1b4:	0f 91       	pop	r16
 1b6:	ff 90       	pop	r15
 1b8:	ef 90       	pop	r14
 1ba:	df 90       	pop	r13
 1bc:	cf 90       	pop	r12
 1be:	bf 90       	pop	r11
 1c0:	af 90       	pop	r10
 1c2:	9f 90       	pop	r9
 1c4:	8f 90       	pop	r8
 1c6:	7f 90       	pop	r7
 1c8:	6f 90       	pop	r6
 1ca:	5f 90       	pop	r5
 1cc:	4f 90       	pop	r4
 1ce:	3f 90       	pop	r3
 1d0:	08 95       	ret

rprintfh.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000004c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000080  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000080  2**0
                  ALLOC
  3 .debug_info   000000f6  00000000  00000000  00000080  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000072  00000000  00000000  00000176  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000f7  00000000  00000000  000001e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000002df  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000080  00000000  00000000  000002ff  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000000e9  00000000  00000000  0000037f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000068  00000000  00000000  00000468  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfu08>:
#include "rprintf.h"


// prints an unsigned 8-bit number in hex (2 digits)
void rprintfu08(uint8_t data)
{
   0:	cf 93       	push	r28
   2:	c8 2f       	mov	r28, r24
	// print 8-bit hex value
	rprintfu04(data>>4);
   4:	82 95       	swap	r24
   6:	8f 70       	andi	r24, 0x0F	; 15
   8:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu04(data);
   c:	8c 2f       	mov	r24, r28
   e:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
}
  12:	cf 91       	pop	r28
  14:	08 95       	ret

00000016 <rprintfu16>:

// prints an unsigned 16-bit number in hex (4 digits)
void rprintfu16(uint16_t data)
{
  16:	cf 93       	push	r28
  18:	c8 2f       	mov	r28, r24
	// print 16-bit hex value
	rprintfu08(data>>8);
  1a:	89 2f       	mov	r24, r25
  1c:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu08(data);
  20:	8c 2f       	mov	r24, r28
  22:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
}
  26:	cf 91       	pop	r28
  28:	08 95       	ret

0000002a <rprintfu32>:

// prints an unsigned 32-bit number in hex (8 digits)
void rprintfu32(uint32_t data)
{
  2a:	cf 92       	push	r12
  2c:	df 92       	push	r13
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	6b 01       	movw	r12, r22
  34:	7c 01       	movw	r14, r24
	// print 32-bit hex value
	rprintfu16(data>>16);
  36:	c7 01       	movw	r24, r14
  38:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
	rprintfu16(data);
  3c:	c6 01       	movw	r24, r12
  3e:	0e 94 00 00 	call	0	; 0x0 <rprintfu08>
}
  42:	ff 90       	pop	r15
  44:	ef 90       	pop	r14
  46:	df 90       	pop	r13
  48:	cf 90       	pop	r12
  4a:	08 95       	ret

rprintfn.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000014c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000180  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000180  2**0
                  ALLOC
  3 .debug_info   000001b7  00000000  00000000  00000180  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000e5  00000000  00000000  00000337  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000365  00000000  00000000  0000041c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000781  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000b7  00000000  00000000  000007a1  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    0000010b  00000000  00000000  00000858  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000084  00000000  00000000  00000964  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintfNum>:
//	Examples:
//	uartPrintfNum(10, 6,  TRUE, ' ',   1234);  -->  " +1234"
//	uartPrintfNum(10, 6, FALSE, '0',   1234);  -->  "001234"
//	uartPrintfNum(16, 6, FALSE, '.', 0x5AA5);  -->  "..5AA5"
void rprintfNum(char base, char numDigits, char isSigned, char padchar, long n)
{
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	a0 97       	sbiw	r28, 0x20	; 32
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	28 2e       	mov	r2, r24
  36:	a6 2e       	mov	r10, r22
  38:	b4 2e       	mov	r11, r20
  3a:	72 2e       	mov	r7, r18
  3c:	67 01       	movw	r12, r14
  3e:	78 01       	movw	r14, r16
	char *p, buf[32];
	unsigned long x;
	unsigned char count;

	// prepare negative number
	if( isSigned && (n < 0) ){
  40:	44 23       	and	r20, r20
  42:	01 f0       	breq	.+0      	; 0x44 <rprintfNum+0x44>
  44:	f7 fe       	sbrs	r15, 7
  46:	00 c0       	rjmp	.+0      	; 0x48 <rprintfNum+0x48>
		x = -n;
  48:	66 27       	eor	r22, r22
  4a:	77 27       	eor	r23, r23
  4c:	cb 01       	movw	r24, r22
  4e:	6c 19       	sub	r22, r12
  50:	7d 09       	sbc	r23, r13
  52:	8e 09       	sbc	r24, r14
  54:	9f 09       	sbc	r25, r15
  56:	00 c0       	rjmp	.+0      	; 0x58 <rprintfNum+0x58>
	}else{
	 	x = n;
  58:	c7 01       	movw	r24, r14
  5a:	b6 01       	movw	r22, r12
	}

	// setup little string buffer
	count = (numDigits-1)-(isSigned?1:0);
  5c:	6a 2c       	mov	r6, r10
  5e:	6a 94       	dec	r6
  60:	21 e0       	ldi	r18, 0x01	; 1
  62:	bb 20       	and	r11, r11
  64:	01 f4       	brne	.+0      	; 0x66 <rprintfNum+0x66>
  66:	20 e0       	ldi	r18, 0x00	; 0
  68:	62 1a       	sub	r6, r18
  	p = buf + sizeof (buf);
  	*--p = '\0';
  6a:	18 a2       	std	Y+32, r1	; 0x20

	// force calculation of first digit
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
  6c:	33 24       	eor	r3, r3
  6e:	44 24       	eor	r4, r4
  70:	55 24       	eor	r5, r5
  72:	a2 01       	movw	r20, r4
  74:	91 01       	movw	r18, r2
  76:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
  7a:	dc 01       	movw	r26, r24
  7c:	cb 01       	movw	r24, r22
  7e:	fc 01       	movw	r30, r24
  80:	ef 70       	andi	r30, 0x0F	; 15
  82:	f0 70       	andi	r31, 0x00	; 0
  84:	e0 50       	subi	r30, 0x00	; 0
  86:	f0 40       	sbci	r31, 0x00	; 0
  88:	e4 91       	lpm	r30, Z
  8a:	ef 8f       	std	Y+31, r30	; 0x1f
	x /= base;
  8c:	c9 01       	movw	r24, r18
  8e:	da 01       	movw	r26, r20
  90:	2e e1       	ldi	r18, 0x1E	; 30
  92:	82 2e       	mov	r8, r18
  94:	91 2c       	mov	r9, r1
  96:	8c 0e       	add	r8, r28
  98:	9d 1e       	adc	r9, r29

	// calculate remaining digits
	while(count--){
  9a:	06 2d       	mov	r16, r6
  9c:	00 c0       	rjmp	.+0      	; 0x9e <rprintfNum+0x9e>
		if(x != 0){
  9e:	00 97       	sbiw	r24, 0x00	; 0
  a0:	a1 05       	cpc	r26, r1
  a2:	b1 05       	cpc	r27, r1
  a4:	01 f0       	breq	.+0      	; 0xa6 <rprintfNum+0xa6>
			// calculate next digit
			*--p = hexchar(x % base);
  a6:	bc 01       	movw	r22, r24
  a8:	cd 01       	movw	r24, r26
  aa:	a2 01       	movw	r20, r4
  ac:	91 01       	movw	r18, r2
  ae:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
  b2:	dc 01       	movw	r26, r24
  b4:	cb 01       	movw	r24, r22
  b6:	fc 01       	movw	r30, r24
  b8:	ef 70       	andi	r30, 0x0F	; 15
  ba:	f0 70       	andi	r31, 0x00	; 0
  bc:	e0 50       	subi	r30, 0x00	; 0
  be:	f0 40       	sbci	r31, 0x00	; 0
  c0:	e4 91       	lpm	r30, Z
  c2:	d4 01       	movw	r26, r8
  c4:	ec 93       	st	X, r30
			x /= base;
  c6:	c9 01       	movw	r24, r18
  c8:	da 01       	movw	r26, r20
  ca:	00 c0       	rjmp	.+0      	; 0xcc <rprintfNum+0xcc>
		}else{
			// no more digits left, pad out to desired length
			*--p = padchar;
  cc:	f4 01       	movw	r30, r8
  ce:	70 82       	st	Z, r7
  d0:	01 50       	subi	r16, 0x01	; 1
  d2:	08 94       	sec
  d4:	81 08       	sbc	r8, r1
  d6:	91 08       	sbc	r9, r1
	// (to prevent zero from not printing at all!!!)
	*--p = hexchar(x % base);
	x /= base;

	// calculate remaining digits
	while(count--){
  d8:	00 23       	and	r16, r16
  da:	01 f4       	brne	.+0      	; 0xdc <rprintfNum+0xdc>
  dc:	8e 01       	movw	r16, r28
  de:	01 5e       	subi	r16, 0xE1	; 225
  e0:	1f 4f       	sbci	r17, 0xFF	; 255
  e2:	06 19       	sub	r16, r6
  e4:	11 09       	sbc	r17, r1
			*--p = padchar;
		}
	}

	// apply signed notation if requested
	if( isSigned )	{
  e6:	bb 20       	and	r11, r11
  e8:	01 f0       	breq	.+0      	; 0xea <rprintfNum+0xea>
		char s = ' ';
		if(n < 0){
  ea:	f7 fc       	sbrc	r15, 7
  ec:	00 c0       	rjmp	.+0      	; 0xee <rprintfNum+0xee>
   			s = '-';
		}else if(n > 0){
  ee:	c1 14       	cp	r12, r1
  f0:	d1 04       	cpc	r13, r1
  f2:	e1 04       	cpc	r14, r1
  f4:	f1 04       	cpc	r15, r1
  f6:	01 f4       	brne	.+0      	; 0xf8 <rprintfNum+0xf8>
		}
	}

	// apply signed notation if requested
	if( isSigned )	{
		char s = ' ';
  f8:	80 e2       	ldi	r24, 0x20	; 32
  fa:	00 c0       	rjmp	.+0      	; 0xfc <rprintfNum+0xfc>
		if(n < 0){
   			s = '-';
  fc:	8d e2       	ldi	r24, 0x2D	; 45
  fe:	00 c0       	rjmp	.+0      	; 0x100 <rprintfNum+0x100>
		}else if(n > 0){
	   		s = '+';
 100:	8b e2       	ldi	r24, 0x2B	; 43
		}
		*--p = s;
 102:	d8 01       	movw	r26, r16
 104:	8e 93       	st	-X, r24
 106:	8d 01       	movw	r16, r26
 108:	00 c0       	rjmp	.+0      	; 0x10a <rprintfNum+0x10a>
	}

	// print the string right-justified
	count = numDigits;
	while(count--){
		rprintfChar(*p++);
 10a:	f8 01       	movw	r30, r16
 10c:	81 91       	ld	r24, Z+
 10e:	8f 01       	movw	r16, r30
 110:	0e 94 00 00 	call	0	; 0x0 <rprintfNum>
 114:	aa 94       	dec	r10
		*--p = s;
	}

	// print the string right-justified
	count = numDigits;
	while(count--){
 116:	aa 20       	and	r10, r10
 118:	01 f4       	brne	.+0      	; 0x11a <rprintfNum+0x11a>
		rprintfChar(*p++);
	}
}
 11a:	a0 96       	adiw	r28, 0x20	; 32
 11c:	0f b6       	in	r0, 0x3f	; 63
 11e:	f8 94       	cli
 120:	de bf       	out	0x3e, r29	; 62
 122:	0f be       	out	0x3f, r0	; 63
 124:	cd bf       	out	0x3d, r28	; 61
 126:	df 91       	pop	r29
 128:	cf 91       	pop	r28
 12a:	1f 91       	pop	r17
 12c:	0f 91       	pop	r16
 12e:	ff 90       	pop	r15
 130:	ef 90       	pop	r14
 132:	df 90       	pop	r13
 134:	cf 90       	pop	r12
 136:	bf 90       	pop	r11
 138:	af 90       	pop	r10
 13a:	9f 90       	pop	r9
 13c:	8f 90       	pop	r8
 13e:	7f 90       	pop	r7
 140:	6f 90       	pop	r6
 142:	5f 90       	pop	r5
 144:	4f 90       	pop	r4
 146:	3f 90       	pop	r3
 148:	2f 90       	pop	r2
 14a:	08 95       	ret

rprintfs.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000174  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001a8  2**0
                  ALLOC
  3 .debug_info   00000197  00000000  00000000  000001a8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000000e5  00000000  00000000  0000033f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000032b  00000000  00000000  00000424  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  0000074f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  0000076f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000109  00000000  00000000  00000787  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000014b  00000000  00000000  00000890  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000080  00000000  00000000  000009dc  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <rprintf1RamRom>:
// Supports:
// %d - decimal
// %x - hex
// %c - character
int rprintf1RamRom(unsigned char stringInRom, const char *format, ...)
{
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	5f 92       	push	r5
   6:	6f 92       	push	r6
   8:	7f 92       	push	r7
   a:	8f 92       	push	r8
   c:	9f 92       	push	r9
   e:	af 92       	push	r10
  10:	bf 92       	push	r11
  12:	cf 92       	push	r12
  14:	df 92       	push	r13
  16:	ef 92       	push	r14
  18:	ff 92       	push	r15
  1a:	0f 93       	push	r16
  1c:	1f 93       	push	r17
  1e:	cf 93       	push	r28
  20:	df 93       	push	r29
  22:	0f 92       	push	r0
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	5d 88       	ldd	r5, Y+21	; 0x15
  2a:	8e 88       	ldd	r8, Y+22	; 0x16
  2c:	9f 88       	ldd	r9, Y+23	; 0x17
	char format_flag;
	char* str;
	unsigned int u_val, div_val, base;
	va_list ap;

	va_start(ap, format);
  2e:	48 e1       	ldi	r20, 0x18	; 24
  30:	a4 2e       	mov	r10, r20
  32:	b1 2c       	mov	r11, r1
  34:	ac 0e       	add	r10, r28
  36:	bd 1e       	adc	r11, r29
					rprintfChar('-');
				}
			}
			if(format_flag == 'u' || format_flag == 'd'){
				// Strip leading zeroes
				while (div_val > 1 && div_val > u_val) div_val /= 10;
  38:	5a e0       	ldi	r21, 0x0A	; 10
  3a:	25 2e       	mov	r2, r21
  3c:	31 2c       	mov	r3, r1
  3e:	00 c0       	rjmp	.+0      	; 0x40 <rprintf1RamRom+0x40>
	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
		{	// Until '%' or '\0'
			if (!format_flag)
  40:	88 23       	and	r24, r24
  42:	01 f4       	brne	.+0      	; 0x44 <rprintf1RamRom+0x44>
				div_val /= base;
			} while (div_val);
		}
	}
	va_end(ap);
}
  44:	80 e0       	ldi	r24, 0x00	; 0
  46:	90 e0       	ldi	r25, 0x00	; 0
  48:	0f 90       	pop	r0
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	0f 91       	pop	r16
  52:	ff 90       	pop	r15
  54:	ef 90       	pop	r14
  56:	df 90       	pop	r13
  58:	cf 90       	pop	r12
  5a:	bf 90       	pop	r11
  5c:	af 90       	pop	r10
  5e:	9f 90       	pop	r9
  60:	8f 90       	pop	r8
  62:	7f 90       	pop	r7
  64:	6f 90       	pop	r6
  66:	5f 90       	pop	r5
  68:	3f 90       	pop	r3
  6a:	2f 90       	pop	r2
  6c:	08 95       	ret
			if (!format_flag)
			{
				va_end(ap);
				return(0);
			}
			rprintfChar(format_flag);
  6e:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
  72:	d4 01       	movw	r26, r8
  74:	11 96       	adiw	r26, 0x01	; 1
	va_list ap;

	va_start(ap, format);
	for (;;)
	{
		while ((format_flag = READMEMBYTE(stringInRom,format++) ) != '%')
  76:	f4 01       	movw	r30, r8
  78:	55 20       	and	r5, r5
  7a:	01 f0       	breq	.+0      	; 0x7c <rprintf1RamRom+0x7c>
  7c:	4d 01       	movw	r8, r26
  7e:	84 91       	lpm	r24, Z
  80:	00 c0       	rjmp	.+0      	; 0x82 <rprintf1RamRom+0x82>
  82:	80 81       	ld	r24, Z
  84:	4d 01       	movw	r8, r26
  86:	85 32       	cpi	r24, 0x25	; 37
  88:	01 f4       	brne	.+0      	; 0x8a <rprintf1RamRom+0x8a>
  8a:	cd 01       	movw	r24, r26
  8c:	01 96       	adiw	r24, 0x01	; 1
				return(0);
			}
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
  8e:	55 20       	and	r5, r5
  90:	01 f0       	breq	.+0      	; 0x92 <rprintf1RamRom+0x92>
  92:	4c 01       	movw	r8, r24
  94:	fd 01       	movw	r30, r26
  96:	04 91       	lpm	r16, Z
  98:	00 c0       	rjmp	.+0      	; 0x9a <rprintf1RamRom+0x9a>
  9a:	0c 91       	ld	r16, X
  9c:	4c 01       	movw	r8, r24
  9e:	03 37       	cpi	r16, 0x73	; 115
  a0:	01 f0       	breq	.+0      	; 0xa2 <rprintf1RamRom+0xa2>
  a2:	04 37       	cpi	r16, 0x74	; 116
  a4:	00 f4       	brcc	.+0      	; 0xa6 <rprintf1RamRom+0xa6>
  a6:	03 36       	cpi	r16, 0x63	; 99
  a8:	01 f0       	breq	.+0      	; 0xaa <rprintf1RamRom+0xaa>
  aa:	04 36       	cpi	r16, 0x64	; 100
  ac:	01 f0       	breq	.+0      	; 0xae <rprintf1RamRom+0xae>
  ae:	05 32       	cpi	r16, 0x25	; 37
  b0:	01 f4       	brne	.+0      	; 0xb2 <rprintf1RamRom+0xb2>
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <rprintf1RamRom+0xb4>
  b4:	05 37       	cpi	r16, 0x75	; 117
  b6:	01 f0       	breq	.+0      	; 0xb8 <rprintf1RamRom+0xb8>
  b8:	08 37       	cpi	r16, 0x78	; 120
  ba:	01 f4       	brne	.+0      	; 0xbc <rprintf1RamRom+0xbc>
  bc:	00 c0       	rjmp	.+0      	; 0xbe <rprintf1RamRom+0xbe>
					  continue;
			default:  rprintfChar('%');
			case '%':
					  rprintfChar(format_flag);
					  continue;
			case 'u': case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
  be:	2a e0       	ldi	r18, 0x0A	; 10
  c0:	62 2e       	mov	r6, r18
  c2:	71 2c       	mov	r7, r1
  c4:	30 e1       	ldi	r19, 0x10	; 16
  c6:	e3 2e       	mov	r14, r19
  c8:	37 e2       	ldi	r19, 0x27	; 39
  ca:	f3 2e       	mov	r15, r19
  cc:	00 c0       	rjmp	.+0      	; 0xce <rprintf1RamRom+0xce>
			rprintfChar(format_flag);
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
		{
			case 's': str = va_arg(ap,char*); rprintfStr(str);continue;
  ce:	85 01       	movw	r16, r10
  d0:	0e 5f       	subi	r16, 0xFE	; 254
  d2:	1f 4f       	sbci	r17, 0xFF	; 255
  d4:	f5 01       	movw	r30, r10
  d6:	80 81       	ld	r24, Z
  d8:	91 81       	ldd	r25, Z+1	; 0x01
  da:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
  de:	00 c0       	rjmp	.+0      	; 0xe0 <rprintf1RamRom+0xe0>
			case 'c': format_flag = va_arg(ap,int);
  e0:	85 01       	movw	r16, r10
  e2:	0e 5f       	subi	r16, 0xFE	; 254
  e4:	1f 4f       	sbci	r17, 0xFF	; 255
					  rprintfChar(format_flag);
  e6:	f5 01       	movw	r30, r10
  e8:	80 81       	ld	r24, Z
  ea:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
		}

		switch (format_flag = READMEMBYTE(stringInRom,format++) )
		{
			case 's': str = va_arg(ap,char*); rprintfStr(str);continue;
			case 'c': format_flag = va_arg(ap,int);
  ee:	58 01       	movw	r10, r16
					  rprintfChar(format_flag);
					  continue;
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <rprintf1RamRom+0xf2>
			default:  rprintfChar('%');
  f2:	85 e2       	ldi	r24, 0x25	; 37
  f4:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
			case '%':
					  rprintfChar(format_flag);
  f8:	80 2f       	mov	r24, r16
  fa:	00 c0       	rjmp	.+0      	; 0xfc <rprintf1RamRom+0xfc>
					  continue;
			case 'u': case 'd': base = 10; div_val = 10000; goto CONVERSION_LOOP;
			case 'x': base = 16; div_val = 0x1000;
  fc:	80 e1       	ldi	r24, 0x10	; 16
  fe:	68 2e       	mov	r6, r24
 100:	71 2c       	mov	r7, r1
 102:	e1 2c       	mov	r14, r1
 104:	90 e1       	ldi	r25, 0x10	; 16
 106:	f9 2e       	mov	r15, r25

			CONVERSION_LOOP:
			u_val = va_arg(ap,int);
 108:	f5 01       	movw	r30, r10
 10a:	82 e0       	ldi	r24, 0x02	; 2
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	a8 0e       	add	r10, r24
 110:	b9 1e       	adc	r11, r25
 112:	c0 80       	ld	r12, Z
 114:	d1 80       	ldd	r13, Z+1	; 0x01
			if (format_flag == 'd')
 116:	04 36       	cpi	r16, 0x64	; 100
 118:	01 f4       	brne	.+0      	; 0x11a <rprintf1RamRom+0x11a>
			{
				if (((int)u_val) < 0)
 11a:	d7 fe       	sbrs	r13, 7
 11c:	00 c0       	rjmp	.+0      	; 0x11e <rprintf1RamRom+0x11e>
				{
					u_val = - u_val;
 11e:	d0 94       	com	r13
 120:	c1 94       	neg	r12
 122:	d1 08       	sbc	r13, r1
 124:	d3 94       	inc	r13
					rprintfChar('-');
 126:	8d e2       	ldi	r24, 0x2D	; 45
 128:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 12c:	00 c0       	rjmp	.+0      	; 0x12e <rprintf1RamRom+0x12e>
				}
			}
			if(format_flag == 'u' || format_flag == 'd'){
 12e:	05 37       	cpi	r16, 0x75	; 117
 130:	01 f4       	brne	.+0      	; 0x132 <rprintf1RamRom+0x132>
 132:	00 c0       	rjmp	.+0      	; 0x134 <rprintf1RamRom+0x134>
				// Strip leading zeroes
				while (div_val > 1 && div_val > u_val) div_val /= 10;
 134:	c7 01       	movw	r24, r14
 136:	b1 01       	movw	r22, r2
 138:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 13c:	7b 01       	movw	r14, r22
 13e:	62 30       	cpi	r22, 0x02	; 2
 140:	71 05       	cpc	r23, r1
 142:	00 f0       	brcs	.+0      	; 0x144 <rprintf1RamRom+0x144>
 144:	ce 14       	cp	r12, r14
 146:	df 04       	cpc	r13, r15
 148:	00 f0       	brcs	.+0      	; 0x14a <rprintf1RamRom+0x14a>
			}
			do
			{
				rprintfu04(u_val/div_val);
 14a:	c6 01       	movw	r24, r12
 14c:	b7 01       	movw	r22, r14
 14e:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 152:	08 2f       	mov	r16, r24
 154:	86 2f       	mov	r24, r22
 156:	99 83       	std	Y+1, r25	; 0x01
 158:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
				u_val %= div_val;
 15c:	c0 2e       	mov	r12, r16
 15e:	99 81       	ldd	r25, Y+1	; 0x01
 160:	d9 2e       	mov	r13, r25
				div_val /= base;
 162:	c7 01       	movw	r24, r14
 164:	b3 01       	movw	r22, r6
 166:	0e 94 00 00 	call	0	; 0x0 <rprintf1RamRom>
 16a:	7b 01       	movw	r14, r22
			} while (div_val);
 16c:	61 15       	cp	r22, r1
 16e:	71 05       	cpc	r23, r1
 170:	01 f4       	brne	.+0      	; 0x172 <rprintf1RamRom+0x172>
 172:	00 c0       	rjmp	.+0      	; 0x174 <__SREG__+0x135>

scheduler.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000362  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000396  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000396  2**0
                  ALLOC
  3 .debug_info   00000992  00000000  00000000  00000396  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000025d  00000000  00000000  00000d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000067d  00000000  00000000  00000f85  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001602  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00001622  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000132  00000000  00000000  0000163a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000005f4  00000000  00000000  0000176c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000ec  00000000  00000000  00001d60  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__scheduleUpdate>:
		}
	}
}

// called under compare interrupts when there is something in the queu
void __scheduleUpdate(const TimerCompare *channel, void* data){
   0:	2f 92       	push	r2
   2:	3f 92       	push	r3
   4:	4f 92       	push	r4
   6:	5f 92       	push	r5
   8:	6f 92       	push	r6
   a:	7f 92       	push	r7
   c:	8f 92       	push	r8
   e:	9f 92       	push	r9
  10:	af 92       	push	r10
  12:	bf 92       	push	r11
  14:	cf 92       	push	r12
  16:	df 92       	push	r13
  18:	ef 92       	push	r14
  1a:	ff 92       	push	r15
  1c:	0f 93       	push	r16
  1e:	1f 93       	push	r17
  20:	cf 93       	push	r28
  22:	df 93       	push	r29
  24:	cd b7       	in	r28, 0x3d	; 61
  26:	de b7       	in	r29, 0x3e	; 62
  28:	2b 97       	sbiw	r28, 0x0b	; 11
  2a:	0f b6       	in	r0, 0x3f	; 63
  2c:	f8 94       	cli
  2e:	de bf       	out	0x3e, r29	; 62
  30:	0f be       	out	0x3f, r0	; 63
  32:	cd bf       	out	0x3d, r28	; 61
  34:	9e 83       	std	Y+6, r25	; 0x06
  36:	8d 83       	std	Y+5, r24	; 0x05
	// Dont call me again
	compareDetach(channel);
  38:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>

	// Turn interrupts back on
	INTERRUPTABLE_SECTION_START;
  3c:	2f b7       	in	r18, 0x3f	; 63
  3e:	2f 83       	std	Y+7, r18	; 0x07
  40:	78 94       	sei
	__running = TRUE;
  42:	8f ef       	ldi	r24, 0xFF	; 255
  44:	80 93 00 00 	sts	0x0000, r24
	TICK_COUNT lowest;
	do{
		int slot;
		__recheck = FALSE;
  48:	10 92 00 00 	sts	0x0000, r1
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
  4c:	20 91 00 00 	lds	r18, 0x0000
  50:	82 2f       	mov	r24, r18
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	01 97       	sbiw	r24, 0x01	; 1
  56:	4d e0       	ldi	r20, 0x0D	; 13
  58:	50 e0       	ldi	r21, 0x00	; 0
  5a:	84 9f       	mul	r24, r20
  5c:	30 01       	movw	r6, r0
  5e:	85 9f       	mul	r24, r21
  60:	70 0c       	add	r7, r0
  62:	94 9f       	mul	r25, r20
  64:	70 0c       	add	r7, r0
  66:	11 24       	eor	r1, r1
  68:	80 e0       	ldi	r24, 0x00	; 0
  6a:	90 e0       	ldi	r25, 0x00	; 0
  6c:	68 0e       	add	r6, r24
  6e:	79 1e       	adc	r7, r25
		}
	}
}

// called under compare interrupts when there is something in the queu
void __scheduleUpdate(const TimerCompare *channel, void* data){
  70:	ad e0       	ldi	r26, 0x0D	; 13
  72:	2a 9f       	mul	r18, r26
  74:	c0 01       	movw	r24, r0
  76:	11 24       	eor	r1, r1
  78:	f3 01       	movw	r30, r6
  7a:	e8 1b       	sub	r30, r24
  7c:	f9 0b       	sbc	r31, r25
  7e:	f9 87       	std	Y+9, r31	; 0x09
  80:	e8 87       	std	Y+8, r30	; 0x08
	TICK_COUNT lowest;
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
  82:	22 24       	eor	r2, r2
  84:	33 24       	eor	r3, r3
  86:	21 01       	movw	r4, r2
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
  88:	00 c0       	rjmp	.+0      	; 0x8a <__scheduleUpdate+0x8a>
			if(job->used){
  8a:	d3 01       	movw	r26, r6
  8c:	8c 91       	ld	r24, X
  8e:	88 23       	and	r24, r24
  90:	01 f4       	brne	.+0      	; 0x92 <__scheduleUpdate+0x92>
  92:	00 c0       	rjmp	.+0      	; 0x94 <__scheduleUpdate+0x94>
				// check if time has elapsed
				TICK_COUNT overflow;	// how many us the timer has overshot when it should have happened
				TICK_COUNT start=job->start;
  94:	19 96       	adiw	r26, 0x09	; 9
  96:	8d 90       	ld	r8, X+
  98:	9d 90       	ld	r9, X+
  9a:	ad 90       	ld	r10, X+
  9c:	bc 90       	ld	r11, X
  9e:	1c 97       	sbiw	r26, 0x0c	; 12
				TICK_COUNT delay=job->delay;
  a0:	15 96       	adiw	r26, 0x05	; 5
  a2:	cd 90       	ld	r12, X+
  a4:	dd 90       	ld	r13, X+
  a6:	ed 90       	ld	r14, X+
  a8:	fc 90       	ld	r15, X
  aa:	18 97       	sbiw	r26, 0x08	; 8
				if(clockHasElapsedGetOverflow(start, delay, &overflow)){
  ac:	c5 01       	movw	r24, r10
  ae:	b4 01       	movw	r22, r8
  b0:	a7 01       	movw	r20, r14
  b2:	96 01       	movw	r18, r12
  b4:	8e 01       	movw	r16, r28
  b6:	0f 5f       	subi	r16, 0xFF	; 255
  b8:	1f 4f       	sbci	r17, 0xFF	; 255
  ba:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
  be:	09 81       	ldd	r16, Y+1	; 0x01
  c0:	1a 81       	ldd	r17, Y+2	; 0x02
  c2:	2b 81       	ldd	r18, Y+3	; 0x03
  c4:	3c 81       	ldd	r19, Y+4	; 0x04
  c6:	88 23       	and	r24, r24
  c8:	01 f0       	breq	.+0      	; 0xca <__scheduleUpdate+0xca>
					SchedulerCallback callback = job->callback;
  ca:	f3 01       	movw	r30, r6
  cc:	01 80       	ldd	r0, Z+1	; 0x01
  ce:	f2 81       	ldd	r31, Z+2	; 0x02
  d0:	e0 2d       	mov	r30, r0
  d2:	fb 87       	std	Y+11, r31	; 0x0b
  d4:	ea 87       	std	Y+10, r30	; 0x0a
					SchedulerData data = job->data;
  d6:	d3 01       	movw	r26, r6
  d8:	13 96       	adiw	r26, 0x03	; 3
  da:	ed 91       	ld	r30, X+
  dc:	fc 91       	ld	r31, X
  de:	14 97       	sbiw	r26, 0x04	; 4

					// Mark this job as unused. No more references shoud be made to job->xxxx
					job->used = FALSE;
  e0:	1c 92       	st	X, r1
					--__numJobs;
  e2:	80 91 00 00 	lds	r24, 0x0000
  e6:	90 91 00 00 	lds	r25, 0x0000
  ea:	01 97       	sbiw	r24, 0x01	; 1
  ec:	90 93 00 00 	sts	0x0000, r25
  f0:	80 93 00 00 	sts	0x0000, r24

					// Run the job with interrupts enabled
					callback(data,start+delay,overflow);
  f4:	b7 01       	movw	r22, r14
  f6:	a6 01       	movw	r20, r12
  f8:	48 0d       	add	r20, r8
  fa:	59 1d       	adc	r21, r9
  fc:	6a 1d       	adc	r22, r10
  fe:	7b 1d       	adc	r23, r11
 100:	cf 01       	movw	r24, r30
 102:	ea 85       	ldd	r30, Y+10	; 0x0a
 104:	fb 85       	ldd	r31, Y+11	; 0x0b
 106:	09 95       	icall


					// Force another loop as the time taken may mean
					// something else can now run
					__recheck = TRUE;
 108:	ff ef       	ldi	r31, 0xFF	; 255
 10a:	f0 93 00 00 	sts	0x0000, r31
 10e:	00 c0       	rjmp	.+0      	; 0x110 <__scheduleUpdate+0x110>
				}else{
				   // overflow has the remaining number of microseconds to wait
				   if(lowest==0 || overflow < lowest){
 110:	21 14       	cp	r2, r1
 112:	31 04       	cpc	r3, r1
 114:	41 04       	cpc	r4, r1
 116:	51 04       	cpc	r5, r1
 118:	01 f0       	breq	.+0      	; 0x11a <__scheduleUpdate+0x11a>
 11a:	02 15       	cp	r16, r2
 11c:	13 05       	cpc	r17, r3
 11e:	24 05       	cpc	r18, r4
 120:	35 05       	cpc	r19, r5
 122:	00 f4       	brcc	.+0      	; 0x124 <__scheduleUpdate+0x124>
					   lowest = overflow;
 124:	18 01       	movw	r2, r16
 126:	29 01       	movw	r4, r18
	do{
		int slot;
		__recheck = FALSE;
		JOB* job;
		lowest=0;
		for(slot=maxJobs-1, job=&__queue[slot]; slot>=0; slot--, job--){
 128:	23 ef       	ldi	r18, 0xF3	; 243
 12a:	3f ef       	ldi	r19, 0xFF	; 255
 12c:	62 0e       	add	r6, r18
 12e:	73 1e       	adc	r7, r19
 130:	48 85       	ldd	r20, Y+8	; 0x08
 132:	59 85       	ldd	r21, Y+9	; 0x09
 134:	64 16       	cp	r6, r20
 136:	75 06       	cpc	r7, r21
 138:	01 f0       	breq	.+0      	; 0x13a <__scheduleUpdate+0x13a>
 13a:	00 c0       	rjmp	.+0      	; 0x13c <__scheduleUpdate+0x13c>
					   lowest = overflow;
				   }
				}
			}
		}
	}while( __recheck);
 13c:	80 91 00 00 	lds	r24, 0x0000
 140:	88 23       	and	r24, r24
 142:	01 f0       	breq	.+0      	; 0x144 <__scheduleUpdate+0x144>
 144:	00 c0       	rjmp	.+0      	; 0x146 <__scheduleUpdate+0x146>
	__running=FALSE;
 146:	10 92 00 00 	sts	0x0000, r1

	if(__numJobs > 0){
 14a:	80 91 00 00 	lds	r24, 0x0000
 14e:	90 91 00 00 	lds	r25, 0x0000
 152:	18 16       	cp	r1, r24
 154:	19 06       	cpc	r1, r25
 156:	04 f0       	brlt	.+0      	; 0x158 <__scheduleUpdate+0x158>
 158:	00 c0       	rjmp	.+0      	; 0x15a <__scheduleUpdate+0x15a>
#define CHANNEL_NUM 1


// Calculate the required compare threshold to cause an interrupt at the required time
static uint16_t calcTicks(TICK_COUNT us){
	TICK_COUNT ticks = (us * cpu_speed_div_1000000) / timerGetPrescaler(g_heartbeat);
 15a:	00 91 00 00 	lds	r16, 0x0000
 15e:	80 90 00 00 	lds	r8, 0x0000
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 162:	e0 2f       	mov	r30, r16
 164:	f8 2d       	mov	r31, r8
 166:	c5 90       	lpm	r12, Z+
 168:	d4 90       	lpm	r13, Z
 16a:	20 91 00 00 	lds	r18, 0x0000
 16e:	30 91 00 00 	lds	r19, 0x0000
 172:	40 e0       	ldi	r20, 0x00	; 0
 174:	50 e0       	ldi	r21, 0x00	; 0
 176:	c2 01       	movw	r24, r4
 178:	b1 01       	movw	r22, r2
 17a:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 17e:	d6 01       	movw	r26, r12
 180:	2d 91       	ld	r18, X+
 182:	3c 91       	ld	r19, X
 184:	40 e0       	ldi	r20, 0x00	; 0
 186:	50 e0       	ldi	r21, 0x00	; 0
 188:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 18c:	69 01       	movw	r12, r18
 18e:	7a 01       	movw	r14, r20
	uint16_t top = timerGetTOP(g_heartbeat);
 190:	80 2f       	mov	r24, r16
 192:	98 2d       	mov	r25, r8
 194:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	uint16_t rtn = MIN(ticks,top);
 198:	8c 01       	movw	r16, r24
 19a:	20 e0       	ldi	r18, 0x00	; 0
 19c:	30 e0       	ldi	r19, 0x00	; 0
 19e:	c0 16       	cp	r12, r16
 1a0:	d1 06       	cpc	r13, r17
 1a2:	e2 06       	cpc	r14, r18
 1a4:	f3 06       	cpc	r15, r19
 1a6:	00 f4       	brcc	.+0      	; 0x1a8 <__scheduleUpdate+0x1a8>
 1a8:	97 01       	movw	r18, r14
 1aa:	86 01       	movw	r16, r12
	}while( __recheck);
	__running=FALSE;

	if(__numJobs > 0){
		uint16_t compare = calcTicks(lowest);
		uint16_t top = timerGetTOP(g_heartbeat);
 1ac:	80 91 00 00 	lds	r24, 0x0000
 1b0:	90 91 00 00 	lds	r25, 0x0000
 1b4:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 1b8:	6c 01       	movw	r12, r24
		compare += timerGetCounter(g_heartbeat);
 1ba:	80 91 00 00 	lds	r24, 0x0000
 1be:	90 91 00 00 	lds	r25, 0x0000
 1c2:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 1c6:	80 0f       	add	r24, r16
 1c8:	91 1f       	adc	r25, r17
		compare %= top;
 1ca:	b6 01       	movw	r22, r12
 1cc:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 1d0:	ac 01       	movw	r20, r24
        compareAttach(channel,&__scheduleUpdate,compare,null);
 1d2:	8d 81       	ldd	r24, Y+5	; 0x05
 1d4:	9e 81       	ldd	r25, Y+6	; 0x06
 1d6:	60 e0       	ldi	r22, 0x00	; 0
 1d8:	70 e0       	ldi	r23, 0x00	; 0
 1da:	20 e0       	ldi	r18, 0x00	; 0
 1dc:	30 e0       	ldi	r19, 0x00	; 0
 1de:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	}

	// Restore previous interrupt enable
	INTERRUPTABLE_SECTION_END;
 1e2:	bf 81       	ldd	r27, Y+7	; 0x07
 1e4:	bf bf       	out	0x3f, r27	; 63
}
 1e6:	2b 96       	adiw	r28, 0x0b	; 11
 1e8:	0f b6       	in	r0, 0x3f	; 63
 1ea:	f8 94       	cli
 1ec:	de bf       	out	0x3e, r29	; 62
 1ee:	0f be       	out	0x3f, r0	; 63
 1f0:	cd bf       	out	0x3d, r28	; 61
 1f2:	df 91       	pop	r29
 1f4:	cf 91       	pop	r28
 1f6:	1f 91       	pop	r17
 1f8:	0f 91       	pop	r16
 1fa:	ff 90       	pop	r15
 1fc:	ef 90       	pop	r14
 1fe:	df 90       	pop	r13
 200:	cf 90       	pop	r12
 202:	bf 90       	pop	r11
 204:	af 90       	pop	r10
 206:	9f 90       	pop	r9
 208:	8f 90       	pop	r8
 20a:	7f 90       	pop	r7
 20c:	6f 90       	pop	r6
 20e:	5f 90       	pop	r5
 210:	4f 90       	pop	r4
 212:	3f 90       	pop	r3
 214:	2f 90       	pop	r2
 216:	08 95       	ret

00000218 <scheduleJob>:
// schedule a new job
// callback Is the function to be run at a later date
// data is a block of data to be passed into the callback
// start (in us) Is the start time of the delay
// delay (in us) Is the amount to delay by
void scheduleJob(SchedulerCallback callback, SchedulerData data, TICK_COUNT start, TICK_COUNT delay){
 218:	4f 92       	push	r4
 21a:	5f 92       	push	r5
 21c:	6f 92       	push	r6
 21e:	7f 92       	push	r7
 220:	8f 92       	push	r8
 222:	9f 92       	push	r9
 224:	af 92       	push	r10
 226:	bf 92       	push	r11
 228:	cf 92       	push	r12
 22a:	df 92       	push	r13
 22c:	ef 92       	push	r14
 22e:	ff 92       	push	r15
 230:	0f 93       	push	r16
 232:	1f 93       	push	r17
 234:	cf 93       	push	r28
 236:	df 93       	push	r29
 238:	00 d0       	rcall	.+0      	; 0x23a <scheduleJob+0x22>
 23a:	00 d0       	rcall	.+0      	; 0x23c <scheduleJob+0x24>
 23c:	cd b7       	in	r28, 0x3d	; 61
 23e:	de b7       	in	r29, 0x3e	; 62
 240:	2c 01       	movw	r4, r24
 242:	3b 01       	movw	r6, r22
 244:	49 01       	movw	r8, r18
 246:	5a 01       	movw	r10, r20
 248:	67 01       	movw	r12, r14
 24a:	78 01       	movw	r14, r16
	boolean doItNow = FALSE;

 	if(delay < 1000U){
 24c:	88 ee       	ldi	r24, 0xE8	; 232
 24e:	c8 16       	cp	r12, r24
 250:	83 e0       	ldi	r24, 0x03	; 3
 252:	d8 06       	cpc	r13, r24
 254:	80 e0       	ldi	r24, 0x00	; 0
 256:	e8 06       	cpc	r14, r24
 258:	80 e0       	ldi	r24, 0x00	; 0
 25a:	f8 06       	cpc	r15, r24
 25c:	00 f4       	brcc	.+0      	; 0x25e <scheduleJob+0x46>
		// it needs to happen now as the delay is < the heartbeat timer interrupt of 1ms
		if(__running){
 25e:	80 91 00 00 	lds	r24, 0x0000
 262:	88 23       	and	r24, r24
 264:	01 f4       	brne	.+0      	; 0x266 <scheduleJob+0x4e>
 266:	00 c0       	rjmp	.+0      	; 0x268 <scheduleJob+0x50>
			// make sure we do another loop of __scheduleUpdate to find it
			__recheck=TRUE;
 268:	8f ef       	ldi	r24, 0xFF	; 255
 26a:	80 93 00 00 	sts	0x0000, r24

	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
 26e:	4f b7       	in	r20, 0x3f	; 63
 270:	f8 94       	cli
			for(slot=0; slot<maxJobs; slot++){
 272:	80 91 00 00 	lds	r24, 0x0000
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	20 e0       	ldi	r18, 0x00	; 0
 27a:	30 e0       	ldi	r19, 0x00	; 0
				JOB* job = &__queue[slot];
 27c:	6d e0       	ldi	r22, 0x0D	; 13
 27e:	70 e0       	ldi	r23, 0x00	; 0
	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
			for(slot=0; slot<maxJobs; slot++){
 280:	00 c0       	rjmp	.+0      	; 0x282 <scheduleJob+0x6a>
				JOB* job = &__queue[slot];
 282:	26 9f       	mul	r18, r22
 284:	f0 01       	movw	r30, r0
 286:	27 9f       	mul	r18, r23
 288:	f0 0d       	add	r31, r0
 28a:	36 9f       	mul	r19, r22
 28c:	f0 0d       	add	r31, r0
 28e:	11 24       	eor	r1, r1
 290:	e0 50       	subi	r30, 0x00	; 0
 292:	f0 40       	sbci	r31, 0x00	; 0
				if(!job->used){
 294:	50 81       	ld	r21, Z
 296:	55 23       	and	r21, r21
 298:	01 f4       	brne	.+0      	; 0x29a <scheduleJob+0x82>
					job->used = TRUE;
 29a:	8f ef       	ldi	r24, 0xFF	; 255
 29c:	80 83       	st	Z, r24
					job->callback = callback;
 29e:	52 82       	std	Z+2, r5	; 0x02
 2a0:	41 82       	std	Z+1, r4	; 0x01
					job->data = data;
 2a2:	74 82       	std	Z+4, r7	; 0x04
 2a4:	63 82       	std	Z+3, r6	; 0x03
					job->start=start;
 2a6:	81 86       	std	Z+9, r8	; 0x09
 2a8:	92 86       	std	Z+10, r9	; 0x0a
 2aa:	a3 86       	std	Z+11, r10	; 0x0b
 2ac:	b4 86       	std	Z+12, r11	; 0x0c
					job->delay=delay;
 2ae:	c5 82       	std	Z+5, r12	; 0x05
 2b0:	d6 82       	std	Z+6, r13	; 0x06
 2b2:	e7 82       	std	Z+7, r14	; 0x07
 2b4:	f0 86       	std	Z+8, r15	; 0x08
					found=TRUE;
					__numJobs++;
 2b6:	80 91 00 00 	lds	r24, 0x0000
 2ba:	90 91 00 00 	lds	r25, 0x0000
 2be:	01 96       	adiw	r24, 0x01	; 1
 2c0:	90 93 00 00 	sts	0x0000, r25
 2c4:	80 93 00 00 	sts	0x0000, r24
					job->used = TRUE;
					job->callback = callback;
					job->data = data;
					job->start=start;
					job->delay=delay;
					found=TRUE;
 2c8:	8f ef       	ldi	r24, 0xFF	; 255
					__numJobs++;
					break;
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <scheduleJob+0xb4>
	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
		CRITICAL_SECTION_START;
			for(slot=0; slot<maxJobs; slot++){
 2cc:	2f 5f       	subi	r18, 0xFF	; 255
 2ce:	3f 4f       	sbci	r19, 0xFF	; 255
 2d0:	28 17       	cp	r18, r24
 2d2:	39 07       	cpc	r19, r25
 2d4:	04 f0       	brlt	.+0      	; 0x2d6 <scheduleJob+0xbe>
	}

	if(!doItNow){
		int slot;
		// queue it up
		boolean found=FALSE;
 2d6:	80 e0       	ldi	r24, 0x00	; 0
					found=TRUE;
					__numJobs++;
					break;
				}
			}
		CRITICAL_SECTION_END; // end atomic
 2d8:	4f bf       	out	0x3f, r20	; 63

		if(!found){
 2da:	88 23       	and	r24, r24
 2dc:	01 f4       	brne	.+0      	; 0x2de <scheduleJob+0xc6>
			// the queue is exhausted
			setError(SCHEDULER_EXHAUSTED);
 2de:	8f ef       	ldi	r24, 0xFF	; 255
 2e0:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
	if(doItNow){
		// we need to do it now
		TICK_COUNT overflow;

		// wait for expiry
		while(!clockHasElapsedGetOverflow(start, delay, &overflow)){
 2e4:	c5 01       	movw	r24, r10
 2e6:	b4 01       	movw	r22, r8
 2e8:	a7 01       	movw	r20, r14
 2ea:	96 01       	movw	r18, r12
 2ec:	8e 01       	movw	r16, r28
 2ee:	0f 5f       	subi	r16, 0xFF	; 255
 2f0:	1f 4f       	sbci	r17, 0xFF	; 255
 2f2:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 2f6:	88 23       	and	r24, r24
 2f8:	01 f0       	breq	.+0      	; 0x2fa <scheduleJob+0xe2>
		}

		// callback
		callback(data,start+delay,overflow);
 2fa:	b7 01       	movw	r22, r14
 2fc:	a6 01       	movw	r20, r12
 2fe:	48 0d       	add	r20, r8
 300:	59 1d       	adc	r21, r9
 302:	6a 1d       	adc	r22, r10
 304:	7b 1d       	adc	r23, r11
 306:	09 81       	ldd	r16, Y+1	; 0x01
 308:	1a 81       	ldd	r17, Y+2	; 0x02
 30a:	2b 81       	ldd	r18, Y+3	; 0x03
 30c:	3c 81       	ldd	r19, Y+4	; 0x04
 30e:	c3 01       	movw	r24, r6
 310:	f2 01       	movw	r30, r4
 312:	09 95       	icall
 314:	00 c0       	rjmp	.+0      	; 0x316 <scheduleJob+0xfe>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 316:	e0 91 00 00 	lds	r30, 0x0000
 31a:	f0 91 00 00 	lds	r31, 0x0000
 31e:	77 96       	adiw	r30, 0x17	; 23
 320:	85 91       	lpm	r24, Z+
 322:	94 91       	lpm	r25, Z
	}else{
		if(!__running){
			const TimerCompare* channel = timerGetCompare(g_heartbeat,CHANNEL_NUM);
			__scheduleUpdate(channel, null);
 324:	40 96       	adiw	r24, 0x10	; 16
 326:	60 e0       	ldi	r22, 0x00	; 0
 328:	70 e0       	ldi	r23, 0x00	; 0
 32a:	0e 94 00 00 	call	0	; 0x0 <__scheduleUpdate>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <scheduleJob+0x118>
		}

		// callback
		callback(data,start+delay,overflow);
	}else{
		if(!__running){
 330:	80 91 00 00 	lds	r24, 0x0000
 334:	88 23       	and	r24, r24
 336:	01 f0       	breq	.+0      	; 0x338 <scheduleJob+0x120>
			const TimerCompare* channel = timerGetCompare(g_heartbeat,CHANNEL_NUM);
			__scheduleUpdate(channel, null);
		}
	}
}
 338:	0f 90       	pop	r0
 33a:	0f 90       	pop	r0
 33c:	0f 90       	pop	r0
 33e:	0f 90       	pop	r0
 340:	df 91       	pop	r29
 342:	cf 91       	pop	r28
 344:	1f 91       	pop	r17
 346:	0f 91       	pop	r16
 348:	ff 90       	pop	r15
 34a:	ef 90       	pop	r14
 34c:	df 90       	pop	r13
 34e:	cf 90       	pop	r12
 350:	bf 90       	pop	r11
 352:	af 90       	pop	r10
 354:	9f 90       	pop	r9
 356:	8f 90       	pop	r8
 358:	7f 90       	pop	r7
 35a:	6f 90       	pop	r6
 35c:	5f 90       	pop	r5
 35e:	4f 90       	pop	r4
 360:	08 95       	ret

segled.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000178  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000001ac  2**0
                  ALLOC
  3 .progmem.data 00000024  00000000  00000000  000001ac  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   0000047c  00000000  00000000  000001d0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000001f7  00000000  00000000  0000064c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000358  00000000  00000000  00000843  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00000b9b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   000000de  00000000  00000000  00000bbb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000001d4  00000000  00000000  00000c99  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000084  00000000  00000000  00000e70  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <segled_set>:
		led->initialised=TRUE;

	}
}

void segled_set(SEGLED* led, SEGLED_SEGMENT segment, boolean value){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	0f 92       	push	r0
  12:	cd b7       	in	r28, 0x3d	; 61
  14:	de b7       	in	r29, 0x3e	; 62
  16:	6c 01       	movw	r12, r24
  18:	f6 2e       	mov	r15, r22
		0b11011010  // Z
};


static void init(SEGLED* led){
	if(!led->initialised){
  1a:	fc 01       	movw	r30, r24
  1c:	80 89       	ldd	r24, Z+16	; 0x10
  1e:	81 fd       	sbrc	r24, 1
  20:	00 c0       	rjmp	.+0      	; 0x22 <segled_set+0x22>
  22:	86 01       	movw	r16, r12
  24:	98 e0       	ldi	r25, 0x08	; 8
  26:	e9 2e       	mov	r14, r25
		for(uint8_t i=0; i<8;i++){
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
  28:	f8 01       	movw	r30, r16
  2a:	81 91       	ld	r24, Z+
  2c:	91 91       	ld	r25, Z+
  2e:	8f 01       	movw	r16, r30
  30:	60 e0       	ldi	r22, 0x00	; 0
  32:	49 83       	std	Y+1, r20	; 0x01
  34:	0e 94 00 00 	call	0	; 0x0 <segled_set>
  38:	ea 94       	dec	r14
};


static void init(SEGLED* led){
	if(!led->initialised){
		for(uint8_t i=0; i<8;i++){
  3a:	49 81       	ldd	r20, Y+1	; 0x01
  3c:	ee 20       	and	r14, r14
  3e:	01 f4       	brne	.+0      	; 0x40 <segled_set+0x40>
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
		}
		led->initialised=TRUE;
  40:	f6 01       	movw	r30, r12
  42:	80 89       	ldd	r24, Z+16	; 0x10
  44:	82 60       	ori	r24, 0x02	; 2
  46:	80 8b       	std	Z+16, r24	; 0x10
	}
}

void segled_set(SEGLED* led, SEGLED_SEGMENT segment, boolean value){
	init(led);
	if(!led->activeHigh){
  48:	f6 01       	movw	r30, r12
  4a:	80 89       	ldd	r24, Z+16	; 0x10
  4c:	80 fd       	sbrc	r24, 0
  4e:	00 c0       	rjmp	.+0      	; 0x50 <segled_set+0x50>
	 	value = (value) ? FALSE : TRUE;
  50:	44 23       	and	r20, r20
  52:	01 f0       	breq	.+0      	; 0x54 <segled_set+0x54>
  54:	40 e0       	ldi	r20, 0x00	; 0
  56:	00 c0       	rjmp	.+0      	; 0x58 <segled_set+0x58>
  58:	4f ef       	ldi	r20, 0xFF	; 255
	}
	const IOPin* pin = led->segment[segment];
  5a:	ef 2d       	mov	r30, r15
  5c:	f0 e0       	ldi	r31, 0x00	; 0
  5e:	ee 0f       	add	r30, r30
  60:	ff 1f       	adc	r31, r31
  62:	ec 0d       	add	r30, r12
  64:	fd 1d       	adc	r31, r13
	pin_set(pin,value);
  66:	80 81       	ld	r24, Z
  68:	91 81       	ldd	r25, Z+1	; 0x01
  6a:	64 2f       	mov	r22, r20
  6c:	0e 94 00 00 	call	0	; 0x0 <segled_set>
}
  70:	0f 90       	pop	r0
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	cf 90       	pop	r12
  82:	08 95       	ret

00000084 <segled_put_char>:

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
  84:	ef 92       	push	r14
  86:	ff 92       	push	r15
  88:	0f 93       	push	r16
  8a:	1f 93       	push	r17
  8c:	cf 93       	push	r28
  8e:	df 93       	push	r29
  90:	8c 01       	movw	r16, r24
  92:	c6 2f       	mov	r28, r22
		0b11011010  // Z
};


static void init(SEGLED* led){
	if(!led->initialised){
  94:	fc 01       	movw	r30, r24
  96:	80 89       	ldd	r24, Z+16	; 0x10
  98:	81 fd       	sbrc	r24, 1
  9a:	00 c0       	rjmp	.+0      	; 0x9c <segled_put_char+0x18>
  9c:	78 01       	movw	r14, r16
  9e:	d8 e0       	ldi	r29, 0x08	; 8
		for(uint8_t i=0; i<8;i++){
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
  a0:	f7 01       	movw	r30, r14
  a2:	81 91       	ld	r24, Z+
  a4:	91 91       	ld	r25, Z+
  a6:	7f 01       	movw	r14, r30
  a8:	60 e0       	ldi	r22, 0x00	; 0
  aa:	0e 94 00 00 	call	0	; 0x0 <segled_set>
  ae:	d1 50       	subi	r29, 0x01	; 1
};


static void init(SEGLED* led){
	if(!led->initialised){
		for(uint8_t i=0; i<8;i++){
  b0:	01 f4       	brne	.+0      	; 0xb2 <segled_put_char+0x2e>
			const IOPin* pin = led->segment[i];
			pin_make_output(pin,FALSE);
		}
		led->initialised=TRUE;
  b2:	f8 01       	movw	r30, r16
  b4:	80 89       	ldd	r24, Z+16	; 0x10
  b6:	82 60       	ori	r24, 0x02	; 2
  b8:	80 8b       	std	Z+16, r24	; 0x10
}

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
	init(led);
	uint8_t mask=0;	// default is a space
	if(ch>='A' && ch<='Z'){
  ba:	8c 2f       	mov	r24, r28
  bc:	81 54       	subi	r24, 0x41	; 65
  be:	8a 31       	cpi	r24, 0x1A	; 26
  c0:	00 f4       	brcc	.+0      	; 0xc2 <segled_put_char+0x3e>
		mask=pgm_read_byte(&atoz[ch-'A']);
  c2:	ec 2f       	mov	r30, r28
  c4:	f0 e0       	ldi	r31, 0x00	; 0
  c6:	e0 50       	subi	r30, 0x00	; 0
  c8:	f0 40       	sbci	r31, 0x00	; 0
  ca:	00 c0       	rjmp	.+0      	; 0xcc <segled_put_char+0x48>
	}else if(ch>='a' && ch<='z'){
  cc:	8c 2f       	mov	r24, r28
  ce:	81 56       	subi	r24, 0x61	; 97
  d0:	8a 31       	cpi	r24, 0x1A	; 26
  d2:	00 f4       	brcc	.+0      	; 0xd4 <segled_put_char+0x50>
		mask=pgm_read_byte(&atoz[ch-'a']);
  d4:	ec 2f       	mov	r30, r28
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	e0 50       	subi	r30, 0x00	; 0
  da:	f0 40       	sbci	r31, 0x00	; 0
  dc:	d4 91       	lpm	r29, Z
  de:	00 c0       	rjmp	.+0      	; 0xe0 <segled_put_char+0x5c>
	}else if(ch>='0' && ch<='9'){
  e0:	8c 2f       	mov	r24, r28
  e2:	80 53       	subi	r24, 0x30	; 48
  e4:	8a 30       	cpi	r24, 0x0A	; 10
  e6:	00 f4       	brcc	.+0      	; 0xe8 <segled_put_char+0x64>
		mask=pgm_read_byte(&digits[ch-'0']);
  e8:	ec 2f       	mov	r30, r28
  ea:	f0 e0       	ldi	r31, 0x00	; 0
  ec:	e0 50       	subi	r30, 0x00	; 0
  ee:	f0 40       	sbci	r31, 0x00	; 0
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <segled_put_char+0x6e>
	}else if(ch>=0 && ch<=9){
  f2:	ca 30       	cpi	r28, 0x0A	; 10
  f4:	00 f4       	brcc	.+0      	; 0xf6 <segled_put_char+0x72>
		mask=pgm_read_byte(&digits[ch]);
  f6:	ec 2f       	mov	r30, r28
  f8:	f0 e0       	ldi	r31, 0x00	; 0
  fa:	e0 50       	subi	r30, 0x00	; 0
  fc:	f0 40       	sbci	r31, 0x00	; 0
  fe:	00 c0       	rjmp	.+0      	; 0x100 <segled_put_char+0x7c>
	}else if(ch=='-'){
 100:	cd 32       	cpi	r28, 0x2D	; 45
 102:	01 f0       	breq	.+0      	; 0x104 <segled_put_char+0x80>
		mask = 0b00000010;
	}else if(ch=='[' || ch=='{' || ch=='('){
 104:	cb 35       	cpi	r28, 0x5B	; 91
 106:	01 f0       	breq	.+0      	; 0x108 <segled_put_char+0x84>
 108:	cb 37       	cpi	r28, 0x7B	; 123
 10a:	01 f0       	breq	.+0      	; 0x10c <segled_put_char+0x88>
 10c:	c8 32       	cpi	r28, 0x28	; 40
 10e:	01 f0       	breq	.+0      	; 0x110 <segled_put_char+0x8c>
		mask = 0b10011100;
	}else if(ch==']' || ch=='}' || ch==')'){
 110:	cd 35       	cpi	r28, 0x5D	; 93
 112:	01 f0       	breq	.+0      	; 0x114 <segled_put_char+0x90>
 114:	cd 37       	cpi	r28, 0x7D	; 125
 116:	01 f0       	breq	.+0      	; 0x118 <segled_put_char+0x94>
 118:	c9 32       	cpi	r28, 0x29	; 41
 11a:	01 f0       	breq	.+0      	; 0x11c <segled_put_char+0x98>
		mask = 0b11110000;
	}else if(ch=='.'){
 11c:	ce 32       	cpi	r28, 0x2E	; 46
 11e:	01 f4       	brne	.+0      	; 0x120 <segled_put_char+0x9c>
		if(led->segment[7]){
 120:	f8 01       	movw	r30, r16
 122:	86 85       	ldd	r24, Z+14	; 0x0e
 124:	97 85       	ldd	r25, Z+15	; 0x0f
 126:	00 97       	sbiw	r24, 0x00	; 0
 128:	01 f0       	breq	.+0      	; 0x12a <segled_put_char+0xa6>
			// it has a full stop
			mask = 0b00000001;
 12a:	d1 e0       	ldi	r29, 0x01	; 1
 12c:	00 c0       	rjmp	.+0      	; 0x12e <segled_put_char+0xaa>
	}else if(ch>='0' && ch<='9'){
		mask=pgm_read_byte(&digits[ch-'0']);
	}else if(ch>=0 && ch<=9){
		mask=pgm_read_byte(&digits[ch]);
	}else if(ch=='-'){
		mask = 0b00000010;
 12e:	d2 e0       	ldi	r29, 0x02	; 2
 130:	00 c0       	rjmp	.+0      	; 0x132 <segled_put_char+0xae>
	}else if(ch=='[' || ch=='{' || ch=='('){
		mask = 0b10011100;
 132:	dc e9       	ldi	r29, 0x9C	; 156
 134:	00 c0       	rjmp	.+0      	; 0x136 <segled_put_char+0xb2>
	}else if(ch==']' || ch=='}' || ch==')'){
		mask = 0b11110000;
 136:	d0 ef       	ldi	r29, 0xF0	; 240
 138:	00 c0       	rjmp	.+0      	; 0x13a <segled_put_char+0xb6>
	pin_set(pin,value);
}

uint8_t segled_put_char(SEGLED* led, uint8_t ch){
	init(led);
	uint8_t mask=0;	// default is a space
 13a:	d0 e0       	ldi	r29, 0x00	; 0
 13c:	00 c0       	rjmp	.+0      	; 0x13e <segled_put_char+0xba>
		if(led->segment[7]){
			// it has a full stop
			mask = 0b00000001;
		}else{
			// no full stop - so just light segment D
			mask = 0b00010000;
 13e:	d0 e1       	ldi	r29, 0x10	; 16
		}
	}
	if(!led->activeHigh){
 140:	f8 01       	movw	r30, r16
 142:	80 89       	ldd	r24, Z+16	; 0x10
 144:	80 ff       	sbrs	r24, 0
	 	mask ^= 0b11111111;
 146:	d0 95       	com	r29
	}else if(ch=='-'){
		mask = 0b00000010;
	}else if(ch=='[' || ch=='{' || ch=='('){
		mask = 0b10011100;
	}else if(ch==']' || ch=='}' || ch==')'){
		mask = 0b11110000;
 148:	28 e0       	ldi	r18, 0x08	; 8
 14a:	e2 2e       	mov	r14, r18
	if(!led->activeHigh){
	 	mask ^= 0b11111111;
	}

	for(uint8_t i=0; i<8;i++){
		const IOPin* pin = led->segment[i];
 14c:	f8 01       	movw	r30, r16
 14e:	81 91       	ld	r24, Z+
 150:	91 91       	ld	r25, Z+
 152:	8f 01       	movw	r16, r30
		if(mask & 0b10000000){
 154:	d7 ff       	sbrs	r29, 7
 156:	00 c0       	rjmp	.+0      	; 0x158 <segled_put_char+0xd4>
			pin_high(pin);
 158:	0e 94 00 00 	call	0	; 0x0 <segled_set>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <segled_put_char+0xda>
		}else{
			pin_low(pin);
 15e:	0e 94 00 00 	call	0	; 0x0 <segled_set>
		}
		mask <<= 1;
 162:	dd 0f       	add	r29, r29
 164:	ea 94       	dec	r14
	}
	if(!led->activeHigh){
	 	mask ^= 0b11111111;
	}

	for(uint8_t i=0; i<8;i++){
 166:	01 f4       	brne	.+0      	; 0x168 <segled_put_char+0xe4>
			pin_low(pin);
		}
		mask <<= 1;
	}
	return ch;
}
 168:	8c 2f       	mov	r24, r28
 16a:	df 91       	pop	r29
 16c:	cf 91       	pop	r28
 16e:	1f 91       	pop	r17
 170:	0f 91       	pop	r16
 172:	ff 90       	pop	r15
 174:	ef 90       	pop	r14
 176:	08 95       	ret

segledMarquee.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000308  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000033c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000033c  2**0
                  ALLOC
  3 .debug_info   00000903  00000000  00000000  0000033c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000253  00000000  00000000  00000c3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000539  00000000  00000000  00000e92  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000013cb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  000013eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000193  00000000  00000000  0000141b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000409  00000000  00000000  000015ae  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000ec  00000000  00000000  000019b8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <marqueeUpdate>:
			}
		}
	}
}

static void marqueeUpdate(SchedulerData data, TICK_COUNT lastTime, TICK_COUNT overflow){
   0:	4f 92       	push	r4
   2:	5f 92       	push	r5
   4:	6f 92       	push	r6
   6:	7f 92       	push	r7
   8:	8f 92       	push	r8
   a:	9f 92       	push	r9
   c:	af 92       	push	r10
   e:	bf 92       	push	r11
  10:	cf 92       	push	r12
  12:	df 92       	push	r13
  14:	ef 92       	push	r14
  16:	ff 92       	push	r15
  18:	0f 93       	push	r16
  1a:	1f 93       	push	r17
  1c:	cf 93       	push	r28
  1e:	df 93       	push	r29
  20:	ec 01       	movw	r28, r24
  22:	2a 01       	movw	r4, r20
  24:	3b 01       	movw	r6, r22
	MARQUEE* m = (MARQUEE*)data;

	char* readPos = m->txt + m->readPos;
  26:	ac 80       	ldd	r10, Y+4	; 0x04
  28:	bd 80       	ldd	r11, Y+5	; 0x05
  2a:	8e 81       	ldd	r24, Y+6	; 0x06
  2c:	9f 81       	ldd	r25, Y+7	; 0x07
  2e:	a8 0e       	add	r10, r24
  30:	b9 1e       	adc	r11, r25
	char  first=*readPos;
  32:	f5 01       	movw	r30, r10
  34:	00 81       	ld	r16, Z
	boolean blink = m->blink;
  36:	8c 89       	ldd	r24, Y+20	; 0x14
  38:	82 95       	swap	r24
  3a:	88 0f       	add	r24, r24
  3c:	88 0f       	add	r24, r24
  3e:	80 7c       	andi	r24, 0xC0	; 192
  40:	88 0f       	add	r24, r24
  42:	88 0b       	sbc	r24, r24

	TICK_COUNT delay = (first=='\0') ? m->delayEnd : m->delayChar;
  44:	00 23       	and	r16, r16
  46:	01 f4       	brne	.+0      	; 0x48 <marqueeUpdate+0x48>
  48:	c8 88       	ldd	r12, Y+16	; 0x10
  4a:	d9 88       	ldd	r13, Y+17	; 0x11
  4c:	ea 88       	ldd	r14, Y+18	; 0x12
  4e:	fb 88       	ldd	r15, Y+19	; 0x13
  50:	00 c0       	rjmp	.+0      	; 0x52 <marqueeUpdate+0x52>
  52:	cc 84       	ldd	r12, Y+12	; 0x0c
  54:	dd 84       	ldd	r13, Y+13	; 0x0d
  56:	ee 84       	ldd	r14, Y+14	; 0x0e
  58:	ff 84       	ldd	r15, Y+15	; 0x0f
	TICK_COUNT delayDiv4 = delay >> 2;

	if(blink==FALSE){
  5a:	88 23       	and	r24, r24
  5c:	01 f4       	brne	.+0      	; 0x5e <marqueeUpdate+0x5e>
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
  5e:	00 23       	and	r16, r16
  60:	01 f0       	breq	.+0      	; 0x62 <marqueeUpdate+0x62>
			char* pos = readPos;
			char prev = readPos[-1];
  62:	f5 01       	movw	r30, r10
  64:	31 97       	sbiw	r30, 0x01	; 1
  66:	50 81       	ld	r21, Z
			blink = TRUE;
			for(size_t led = 0; led < m->num_leds; led++){
  68:	2a 81       	ldd	r18, Y+2	; 0x02
  6a:	3b 81       	ldd	r19, Y+3	; 0x03
  6c:	f5 01       	movw	r30, r10
  6e:	80 e0       	ldi	r24, 0x00	; 0
  70:	90 e0       	ldi	r25, 0x00	; 0
  72:	00 c0       	rjmp	.+0      	; 0x74 <marqueeUpdate+0x74>
				char ch = *pos++;
  74:	41 91       	ld	r20, Z+
				// If we've hit end of line or a different char then no blink
				if(ch=='\0' || ch!=prev){
  76:	44 23       	and	r20, r20
  78:	01 f0       	breq	.+0      	; 0x7a <marqueeUpdate+0x7a>
  7a:	45 17       	cp	r20, r21
  7c:	01 f4       	brne	.+0      	; 0x7e <marqueeUpdate+0x7e>
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
			blink = TRUE;
			for(size_t led = 0; led < m->num_leds; led++){
  7e:	01 96       	adiw	r24, 0x01	; 1
  80:	82 17       	cp	r24, r18
  82:	93 07       	cpc	r25, r19
  84:	01 f4       	brne	.+0      	; 0x86 <marqueeUpdate+0x86>
	if(blink==FALSE){
		// we are not currently bliking. Check if we should start.
		if(first!='\0'){
			char* pos = readPos;
			char prev = readPos[-1];
			blink = TRUE;
  86:	1f ef       	ldi	r17, 0xFF	; 255
  88:	00 c0       	rjmp	.+0      	; 0x8a <marqueeUpdate+0x8a>
			for(size_t led = 0; led < m->num_leds; led++){
				char ch = *pos++;
				// If we've hit end of line or a different char then no blink
				if(ch=='\0' || ch!=prev){
					blink=FALSE;
  8a:	10 e0       	ldi	r17, 0x00	; 0
		// We are already blinking, so turn it off
		blink=FALSE;
	}

	// Set it for next time
	if(blink != m->blink){
  8c:	8c 89       	ldd	r24, Y+20	; 0x14
  8e:	82 95       	swap	r24
  90:	88 0f       	add	r24, r24
  92:	88 0f       	add	r24, r24
  94:	80 7c       	andi	r24, 0xC0	; 192
  96:	88 0f       	add	r24, r24
  98:	88 0b       	sbc	r24, r24
  9a:	18 17       	cp	r17, r24
  9c:	01 f0       	breq	.+0      	; 0x9e <marqueeUpdate+0x9e>
	char* readPos = m->txt + m->readPos;
	char  first=*readPos;
	boolean blink = m->blink;

	TICK_COUNT delay = (first=='\0') ? m->delayEnd : m->delayChar;
	TICK_COUNT delayDiv4 = delay >> 2;
  9e:	d7 01       	movw	r26, r14
  a0:	c6 01       	movw	r24, r12
  a2:	32 e0       	ldi	r19, 0x02	; 2
  a4:	b6 95       	lsr	r27
  a6:	a7 95       	ror	r26
  a8:	97 95       	ror	r25
  aa:	87 95       	ror	r24
  ac:	3a 95       	dec	r19
  ae:	01 f4       	brne	.+0      	; 0xb0 <marqueeUpdate+0xb0>
		blink=FALSE;
	}

	// Set it for next time
	if(blink != m->blink){
		m->blink = blink;
  b0:	31 2f       	mov	r19, r17
  b2:	32 70       	andi	r19, 0x02	; 2
  b4:	2c 89       	ldd	r18, Y+20	; 0x14
  b6:	2d 7f       	andi	r18, 0xFD	; 253
  b8:	23 2b       	or	r18, r19
  ba:	2c 8b       	std	Y+20, r18	; 0x14
		delay = (blink) ? delayDiv4 : delay - delayDiv4;
  bc:	11 23       	and	r17, r17
  be:	01 f4       	brne	.+0      	; 0xc0 <marqueeUpdate+0xc0>
  c0:	c8 1a       	sub	r12, r24
  c2:	d9 0a       	sbc	r13, r25
  c4:	ea 0a       	sbc	r14, r26
  c6:	fb 0a       	sbc	r15, r27
  c8:	00 c0       	rjmp	.+0      	; 0xca <marqueeUpdate+0xca>
  ca:	6c 01       	movw	r12, r24
  cc:	7d 01       	movw	r14, r26
	}

	// Write chars to leds
	for(size_t l = 0; l < m->num_leds; l++){
  ce:	88 24       	eor	r8, r8
  d0:	99 24       	eor	r9, r9
  d2:	00 c0       	rjmp	.+0      	; 0xd4 <marqueeUpdate+0xd4>
		SEGLED* led = (SEGLED*)pgm_read_word(&m->leds[l]);
  d4:	c4 01       	movw	r24, r8
  d6:	88 0f       	add	r24, r24
  d8:	99 1f       	adc	r25, r25
  da:	e8 81       	ld	r30, Y
  dc:	f9 81       	ldd	r31, Y+1	; 0x01
  de:	e8 0f       	add	r30, r24
  e0:	f9 1f       	adc	r31, r25
  e2:	25 91       	lpm	r18, Z+
  e4:	34 91       	lpm	r19, Z
  e6:	c9 01       	movw	r24, r18
		char ch = (blink) ? '\0' : *readPos;
  e8:	11 23       	and	r17, r17
  ea:	01 f4       	brne	.+0      	; 0xec <marqueeUpdate+0xec>
  ec:	f5 01       	movw	r30, r10
  ee:	60 81       	ld	r22, Z
		if(ch!='\0'){
  f0:	66 23       	and	r22, r22
  f2:	01 f0       	breq	.+0      	; 0xf4 <marqueeUpdate+0xf4>
			readPos++;
  f4:	08 94       	sec
  f6:	a1 1c       	adc	r10, r1
  f8:	b1 1c       	adc	r11, r1
  fa:	00 c0       	rjmp	.+0      	; 0xfc <marqueeUpdate+0xfc>
		}else{
			ch = ' ';
  fc:	60 e2       	ldi	r22, 0x20	; 32
		}
		segled_put_char(led,ch);
  fe:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
		m->blink = blink;
		delay = (blink) ? delayDiv4 : delay - delayDiv4;
	}

	// Write chars to leds
	for(size_t l = 0; l < m->num_leds; l++){
 102:	08 94       	sec
 104:	81 1c       	adc	r8, r1
 106:	91 1c       	adc	r9, r1
 108:	8a 81       	ldd	r24, Y+2	; 0x02
 10a:	9b 81       	ldd	r25, Y+3	; 0x03
 10c:	88 16       	cp	r8, r24
 10e:	99 06       	cpc	r9, r25
 110:	00 f0       	brcs	.+0      	; 0x112 <marqueeUpdate+0x112>
			ch = ' ';
		}
		segled_put_char(led,ch);
	}

	if(first=='\0'){
 112:	00 23       	and	r16, r16
 114:	01 f4       	brne	.+0      	; 0x116 <marqueeUpdate+0x116>
		// line is finished
		m->readPos = 0;
 116:	1f 82       	std	Y+7, r1	; 0x07
 118:	1e 82       	std	Y+6, r1	; 0x06
		if(m->delayEnd==0 || m->txt[0]=='\0'){
 11a:	88 89       	ldd	r24, Y+16	; 0x10
 11c:	99 89       	ldd	r25, Y+17	; 0x11
 11e:	aa 89       	ldd	r26, Y+18	; 0x12
 120:	bb 89       	ldd	r27, Y+19	; 0x13
 122:	00 97       	sbiw	r24, 0x00	; 0
 124:	a1 05       	cpc	r26, r1
 126:	b1 05       	cpc	r27, r1
 128:	01 f0       	breq	.+0      	; 0x12a <marqueeUpdate+0x12a>
 12a:	ec 81       	ldd	r30, Y+4	; 0x04
 12c:	fd 81       	ldd	r31, Y+5	; 0x05
 12e:	80 81       	ld	r24, Z
 130:	88 23       	and	r24, r24
 132:	01 f4       	brne	.+0      	; 0x134 <marqueeUpdate+0x134>
			m->active=FALSE;
 134:	8c 89       	ldd	r24, Y+20	; 0x14
 136:	8e 7f       	andi	r24, 0xFE	; 254
 138:	00 c0       	rjmp	.+0      	; 0x13a <marqueeUpdate+0x13a>
		}else{
			m->blink = FALSE;
 13a:	8c 89       	ldd	r24, Y+20	; 0x14
 13c:	8d 7f       	andi	r24, 0xFD	; 253
 13e:	8c 8b       	std	Y+20, r24	; 0x14
 140:	00 c0       	rjmp	.+0      	; 0x142 <marqueeUpdate+0x142>
		}
	}else{
		// middle of line
		if(!blink){
 142:	11 23       	and	r17, r17
 144:	01 f4       	brne	.+0      	; 0x146 <marqueeUpdate+0x146>
			// Show character next time
			m->readPos += 1;
 146:	8e 81       	ldd	r24, Y+6	; 0x06
 148:	9f 81       	ldd	r25, Y+7	; 0x07
 14a:	01 96       	adiw	r24, 0x01	; 1
 14c:	9f 83       	std	Y+7, r25	; 0x07
 14e:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	if(m->active){
 150:	8c 89       	ldd	r24, Y+20	; 0x14
 152:	80 ff       	sbrs	r24, 0
 154:	00 c0       	rjmp	.+0      	; 0x156 <marqueeUpdate+0x156>
		scheduleJob(&marqueeUpdate,data,lastTime,delay);
 156:	80 e0       	ldi	r24, 0x00	; 0
 158:	90 e0       	ldi	r25, 0x00	; 0
 15a:	be 01       	movw	r22, r28
 15c:	a3 01       	movw	r20, r6
 15e:	92 01       	movw	r18, r4
 160:	87 01       	movw	r16, r14
 162:	76 01       	movw	r14, r12
 164:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
	}
}
 168:	df 91       	pop	r29
 16a:	cf 91       	pop	r28
 16c:	1f 91       	pop	r17
 16e:	0f 91       	pop	r16
 170:	ff 90       	pop	r15
 172:	ef 90       	pop	r14
 174:	df 90       	pop	r13
 176:	cf 90       	pop	r12
 178:	bf 90       	pop	r11
 17a:	af 90       	pop	r10
 17c:	9f 90       	pop	r9
 17e:	8f 90       	pop	r8
 180:	7f 90       	pop	r7
 182:	6f 90       	pop	r6
 184:	5f 90       	pop	r5
 186:	4f 90       	pop	r4
 188:	08 95       	ret

0000018a <marqueeSendByte>:

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
 18a:	cf 92       	push	r12
 18c:	df 92       	push	r13
 18e:	ef 92       	push	r14
 190:	ff 92       	push	r15
 192:	0f 93       	push	r16
 194:	1f 93       	push	r17
 196:	cf 93       	push	r28
 198:	df 93       	push	r29
 19a:	ec 01       	movw	r28, r24
 19c:	c6 2e       	mov	r12, r22
// For malloc
#include <stdlib.h>

// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
 19e:	8c 81       	ldd	r24, Y+4	; 0x04
 1a0:	9d 81       	ldd	r25, Y+5	; 0x05
 1a2:	00 97       	sbiw	r24, 0x00	; 0
 1a4:	01 f4       	brne	.+0      	; 0x1a6 <marqueeSendByte+0x1c>
		marquee->txt = malloc(1 + marquee->txtSize);
 1a6:	8a 85       	ldd	r24, Y+10	; 0x0a
 1a8:	9b 85       	ldd	r25, Y+11	; 0x0b
 1aa:	01 96       	adiw	r24, 0x01	; 1
 1ac:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
 1b0:	9d 83       	std	Y+5, r25	; 0x05
 1b2:	8c 83       	std	Y+4, r24	; 0x04
		if(marquee->txt){
 1b4:	00 97       	sbiw	r24, 0x00	; 0
 1b6:	01 f4       	brne	.+0      	; 0x1b8 <marqueeSendByte+0x2e>
 1b8:	00 c0       	rjmp	.+0      	; 0x1ba <marqueeSendByte+0x30>
			for(int i=0; i<=marquee->txtSize;i++){
				marquee->txt[i] = '\0';
 1ba:	ec 81       	ldd	r30, Y+4	; 0x04
 1bc:	fd 81       	ldd	r31, Y+5	; 0x05
 1be:	e8 0f       	add	r30, r24
 1c0:	f9 1f       	adc	r31, r25
 1c2:	10 82       	st	Z, r1
// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
		marquee->txt = malloc(1 + marquee->txtSize);
		if(marquee->txt){
			for(int i=0; i<=marquee->txtSize;i++){
 1c4:	01 96       	adiw	r24, 0x01	; 1
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <marqueeSendByte+0x3e>

// Initialise a given marquee
static void marquee_init(MARQUEE* marquee){
	if(marquee->txt == null){
		marquee->txt = malloc(1 + marquee->txtSize);
		if(marquee->txt){
 1c8:	80 e0       	ldi	r24, 0x00	; 0
 1ca:	90 e0       	ldi	r25, 0x00	; 0
			for(int i=0; i<=marquee->txtSize;i++){
 1cc:	2a 85       	ldd	r18, Y+10	; 0x0a
 1ce:	3b 85       	ldd	r19, Y+11	; 0x0b
 1d0:	28 17       	cp	r18, r24
 1d2:	39 07       	cpc	r19, r25
 1d4:	00 f4       	brcc	.+0      	; 0x1d6 <marqueeSendByte+0x4c>
				marquee->txt[i] = '\0';
			}
			marquee->readPos = marquee->writePos = 0;
 1d6:	19 86       	std	Y+9, r1	; 0x09
 1d8:	18 86       	std	Y+8, r1	; 0x08
 1da:	1f 82       	std	Y+7, r1	; 0x07
 1dc:	1e 82       	std	Y+6, r1	; 0x06
			marquee->active = FALSE;
 1de:	8c 89       	ldd	r24, Y+20	; 0x14
 1e0:	8e 7f       	andi	r24, 0xFE	; 254
 1e2:	8c 8b       	std	Y+20, r24	; 0x14
			for(size_t i = 0; i < marquee->num_leds; i++){
 1e4:	ee 24       	eor	r14, r14
 1e6:	ff 24       	eor	r15, r15
 1e8:	00 c0       	rjmp	.+0      	; 0x1ea <marqueeSendByte+0x60>
				SEGLED* led = (SEGLED*)pgm_read_word(&marquee->leds[i]);
 1ea:	c7 01       	movw	r24, r14
 1ec:	88 0f       	add	r24, r24
 1ee:	99 1f       	adc	r25, r25
 1f0:	e8 81       	ld	r30, Y
 1f2:	f9 81       	ldd	r31, Y+1	; 0x01
 1f4:	e8 0f       	add	r30, r24
 1f6:	f9 1f       	adc	r31, r25
 1f8:	85 91       	lpm	r24, Z+
 1fa:	94 91       	lpm	r25, Z
				segled_put_char(led,' ');
 1fc:	60 e2       	ldi	r22, 0x20	; 32
 1fe:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
			for(int i=0; i<=marquee->txtSize;i++){
				marquee->txt[i] = '\0';
			}
			marquee->readPos = marquee->writePos = 0;
			marquee->active = FALSE;
			for(size_t i = 0; i < marquee->num_leds; i++){
 202:	08 94       	sec
 204:	e1 1c       	adc	r14, r1
 206:	f1 1c       	adc	r15, r1
 208:	8a 81       	ldd	r24, Y+2	; 0x02
 20a:	9b 81       	ldd	r25, Y+3	; 0x03
 20c:	e8 16       	cp	r14, r24
 20e:	f9 06       	cpc	r15, r25
 210:	00 f0       	brcs	.+0      	; 0x212 <marqueeSendByte+0x88>
	}
}

uint8_t marqueeSendByte(MARQUEE* marquee, uint8_t byte){
	marquee_init(marquee);
	if(marquee->txt){
 212:	8c 81       	ldd	r24, Y+4	; 0x04
 214:	9d 81       	ldd	r25, Y+5	; 0x05
 216:	00 97       	sbiw	r24, 0x00	; 0
 218:	01 f4       	brne	.+0      	; 0x21a <marqueeSendByte+0x90>
 21a:	00 c0       	rjmp	.+0      	; 0x21c <marqueeSendByte+0x92>

		if(byte=='\n'){
 21c:	2a e0       	ldi	r18, 0x0A	; 10
 21e:	c2 16       	cp	r12, r18
 220:	01 f4       	brne	.+0      	; 0x222 <marqueeSendByte+0x98>
			// Start writing at the beginning of the line
			marquee->txt[marquee->writePos] = '\0';
 222:	e8 85       	ldd	r30, Y+8	; 0x08
 224:	f9 85       	ldd	r31, Y+9	; 0x09
 226:	e8 0f       	add	r30, r24
 228:	f9 1f       	adc	r31, r25
 22a:	10 82       	st	Z, r1
			marquee->writePos = 0;
 22c:	19 86       	std	Y+9, r1	; 0x09
 22e:	18 86       	std	Y+8, r1	; 0x08
			CRITICAL_SECTION_START;
 230:	df b6       	in	r13, 0x3f	; 63
 232:	f8 94       	cli
			if(!marquee->active){
 234:	8c 89       	ldd	r24, Y+20	; 0x14
 236:	80 fd       	sbrc	r24, 0
 238:	00 c0       	rjmp	.+0      	; 0x23a <marqueeSendByte+0xb0>
				marquee->active = TRUE;
 23a:	8c 89       	ldd	r24, Y+20	; 0x14
 23c:	81 60       	ori	r24, 0x01	; 1
 23e:	8c 8b       	std	Y+20, r24	; 0x14
				marquee->blink = FALSE;
 240:	8c 89       	ldd	r24, Y+20	; 0x14
 242:	8d 7f       	andi	r24, 0xFD	; 253
 244:	8c 8b       	std	Y+20, r24	; 0x14
				marquee->readPos=0;
 246:	1f 82       	std	Y+7, r1	; 0x07
 248:	1e 82       	std	Y+6, r1	; 0x06
				scheduleJob(&marqueeUpdate,(SchedulerData)marquee,clockGetus(),marquee->delayChar);
 24a:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
 24e:	9b 01       	movw	r18, r22
 250:	ac 01       	movw	r20, r24
 252:	ec 84       	ldd	r14, Y+12	; 0x0c
 254:	fd 84       	ldd	r15, Y+13	; 0x0d
 256:	0e 85       	ldd	r16, Y+14	; 0x0e
 258:	1f 85       	ldd	r17, Y+15	; 0x0f
 25a:	80 e0       	ldi	r24, 0x00	; 0
 25c:	90 e0       	ldi	r25, 0x00	; 0
 25e:	be 01       	movw	r22, r28
 260:	0e 94 00 00 	call	0	; 0x0 <marqueeUpdate>
			}
			CRITICAL_SECTION_END;
 264:	df be       	out	0x3f, r13	; 63
 266:	00 c0       	rjmp	.+0      	; 0x268 <marqueeSendByte+0xde>
		}else if(byte!='\r'){
 268:	2d e0       	ldi	r18, 0x0D	; 13
 26a:	c2 16       	cp	r12, r18
 26c:	01 f0       	breq	.+0      	; 0x26e <marqueeSendByte+0xe4>
			// Now put the character to the buffer
			if(marquee->writePos < marquee->txtSize){
 26e:	28 85       	ldd	r18, Y+8	; 0x08
 270:	39 85       	ldd	r19, Y+9	; 0x09
 272:	4a 85       	ldd	r20, Y+10	; 0x0a
 274:	5b 85       	ldd	r21, Y+11	; 0x0b
 276:	24 17       	cp	r18, r20
 278:	35 07       	cpc	r19, r21
 27a:	00 f4       	brcc	.+0      	; 0x27c <marqueeSendByte+0xf2>
				char* put = marquee->txt + marquee->writePos;
 27c:	fc 01       	movw	r30, r24
 27e:	e2 0f       	add	r30, r18
 280:	f3 1f       	adc	r31, r19
				CRITICAL_SECTION_START;
 282:	2f b7       	in	r18, 0x3f	; 63
 284:	f8 94       	cli
				*put++ = byte;
 286:	c0 82       	st	Z, r12
				*put = '\0';
 288:	11 82       	std	Z+1, r1	; 0x01
				marquee->writePos += 1;
 28a:	88 85       	ldd	r24, Y+8	; 0x08
 28c:	99 85       	ldd	r25, Y+9	; 0x09
 28e:	01 96       	adiw	r24, 0x01	; 1
 290:	99 87       	std	Y+9, r25	; 0x09
 292:	88 87       	std	Y+8, r24	; 0x08
				marquee->readPos = 0;
 294:	1f 82       	std	Y+7, r1	; 0x07
 296:	1e 82       	std	Y+6, r1	; 0x06
				CRITICAL_SECTION_END;
 298:	2f bf       	out	0x3f, r18	; 63
			}
		}
	}
	return byte;
}
 29a:	8c 2d       	mov	r24, r12
 29c:	df 91       	pop	r29
 29e:	cf 91       	pop	r28
 2a0:	1f 91       	pop	r17
 2a2:	0f 91       	pop	r16
 2a4:	ff 90       	pop	r15
 2a6:	ef 90       	pop	r14
 2a8:	df 90       	pop	r13
 2aa:	cf 90       	pop	r12
 2ac:	08 95       	ret

000002ae <marqueeStop>:


// Stop an existing marquee
void marqueeStop(MARQUEE* marquee){
 2ae:	fc 01       	movw	r30, r24
	if(marquee && marquee->txt){
 2b0:	00 97       	sbiw	r24, 0x00	; 0
 2b2:	01 f0       	breq	.+0      	; 0x2b4 <marqueeStop+0x6>
 2b4:	84 81       	ldd	r24, Z+4	; 0x04
 2b6:	95 81       	ldd	r25, Z+5	; 0x05
 2b8:	00 97       	sbiw	r24, 0x00	; 0
 2ba:	01 f0       	breq	.+0      	; 0x2bc <marqueeStop+0xe>
		CRITICAL_SECTION_START;
 2bc:	8f b7       	in	r24, 0x3f	; 63
 2be:	f8 94       	cli
		marquee->readPos = marquee->writePos = 0;
 2c0:	11 86       	std	Z+9, r1	; 0x09
 2c2:	10 86       	std	Z+8, r1	; 0x08
 2c4:	17 82       	std	Z+7, r1	; 0x07
 2c6:	16 82       	std	Z+6, r1	; 0x06
		marquee->txt[0]='\0';
 2c8:	04 80       	ldd	r0, Z+4	; 0x04
 2ca:	f5 81       	ldd	r31, Z+5	; 0x05
 2cc:	e0 2d       	mov	r30, r0
 2ce:	10 82       	st	Z, r1
		CRITICAL_SECTION_END;
 2d0:	8f bf       	out	0x3f, r24	; 63
 2d2:	08 95       	ret

000002d4 <marqueeIsActive>:
	}
}

// Is there an existing message being scrolled
boolean marqueeIsActive(const MARQUEE * marquee){
	return (marquee->active) ? TRUE : FALSE;
 2d4:	fc 01       	movw	r30, r24
 2d6:	84 89       	ldd	r24, Z+20	; 0x14
 2d8:	80 ff       	sbrs	r24, 0
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <marqueeIsActive+0x8>
 2dc:	8f ef       	ldi	r24, 0xFF	; 255
 2de:	08 95       	ret
 2e0:	80 e0       	ldi	r24, 0x00	; 0
}
 2e2:	08 95       	ret

000002e4 <marqueeSetCharDelay>:

void marqueeSetCharDelay(MARQUEE* marquee,TICK_COUNT delay){
	CRITICAL_SECTION_START;
 2e4:	2f b7       	in	r18, 0x3f	; 63
 2e6:	f8 94       	cli
	marquee->delayChar = delay;
 2e8:	fc 01       	movw	r30, r24
 2ea:	44 87       	std	Z+12, r20	; 0x0c
 2ec:	55 87       	std	Z+13, r21	; 0x0d
 2ee:	66 87       	std	Z+14, r22	; 0x0e
 2f0:	77 87       	std	Z+15, r23	; 0x0f
	CRITICAL_SECTION_END;
 2f2:	2f bf       	out	0x3f, r18	; 63
}
 2f4:	08 95       	ret

000002f6 <marqueeSetEndDelay>:

void marqueeSetEndDelay(MARQUEE* marquee,TICK_COUNT delay){
	CRITICAL_SECTION_START;
 2f6:	2f b7       	in	r18, 0x3f	; 63
 2f8:	f8 94       	cli
	marquee->delayEnd = delay;
 2fa:	fc 01       	movw	r30, r24
 2fc:	40 8b       	std	Z+16, r20	; 0x10
 2fe:	51 8b       	std	Z+17, r21	; 0x11
 300:	62 8b       	std	Z+18, r22	; 0x12
 302:	73 8b       	std	Z+19, r23	; 0x13
	CRITICAL_SECTION_END;
 304:	2f bf       	out	0x3f, r18	; 63
}
 306:	08 95       	ret

servoMux.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003c0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  000003f4  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003f4  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001271  00000000  00000000  000003f8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002e2  00000000  00000000  00001669  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000898  00000000  00000000  0000194b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000021e3  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000060  00000000  00000000  00002203  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000001f8  00000000  00000000  00002263  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000009df  00000000  00000000  0000245b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000e8  00000000  00000000  00002e3c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <mux_setSpeed>:
	//compareSetThreshold(channel,newPos);
	PORT port = driver->specific.softwareMUX.pwmPort;
	_SFR_MEM16(port) = newPos; 					// set 16 bit word
}

static void mux_setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
	SERVO* servo = (SERVO*)actuator;

	// Interpolate the values
	uint16_t ticks=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
   a:	2c 85       	ldd	r18, Y+12	; 0x0c
   c:	3d 85       	ldd	r19, Y+13	; 0x0d
   e:	0e 85       	ldd	r16, Y+14	; 0x0e
  10:	1f 85       	ldd	r17, Y+15	; 0x0f
  12:	86 2f       	mov	r24, r22
  14:	99 27       	eor	r25, r25
  16:	87 fd       	sbrc	r24, 7
  18:	90 95       	com	r25
  1a:	61 e8       	ldi	r22, 0x81	; 129
  1c:	7f ef       	ldi	r23, 0xFF	; 255
  1e:	4f e7       	ldi	r20, 0x7F	; 127
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

	// The min/max ticks are based on a 20ms frequency, but we actually using 2.5ms
	// so multiply by 20/2.5 = 8
	ticks *= 8;		//
  26:	e3 e0       	ldi	r30, 0x03	; 3
  28:	88 0f       	add	r24, r24
  2a:	99 1f       	adc	r25, r25
  2c:	ea 95       	dec	r30
  2e:	01 f4       	brne	.+0      	; 0x30 <mux_setSpeed+0x30>

	if(ticks!=servo->delay){
  30:	28 89       	ldd	r18, Y+16	; 0x10
  32:	39 89       	ldd	r19, Y+17	; 0x11
  34:	82 17       	cp	r24, r18
  36:	93 07       	cpc	r25, r19
  38:	01 f0       	breq	.+0      	; 0x3a <mux_setSpeed+0x3a>
		CRITICAL_SECTION{
  3a:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  3c:	f8 94       	cli
			servo->delay = ticks;
  3e:	99 8b       	std	Y+17, r25	; 0x11
  40:	88 8b       	std	Y+16, r24	; 0x10
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  42:	2f bf       	out	0x3f, r18	; 63
		};
	}
}
  44:	df 91       	pop	r29
  46:	cf 91       	pop	r28
  48:	1f 91       	pop	r17
  4a:	0f 91       	pop	r16
  4c:	08 95       	ret

0000004e <service>:

/**
 * We have just hit top and are starting to count down again.
 * The new PWM duty cycle has been clocked in for the next servo
 */
static void service(const Timer *timer, void* data){
  4e:	af 92       	push	r10
  50:	bf 92       	push	r11
  52:	df 92       	push	r13
  54:	ef 92       	push	r14
  56:	ff 92       	push	r15
  58:	0f 93       	push	r16
  5a:	1f 93       	push	r17
  5c:	cf 93       	push	r28
  5e:	df 93       	push	r29
  60:	5c 01       	movw	r10, r24
  62:	7b 01       	movw	r14, r22
	SERVO_DRIVER* driver = data;
	uint8_t i;

	// Move to the next servo
	uint8_t index = (driver->specific.softwareMUX.currentServo + 1)& 7;
  64:	db 01       	movw	r26, r22
  66:	17 96       	adiw	r26, 0x07	; 7
  68:	1c 91       	ld	r17, X
  6a:	17 97       	sbiw	r26, 0x07	; 7
  6c:	1f 5f       	subi	r17, 0xFF	; 255
  6e:	17 70       	andi	r17, 0x07	; 7
	driver->specific.softwareMUX.currentServo = index;
  70:	17 96       	adiw	r26, 0x07	; 7
  72:	1c 93       	st	X, r17
  74:	17 97       	sbiw	r26, 0x07	; 7
  76:	eb 01       	movw	r28, r22

	// Set the multiplex pins so the pulse goes to the correct servo
	// This needs to be done quickly to stop the start of the pulse
	// going to the wrong sevo
	uint8_t bits = index;
  78:	d1 2e       	mov	r13, r17
	for (i = 0; i < NUM_MUX_PINS; i++){
  7a:	00 e0       	ldi	r16, 0x00	; 0
		const IOPin* pin = driver->specific.softwareMUX.muxPins[i];
  7c:	8a 85       	ldd	r24, Y+10	; 0x0a
  7e:	9b 85       	ldd	r25, Y+11	; 0x0b
		if(bits & 1){
  80:	d0 fe       	sbrs	r13, 0
  82:	00 c0       	rjmp	.+0      	; 0x84 <service+0x36>
			pin_high(pin);
  84:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
  88:	00 c0       	rjmp	.+0      	; 0x8a <service+0x3c>
		}else{
			pin_low(pin);
  8a:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		}
		bits >>= 1;
  8e:	d6 94       	lsr	r13

	// Set the multiplex pins so the pulse goes to the correct servo
	// This needs to be done quickly to stop the start of the pulse
	// going to the wrong sevo
	uint8_t bits = index;
	for (i = 0; i < NUM_MUX_PINS; i++){
  90:	0f 5f       	subi	r16, 0xFF	; 255
  92:	22 96       	adiw	r28, 0x02	; 2
  94:	03 30       	cpi	r16, 0x03	; 3
  96:	01 f4       	brne	.+0      	; 0x98 <service+0x4a>
		bits >>= 1;
	}

	// Keep track of the lowest value of the timer counter
	// Setting a delay between this value and TOP will mean the mux bits dont get changed in time
	uint16_t thisDelay = timerGetCounter(timer);
  98:	c5 01       	movw	r24, r10
  9a:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
	if(thisDelay < maxDelay){
  9e:	20 91 00 00 	lds	r18, 0x0000
  a2:	30 91 00 00 	lds	r19, 0x0000
  a6:	82 17       	cp	r24, r18
  a8:	93 07       	cpc	r25, r19
  aa:	00 f4       	brcc	.+0      	; 0xac <service+0x5e>
		maxDelay = thisDelay;
  ac:	90 93 00 00 	sts	0x0000, r25
  b0:	80 93 00 00 	sts	0x0000, r24
	}

	// Time critical part is over
	// Now calculate the pulse width for next servo
	uint16_t newPos=0;
	index = (index + 1) & 7;
  b4:	1f 5f       	subi	r17, 0xFF	; 255
  b6:	17 70       	andi	r17, 0x07	; 7
	if(index < driver->num_servos){
  b8:	f7 01       	movw	r30, r14
  ba:	82 81       	ldd	r24, Z+2	; 0x02
  bc:	18 17       	cp	r17, r24
  be:	00 f4       	brcc	.+0      	; 0xc0 <service+0x72>
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[index]);
  c0:	81 2f       	mov	r24, r17
  c2:	90 e0       	ldi	r25, 0x00	; 0
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	01 90       	ld	r0, Z+
  ca:	f0 81       	ld	r31, Z
  cc:	e0 2d       	mov	r30, r0
  ce:	e8 0f       	add	r30, r24
  d0:	f9 1f       	adc	r31, r25
  d2:	85 91       	lpm	r24, Z+
  d4:	94 91       	lpm	r25, Z
  d6:	fc 01       	movw	r30, r24
		if(servo->actuator.connected){
  d8:	83 81       	ldd	r24, Z+3	; 0x03
  da:	80 ff       	sbrs	r24, 0
  dc:	00 c0       	rjmp	.+0      	; 0xde <service+0x90>
			newPos = servo->delay;
  de:	20 89       	ldd	r18, Z+16	; 0x10
  e0:	31 89       	ldd	r19, Z+17	; 0x11

			// Limit to the maximum value
			uint16_t limit = maxDelay;
  e2:	80 91 00 00 	lds	r24, 0x0000
  e6:	90 91 00 00 	lds	r25, 0x0000
  ea:	28 17       	cp	r18, r24
  ec:	39 07       	cpc	r19, r25
  ee:	00 f4       	brcc	.+0      	; 0xf0 <service+0xa2>
  f0:	c9 01       	movw	r24, r18
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <service+0xa6>
		maxDelay = thisDelay;
	}

	// Time critical part is over
	// Now calculate the pulse width for next servo
	uint16_t newPos=0;
  f4:	80 e0       	ldi	r24, 0x00	; 0
  f6:	90 e0       	ldi	r25, 0x00	; 0
	}

	// Set the threshold inline - to save more registers push/pops
	//compareSetThreshold(channel,newPos);
	PORT port = driver->specific.softwareMUX.pwmPort;
	_SFR_MEM16(port) = newPos; 					// set 16 bit word
  f8:	d7 01       	movw	r26, r14
  fa:	50 96       	adiw	r26, 0x10	; 16
  fc:	ed 91       	ld	r30, X+
  fe:	fc 91       	ld	r31, X
 100:	51 97       	sbiw	r26, 0x11	; 17
 102:	91 83       	std	Z+1, r25	; 0x01
 104:	80 83       	st	Z, r24
}
 106:	df 91       	pop	r29
 108:	cf 91       	pop	r28
 10a:	1f 91       	pop	r17
 10c:	0f 91       	pop	r16
 10e:	ff 90       	pop	r15
 110:	ef 90       	pop	r14
 112:	df 90       	pop	r13
 114:	bf 90       	pop	r11
 116:	af 90       	pop	r10
 118:	08 95       	ret

0000011a <servosMuxInit>:
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 11a:	2f 92       	push	r2
 11c:	3f 92       	push	r3
 11e:	4f 92       	push	r4
 120:	5f 92       	push	r5
 122:	6f 92       	push	r6
 124:	7f 92       	push	r7
 126:	8f 92       	push	r8
 128:	9f 92       	push	r9
 12a:	af 92       	push	r10
 12c:	bf 92       	push	r11
 12e:	cf 92       	push	r12
 130:	df 92       	push	r13
 132:	ef 92       	push	r14
 134:	ff 92       	push	r15
 136:	0f 93       	push	r16
 138:	1f 93       	push	r17
 13a:	cf 93       	push	r28
 13c:	df 93       	push	r29
 13e:	cd b7       	in	r28, 0x3d	; 61
 140:	de b7       	in	r29, 0x3e	; 62
 142:	2a 97       	sbiw	r28, 0x0a	; 10
 144:	0f b6       	in	r0, 0x3f	; 63
 146:	f8 94       	cli
 148:	de bf       	out	0x3e, r29	; 62
 14a:	0f be       	out	0x3f, r0	; 63
 14c:	cd bf       	out	0x3d, r28	; 61
 14e:	7c 01       	movw	r14, r24
 150:	cb 01       	movw	r24, r22
 152:	5a 83       	std	Y+2, r21	; 0x02
 154:	49 83       	std	Y+1, r20	; 0x01
 156:	3c 83       	std	Y+4, r19	; 0x04
 158:	2b 83       	std	Y+3, r18	; 0x03
 15a:	1e 83       	std	Y+6, r17	; 0x06
 15c:	0d 83       	std	Y+5, r16	; 0x05
	const TimerCompare* channel = compareFromIOPin(pwm16);
 15e:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 162:	1c 01       	movw	r2, r24
	const Timer* timer = (channel==null) ? null : compareGetTimer(channel);
 164:	00 97       	sbiw	r24, 0x00	; 0
 166:	01 f4       	brne	.+0      	; 0x168 <servosMuxInit+0x4e>
 168:	00 c0       	rjmp	.+0      	; 0x16a <servosMuxInit+0x50>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 16a:	fc 01       	movw	r30, r24
 16c:	32 96       	adiw	r30, 0x02	; 2
 16e:	e4 91       	lpm	r30, Z
 170:	f0 e0       	ldi	r31, 0x00	; 0
 172:	8c e2       	ldi	r24, 0x2C	; 44
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	e8 9f       	mul	r30, r24
 178:	60 01       	movw	r12, r0
 17a:	e9 9f       	mul	r30, r25
 17c:	d0 0c       	add	r13, r0
 17e:	f8 9f       	mul	r31, r24
 180:	d0 0c       	add	r13, r0
 182:	11 24       	eor	r1, r1
 184:	80 e0       	ldi	r24, 0x00	; 0
 186:	90 e0       	ldi	r25, 0x00	; 0
 188:	c8 0e       	add	r12, r24
 18a:	d9 1e       	adc	r13, r25

	if(timer!=null && timerIs16bit(timer)){
 18c:	c1 14       	cp	r12, r1
 18e:	d1 04       	cpc	r13, r1
 190:	01 f4       	brne	.+0      	; 0x192 <servosMuxInit+0x78>
 192:	00 c0       	rjmp	.+0      	; 0x194 <servosMuxInit+0x7a>
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 194:	f6 01       	movw	r30, r12
 196:	36 96       	adiw	r30, 0x06	; 6
 198:	e4 91       	lpm	r30, Z
 19a:	ee 23       	and	r30, r30
 19c:	01 f4       	brne	.+0      	; 0x19e <servosMuxInit+0x84>
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <servosMuxInit+0x86>

		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
 1a0:	8b e0       	ldi	r24, 0x0B	; 11
 1a2:	90 e0       	ldi	r25, 0x00	; 0
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
 1a4:	41 e0       	ldi	r20, 0x01	; 1
 1a6:	64 2e       	mov	r6, r20
 1a8:	71 2c       	mov	r7, r1
			int inx = __timerPrescalerIndex(timer, prescale);
			if(inx!=-1){
				// TOP=F_CPU / (2 * Prescaler * 400Hz)
			    uint32_t top = cpu_speed / (uint16_t)(2U*400U * prescale);
 1aa:	50 e2       	ldi	r21, 0x20	; 32
 1ac:	45 2e       	mov	r4, r21
 1ae:	53 e0       	ldi	r21, 0x03	; 3
 1b0:	55 2e       	mov	r5, r21
 1b2:	80 90 00 00 	lds	r8, 0x0000
 1b6:	90 90 00 00 	lds	r9, 0x0000
 1ba:	a0 90 00 00 	lds	r10, 0x0000
 1be:	b0 90 00 00 	lds	r11, 0x0000
 1c2:	98 87       	std	Y+8, r25	; 0x08
 1c4:	8f 83       	std	Y+7, r24	; 0x07
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
			int inx = __timerPrescalerIndex(timer, prescale);
 1c6:	c6 01       	movw	r24, r12
 1c8:	b3 01       	movw	r22, r6
 1ca:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			if(inx!=-1){
 1ce:	ef ef       	ldi	r30, 0xFF	; 255
 1d0:	8f 3f       	cpi	r24, 0xFF	; 255
 1d2:	9e 07       	cpc	r25, r30
 1d4:	01 f0       	breq	.+0      	; 0x1d6 <servosMuxInit+0xbc>
				// TOP=F_CPU / (2 * Prescaler * 400Hz)
			    uint32_t top = cpu_speed / (uint16_t)(2U*400U * prescale);
 1d6:	64 9c       	mul	r6, r4
 1d8:	90 01       	movw	r18, r0
 1da:	65 9c       	mul	r6, r5
 1dc:	30 0d       	add	r19, r0
 1de:	74 9c       	mul	r7, r4
 1e0:	30 0d       	add	r19, r0
 1e2:	11 24       	eor	r1, r1
 1e4:	40 e0       	ldi	r20, 0x00	; 0
 1e6:	50 e0       	ldi	r21, 0x00	; 0
 1e8:	c5 01       	movw	r24, r10
 1ea:	b4 01       	movw	r22, r8
 1ec:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 1f0:	89 01       	movw	r16, r18
 1f2:	9a 01       	movw	r18, r20
			    if(top <= maxTop){
 1f4:	00 30       	cpi	r16, 0x00	; 0
 1f6:	f0 e0       	ldi	r31, 0x00	; 0
 1f8:	1f 07       	cpc	r17, r31
 1fa:	f1 e0       	ldi	r31, 0x01	; 1
 1fc:	2f 07       	cpc	r18, r31
 1fe:	f0 e0       	ldi	r31, 0x00	; 0
 200:	3f 07       	cpc	r19, r31
 202:	00 f0       	brcs	.+0      	; 0x204 <servosMuxInit+0xea>
		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
		uint32_t maxTop = (timerIs16bit(timer)) ? 0xFFFFU : 0xFFU;
		for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
 204:	66 0c       	add	r6, r6
 206:	77 1c       	adc	r7, r7
 208:	8f 81       	ldd	r24, Y+7	; 0x07
 20a:	98 85       	ldd	r25, Y+8	; 0x08
 20c:	01 97       	sbiw	r24, 0x01	; 1
 20e:	98 87       	std	Y+8, r25	; 0x08
 210:	8f 83       	std	Y+7, r24	; 0x07
 212:	00 97       	sbiw	r24, 0x00	; 0
 214:	01 f4       	brne	.+0      	; 0x216 <servosMuxInit+0xfc>
		int i;

		// Select a prescaler that allows us to have a cycle time of 2.5ms
		// ie 20ms / 8 servers = 2.5ms per servo. 2.5ms = 400Hz
		uint16_t prescale;
		uint16_t bestTop=0;
 216:	00 e0       	ldi	r16, 0x00	; 0
 218:	10 e0       	ldi	r17, 0x00	; 0
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 21a:	f6 01       	movw	r30, r12
 21c:	34 96       	adiw	r30, 0x04	; 4
 21e:	85 91       	lpm	r24, Z+
 220:	94 91       	lpm	r25, Z
 222:	fc 01       	movw	r30, r24
 224:	80 81       	ld	r24, Z
 226:	90 e0       	ldi	r25, 0x00	; 0
 228:	87 70       	andi	r24, 0x07	; 7
 22a:	90 70       	andi	r25, 0x00	; 0
 22c:	00 97       	sbiw	r24, 0x00	; 0
 22e:	01 f4       	brne	.+0      	; 0x230 <servosMuxInit+0x116>
 230:	00 c0       	rjmp	.+0      	; 0x232 <servosMuxInit+0x118>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 232:	f6 01       	movw	r30, r12
 234:	a5 91       	lpm	r26, Z+
 236:	b4 91       	lpm	r27, Z
		}


		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			if(timerGetMode(timer) != TIMER_MODE_PWM_PHASE_CORRECT_ICR
 238:	1a 96       	adiw	r26, 0x0a	; 10
 23a:	8c 91       	ld	r24, X
 23c:	1a 97       	sbiw	r26, 0x0a	; 10
 23e:	8a 30       	cpi	r24, 0x0A	; 10
 240:	01 f4       	brne	.+0      	; 0x242 <servosMuxInit+0x128>
					|| timerGetPrescaler(timer)!=prescale
 242:	8d 91       	ld	r24, X+
 244:	9c 91       	ld	r25, X
 246:	11 97       	sbiw	r26, 0x01	; 1
 248:	86 15       	cp	r24, r6
 24a:	97 05       	cpc	r25, r7
 24c:	01 f4       	brne	.+0      	; 0x24e <servosMuxInit+0x134>
					|| timerGetTOP(timer)!=bestTop
 24e:	c6 01       	movw	r24, r12
 250:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 254:	80 17       	cp	r24, r16
 256:	91 07       	cpc	r25, r17
 258:	01 f0       	breq	.+0      	; 0x25a <servosMuxInit+0x140>
					){
				setError(PWM_TIMER_IN_USE);
 25a:	82 ef       	ldi	r24, 0xF2	; 242
 25c:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			// Set the ICR
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
			_SFR_MEM16(icrPort)=bestTop;
		}
		// Use non-inverted PWM
		compareSetOutputMode(channel,CHANNEL_MODE_NON_INVERTING);
 260:	c1 01       	movw	r24, r2
 262:	62 e0       	ldi	r22, 0x02	; 2
 264:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>


		driver->specific.softwareMUX.currentServo = driver->num_servos;
 268:	f7 01       	movw	r30, r14
 26a:	82 81       	ldd	r24, Z+2	; 0x02
 26c:	87 83       	std	Z+7, r24	; 0x07
		driver->specific.softwareMUX.servo_cycle = bestTop;
 26e:	11 87       	std	Z+9, r17	; 0x09
 270:	00 87       	std	Z+8, r16	; 0x08

		// Set all the multiplex pins as output low
		driver->specific.softwareMUX.muxPins[0] = mux1;
 272:	89 81       	ldd	r24, Y+1	; 0x01
 274:	9a 81       	ldd	r25, Y+2	; 0x02
 276:	93 87       	std	Z+11, r25	; 0x0b
 278:	82 87       	std	Z+10, r24	; 0x0a
		driver->specific.softwareMUX.muxPins[1] = mux2;
 27a:	8b 81       	ldd	r24, Y+3	; 0x03
 27c:	9c 81       	ldd	r25, Y+4	; 0x04
 27e:	95 87       	std	Z+13, r25	; 0x0d
 280:	84 87       	std	Z+12, r24	; 0x0c
		driver->specific.softwareMUX.muxPins[2] = mux3;
 282:	8d 81       	ldd	r24, Y+5	; 0x05
 284:	9e 81       	ldd	r25, Y+6	; 0x06
 286:	97 87       	std	Z+15, r25	; 0x0f
 288:	86 87       	std	Z+14, r24	; 0x0e
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
 28a:	f1 01       	movw	r30, r2
 28c:	36 96       	adiw	r30, 0x06	; 6
 28e:	85 91       	lpm	r24, Z+
 290:	94 91       	lpm	r25, Z
		driver->specific.softwareMUX.pwmPort = port;
 292:	f7 01       	movw	r30, r14
 294:	80 8b       	std	Z+16, r24	; 0x10
 296:	91 8b       	std	Z+17, r25	; 0x11
		pin_make_output(mux1,FALSE);
 298:	89 81       	ldd	r24, Y+1	; 0x01
 29a:	9a 81       	ldd	r25, Y+2	; 0x02
 29c:	60 e0       	ldi	r22, 0x00	; 0
 29e:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		pin_make_output(mux2,FALSE);
 2a2:	8b 81       	ldd	r24, Y+3	; 0x03
 2a4:	9c 81       	ldd	r25, Y+4	; 0x04
 2a6:	60 e0       	ldi	r22, 0x00	; 0
 2a8:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
		pin_make_output(mux3,FALSE);
 2ac:	8d 81       	ldd	r24, Y+5	; 0x05
 2ae:	9e 81       	ldd	r25, Y+6	; 0x06
 2b0:	60 e0       	ldi	r22, 0x00	; 0
 2b2:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

		maxDelay = bestTop;
 2b6:	10 93 00 00 	sts	0x0000, r17
 2ba:	00 93 00 00 	sts	0x0000, r16

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 2be:	f7 01       	movw	r30, r14
 2c0:	82 80       	ldd	r8, Z+2	; 0x02
 2c2:	aa 24       	eor	r10, r10
 2c4:	bb 24       	eor	r11, r11
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 2c6:	99 24       	eor	r9, r9
		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);

			// Connect the servo to this driver
			servo->actuator.class = &c_mux_Servos;
 2c8:	20 e0       	ldi	r18, 0x00	; 0
 2ca:	42 2e       	mov	r4, r18
 2cc:	20 e0       	ldi	r18, 0x00	; 0
 2ce:	52 2e       	mov	r5, r18
		pin_make_output(mux3,FALSE);

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <servosMuxInit+0x1b8>
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 2d2:	9c 01       	movw	r18, r24
 2d4:	22 0f       	add	r18, r18
 2d6:	33 1f       	adc	r19, r19

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 2d8:	f7 01       	movw	r30, r14
 2da:	80 81       	ld	r24, Z
 2dc:	91 81       	ldd	r25, Z+1	; 0x01
 2de:	82 0f       	add	r24, r18
 2e0:	93 1f       	adc	r25, r19
 2e2:	fc 01       	movw	r30, r24
 2e4:	05 91       	lpm	r16, Z+
 2e6:	14 91       	lpm	r17, Z
 2e8:	98 01       	movw	r18, r16

			// Connect the servo to this driver
			servo->actuator.class = &c_mux_Servos;
 2ea:	f8 01       	movw	r30, r16
 2ec:	51 82       	std	Z+1, r5	; 0x01
 2ee:	40 82       	st	Z, r4
			servo->driver = driver;
 2f0:	f5 82       	std	Z+5, r15	; 0x05
 2f2:	e4 82       	std	Z+4, r14	; 0x04
			servo->top = driver->specific.softwareMUX.servo_cycle;
 2f4:	f7 01       	movw	r30, r14
 2f6:	80 85       	ldd	r24, Z+8	; 0x08
 2f8:	91 85       	ldd	r25, Z+9	; 0x09
 2fa:	f8 01       	movw	r30, r16
 2fc:	93 8b       	std	Z+19, r25	; 0x13
 2fe:	82 8b       	std	Z+18, r24	; 0x12

			servoSetConfig(servo,servo->center_us,servo->range_us);
 300:	60 85       	ldd	r22, Z+8	; 0x08
 302:	71 85       	ldd	r23, Z+9	; 0x09
 304:	42 85       	ldd	r20, Z+10	; 0x0a
 306:	53 85       	ldd	r21, Z+11	; 0x0b
 308:	c8 01       	movw	r24, r16
 30a:	09 87       	std	Y+9, r16	; 0x09
 30c:	3a 87       	std	Y+10, r19	; 0x0a
 30e:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

			// The servo is connected
			act_setConnected(servo,TRUE);
 312:	29 85       	ldd	r18, Y+9	; 0x09
 314:	82 2f       	mov	r24, r18
 316:	91 2f       	mov	r25, r17
 318:	6f ef       	ldi	r22, 0xFF	; 255
 31a:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 31e:	29 85       	ldd	r18, Y+9	; 0x09
 320:	82 2f       	mov	r24, r18
 322:	91 2f       	mov	r25, r17
 324:	60 e0       	ldi	r22, 0x00	; 0
 326:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 32a:	08 94       	sec
 32c:	a1 1c       	adc	r10, r1
 32e:	b1 1c       	adc	r11, r1
}

// Define the class
static const __ACTUATOR_DRIVER_CLASS c_mux_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&mux_setSpeed,null);

void servosMuxInit(SERVO_DRIVER* driver, const IOPin* pwm16, const IOPin* mux1, const IOPin* mux2, const IOPin* mux3){
 330:	c4 01       	movw	r24, r8
 332:	8a 19       	sub	r24, r10
 334:	9b 09       	sbc	r25, r11
		pin_make_output(mux3,FALSE);

		maxDelay = bestTop;

		// Initialise each servo
		for(i= driver->num_servos-1;i>=0;i--){
 336:	ff ef       	ldi	r31, 0xFF	; 255
 338:	8f 3f       	cpi	r24, 0xFF	; 255
 33a:	9f 07       	cpc	r25, r31
 33c:	01 f4       	brne	.+0      	; 0x33e <servosMuxInit+0x224>
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}


		// Set up the timer to start processing interrupts
		if(getError()==0){
 33e:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 342:	88 23       	and	r24, r24
 344:	01 f4       	brne	.+0      	; 0x346 <servosMuxInit+0x22c>
			CRITICAL_SECTION{
 346:	0f b7       	in	r16, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 348:	f8 94       	cli
				timerCaptureAttach(timer,&service,driver,false);
 34a:	c6 01       	movw	r24, r12
 34c:	60 e0       	ldi	r22, 0x00	; 0
 34e:	70 e0       	ldi	r23, 0x00	; 0
 350:	a7 01       	movw	r20, r14
 352:	20 e0       	ldi	r18, 0x00	; 0
 354:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
				// Set 0% duty cycle to start with
				compareSetThreshold(channel,0);
 358:	c1 01       	movw	r24, r2
 35a:	60 e0       	ldi	r22, 0x00	; 0
 35c:	70 e0       	ldi	r23, 0x00	; 0
 35e:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>

				// Do this last as it then turns on the timer
				timerSetPrescaler(timer,prescale);
 362:	c6 01       	movw	r24, r12
 364:	b3 01       	movw	r22, r6
 366:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 36a:	0f bf       	out	0x3f, r16	; 63
 36c:	00 c0       	rjmp	.+0      	; 0x36e <servosMuxInit+0x254>



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 36e:	89 ef       	ldi	r24, 0xF9	; 249
 370:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
 374:	00 c0       	rjmp	.+0      	; 0x376 <servosMuxInit+0x25c>
					|| timerGetTOP(timer)!=bestTop
					){
				setError(PWM_TIMER_IN_USE);
			}
		}else{
			timerSetMode(timer,TIMER_MODE_PWM_PHASE_CORRECT_ICR);
 376:	c6 01       	movw	r24, r12
 378:	6a e0       	ldi	r22, 0x0A	; 10
 37a:	0e 94 00 00 	call	0	; 0x0 <mux_setSpeed>
			// Set the ICR
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
 37e:	f6 01       	movw	r30, r12
 380:	7f 96       	adiw	r30, 0x1f	; 31
 382:	85 91       	lpm	r24, Z+
 384:	94 91       	lpm	r25, Z
			_SFR_MEM16(icrPort)=bestTop;
 386:	fc 01       	movw	r30, r24
 388:	11 83       	std	Z+1, r17	; 0x01
 38a:	00 83       	st	Z, r16
 38c:	00 c0       	rjmp	.+0      	; 0x38e <servosMuxInit+0x274>
	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
	}

}
 38e:	2a 96       	adiw	r28, 0x0a	; 10
 390:	0f b6       	in	r0, 0x3f	; 63
 392:	f8 94       	cli
 394:	de bf       	out	0x3e, r29	; 62
 396:	0f be       	out	0x3f, r0	; 63
 398:	cd bf       	out	0x3d, r28	; 61
 39a:	df 91       	pop	r29
 39c:	cf 91       	pop	r28
 39e:	1f 91       	pop	r17
 3a0:	0f 91       	pop	r16
 3a2:	ff 90       	pop	r15
 3a4:	ef 90       	pop	r14
 3a6:	df 90       	pop	r13
 3a8:	cf 90       	pop	r12
 3aa:	bf 90       	pop	r11
 3ac:	af 90       	pop	r10
 3ae:	9f 90       	pop	r9
 3b0:	8f 90       	pop	r8
 3b2:	7f 90       	pop	r7
 3b4:	6f 90       	pop	r6
 3b6:	5f 90       	pop	r5
 3b8:	4f 90       	pop	r4
 3ba:	3f 90       	pop	r3
 3bc:	2f 90       	pop	r2
 3be:	08 95       	ret

servoPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000026e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000002a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000002a2  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000002a2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   0000108b  00000000  00000000  000002a6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 0000029c  00000000  00000000  00001331  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000005fa  00000000  00000000  000015cd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001bc7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000058  00000000  00000000  00001be7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000183  00000000  00000000  00001c3f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000947  00000000  00000000  00001dc2  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000d8  00000000  00000000  0000270c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setConnected>:

	// Change the duty cycle
	compareSetThreshold(channel,delay);
}

static void setConnected(__ACTUATOR *actuator, boolean connected){
   0:	cf 93       	push	r28
   2:	df 93       	push	r29
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
	SERVO* servo = (SERVO*)actuator;
	const TimerCompare* channel = compareFromIOPin(servo->pin);
   a:	fc 01       	movw	r30, r24
   c:	86 81       	ldd	r24, Z+6	; 0x06
   e:	97 81       	ldd	r25, Z+7	; 0x07
  10:	69 83       	std	Y+1, r22	; 0x01
  12:	0e 94 00 00 	call	0	; 0x0 <setConnected>

	// Turn on/off the pin
	compareSetOutputMode(channel, (connected) ? CHANNEL_MODE_NON_INVERTING : CHANNEL_MODE_DISCONNECT);
  16:	69 81       	ldd	r22, Y+1	; 0x01
  18:	66 23       	and	r22, r22
  1a:	01 f0       	breq	.+0      	; 0x1c <setConnected+0x1c>
  1c:	62 e0       	ldi	r22, 0x02	; 2
  1e:	00 c0       	rjmp	.+0      	; 0x20 <setConnected+0x20>
  20:	60 e0       	ldi	r22, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  26:	0f 90       	pop	r0
  28:	df 91       	pop	r29
  2a:	cf 91       	pop	r28
  2c:	08 95       	ret

0000002e <setSpeed>:
#include "timer.h"
#include "core.h"
#include "servos.h"

// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
  2e:	ef 92       	push	r14
  30:	ff 92       	push	r15
  32:	0f 93       	push	r16
  34:	1f 93       	push	r17
  36:	cf 93       	push	r28
  38:	df 93       	push	r29
  3a:	0f 92       	push	r0
  3c:	cd b7       	in	r28, 0x3d	; 61
  3e:	de b7       	in	r29, 0x3e	; 62
  40:	8c 01       	movw	r16, r24
	SERVO* servo = (SERVO*)actuator;
	const TimerCompare* channel = compareFromIOPin(servo->pin);
  42:	fc 01       	movw	r30, r24
  44:	86 81       	ldd	r24, Z+6	; 0x06
  46:	97 81       	ldd	r25, Z+7	; 0x07
  48:	69 83       	std	Y+1, r22	; 0x01
  4a:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  4e:	7c 01       	movw	r14, r24

	// Interpolate the values
	uint16_t delay = interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
  50:	f8 01       	movw	r30, r16
  52:	24 85       	ldd	r18, Z+12	; 0x0c
  54:	35 85       	ldd	r19, Z+13	; 0x0d
  56:	06 85       	ldd	r16, Z+14	; 0x0e
  58:	17 85       	ldd	r17, Z+15	; 0x0f
  5a:	69 81       	ldd	r22, Y+1	; 0x01
  5c:	86 2f       	mov	r24, r22
  5e:	99 27       	eor	r25, r25
  60:	87 fd       	sbrc	r24, 7
  62:	90 95       	com	r25
  64:	61 e8       	ldi	r22, 0x81	; 129
  66:	7f ef       	ldi	r23, 0xFF	; 255
  68:	4f e7       	ldi	r20, 0x7F	; 127
  6a:	50 e0       	ldi	r21, 0x00	; 0
  6c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
  70:	bc 01       	movw	r22, r24
//	servo->delay = delay;

	// Change the duty cycle
	compareSetThreshold(channel,delay);
  72:	c7 01       	movw	r24, r14
  74:	0e 94 00 00 	call	0	; 0x0 <setConnected>
}
  78:	0f 90       	pop	r0
  7a:	df 91       	pop	r29
  7c:	cf 91       	pop	r28
  7e:	1f 91       	pop	r17
  80:	0f 91       	pop	r16
  82:	ff 90       	pop	r15
  84:	ef 90       	pop	r14
  86:	08 95       	ret

00000088 <servoPWMInit>:


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  88:	2f 92       	push	r2
  8a:	3f 92       	push	r3
  8c:	4f 92       	push	r4
  8e:	5f 92       	push	r5
  90:	6f 92       	push	r6
  92:	7f 92       	push	r7
  94:	8f 92       	push	r8
  96:	9f 92       	push	r9
  98:	af 92       	push	r10
  9a:	bf 92       	push	r11
  9c:	cf 92       	push	r12
  9e:	df 92       	push	r13
  a0:	ef 92       	push	r14
  a2:	ff 92       	push	r15
  a4:	0f 93       	push	r16
  a6:	1f 93       	push	r17
  a8:	cf 93       	push	r28
  aa:	df 93       	push	r29
  ac:	00 d0       	rcall	.+0      	; 0xae <servoPWMInit+0x26>
  ae:	00 d0       	rcall	.+0      	; 0xb0 <servoPWMInit+0x28>
  b0:	cd b7       	in	r28, 0x3d	; 61
  b2:	de b7       	in	r29, 0x3e	; 62
  b4:	2c 01       	movw	r4, r24
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
  b6:	fc 01       	movw	r30, r24
  b8:	82 81       	ldd	r24, Z+2	; 0x02
  ba:	66 24       	eor	r6, r6
  bc:	77 24       	eor	r7, r7


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	9c 01       	movw	r18, r24
  c2:	21 50       	subi	r18, 0x01	; 1
  c4:	30 40       	sbci	r19, 0x00	; 0
  c6:	3a 83       	std	Y+2, r19	; 0x02
  c8:	29 83       	std	Y+1, r18	; 0x01
  ca:	4f ef       	ldi	r20, 0xFF	; 255
  cc:	24 2e       	mov	r2, r20
  ce:	4f e7       	ldi	r20, 0x7F	; 127
  d0:	34 2e       	mov	r3, r20
  d2:	28 0e       	add	r2, r24
  d4:	39 1e       	adc	r3, r25
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <servoPWMInit+0x50>


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
  d8:	c1 01       	movw	r24, r2
  da:	86 19       	sub	r24, r6
  dc:	97 09       	sbc	r25, r7
  de:	88 0f       	add	r24, r24
  e0:	99 1f       	adc	r25, r25
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  e2:	f2 01       	movw	r30, r4
  e4:	20 81       	ld	r18, Z
  e6:	31 81       	ldd	r19, Z+1	; 0x01
  e8:	28 0f       	add	r18, r24
  ea:	39 1f       	adc	r19, r25
  ec:	f9 01       	movw	r30, r18
  ee:	85 91       	lpm	r24, Z+
  f0:	94 91       	lpm	r25, Z
  f2:	8c 01       	movw	r16, r24

		// Connect the servo to this driver
		servo->driver = driver;
  f4:	fc 01       	movw	r30, r24
  f6:	55 82       	std	Z+5, r5	; 0x05
  f8:	44 82       	std	Z+4, r4	; 0x04

		const TimerCompare* channel = compareFromIOPin(servo->pin);
  fa:	86 81       	ldd	r24, Z+6	; 0x06
  fc:	97 81       	ldd	r25, Z+7	; 0x07
  fe:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 102:	5c 01       	movw	r10, r24
		if(channel==null){
 104:	00 97       	sbiw	r24, 0x00	; 0
 106:	01 f4       	brne	.+0      	; 0x108 <servoPWMInit+0x80>
			setError(PWM_PIN_NOT_AVAILABLE);
 108:	84 ef       	ldi	r24, 0xF4	; 244
 10a:	00 c0       	rjmp	.+0      	; 0x10c <servoPWMInit+0x84>
			continue;
		}
		if(compareIsInUse(channel)){
 10c:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 110:	88 23       	and	r24, r24
 112:	01 f0       	breq	.+0      	; 0x114 <servoPWMInit+0x8c>
			setError(PWM_PIN_IN_USE);
 114:	83 ef       	ldi	r24, 0xF3	; 243
 116:	0e 94 00 00 	call	0	; 0x0 <setConnected>
			continue;
 11a:	00 c0       	rjmp	.+0      	; 0x11c <servoPWMInit+0x94>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 11c:	f5 01       	movw	r30, r10
 11e:	32 96       	adiw	r30, 0x02	; 2
 120:	e4 91       	lpm	r30, Z
 122:	f0 e0       	ldi	r31, 0x00	; 0
		}

		// Find which timer the compare unit is attached to
		const Timer* timer = compareGetTimer(channel);
 124:	8c e2       	ldi	r24, 0x2C	; 44
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	e8 9f       	mul	r30, r24
 12a:	90 01       	movw	r18, r0
 12c:	e9 9f       	mul	r30, r25
 12e:	30 0d       	add	r19, r0
 130:	f8 9f       	mul	r31, r24
 132:	30 0d       	add	r19, r0
 134:	11 24       	eor	r1, r1
 136:	20 50       	subi	r18, 0x00	; 0
 138:	30 40       	sbci	r19, 0x00	; 0
 13a:	3c 83       	std	Y+4, r19	; 0x04
 13c:	2b 83       	std	Y+3, r18	; 0x03
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 13e:	f9 01       	movw	r30, r18
 140:	36 96       	adiw	r30, 0x06	; 6
 142:	e4 91       	lpm	r30, Z

		// We need a 16 bit timer
		if(!timerIs16bit(timer)){
 144:	ee 23       	and	r30, r30
 146:	01 f4       	brne	.+0      	; 0x148 <servoPWMInit+0xc0>
			setError(SERVO_TIMER_MUST_BE_16_BIT);
 148:	89 ef       	ldi	r24, 0xF9	; 249
 14a:	00 c0       	rjmp	.+0      	; 0x14c <servoPWMInit+0xc4>
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
 14c:	eb 81       	ldd	r30, Y+3	; 0x03
 14e:	fc 81       	ldd	r31, Y+4	; 0x04
 150:	39 96       	adiw	r30, 0x09	; 9
 152:	85 91       	lpm	r24, Z+
 154:	94 91       	lpm	r25, Z
 156:	96 ff       	sbrs	r25, 6
 158:	00 c0       	rjmp	.+0      	; 0x15a <servoPWMInit+0xd2>
			setError(PWM_TIMER_MODE_PWM_FAST_ICR_UNSUPPORTED);
			continue;
		}

		// Find the optimum prescale value
		uint16_t prescale=timerGetBestPrescaler(timer, SERVO_CYCLE);
 15a:	8b 81       	ldd	r24, Y+3	; 0x03
 15c:	9c 81       	ldd	r25, Y+4	; 0x04
 15e:	64 e1       	ldi	r22, 0x14	; 20
 160:	70 e0       	ldi	r23, 0x00	; 0
 162:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 166:	4c 01       	movw	r8, r24
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 168:	eb 81       	ldd	r30, Y+3	; 0x03
 16a:	fc 81       	ldd	r31, Y+4	; 0x04
 16c:	34 96       	adiw	r30, 0x04	; 4
 16e:	85 91       	lpm	r24, Z+
 170:	94 91       	lpm	r25, Z
 172:	fc 01       	movw	r30, r24
 174:	80 81       	ld	r24, Z
 176:	90 e0       	ldi	r25, 0x00	; 0
 178:	87 70       	andi	r24, 0x07	; 7
 17a:	90 70       	andi	r25, 0x00	; 0
 17c:	00 97       	sbiw	r24, 0x00	; 0
 17e:	01 f0       	breq	.+0      	; 0x180 <servoPWMInit+0xf8>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 180:	eb 81       	ldd	r30, Y+3	; 0x03
 182:	fc 81       	ldd	r31, Y+4	; 0x04
 184:	a5 91       	lpm	r26, Z+
 186:	b4 91       	lpm	r27, Z
		if(timerIsInUse(timer) && (timerGetPrescaler(timer)!=prescale || timerGetMode(timer)!=TIMER_MODE_PWM_FAST_ICR)){
 188:	8d 91       	ld	r24, X+
 18a:	9c 91       	ld	r25, X
 18c:	11 97       	sbiw	r26, 0x01	; 1
 18e:	88 15       	cp	r24, r8
 190:	99 05       	cpc	r25, r9
 192:	01 f4       	brne	.+0      	; 0x194 <servoPWMInit+0x10c>
 194:	1a 96       	adiw	r26, 0x0a	; 10
 196:	8c 91       	ld	r24, X
 198:	1a 97       	sbiw	r26, 0x0a	; 10
 19a:	8e 30       	cpi	r24, 0x0E	; 14
 19c:	01 f0       	breq	.+0      	; 0x19e <servoPWMInit+0x116>
			setError(PWM_TIMER_IN_USE);
 19e:	82 ef       	ldi	r24, 0xF2	; 242
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <servoPWMInit+0x11a>
			continue;
		}

		// Connect to driver
		servo->actuator.class = &c_servoPWM;
 1a2:	20 e0       	ldi	r18, 0x00	; 0
 1a4:	30 e0       	ldi	r19, 0x00	; 0
 1a6:	f8 01       	movw	r30, r16
 1a8:	31 83       	std	Z+1, r19	; 0x01
 1aa:	20 83       	st	Z, r18

		// Make sure its an output pin, low
		pin_make_output(servo->pin, FALSE);
 1ac:	86 81       	ldd	r24, Z+6	; 0x06
 1ae:	97 81       	ldd	r25, Z+7	; 0x07
 1b0:	60 e0       	ldi	r22, 0x00	; 0
 1b2:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// put the timer into the correct mode
		timerSetMode(timer,TIMER_MODE_PWM_FAST_ICR);
 1b6:	8b 81       	ldd	r24, Y+3	; 0x03
 1b8:	9c 81       	ldd	r25, Y+4	; 0x04
 1ba:	6e e0       	ldi	r22, 0x0E	; 14
 1bc:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Set top for the correct cycle time
		uint16_t top = ticks_per_ms(SERVO_CYCLE,prescale);
 1c0:	64 e1       	ldi	r22, 0x14	; 20
 1c2:	70 e0       	ldi	r23, 0x00	; 0
 1c4:	80 e0       	ldi	r24, 0x00	; 0
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	a4 01       	movw	r20, r8
 1ca:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 1ce:	6b 01       	movw	r12, r22
 1d0:	7c 01       	movw	r14, r24
		compareAttach(channel,&nullTimerCompareCallback,0,null);
 1d2:	c5 01       	movw	r24, r10
 1d4:	60 e0       	ldi	r22, 0x00	; 0
 1d6:	70 e0       	ldi	r23, 0x00	; 0
 1d8:	40 e0       	ldi	r20, 0x00	; 0
 1da:	50 e0       	ldi	r21, 0x00	; 0
 1dc:	20 e0       	ldi	r18, 0x00	; 0
 1de:	30 e0       	ldi	r19, 0x00	; 0
 1e0:	0e 94 00 00 	call	0	; 0x0 <setConnected>
		PORT icr = pgm_read_word(&timer->pgm_icr);
 1e4:	eb 81       	ldd	r30, Y+3	; 0x03
 1e6:	fc 81       	ldd	r31, Y+4	; 0x04
 1e8:	7f 96       	adiw	r30, 0x1f	; 31
 1ea:	85 91       	lpm	r24, Z+
 1ec:	94 91       	lpm	r25, Z
		_SFR_MEM16(icr)=top;
 1ee:	fc 01       	movw	r30, r24
 1f0:	d1 82       	std	Z+1, r13	; 0x01
 1f2:	c0 82       	st	Z, r12
		servo->top = top;
 1f4:	f8 01       	movw	r30, r16
 1f6:	d3 8a       	std	Z+19, r13	; 0x13
 1f8:	c2 8a       	std	Z+18, r12	; 0x12
		uint32_t max = servo->center_us + servo->range_us;
		m2 =  m1 * max;
		m3 =  m2 / SERVO_CYCLE;
		servo->max_ticks = m3;
		*/
		servoSetConfig(servo, servo->center_us, servo->range_us);
 1fa:	60 85       	ldd	r22, Z+8	; 0x08
 1fc:	71 85       	ldd	r23, Z+9	; 0x09
 1fe:	42 85       	ldd	r20, Z+10	; 0x0a
 200:	53 85       	ldd	r21, Z+11	; 0x0b
 202:	c8 01       	movw	r24, r16
 204:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Do this last as it then turns on the timer
		timerSetPrescaler(timer,prescale);
 208:	8b 81       	ldd	r24, Y+3	; 0x03
 20a:	9c 81       	ldd	r25, Y+4	; 0x04
 20c:	b4 01       	movw	r22, r8
 20e:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Start off braking
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 212:	c8 01       	movw	r24, r16
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	0e 94 00 00 	call	0	; 0x0 <setConnected>

		// Indicate the servo is connected
		act_setConnected(servo,TRUE);
 21a:	c8 01       	movw	r24, r16
 21c:	6f ef       	ldi	r22, 0xFF	; 255
 21e:	0e 94 00 00 	call	0	; 0x0 <setConnected>
 222:	08 94       	sec
 224:	61 1c       	adc	r6, r1
 226:	71 1c       	adc	r7, r1


// Pass the list of servos, the list should be in PROGMEM space to save Flash RAM
// The specified Timer must implement timer compare interrupts and, if so, it will
// ise the timer compare channel A (if there is more than one)
void servoPWMInit(SERVO_DRIVER* driver){
 228:	89 81       	ldd	r24, Y+1	; 0x01
 22a:	9a 81       	ldd	r25, Y+2	; 0x02
 22c:	86 19       	sub	r24, r6
 22e:	97 09       	sbc	r25, r7
	// Make sure each servo is set as an output
	for(int i= driver->num_servos-1;i>=0;i--){
 230:	ff ef       	ldi	r31, 0xFF	; 255
 232:	8f 3f       	cpi	r24, 0xFF	; 255
 234:	9f 07       	cpc	r25, r31
 236:	01 f0       	breq	.+0      	; 0x238 <servoPWMInit+0x1b0>
 238:	00 c0       	rjmp	.+0      	; 0x23a <servoPWMInit+0x1b2>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <servoPWMInit+0x1b4>
			continue;
		}

		// Make sure it supports fast pwm using ICR
		if(!timerIsModeSupported(timer,TIMER_MODE_PWM_FAST_ICR)){
			setError(PWM_TIMER_MODE_PWM_FAST_ICR_UNSUPPORTED);
 23c:	81 ef       	ldi	r24, 0xF1	; 241
 23e:	00 c0       	rjmp	.+0      	; 0x240 <servoPWMInit+0x1b8>
		act_setSpeed(servo,DRIVE_SPEED_BRAKE);

		// Indicate the servo is connected
		act_setConnected(servo,TRUE);
	}
}
 240:	0f 90       	pop	r0
 242:	0f 90       	pop	r0
 244:	0f 90       	pop	r0
 246:	0f 90       	pop	r0
 248:	df 91       	pop	r29
 24a:	cf 91       	pop	r28
 24c:	1f 91       	pop	r17
 24e:	0f 91       	pop	r16
 250:	ff 90       	pop	r15
 252:	ef 90       	pop	r14
 254:	df 90       	pop	r13
 256:	cf 90       	pop	r12
 258:	bf 90       	pop	r11
 25a:	af 90       	pop	r10
 25c:	9f 90       	pop	r9
 25e:	8f 90       	pop	r8
 260:	7f 90       	pop	r7
 262:	6f 90       	pop	r6
 264:	5f 90       	pop	r5
 266:	4f 90       	pop	r4
 268:	3f 90       	pop	r3
 26a:	2f 90       	pop	r2
 26c:	08 95       	ret

servos.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000003be  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000003f2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000003f2  2**0
                  ALLOC
  3 .progmem.data 00000004  00000000  00000000  000003f2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   00001346  00000000  00000000  000003f6  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002f2  00000000  00000000  0000173c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    0000081d  00000000  00000000  00001a2e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000224b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000050  00000000  00000000  0000226b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000216  00000000  00000000  000022bb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    000009b5  00000000  00000000  000024d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000010c  00000000  00000000  00002e88  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <setSpeed>:
#define CHANNEL_ON  0
#define CHANNEL_OFF 1


// Callback - for when the speed has been set
static void setSpeed(__ACTUATOR *actuator, DRIVE_SPEED speed){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
   8:	ec 01       	movw	r28, r24
	SERVO* servo = (SERVO*)actuator;

	// Interpolate the values
	uint16_t ticks=interpolateU(speed, DRIVE_SPEED_MIN, DRIVE_SPEED_MAX, servo->min_ticks , servo->max_ticks);
   a:	2c 85       	ldd	r18, Y+12	; 0x0c
   c:	3d 85       	ldd	r19, Y+13	; 0x0d
   e:	0e 85       	ldd	r16, Y+14	; 0x0e
  10:	1f 85       	ldd	r17, Y+15	; 0x0f
  12:	86 2f       	mov	r24, r22
  14:	99 27       	eor	r25, r25
  16:	87 fd       	sbrc	r24, 7
  18:	90 95       	com	r25
  1a:	61 e8       	ldi	r22, 0x81	; 129
  1c:	7f ef       	ldi	r23, 0xFF	; 255
  1e:	4f e7       	ldi	r20, 0x7F	; 127
  20:	50 e0       	ldi	r21, 0x00	; 0
  22:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	if(ticks!=servo->delay){
  26:	28 89       	ldd	r18, Y+16	; 0x10
  28:	39 89       	ldd	r19, Y+17	; 0x11
  2a:	82 17       	cp	r24, r18
  2c:	93 07       	cpc	r25, r19
  2e:	01 f0       	breq	.+0      	; 0x30 <setSpeed+0x30>
		CRITICAL_SECTION{
  30:	2f b7       	in	r18, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
  32:	f8 94       	cli
			servo->delay = ticks;
  34:	99 8b       	std	Y+17, r25	; 0x11
  36:	88 8b       	std	Y+16, r24	; 0x10
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
  38:	2f bf       	out	0x3f, r18	; 63
		};
	}
}
  3a:	df 91       	pop	r29
  3c:	cf 91       	pop	r28
  3e:	1f 91       	pop	r17
  40:	0f 91       	pop	r16
  42:	08 95       	ret

00000044 <__servoEndService>:
// Define the class
static const __ACTUATOR_DRIVER_CLASS c_Servos = MAKE_ACTUATOR_DRIVER_CLASS(&setSpeed,null);


// Called to turn off the current pulse
static void __servoEndService(const TimerCompare *timer_compare, void* data){
  44:	cf 93       	push	r28
  46:	df 93       	push	r29
  48:	ec 01       	movw	r28, r24
  4a:	fb 01       	movw	r30, r22
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;

	if(driver->specific.softwarePWM.currentServo < driver->num_servos){
  4c:	87 81       	ldd	r24, Z+7	; 0x07
  4e:	92 81       	ldd	r25, Z+2	; 0x02
  50:	89 17       	cp	r24, r25
  52:	00 f4       	brcc	.+0      	; 0x54 <__servoEndService+0x10>
		// turn off the previous channel
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[driver->specific.softwarePWM.currentServo]);
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	88 0f       	add	r24, r24
  58:	99 1f       	adc	r25, r25
  5a:	01 90       	ld	r0, Z+
  5c:	f0 81       	ld	r31, Z
  5e:	e0 2d       	mov	r30, r0
  60:	e8 0f       	add	r30, r24
  62:	f9 1f       	adc	r31, r25
  64:	a5 91       	lpm	r26, Z+
  66:	b4 91       	lpm	r27, Z
		pin_low(servo->pin);
  68:	16 96       	adiw	r26, 0x06	; 6
  6a:	8d 91       	ld	r24, X+
  6c:	9c 91       	ld	r25, X
  6e:	17 97       	sbiw	r26, 0x07	; 7
  70:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

	// disable channel that turns pulses off
	__portMaskClear(&timer_compare->pgm_intenable);
  74:	ce 01       	movw	r24, r28
  76:	03 96       	adiw	r24, 0x03	; 3
  78:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

}
  7c:	df 91       	pop	r29
  7e:	cf 91       	pop	r28
  80:	08 95       	ret

00000082 <__servoStartService>:

static void __servoStartService(const TimerCompare *timer_compare, void* data){
  82:	8f 92       	push	r8
  84:	9f 92       	push	r9
  86:	af 92       	push	r10
  88:	bf 92       	push	r11
  8a:	cf 92       	push	r12
  8c:	df 92       	push	r13
  8e:	ef 92       	push	r14
  90:	ff 92       	push	r15
  92:	0f 93       	push	r16
  94:	1f 93       	push	r17
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
  9a:	5c 01       	movw	r10, r24
  9c:	8b 01       	movw	r16, r22
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  9e:	ec 01       	movw	r28, r24
  a0:	22 96       	adiw	r28, 0x02	; 2
  a2:	fe 01       	movw	r30, r28
  a4:	84 91       	lpm	r24, Z
  a6:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t delay;	// The next delay in cycles
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;
	const Timer* timer = compareGetTimer(timer_compare);
  a8:	2c e2       	ldi	r18, 0x2C	; 44
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	82 9f       	mul	r24, r18
  ae:	70 01       	movw	r14, r0
  b0:	83 9f       	mul	r24, r19
  b2:	f0 0c       	add	r15, r0
  b4:	92 9f       	mul	r25, r18
  b6:	f0 0c       	add	r15, r0
  b8:	11 24       	eor	r1, r1
  ba:	80 e0       	ldi	r24, 0x00	; 0
  bc:	90 e0       	ldi	r25, 0x00	; 0
  be:	e8 0e       	add	r14, r24
  c0:	f9 1e       	adc	r15, r25
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  c2:	f7 01       	movw	r30, r14
  c4:	77 96       	adiw	r30, 0x17	; 23
  c6:	85 91       	lpm	r24, Z+
  c8:	94 91       	lpm	r25, Z
  ca:	40 e1       	ldi	r20, 0x10	; 16
  cc:	84 2e       	mov	r8, r20
  ce:	91 2c       	mov	r9, r1
  d0:	88 0e       	add	r8, r24
  d2:	99 1e       	adc	r9, r25
	const TimerCompare* turnOff = timerGetCompare(timer,CHANNEL_OFF);

	// Wait if previous pulse is still going
	while( __portMaskGet(&turnOff->pgm_intenable) ){
  d4:	53 e1       	ldi	r21, 0x13	; 19
  d6:	c5 2e       	mov	r12, r21
  d8:	d1 2c       	mov	r13, r1
  da:	c8 0e       	add	r12, r24
  dc:	d9 1e       	adc	r13, r25
  de:	00 c0       	rjmp	.+0      	; 0xe0 <__servoStartService+0x5e>
		breathe();
  e0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	SERVO_DRIVER* driver = (SERVO_DRIVER*)data;
	const Timer* timer = compareGetTimer(timer_compare);
	const TimerCompare* turnOff = timerGetCompare(timer,CHANNEL_OFF);

	// Wait if previous pulse is still going
	while( __portMaskGet(&turnOff->pgm_intenable) ){
  e4:	c6 01       	movw	r24, r12
  e6:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
  ea:	88 23       	and	r24, r24
  ec:	01 f4       	brne	.+0      	; 0xee <__servoStartService+0x6c>
		breathe();
	}

	// Start processing the next one
	if(driver->servos_init){
  ee:	f8 01       	movw	r30, r16
  f0:	83 81       	ldd	r24, Z+3	; 0x03
  f2:	88 23       	and	r24, r24
  f4:	01 f0       	breq	.+0      	; 0xf6 <__servoStartService+0x74>
		driver->specific.softwarePWM.currentServo++;
  f6:	87 81       	ldd	r24, Z+7	; 0x07
  f8:	8f 5f       	subi	r24, 0xFF	; 255
  fa:	87 83       	std	Z+7, r24	; 0x07
  fc:	00 c0       	rjmp	.+0      	; 0xfe <__servoStartService+0x7c>
	}else{
		driver->servos_init=TRUE;
  fe:	8f ef       	ldi	r24, 0xFF	; 255
 100:	f8 01       	movw	r30, r16
 102:	83 83       	std	Z+3, r24	; 0x03
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 104:	fe 01       	movw	r30, r28
 106:	24 91       	lpm	r18, Z
 108:	30 e0       	ldi	r19, 0x00	; 0
		// Set the threshold to when the first compare was fired
		// so that if there are multiple banks then each bank is
		// reset to use its actual start time.
		compareSetThreshold(timer_compare,timerGetCounter(compareGetTimer(timer_compare)));
 10a:	4c e2       	ldi	r20, 0x2C	; 44
 10c:	50 e0       	ldi	r21, 0x00	; 0
 10e:	24 9f       	mul	r18, r20
 110:	c0 01       	movw	r24, r0
 112:	25 9f       	mul	r18, r21
 114:	90 0d       	add	r25, r0
 116:	34 9f       	mul	r19, r20
 118:	90 0d       	add	r25, r0
 11a:	11 24       	eor	r1, r1
 11c:	80 50       	subi	r24, 0x00	; 0
 11e:	90 40       	sbci	r25, 0x00	; 0
 120:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 124:	bc 01       	movw	r22, r24
 126:	c5 01       	movw	r24, r10
 128:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}

	if(driver->specific.softwarePWM.currentServo != driver->num_servos){
 12c:	f8 01       	movw	r30, r16
 12e:	97 81       	ldd	r25, Z+7	; 0x07
 130:	82 81       	ldd	r24, Z+2	; 0x02
 132:	98 17       	cp	r25, r24
 134:	01 f4       	brne	.+0      	; 0x136 <__servoStartService+0xb4>
 136:	00 c0       	rjmp	.+0      	; 0x138 <__servoStartService+0xb6>
		// do the next servo
		if(driver->specific.softwarePWM.currentServo > driver->num_servos){
 138:	89 17       	cp	r24, r25
 13a:	00 f4       	brcc	.+0      	; 0x13c <__servoStartService+0xba>
			// restart from the beginning
			driver->specific.softwarePWM.currentServo = 0;
 13c:	17 82       	std	Z+7, r1	; 0x07
			driver->specific.softwarePWM.total_delay = 0;
 13e:	11 86       	std	Z+9, r1	; 0x09
 140:	10 86       	std	Z+8, r1	; 0x08

		}

		// Locate the servo
		SERVO* servo = (SERVO *)pgm_read_word(&driver->servos[driver->specific.softwarePWM.currentServo]);
 142:	f8 01       	movw	r30, r16
 144:	87 81       	ldd	r24, Z+7	; 0x07
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	88 0f       	add	r24, r24
 14a:	99 1f       	adc	r25, r25
 14c:	20 81       	ld	r18, Z
 14e:	31 81       	ldd	r19, Z+1	; 0x01
 150:	28 0f       	add	r18, r24
 152:	39 1f       	adc	r19, r25
 154:	f9 01       	movw	r30, r18
 156:	85 91       	lpm	r24, Z+
 158:	94 91       	lpm	r25, Z
 15a:	c8 2f       	mov	r28, r24
 15c:	d9 2f       	mov	r29, r25
		delay = servo->delay;		// The pulse length to set

		uint16_t now = timerGetCounter(timer);
 15e:	c7 01       	movw	r24, r14
 160:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 164:	7c 01       	movw	r14, r24
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
 166:	8b 81       	ldd	r24, Y+3	; 0x03
 168:	80 ff       	sbrs	r24, 0
 16a:	00 c0       	rjmp	.+0      	; 0x16c <__servoStartService+0xea>

		// ignore the servo if its not connected
		if(act_isConnected(servo)){
			// turn on servo channel bit
			pin_high(servo->pin);
 16c:	8e 81       	ldd	r24, Y+6	; 0x06
 16e:	9f 81       	ldd	r25, Y+7	; 0x07
 170:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
		}


		// Set time to turn pin low
		compareSetThreshold(turnOff,servo->delay + now);
 174:	68 89       	ldd	r22, Y+16	; 0x10
 176:	79 89       	ldd	r23, Y+17	; 0x11
 178:	6e 0d       	add	r22, r14
 17a:	7f 1d       	adc	r23, r15
 17c:	c4 01       	movw	r24, r8
 17e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 182:	c4 01       	movw	r24, r8
 184:	08 96       	adiw	r24, 0x08	; 8
 186:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// enable channel that turns pulses off
		compareClearInterruptPending(turnOff);
		__portMaskSet(&turnOff->pgm_intenable);
 18a:	c6 01       	movw	r24, r12
 18c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Set the time to check the next servo
		compareSetThreshold(timer_compare,servo->max_ticks + now);
 190:	6e 85       	ldd	r22, Y+14	; 0x0e
 192:	7f 85       	ldd	r23, Y+15	; 0x0f
 194:	6e 0d       	add	r22, r14
 196:	7f 1d       	adc	r23, r15
 198:	c5 01       	movw	r24, r10
 19a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// Accumulate total time in this pass of the servos
		driver->specific.softwarePWM.total_delay += servo->max_ticks;
 19e:	f8 01       	movw	r30, r16
 1a0:	80 85       	ldd	r24, Z+8	; 0x08
 1a2:	91 85       	ldd	r25, Z+9	; 0x09
 1a4:	2e 85       	ldd	r18, Y+14	; 0x0e
 1a6:	3f 85       	ldd	r19, Y+15	; 0x0f
 1a8:	82 0f       	add	r24, r18
 1aa:	93 1f       	adc	r25, r19
 1ac:	91 87       	std	Z+9, r25	; 0x09
 1ae:	80 87       	std	Z+8, r24	; 0x08
 1b0:	00 c0       	rjmp	.+0      	; 0x1b2 <__servoStartService+0x130>

	}else{
		// disable channel that turns pulses off
		__portMaskClear(&turnOff->pgm_intenable);
 1b2:	c6 01       	movw	r24, r12
 1b4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

		// pause before going back to the first servo
		delay = (driver->specific.softwarePWM.total_delay > driver->specific.softwarePWM.servo_cycle)
 1b8:	f8 01       	movw	r30, r16
 1ba:	80 85       	ldd	r24, Z+8	; 0x08
 1bc:	91 85       	ldd	r25, Z+9	; 0x09
 1be:	c2 85       	ldd	r28, Z+10	; 0x0a
 1c0:	d3 85       	ldd	r29, Z+11	; 0x0b
				? 100
				:  driver->specific.softwarePWM.servo_cycle - driver->specific.softwarePWM.total_delay;
 1c2:	c8 17       	cp	r28, r24
 1c4:	d9 07       	cpc	r29, r25
 1c6:	00 f0       	brcs	.+0      	; 0x1c8 <__servoStartService+0x146>
 1c8:	c8 1b       	sub	r28, r24
 1ca:	d9 0b       	sbc	r29, r25
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <__servoStartService+0x14c>
 1ce:	c4 e6       	ldi	r28, 0x64	; 100
 1d0:	d0 e0       	ldi	r29, 0x00	; 0

		// Re-fire the event
		compareSetThreshold(timer_compare,delay + compareGetThreshold(timer_compare));
 1d2:	c5 01       	movw	r24, r10
 1d4:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 1d8:	bc 01       	movw	r22, r24
 1da:	6c 0f       	add	r22, r28
 1dc:	7d 1f       	adc	r23, r29
 1de:	c5 01       	movw	r24, r10
 1e0:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
	}


}
 1e4:	df 91       	pop	r29
 1e6:	cf 91       	pop	r28
 1e8:	1f 91       	pop	r17
 1ea:	0f 91       	pop	r16
 1ec:	ff 90       	pop	r15
 1ee:	ef 90       	pop	r14
 1f0:	df 90       	pop	r13
 1f2:	cf 90       	pop	r12
 1f4:	bf 90       	pop	r11
 1f6:	af 90       	pop	r10
 1f8:	9f 90       	pop	r9
 1fa:	8f 90       	pop	r8
 1fc:	08 95       	ret

000001fe <servosInit>:

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 1fe:	2f 92       	push	r2
 200:	3f 92       	push	r3
 202:	4f 92       	push	r4
 204:	5f 92       	push	r5
 206:	6f 92       	push	r6
 208:	7f 92       	push	r7
 20a:	8f 92       	push	r8
 20c:	9f 92       	push	r9
 20e:	af 92       	push	r10
 210:	bf 92       	push	r11
 212:	cf 92       	push	r12
 214:	df 92       	push	r13
 216:	ef 92       	push	r14
 218:	ff 92       	push	r15
 21a:	0f 93       	push	r16
 21c:	1f 93       	push	r17
 21e:	cf 93       	push	r28
 220:	df 93       	push	r29
 222:	8c 01       	movw	r16, r24
 224:	5b 01       	movw	r10, r22
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 226:	fb 01       	movw	r30, r22
 228:	77 96       	adiw	r30, 0x17	; 23
 22a:	45 90       	lpm	r4, Z+
 22c:	54 90       	lpm	r5, Z
 22e:	32 01       	movw	r6, r4
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
 230:	fb 01       	movw	r30, r22
 232:	36 96       	adiw	r30, 0x06	; 6
 234:	e4 91       	lpm	r30, Z
	const TimerCompare* channel1 = timerGetCompare(timer,CHANNEL_ON);
	const TimerCompare* channel2 = timerGetCompare(timer,CHANNEL_OFF);

	if(timerIs16bit(timer) && timerNumberOfCompareUnits(timer) >= 2){
 236:	ee 23       	and	r30, r30
 238:	01 f4       	brne	.+0      	; 0x23a <servosInit+0x3c>
 23a:	00 c0       	rjmp	.+0      	; 0x23c <servosInit+0x3e>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
 23c:	fb 01       	movw	r30, r22
 23e:	38 96       	adiw	r30, 0x08	; 8
 240:	e4 91       	lpm	r30, Z
 242:	e2 30       	cpi	r30, 0x02	; 2
 244:	00 f4       	brcc	.+0      	; 0x246 <servosInit+0x48>
 246:	00 c0       	rjmp	.+0      	; 0x248 <servosInit+0x4a>
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 248:	fb 01       	movw	r30, r22
 24a:	34 96       	adiw	r30, 0x04	; 4
 24c:	85 91       	lpm	r24, Z+
 24e:	94 91       	lpm	r25, Z
 250:	fc 01       	movw	r30, r24
 252:	80 81       	ld	r24, Z
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	87 70       	andi	r24, 0x07	; 7
 258:	90 70       	andi	r25, 0x00	; 0
 25a:	00 97       	sbiw	r24, 0x00	; 0
 25c:	01 f4       	brne	.+0      	; 0x25e <servosInit+0x60>
 25e:	00 c0       	rjmp	.+0      	; 0x260 <servosInit+0x62>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 260:	fb 01       	movw	r30, r22
 262:	a5 91       	lpm	r26, Z+
 264:	b4 91       	lpm	r27, Z
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
 266:	8d 90       	ld	r8, X+
 268:	9c 90       	ld	r9, X
 26a:	11 97       	sbiw	r26, 0x01	; 1
		uint16_t prescale;

		// If the timer is already in use then find its prescaler
		if(timerIsInUse(timer)){
			prescale = timerGetPrescaler(timer);
			if(timerGetMode(timer) != TIMER_MODE_NORMAL){
 26c:	1a 96       	adiw	r26, 0x0a	; 10
 26e:	8c 91       	ld	r24, X
 270:	1a 97       	sbiw	r26, 0x0a	; 10
 272:	88 23       	and	r24, r24
 274:	01 f0       	breq	.+0      	; 0x276 <servosInit+0x78>
				setError(PWM_TIMER_IN_USE);
 276:	82 ef       	ldi	r24, 0xF2	; 242
 278:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			}
		}else{
			prescale = timerGetBestPrescaler(timer, SERVO_CYCLE + 5 );
		}

		driver->specific.softwarePWM.currentServo = driver->num_servos;
 27c:	f8 01       	movw	r30, r16
 27e:	82 81       	ldd	r24, Z+2	; 0x02
 280:	87 83       	std	Z+7, r24	; 0x07

		// Find how many timer ticks there will be for SERVO_CYCLE
		uint32_t tmp32 = ticks_per_ms(SERVO_CYCLE,prescale);
 282:	64 e1       	ldi	r22, 0x14	; 20
 284:	70 e0       	ldi	r23, 0x00	; 0
 286:	80 e0       	ldi	r24, 0x00	; 0
 288:	90 e0       	ldi	r25, 0x00	; 0
 28a:	a4 01       	movw	r20, r8
 28c:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 290:	dc 01       	movw	r26, r24
 292:	cb 01       	movw	r24, r22
		driver->specific.softwarePWM.servo_cycle = tmp32;
 294:	f8 01       	movw	r30, r16
 296:	93 87       	std	Z+11, r25	; 0x0b
 298:	82 87       	std	Z+10, r24	; 0x0a
		// make sure it fits
		if( (tmp32 & 0xFFFF0000UL)!=0){
 29a:	80 70       	andi	r24, 0x00	; 0
 29c:	90 70       	andi	r25, 0x00	; 0
 29e:	00 97       	sbiw	r24, 0x00	; 0
 2a0:	a1 05       	cpc	r26, r1
 2a2:	b1 05       	cpc	r27, r1
 2a4:	01 f0       	breq	.+0      	; 0x2a6 <servosInit+0xa8>
			setError(SERVO_TIMING);
 2a6:	86 ee       	ldi	r24, 0xE6	; 230
 2a8:	00 c0       	rjmp	.+0      	; 0x2aa <servosInit+0xac>
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 2aa:	f8 01       	movw	r30, r16
 2ac:	22 80       	ldd	r2, Z+2	; 0x02
 2ae:	cc 24       	eor	r12, r12
 2b0:	dd 24       	eor	r13, r13
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 2b2:	33 24       	eor	r3, r3
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <servosInit+0xb8>
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 2b6:	9c 01       	movw	r18, r24
 2b8:	22 0f       	add	r18, r18
 2ba:	33 1f       	adc	r19, r19
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
			SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
 2bc:	f8 01       	movw	r30, r16
 2be:	80 81       	ld	r24, Z
 2c0:	91 81       	ldd	r25, Z+1	; 0x01
 2c2:	82 0f       	add	r24, r18
 2c4:	93 1f       	adc	r25, r19
 2c6:	fc 01       	movw	r30, r24
 2c8:	e5 90       	lpm	r14, Z+
 2ca:	f4 90       	lpm	r15, Z
 2cc:	ce 2d       	mov	r28, r14
 2ce:	df 2d       	mov	r29, r15

			// Connect the servo to this driver
			servo->actuator.class = &c_Servos;
 2d0:	80 e0       	ldi	r24, 0x00	; 0
 2d2:	90 e0       	ldi	r25, 0x00	; 0
 2d4:	99 83       	std	Y+1, r25	; 0x01
 2d6:	88 83       	st	Y, r24
			servo->driver = driver;
 2d8:	1d 83       	std	Y+5, r17	; 0x05
 2da:	0c 83       	std	Y+4, r16	; 0x04
			servo->top = driver->specific.softwarePWM.servo_cycle;
 2dc:	f8 01       	movw	r30, r16
 2de:	82 85       	ldd	r24, Z+10	; 0x0a
 2e0:	93 85       	ldd	r25, Z+11	; 0x0b
 2e2:	9b 8b       	std	Y+19, r25	; 0x13
 2e4:	8a 8b       	std	Y+18, r24	; 0x12

			pin_make_output(servo->pin, FALSE);
 2e6:	8e 81       	ldd	r24, Y+6	; 0x06
 2e8:	9f 81       	ldd	r25, Y+7	; 0x07
 2ea:	60 e0       	ldi	r22, 0x00	; 0
 2ec:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			servoSetConfig(servo,servo->center_us,servo->range_us);
 2f0:	68 85       	ldd	r22, Y+8	; 0x08
 2f2:	79 85       	ldd	r23, Y+9	; 0x09
 2f4:	4a 85       	ldd	r20, Y+10	; 0x0a
 2f6:	5b 85       	ldd	r21, Y+11	; 0x0b
 2f8:	ce 01       	movw	r24, r28
 2fa:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			act_setConnected(servo,TRUE);
 2fe:	8e 2d       	mov	r24, r14
 300:	9f 2d       	mov	r25, r15
 302:	6f ef       	ldi	r22, 0xFF	; 255
 304:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Start off braking
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
 308:	8e 2d       	mov	r24, r14
 30a:	9f 2d       	mov	r25, r15
 30c:	60 e0       	ldi	r22, 0x00	; 0
 30e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 312:	08 94       	sec
 314:	c1 1c       	adc	r12, r1
 316:	d1 1c       	adc	r13, r1
	}


}

void servosInit(SERVO_DRIVER* driver, const Timer* timer){
 318:	c1 01       	movw	r24, r2
 31a:	8c 19       	sub	r24, r12
 31c:	9d 09       	sbc	r25, r13
			return;
		}


		// Make sure each servo is set as an output
		for(i= driver->num_servos-1;i>=0;i--){
 31e:	ff ef       	ldi	r31, 0xFF	; 255
 320:	8f 3f       	cpi	r24, 0xFF	; 255
 322:	9f 07       	cpc	r25, r31
 324:	01 f4       	brne	.+0      	; 0x326 <servosInit+0x128>
			act_setSpeed(servo,DRIVE_SPEED_BRAKE);
		}


		// Set the threshold to start interrupt chain
		if(getError()==0){
 326:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 32a:	88 23       	and	r24, r24
 32c:	01 f4       	brne	.+0      	; 0x32e <servosInit+0x130>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 32e:	e2 01       	movw	r28, r4
 330:	60 96       	adiw	r28, 0x10	; 16
			CRITICAL_SECTION_START;
 332:	ff b6       	in	r15, 0x3f	; 63
 334:	f8 94       	cli

			compareAttach(channel1, &__servoStartService,  compareGetThreshold(channel1) + driver->specific.softwarePWM.servo_cycle, driver);
 336:	c3 01       	movw	r24, r6
 338:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 33c:	f8 01       	movw	r30, r16
 33e:	42 85       	ldd	r20, Z+10	; 0x0a
 340:	53 85       	ldd	r21, Z+11	; 0x0b
 342:	48 0f       	add	r20, r24
 344:	59 1f       	adc	r21, r25
 346:	c3 01       	movw	r24, r6
 348:	60 e0       	ldi	r22, 0x00	; 0
 34a:	70 e0       	ldi	r23, 0x00	; 0
 34c:	98 01       	movw	r18, r16
 34e:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			compareAttach(channel2, &__servoEndService  ,  compareGetThreshold(channel2) + driver->specific.softwarePWM.servo_cycle, driver);
 352:	ce 01       	movw	r24, r28
 354:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 358:	f8 01       	movw	r30, r16
 35a:	42 85       	ldd	r20, Z+10	; 0x0a
 35c:	53 85       	ldd	r21, Z+11	; 0x0b
 35e:	48 0f       	add	r20, r24
 360:	59 1f       	adc	r21, r25
 362:	ce 01       	movw	r24, r28
 364:	60 e0       	ldi	r22, 0x00	; 0
 366:	70 e0       	ldi	r23, 0x00	; 0
 368:	98 01       	movw	r18, r16
 36a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
			__portMaskClear(&channel2->pgm_intenable);		// disable channel2
 36e:	c2 01       	movw	r24, r4
 370:	43 96       	adiw	r24, 0x13	; 19
 372:	0e 94 00 00 	call	0	; 0x0 <setSpeed>

			// Do this last as it then turns on the timer
			timerSetPrescaler(timer,prescale);
 376:	c5 01       	movw	r24, r10
 378:	b4 01       	movw	r22, r8
 37a:	0e 94 00 00 	call	0	; 0x0 <setSpeed>


			CRITICAL_SECTION_END;
 37e:	ff be       	out	0x3f, r15	; 63
 380:	00 c0       	rjmp	.+0      	; 0x382 <servosInit+0x184>



	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
 382:	89 ef       	ldi	r24, 0xF9	; 249
 384:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 388:	00 c0       	rjmp	.+0      	; 0x38a <servosInit+0x18c>
			prescale = timerGetPrescaler(timer);
			if(timerGetMode(timer) != TIMER_MODE_NORMAL){
				setError(PWM_TIMER_IN_USE);
			}
		}else{
			prescale = timerGetBestPrescaler(timer, SERVO_CYCLE + 5 );
 38a:	cb 01       	movw	r24, r22
 38c:	69 e1       	ldi	r22, 0x19	; 25
 38e:	70 e0       	ldi	r23, 0x00	; 0
 390:	0e 94 00 00 	call	0	; 0x0 <setSpeed>
 394:	4c 01       	movw	r8, r24
 396:	00 c0       	rjmp	.+0      	; 0x398 <servosInit+0x19a>
	}else{
		// We need a 16 bit bit timer
		setError(SERVO_TIMER_MUST_BE_16_BIT);
	}

}
 398:	df 91       	pop	r29
 39a:	cf 91       	pop	r28
 39c:	1f 91       	pop	r17
 39e:	0f 91       	pop	r16
 3a0:	ff 90       	pop	r15
 3a2:	ef 90       	pop	r14
 3a4:	df 90       	pop	r13
 3a6:	cf 90       	pop	r12
 3a8:	bf 90       	pop	r11
 3aa:	af 90       	pop	r10
 3ac:	9f 90       	pop	r9
 3ae:	8f 90       	pop	r8
 3b0:	7f 90       	pop	r7
 3b2:	6f 90       	pop	r6
 3b4:	5f 90       	pop	r5
 3b6:	4f 90       	pop	r4
 3b8:	3f 90       	pop	r3
 3ba:	2f 90       	pop	r2
 3bc:	08 95       	ret

servosCenter.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000354  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000388  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00000000  00000000  00000388  2**0
                  ALLOC
  3 .progmem.data 000000cc  00000000  00000000  00000388  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00000bb4  00000000  00000000  00000454  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000002b4  00000000  00000000  00001008  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000004c3  00000000  00000000  000012bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  0000177f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  0000179f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000018b  00000000  00000000  000017b7  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000504  00000000  00000000  00001942  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000000f8  00000000  00000000  00001e48  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <list>:
		c = c - 'a' + 'A';
	}
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
   0:	af 92       	push	r10
   2:	bf 92       	push	r11
   4:	cf 92       	push	r12
   6:	df 92       	push	r13
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	f8 2e       	mov	r15, r24
  14:	c9 2f       	mov	r28, r25
  16:	c6 2e       	mov	r12, r22
	rprintf("\nServo Center Range\n");
  18:	00 d0       	rcall	.+0      	; 0x1a <list+0x1a>
  1a:	0f 92       	push	r0
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	ad b7       	in	r26, 0x3d	; 61
  20:	be b7       	in	r27, 0x3e	; 62
  22:	11 96       	adiw	r26, 0x01	; 1
  24:	8c 93       	st	X, r24
  26:	11 97       	sbiw	r26, 0x01	; 1
  28:	20 e0       	ldi	r18, 0x00	; 0
  2a:	30 e0       	ldi	r19, 0x00	; 0
  2c:	13 96       	adiw	r26, 0x03	; 3
  2e:	3c 93       	st	X, r19
  30:	2e 93       	st	-X, r18
  32:	12 97       	sbiw	r26, 0x02	; 2
  34:	0e 94 00 00 	call	0	; 0x0 <list>
  38:	0f 2d       	mov	r16, r15
  3a:	1c 2f       	mov	r17, r28
	for(int i=0; i<numServos; i++){
  3c:	0f 90       	pop	r0
  3e:	0f 90       	pop	r0
  40:	0f 90       	pop	r0
  42:	c0 e0       	ldi	r28, 0x00	; 0
  44:	d0 e0       	ldi	r29, 0x00	; 0
  46:	dd 24       	eor	r13, r13
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
  48:	ff 24       	eor	r15, r15
  4a:	f3 94       	inc	r15
  4c:	80 e0       	ldi	r24, 0x00	; 0
  4e:	a8 2e       	mov	r10, r24
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	b8 2e       	mov	r11, r24
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
	rprintf("\nServo Center Range\n");
	for(int i=0; i<numServos; i++){
  54:	00 c0       	rjmp	.+0      	; 0x56 <list+0x56>
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
  56:	f8 01       	movw	r30, r16
  58:	85 91       	lpm	r24, Z+
  5a:	94 91       	lpm	r25, Z
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
  5c:	ed b7       	in	r30, 0x3d	; 61
  5e:	fe b7       	in	r31, 0x3e	; 62
  60:	39 97       	sbiw	r30, 0x09	; 9
  62:	0f b6       	in	r0, 0x3f	; 63
  64:	f8 94       	cli
  66:	fe bf       	out	0x3e, r31	; 62
  68:	0f be       	out	0x3f, r0	; 63
  6a:	ed bf       	out	0x3d, r30	; 61
  6c:	31 96       	adiw	r30, 0x01	; 1
  6e:	ad b7       	in	r26, 0x3d	; 61
  70:	be b7       	in	r27, 0x3e	; 62
  72:	11 96       	adiw	r26, 0x01	; 1
  74:	fc 92       	st	X, r15
  76:	b2 82       	std	Z+2, r11	; 0x02
  78:	a1 82       	std	Z+1, r10	; 0x01
  7a:	d4 83       	std	Z+4, r29	; 0x04
  7c:	c3 83       	std	Z+3, r28	; 0x03
  7e:	dc 01       	movw	r26, r24
  80:	18 96       	adiw	r26, 0x08	; 8
  82:	8d 91       	ld	r24, X+
  84:	9c 91       	ld	r25, X
  86:	19 97       	sbiw	r26, 0x09	; 9
  88:	96 83       	std	Z+6, r25	; 0x06
  8a:	85 83       	std	Z+5, r24	; 0x05
  8c:	1a 96       	adiw	r26, 0x0a	; 10
  8e:	8d 91       	ld	r24, X+
  90:	9c 91       	ld	r25, X
  92:	1b 97       	sbiw	r26, 0x0b	; 11
  94:	90 87       	std	Z+8, r25	; 0x08
  96:	87 83       	std	Z+7, r24	; 0x07
  98:	0e 94 00 00 	call	0	; 0x0 <list>
	return c;
}

static void list(SERVO_LIST* const servos, uint8_t numServos){
	rprintf("\nServo Center Range\n");
	for(int i=0; i<numServos; i++){
  9c:	21 96       	adiw	r28, 0x01	; 1
  9e:	0e 5f       	subi	r16, 0xFE	; 254
  a0:	1f 4f       	sbci	r17, 0xFF	; 255
  a2:	ed b7       	in	r30, 0x3d	; 61
  a4:	fe b7       	in	r31, 0x3e	; 62
  a6:	39 96       	adiw	r30, 0x09	; 9
  a8:	0f b6       	in	r0, 0x3f	; 63
  aa:	f8 94       	cli
  ac:	fe bf       	out	0x3e, r31	; 62
  ae:	0f be       	out	0x3f, r0	; 63
  b0:	ed bf       	out	0x3d, r30	; 61
  b2:	cc 15       	cp	r28, r12
  b4:	dd 05       	cpc	r29, r13
  b6:	04 f0       	brlt	.+0      	; 0xb8 <list+0xb8>
		SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
		rprintf("%5d  %4d  %4d\n",i,servo->center_us,servo->range_us);
	}
}
  b8:	df 91       	pop	r29
  ba:	cf 91       	pop	r28
  bc:	1f 91       	pop	r17
  be:	0f 91       	pop	r16
  c0:	ff 90       	pop	r15
  c2:	df 90       	pop	r13
  c4:	cf 90       	pop	r12
  c6:	bf 90       	pop	r11
  c8:	af 90       	pop	r10
  ca:	08 95       	ret

000000cc <update>:

static void update(SERVO_LIST* const servos, int diff){
  cc:	db 01       	movw	r26, r22
	SERVO* servo = (SERVO*)pgm_read_word(&servos[current]);
  ce:	e0 91 00 00 	lds	r30, 0x0000
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	ee 0f       	add	r30, r30
  d6:	ff 1f       	adc	r31, r31
  d8:	e8 0f       	add	r30, r24
  da:	f9 1f       	adc	r31, r25
  dc:	25 91       	lpm	r18, Z+
  de:	34 91       	lpm	r19, Z
  e0:	c9 01       	movw	r24, r18
	uint16_t c = servo->center_us;
  e2:	f9 01       	movw	r30, r18
  e4:	60 85       	ldd	r22, Z+8	; 0x08
  e6:	71 85       	ldd	r23, Z+9	; 0x09
	uint16_t r = servo->range_us;
  e8:	42 85       	ldd	r20, Z+10	; 0x0a
  ea:	53 85       	ldd	r21, Z+11	; 0x0b

	if(ranging){
  ec:	20 91 00 00 	lds	r18, 0x0000
  f0:	22 23       	and	r18, r18
  f2:	01 f0       	breq	.+0      	; 0xf4 <update+0x28>
		r += diff;
  f4:	4a 0f       	add	r20, r26
  f6:	5b 1f       	adc	r21, r27
  f8:	00 c0       	rjmp	.+0      	; 0xfa <update+0x2e>
	}else{
		c += diff;
  fa:	6a 0f       	add	r22, r26
  fc:	7b 1f       	adc	r23, r27
	}

	servoSetConfig(servo,c,r);
  fe:	0e 94 00 00 	call	0	; 0x0 <list>
}
 102:	08 95       	ret

00000104 <setRanging>:

static void setRanging( boolean r, SERVO_LIST* const servos, uint8_t numServos){
 104:	cf 92       	push	r12
 106:	df 92       	push	r13
 108:	ff 92       	push	r15
 10a:	0f 93       	push	r16
 10c:	1f 93       	push	r17
 10e:	cf 93       	push	r28
 110:	df 93       	push	r29
	if(ranging != r){
 112:	90 91 00 00 	lds	r25, 0x0000
 116:	98 17       	cp	r25, r24
 118:	01 f0       	breq	.+0      	; 0x11a <setRanging+0x16>
		ranging = r;
 11a:	80 93 00 00 	sts	0x0000, r24
		DRIVE_SPEED speed = (ranging) ? DRIVE_SPEED_MAX : DRIVE_SPEED_BRAKE;
 11e:	88 23       	and	r24, r24
 120:	01 f0       	breq	.+0      	; 0x122 <setRanging+0x1e>
 122:	3f e7       	ldi	r19, 0x7F	; 127
 124:	f3 2e       	mov	r15, r19
 126:	00 c0       	rjmp	.+0      	; 0x128 <setRanging+0x24>
 128:	ff 24       	eor	r15, r15
 12a:	eb 01       	movw	r28, r22
		for(int i=0; i<numServos; i++){
 12c:	00 e0       	ldi	r16, 0x00	; 0
 12e:	10 e0       	ldi	r17, 0x00	; 0
 130:	c4 2e       	mov	r12, r20
 132:	dd 24       	eor	r13, r13
 134:	00 c0       	rjmp	.+0      	; 0x136 <setRanging+0x32>
			SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
 136:	fe 01       	movw	r30, r28
 138:	85 91       	lpm	r24, Z+
 13a:	94 91       	lpm	r25, Z
			act_setSpeed(servo,speed);
 13c:	6f 2d       	mov	r22, r15
 13e:	0e 94 00 00 	call	0	; 0x0 <list>

static void setRanging( boolean r, SERVO_LIST* const servos, uint8_t numServos){
	if(ranging != r){
		ranging = r;
		DRIVE_SPEED speed = (ranging) ? DRIVE_SPEED_MAX : DRIVE_SPEED_BRAKE;
		for(int i=0; i<numServos; i++){
 142:	0f 5f       	subi	r16, 0xFF	; 255
 144:	1f 4f       	sbci	r17, 0xFF	; 255
 146:	22 96       	adiw	r28, 0x02	; 2
 148:	0c 15       	cp	r16, r12
 14a:	1d 05       	cpc	r17, r13
 14c:	04 f0       	brlt	.+0      	; 0x14e <setRanging+0x4a>
			SERVO* servo = (SERVO*)pgm_read_word(&servos[i]);
			act_setSpeed(servo,speed);
		}
	}
}
 14e:	df 91       	pop	r29
 150:	cf 91       	pop	r28
 152:	1f 91       	pop	r17
 154:	0f 91       	pop	r16
 156:	ff 90       	pop	r15
 158:	df 90       	pop	r13
 15a:	cf 90       	pop	r12
 15c:	08 95       	ret

0000015e <help>:


static uint8_t current;
static boolean ranging;

static void help(void){
 15e:	cf 93       	push	r28
	rprintf("\nL = List");
 160:	00 d0       	rcall	.+0      	; 0x162 <help+0x4>
 162:	0f 92       	push	r0
 164:	c1 e0       	ldi	r28, 0x01	; 1
 166:	ed b7       	in	r30, 0x3d	; 61
 168:	fe b7       	in	r31, 0x3e	; 62
 16a:	c1 83       	std	Z+1, r28	; 0x01
 16c:	80 e0       	ldi	r24, 0x00	; 0
 16e:	90 e0       	ldi	r25, 0x00	; 0
 170:	93 83       	std	Z+3, r25	; 0x03
 172:	82 83       	std	Z+2, r24	; 0x02
 174:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n+ = Increment");
 178:	ed b7       	in	r30, 0x3d	; 61
 17a:	fe b7       	in	r31, 0x3e	; 62
 17c:	c1 83       	std	Z+1, r28	; 0x01
 17e:	80 e0       	ldi	r24, 0x00	; 0
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	93 83       	std	Z+3, r25	; 0x03
 184:	82 83       	std	Z+2, r24	; 0x02
 186:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n- = Decrement");
 18a:	ed b7       	in	r30, 0x3d	; 61
 18c:	fe b7       	in	r31, 0x3e	; 62
 18e:	c1 83       	std	Z+1, r28	; 0x01
 190:	80 e0       	ldi	r24, 0x00	; 0
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	93 83       	std	Z+3, r25	; 0x03
 196:	82 83       	std	Z+2, r24	; 0x02
 198:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n* = Add 10");
 19c:	ed b7       	in	r30, 0x3d	; 61
 19e:	fe b7       	in	r31, 0x3e	; 62
 1a0:	c1 83       	std	Z+1, r28	; 0x01
 1a2:	80 e0       	ldi	r24, 0x00	; 0
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	93 83       	std	Z+3, r25	; 0x03
 1a8:	82 83       	std	Z+2, r24	; 0x02
 1aa:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\n/ = Sub 10");
 1ae:	ed b7       	in	r30, 0x3d	; 61
 1b0:	fe b7       	in	r31, 0x3e	; 62
 1b2:	c1 83       	std	Z+1, r28	; 0x01
 1b4:	80 e0       	ldi	r24, 0x00	; 0
 1b6:	90 e0       	ldi	r25, 0x00	; 0
 1b8:	93 83       	std	Z+3, r25	; 0x03
 1ba:	82 83       	std	Z+2, r24	; 0x02
 1bc:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nN = Next Servo");
 1c0:	ed b7       	in	r30, 0x3d	; 61
 1c2:	fe b7       	in	r31, 0x3e	; 62
 1c4:	c1 83       	std	Z+1, r28	; 0x01
 1c6:	80 e0       	ldi	r24, 0x00	; 0
 1c8:	90 e0       	ldi	r25, 0x00	; 0
 1ca:	93 83       	std	Z+3, r25	; 0x03
 1cc:	82 83       	std	Z+2, r24	; 0x02
 1ce:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nP = Previous Servo");
 1d2:	ed b7       	in	r30, 0x3d	; 61
 1d4:	fe b7       	in	r31, 0x3e	; 62
 1d6:	c1 83       	std	Z+1, r28	; 0x01
 1d8:	80 e0       	ldi	r24, 0x00	; 0
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	93 83       	std	Z+3, r25	; 0x03
 1de:	82 83       	std	Z+2, r24	; 0x02
 1e0:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nC = Center mode");
 1e4:	ed b7       	in	r30, 0x3d	; 61
 1e6:	fe b7       	in	r31, 0x3e	; 62
 1e8:	c1 83       	std	Z+1, r28	; 0x01
 1ea:	80 e0       	ldi	r24, 0x00	; 0
 1ec:	90 e0       	ldi	r25, 0x00	; 0
 1ee:	93 83       	std	Z+3, r25	; 0x03
 1f0:	82 83       	std	Z+2, r24	; 0x02
 1f2:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintf("\nR = Range mode");
 1f6:	ed b7       	in	r30, 0x3d	; 61
 1f8:	fe b7       	in	r31, 0x3e	; 62
 1fa:	c1 83       	std	Z+1, r28	; 0x01
 1fc:	80 e0       	ldi	r24, 0x00	; 0
 1fe:	90 e0       	ldi	r25, 0x00	; 0
 200:	93 83       	std	Z+3, r25	; 0x03
 202:	82 83       	std	Z+2, r24	; 0x02
 204:	0e 94 00 00 	call	0	; 0x0 <list>
	rprintfCRLF();
 208:	0f 90       	pop	r0
 20a:	0f 90       	pop	r0
 20c:	0f 90       	pop	r0
 20e:	0e 94 00 00 	call	0	; 0x0 <list>
}
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <prompt>:

static void prompt(void){
	if(ranging){
 216:	80 91 00 00 	lds	r24, 0x0000
 21a:	88 23       	and	r24, r24
 21c:	01 f0       	breq	.+0      	; 0x21e <prompt+0x8>
		rprintf("\nRange Servo %d>",current);
 21e:	00 d0       	rcall	.+0      	; 0x220 <prompt+0xa>
 220:	00 d0       	rcall	.+0      	; 0x222 <prompt+0xc>
 222:	0f 92       	push	r0
 224:	ed b7       	in	r30, 0x3d	; 61
 226:	fe b7       	in	r31, 0x3e	; 62
 228:	31 96       	adiw	r30, 0x01	; 1
 22a:	81 e0       	ldi	r24, 0x01	; 1
 22c:	ad b7       	in	r26, 0x3d	; 61
 22e:	be b7       	in	r27, 0x3e	; 62
 230:	11 96       	adiw	r26, 0x01	; 1
 232:	8c 93       	st	X, r24
 234:	11 97       	sbiw	r26, 0x01	; 1
 236:	80 e0       	ldi	r24, 0x00	; 0
 238:	90 e0       	ldi	r25, 0x00	; 0
 23a:	00 c0       	rjmp	.+0      	; 0x23c <prompt+0x26>
	}else{
		rprintf("\nCenter Servo %d>",current);
 23c:	00 d0       	rcall	.+0      	; 0x23e <prompt+0x28>
 23e:	00 d0       	rcall	.+0      	; 0x240 <prompt+0x2a>
 240:	0f 92       	push	r0
 242:	ed b7       	in	r30, 0x3d	; 61
 244:	fe b7       	in	r31, 0x3e	; 62
 246:	31 96       	adiw	r30, 0x01	; 1
 248:	81 e0       	ldi	r24, 0x01	; 1
 24a:	ad b7       	in	r26, 0x3d	; 61
 24c:	be b7       	in	r27, 0x3e	; 62
 24e:	11 96       	adiw	r26, 0x01	; 1
 250:	8c 93       	st	X, r24
 252:	80 e0       	ldi	r24, 0x00	; 0
 254:	90 e0       	ldi	r25, 0x00	; 0
 256:	92 83       	std	Z+2, r25	; 0x02
 258:	81 83       	std	Z+1, r24	; 0x01
 25a:	80 91 00 00 	lds	r24, 0x0000
 25e:	83 83       	std	Z+3, r24	; 0x03
 260:	14 82       	std	Z+4, r1	; 0x04
 262:	0e 94 00 00 	call	0	; 0x0 <list>
 266:	0f 90       	pop	r0
 268:	0f 90       	pop	r0
 26a:	0f 90       	pop	r0
 26c:	0f 90       	pop	r0
 26e:	0f 90       	pop	r0
 270:	08 95       	ret

00000272 <_servosCenter>:
		}
	}
}


void _servosCenter(SERVO_LIST* const servos, uint8_t numServos, UART* uart){
 272:	ec 01       	movw	r28, r24
 274:	16 2f       	mov	r17, r22
 276:	7a 01       	movw	r14, r20
	rprintfInit(uart->writer);
 278:	fa 01       	movw	r30, r20
 27a:	83 89       	ldd	r24, Z+19	; 0x13
 27c:	94 89       	ldd	r25, Z+20	; 0x14
 27e:	0e 94 00 00 	call	0	; 0x0 <list>

	list(servos,numServos);
 282:	ce 01       	movw	r24, r28
 284:	61 2f       	mov	r22, r17
 286:	0e 94 00 00 	call	0	; 0x0 <list>
	help();
 28a:	0e 94 00 00 	call	0	; 0x0 <list>
	prompt();
 28e:	0e 94 00 00 	call	0	; 0x0 <list>
		case 'N':
			current = (current+1) % numServos;
			prompt();
			break;
		case 'P':
			current = (current==0) ? numServos-1 : current-1;
 292:	01 2f       	mov	r16, r17
 294:	01 50       	subi	r16, 0x01	; 1
			break;
		case '/':
			update(servos,-10);
			break;
		case 'N':
			current = (current+1) % numServos;
 296:	d1 2e       	mov	r13, r17
 298:	cc 24       	eor	r12, r12
}

static char getCh(UART* uart){
	int val;
	do{
		val = __uartGetByte(uart);
 29a:	c7 01       	movw	r24, r14
 29c:	0e 94 00 00 	call	0	; 0x0 <list>
	}while(val==-1);
 2a0:	ff ef       	ldi	r31, 0xFF	; 255
 2a2:	8f 3f       	cpi	r24, 0xFF	; 255
 2a4:	9f 07       	cpc	r25, r31
 2a6:	01 f0       	breq	.+0      	; 0x2a8 <_servosCenter+0x36>
	char c = val;
	if(c>='a' && c<='z'){
 2a8:	98 2f       	mov	r25, r24
 2aa:	91 56       	subi	r25, 0x61	; 97
 2ac:	9a 31       	cpi	r25, 0x1A	; 26
 2ae:	00 f4       	brcc	.+0      	; 0x2b0 <_servosCenter+0x3e>
		c = c - 'a' + 'A';
 2b0:	80 52       	subi	r24, 0x20	; 32
	list(servos,numServos);
	help();
	prompt();
	while(1){
		char c = getCh(uart);
		switch(c){
 2b2:	8c 34       	cpi	r24, 0x4C	; 76
 2b4:	01 f0       	breq	.+0      	; 0x2b6 <_servosCenter+0x44>
 2b6:	8d 34       	cpi	r24, 0x4D	; 77
 2b8:	00 f4       	brcc	.+0      	; 0x2ba <_servosCenter+0x48>
 2ba:	8d 32       	cpi	r24, 0x2D	; 45
 2bc:	01 f0       	breq	.+0      	; 0x2be <_servosCenter+0x4c>
 2be:	8e 32       	cpi	r24, 0x2E	; 46
 2c0:	00 f4       	brcc	.+0      	; 0x2c2 <_servosCenter+0x50>
 2c2:	8a 32       	cpi	r24, 0x2A	; 42
 2c4:	01 f0       	breq	.+0      	; 0x2c6 <_servosCenter+0x54>
 2c6:	8b 32       	cpi	r24, 0x2B	; 43
 2c8:	01 f0       	breq	.+0      	; 0x2ca <_servosCenter+0x58>
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <_servosCenter+0x5a>
 2cc:	00 c0       	rjmp	.+0      	; 0x2ce <_servosCenter+0x5c>
 2ce:	8f 32       	cpi	r24, 0x2F	; 47
 2d0:	01 f0       	breq	.+0      	; 0x2d2 <_servosCenter+0x60>
 2d2:	83 34       	cpi	r24, 0x43	; 67
 2d4:	01 f4       	brne	.+0      	; 0x2d6 <_servosCenter+0x64>
 2d6:	00 c0       	rjmp	.+0      	; 0x2d8 <_servosCenter+0x66>
 2d8:	80 35       	cpi	r24, 0x50	; 80
 2da:	01 f0       	breq	.+0      	; 0x2dc <_servosCenter+0x6a>
 2dc:	82 35       	cpi	r24, 0x52	; 82
 2de:	01 f0       	breq	.+0      	; 0x2e0 <_servosCenter+0x6e>
 2e0:	8e 34       	cpi	r24, 0x4E	; 78
 2e2:	01 f4       	brne	.+0      	; 0x2e4 <_servosCenter+0x72>
 2e4:	00 c0       	rjmp	.+0      	; 0x2e6 <_servosCenter+0x74>
		case 'L':
			list(servos,numServos);
 2e6:	ce 01       	movw	r24, r28
 2e8:	61 2f       	mov	r22, r17
 2ea:	0e 94 00 00 	call	0	; 0x0 <list>
 2ee:	00 c0       	rjmp	.+0      	; 0x2f0 <_servosCenter+0x7e>
			prompt();
			break;
		case '+':
			update(servos,1);
 2f0:	ce 01       	movw	r24, r28
 2f2:	61 e0       	ldi	r22, 0x01	; 1
 2f4:	70 e0       	ldi	r23, 0x00	; 0
 2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <_servosCenter+0x86>
			break;
		case '*':
			update(servos,10);
 2f8:	ce 01       	movw	r24, r28
 2fa:	6a e0       	ldi	r22, 0x0A	; 10
 2fc:	70 e0       	ldi	r23, 0x00	; 0
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <_servosCenter+0x8e>
			break;
		case '-':
			update(servos,-1);
 300:	ce 01       	movw	r24, r28
 302:	6f ef       	ldi	r22, 0xFF	; 255
 304:	7f ef       	ldi	r23, 0xFF	; 255
 306:	00 c0       	rjmp	.+0      	; 0x308 <_servosCenter+0x96>
			break;
		case '/':
			update(servos,-10);
 308:	ce 01       	movw	r24, r28
 30a:	66 ef       	ldi	r22, 0xF6	; 246
 30c:	7f ef       	ldi	r23, 0xFF	; 255
 30e:	0e 94 00 00 	call	0	; 0x0 <list>
			break;
 312:	00 c0       	rjmp	.+0      	; 0x314 <_servosCenter+0xa2>
		case 'N':
			current = (current+1) % numServos;
 314:	80 91 00 00 	lds	r24, 0x0000
 318:	90 e0       	ldi	r25, 0x00	; 0
 31a:	01 96       	adiw	r24, 0x01	; 1
 31c:	6d 2d       	mov	r22, r13
 31e:	7c 2d       	mov	r23, r12
 320:	0e 94 00 00 	call	0	; 0x0 <list>
 324:	00 c0       	rjmp	.+0      	; 0x326 <_servosCenter+0xb4>
			prompt();
			break;
		case 'P':
			current = (current==0) ? numServos-1 : current-1;
 326:	80 91 00 00 	lds	r24, 0x0000
 32a:	88 23       	and	r24, r24
 32c:	01 f4       	brne	.+0      	; 0x32e <_servosCenter+0xbc>
 32e:	80 2f       	mov	r24, r16
 330:	00 c0       	rjmp	.+0      	; 0x332 <_servosCenter+0xc0>
 332:	81 50       	subi	r24, 0x01	; 1
 334:	80 93 00 00 	sts	0x0000, r24
 338:	00 c0       	rjmp	.+0      	; 0x33a <_servosCenter+0xc8>
			prompt();
			break;
		case 'C':
			setRanging(FALSE, servos,numServos);
 33a:	80 e0       	ldi	r24, 0x00	; 0
 33c:	00 c0       	rjmp	.+0      	; 0x33e <_servosCenter+0xcc>
			prompt();
			break;
		case 'R':
			setRanging(TRUE, servos,numServos);
 33e:	8f ef       	ldi	r24, 0xFF	; 255
 340:	be 01       	movw	r22, r28
 342:	41 2f       	mov	r20, r17
 344:	0e 94 00 00 	call	0	; 0x0 <list>
 348:	00 c0       	rjmp	.+0      	; 0x34a <_servosCenter+0xd8>
			prompt();
			break;
		default:
			help();
 34a:	0e 94 00 00 	call	0	; 0x0 <list>
			prompt();
 34e:	0e 94 00 00 	call	0	; 0x0 <list>
			break;
 352:	00 c0       	rjmp	.+0      	; 0x354 <_servosCenter+0xe2>

servosConfig.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000102  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000136  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000136  2**0
                  ALLOC
  3 .debug_info   000009a4  00000000  00000000  00000136  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001da  00000000  00000000  00000ada  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000029d  00000000  00000000  00000cb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000f51  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000117  00000000  00000000  00000f71  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004b5  00000000  00000000  00001088  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000068  00000000  00000000  00001540  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servoSetConfig>:
 *      Author: Clive Webster
 *
 * Change the config settings for a given servo
 */
#include "servos.h"
void servoSetConfig(SERVO* servo, uint16_t center, uint16_t range){
   0:	7f 92       	push	r7
   2:	8f 92       	push	r8
   4:	9f 92       	push	r9
   6:	af 92       	push	r10
   8:	bf 92       	push	r11
   a:	cf 92       	push	r12
   c:	df 92       	push	r13
   e:	ef 92       	push	r14
  10:	ff 92       	push	r15
  12:	0f 93       	push	r16
  14:	1f 93       	push	r17
  16:	cf 93       	push	r28
  18:	df 93       	push	r29
  1a:	ec 01       	movw	r28, r24
  1c:	4b 01       	movw	r8, r22
  1e:	5a 01       	movw	r10, r20
	servo->center_us = center;						// Set the new center value
  20:	79 87       	std	Y+9, r23	; 0x09
  22:	68 87       	std	Y+8, r22	; 0x08
	servo->range_us = range;						// Set the new range value
  24:	5b 87       	std	Y+11, r21	; 0x0b
  26:	4a 87       	std	Y+10, r20	; 0x0a

	SERVO_DRIVER* driver = servo->driver;			// Get the current driver
	if(driver){
  28:	8c 81       	ldd	r24, Y+4	; 0x04
  2a:	9d 81       	ldd	r25, Y+5	; 0x05
  2c:	00 97       	sbiw	r24, 0x00	; 0
  2e:	01 f4       	brne	.+0      	; 0x30 <servoSetConfig+0x30>
  30:	00 c0       	rjmp	.+0      	; 0x32 <servoSetConfig+0x32>
		// The servo is 'live'
		CRITICAL_SECTION_START;
  32:	7f b6       	in	r7, 0x3f	; 63
  34:	f8 94       	cli
		// Take the useable servo range and calculate the min/max pulses
		// (SERVO_CYCLE*1000) = servo_cycle
		//        min			    x
		// x = (min * g_servo_cycle)/(SERVO_CYCLE*1000)
		uint32_t min = center - range;
		uint32_t m1 =  servo->top / 1000;
  36:	8a 89       	ldd	r24, Y+18	; 0x12
  38:	9b 89       	ldd	r25, Y+19	; 0x13
  3a:	68 ee       	ldi	r22, 0xE8	; 232
  3c:	73 e0       	ldi	r23, 0x03	; 3
  3e:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
  42:	6b 01       	movw	r12, r22
  44:	ee 24       	eor	r14, r14
  46:	ff 24       	eor	r15, r15

		// Take the useable servo range and calculate the min/max pulses
		// (SERVO_CYCLE*1000) = servo_cycle
		//        min			    x
		// x = (min * g_servo_cycle)/(SERVO_CYCLE*1000)
		uint32_t min = center - range;
  48:	b4 01       	movw	r22, r8
  4a:	6a 19       	sub	r22, r10
  4c:	7b 09       	sbc	r23, r11
  4e:	80 e0       	ldi	r24, 0x00	; 0
  50:	90 e0       	ldi	r25, 0x00	; 0
		uint32_t m1 =  servo->top / 1000;
		uint32_t m2 =  m1 * min;
  52:	a7 01       	movw	r20, r14
  54:	96 01       	movw	r18, r12
  56:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		uint32_t m3 =  m2 / SERVO_CYCLE;
  5a:	24 e1       	ldi	r18, 0x14	; 20
  5c:	30 e0       	ldi	r19, 0x00	; 0
  5e:	40 e0       	ldi	r20, 0x00	; 0
  60:	50 e0       	ldi	r21, 0x00	; 0
  62:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
  66:	89 01       	movw	r16, r18
  68:	9a 01       	movw	r18, r20
		if( (m3 & 0xFFFF0000UL)!=0){
  6a:	d9 01       	movw	r26, r18
  6c:	c8 01       	movw	r24, r16
  6e:	80 70       	andi	r24, 0x00	; 0
  70:	90 70       	andi	r25, 0x00	; 0
  72:	00 97       	sbiw	r24, 0x00	; 0
  74:	a1 05       	cpc	r26, r1
  76:	b1 05       	cpc	r27, r1
  78:	01 f0       	breq	.+0      	; 0x7a <servoSetConfig+0x7a>
			// doesn't fit
			setError(SERVO_TIMING);
  7a:	86 ee       	ldi	r24, 0xE6	; 230
  7c:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
			m3 = 0xFFFFUL;
  80:	0f ef       	ldi	r16, 0xFF	; 255
  82:	1f ef       	ldi	r17, 0xFF	; 255
  84:	20 e0       	ldi	r18, 0x00	; 0
  86:	30 e0       	ldi	r19, 0x00	; 0
		}
		servo->min_ticks = m3;
  88:	1d 87       	std	Y+13, r17	; 0x0d
  8a:	0c 87       	std	Y+12, r16	; 0x0c

		uint32_t max = center + range;
  8c:	b5 01       	movw	r22, r10
  8e:	68 0d       	add	r22, r8
  90:	79 1d       	adc	r23, r9
  92:	80 e0       	ldi	r24, 0x00	; 0
  94:	90 e0       	ldi	r25, 0x00	; 0
		m2 =  m1 * max;
  96:	a7 01       	movw	r20, r14
  98:	96 01       	movw	r18, r12
  9a:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		m3 =  m2 / SERVO_CYCLE;
  9e:	24 e1       	ldi	r18, 0x14	; 20
  a0:	30 e0       	ldi	r19, 0x00	; 0
  a2:	40 e0       	ldi	r20, 0x00	; 0
  a4:	50 e0       	ldi	r21, 0x00	; 0
  a6:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
  aa:	89 01       	movw	r16, r18
  ac:	9a 01       	movw	r18, r20
		if( (m3 & 0xFFFF0000UL)!=0){
  ae:	d9 01       	movw	r26, r18
  b0:	c8 01       	movw	r24, r16
  b2:	80 70       	andi	r24, 0x00	; 0
  b4:	90 70       	andi	r25, 0x00	; 0
  b6:	00 97       	sbiw	r24, 0x00	; 0
  b8:	a1 05       	cpc	r26, r1
  ba:	b1 05       	cpc	r27, r1
  bc:	01 f0       	breq	.+0      	; 0xbe <servoSetConfig+0xbe>
			// doesn't fit
			setError(SERVO_TIMING);
  be:	86 ee       	ldi	r24, 0xE6	; 230
  c0:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
			m3 = 0xFFFFUL;
  c4:	0f ef       	ldi	r16, 0xFF	; 255
  c6:	1f ef       	ldi	r17, 0xFF	; 255
  c8:	20 e0       	ldi	r18, 0x00	; 0
  ca:	30 e0       	ldi	r19, 0x00	; 0
		}
		servo->max_ticks = m3;
  cc:	1f 87       	std	Y+15, r17	; 0x0f
  ce:	0e 87       	std	Y+14, r16	; 0x0e
}

void __act_setConnected(__ACTUATOR* act,boolean connected);

static __inline__ boolean __act_isConnected(const __ACTUATOR* act){
	return (act->connected) ? TRUE : FALSE;
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	80 ff       	sbrs	r24, 0
  d4:	00 c0       	rjmp	.+0      	; 0xd6 <servoSetConfig+0xd6>

		// Set the speed again
		if(act_isConnected(servo)){
			DRIVE_SPEED speed = servo->actuator.required_speed;
  d6:	6a 81       	ldd	r22, Y+2	; 0x02
			servo->actuator.required_speed-=1;
  d8:	86 2f       	mov	r24, r22
  da:	81 50       	subi	r24, 0x01	; 1
  dc:	8a 83       	std	Y+2, r24	; 0x02
			act_setSpeed(servo,speed);
  de:	ce 01       	movw	r24, r28
  e0:	0e 94 00 00 	call	0	; 0x0 <servoSetConfig>
		}
		CRITICAL_SECTION_END;
  e4:	7f be       	out	0x3f, r7	; 63
	}
}
  e6:	df 91       	pop	r29
  e8:	cf 91       	pop	r28
  ea:	1f 91       	pop	r17
  ec:	0f 91       	pop	r16
  ee:	ff 90       	pop	r15
  f0:	ef 90       	pop	r14
  f2:	df 90       	pop	r13
  f4:	cf 90       	pop	r12
  f6:	bf 90       	pop	r11
  f8:	af 90       	pop	r10
  fa:	9f 90       	pop	r9
  fc:	8f 90       	pop	r8
  fe:	7f 90       	pop	r7
 100:	08 95       	ret

servosConnect.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000005a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000008e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000008e  2**0
                  ALLOC
  3 .debug_info   00000918  00000000  00000000  0000008e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001b4  00000000  00000000  000009a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000eb  00000000  00000000  00000b5a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000c45  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000c65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000011b  00000000  00000000  00000c7d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004af  00000000  00000000  00000d98  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000048  00000000  00000000  00001248  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servosSetConnected>:
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	7c 01       	movw	r14, r24
  10:	16 2f       	mov	r17, r22
	for(int i=driver->num_servos - 1; i >= 0; i--){
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	cc 90       	ld	r12, X
  18:	12 97       	sbiw	r26, 0x02	; 2
  1a:	c0 e0       	ldi	r28, 0x00	; 0
  1c:	d0 e0       	ldi	r29, 0x00	; 0
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  1e:	dd 24       	eor	r13, r13
	for(int i=driver->num_servos - 1; i >= 0; i--){
  20:	00 c0       	rjmp	.+0      	; 0x22 <servosSetConnected+0x22>
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  22:	88 0f       	add	r24, r24
  24:	99 1f       	adc	r25, r25
	for(int i=driver->num_servos - 1; i >= 0; i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  26:	d7 01       	movw	r26, r14
  28:	ed 91       	ld	r30, X+
  2a:	fc 91       	ld	r31, X
  2c:	e8 0f       	add	r30, r24
  2e:	f9 1f       	adc	r31, r25
  30:	85 91       	lpm	r24, Z+
  32:	94 91       	lpm	r25, Z
		act_setConnected(servo, connect);
  34:	61 2f       	mov	r22, r17
  36:	0e 94 00 00 	call	0	; 0x0 <servosSetConnected>
  3a:	21 96       	adiw	r28, 0x01	; 1
 *  Created on: 26-Sep-2009
 *      Author: Clive Webster
 */
#include "servos.h"

void servosSetConnected(const SERVO_DRIVER* driver, boolean connect){
  3c:	c6 01       	movw	r24, r12
  3e:	8c 1b       	sub	r24, r28
  40:	9d 0b       	sbc	r25, r29
	for(int i=driver->num_servos - 1; i >= 0; i--){
  42:	bf ef       	ldi	r27, 0xFF	; 255
  44:	8f 3f       	cpi	r24, 0xFF	; 255
  46:	9b 07       	cpc	r25, r27
  48:	01 f4       	brne	.+0      	; 0x4a <servosSetConnected+0x4a>
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		act_setConnected(servo, connect);
	}
}
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	ff 90       	pop	r15
  52:	ef 90       	pop	r14
  54:	df 90       	pop	r13
  56:	cf 90       	pop	r12
  58:	08 95       	ret

servosSpeed.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000005a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000008e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000008e  2**0
                  ALLOC
  3 .debug_info   00000918  00000000  00000000  0000008e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001b4  00000000  00000000  000009a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    000000eb  00000000  00000000  00000b5a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000c45  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000018  00000000  00000000  00000c65  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000119  00000000  00000000  00000c7d  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000004a1  00000000  00000000  00000d96  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000048  00000000  00000000  00001238  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <servosSetSpeed>:
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	7c 01       	movw	r14, r24
  10:	16 2f       	mov	r17, r22
	for(int i=driver->num_servos - 1; i >= 0; i--){
  12:	dc 01       	movw	r26, r24
  14:	12 96       	adiw	r26, 0x02	; 2
  16:	cc 90       	ld	r12, X
  18:	12 97       	sbiw	r26, 0x02	; 2
  1a:	c0 e0       	ldi	r28, 0x00	; 0
  1c:	d0 e0       	ldi	r29, 0x00	; 0
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  1e:	dd 24       	eor	r13, r13
	for(int i=driver->num_servos - 1; i >= 0; i--){
  20:	00 c0       	rjmp	.+0      	; 0x22 <servosSetSpeed+0x22>
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  22:	88 0f       	add	r24, r24
  24:	99 1f       	adc	r25, r25
	for(int i=driver->num_servos - 1; i >= 0; i--){
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
  26:	d7 01       	movw	r26, r14
  28:	ed 91       	ld	r30, X+
  2a:	fc 91       	ld	r31, X
  2c:	e8 0f       	add	r30, r24
  2e:	f9 1f       	adc	r31, r25
  30:	85 91       	lpm	r24, Z+
  32:	94 91       	lpm	r25, Z
		act_setSpeed(servo, speed);
  34:	61 2f       	mov	r22, r17
  36:	0e 94 00 00 	call	0	; 0x0 <servosSetSpeed>
  3a:	21 96       	adiw	r28, 0x01	; 1
 *      Author: Clive Webster
 */
#include "servos.h"
#include "actuators.h"

void servosSetSpeed(const SERVO_DRIVER* driver, DRIVE_SPEED speed){
  3c:	c6 01       	movw	r24, r12
  3e:	8c 1b       	sub	r24, r28
  40:	9d 0b       	sbc	r25, r29
	for(int i=driver->num_servos - 1; i >= 0; i--){
  42:	bf ef       	ldi	r27, 0xFF	; 255
  44:	8f 3f       	cpi	r24, 0xFF	; 255
  46:	9b 07       	cpc	r25, r27
  48:	01 f4       	brne	.+0      	; 0x4a <servosSetSpeed+0x4a>
		SERVO* servo = (SERVO*)pgm_read_word(&driver->servos[i]);
		act_setSpeed(servo, speed);
	}
}
  4a:	df 91       	pop	r29
  4c:	cf 91       	pop	r28
  4e:	1f 91       	pop	r17
  50:	ff 90       	pop	r15
  52:	ef 90       	pop	r14
  54:	df 90       	pop	r13
  56:	cf 90       	pop	r12
  58:	08 95       	ret

spi.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000012a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  0000015e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  00000170  2**0
                  ALLOC
  3 .debug_info   0000065c  00000000  00000000  00000170  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000023b  00000000  00000000  000007cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000171  00000000  00000000  00000a07  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000b78  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000030  00000000  00000000  00000b98  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000000fa  00000000  00000000  00000bc8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000033d  00000000  00000000  00000cc2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000094  00000000  00000000  00001000  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiHWOff>:
    CRITICAL_SECTION_END;
}

// Turn off the SPI hardware
static void __spiHWOff(SPI_ABSTRACT_BUS* spi){
	SPCR &= ~(1<<SPE);
   0:	8c b5       	in	r24, 0x2c	; 44
   2:	8f 7b       	andi	r24, 0xBF	; 191
   4:	8c bd       	out	0x2c, r24	; 44
}
   6:	08 95       	ret

00000008 <__spiHWSetClock>:
		break;
	}
}

static void __spiHWSetClock(SPI_ABSTRACT_BUS* spi, SPI_CLOCK clock){
	cbi(SPCR,SPR1);
   8:	8c b5       	in	r24, 0x2c	; 44
   a:	8d 7f       	andi	r24, 0xFD	; 253
   c:	8c bd       	out	0x2c, r24	; 44
	cbi(SPCR,SPR0);
   e:	8c b5       	in	r24, 0x2c	; 44
  10:	8e 7f       	andi	r24, 0xFE	; 254
  12:	8c bd       	out	0x2c, r24	; 44
#ifdef SPI2X
	cbi(SPSR,SPI2X);
  14:	8d b5       	in	r24, 0x2d	; 45
  16:	8e 7f       	andi	r24, 0xFE	; 254
  18:	8d bd       	out	0x2d, r24	; 45
#endif
	switch(clock){
  1a:	60 31       	cpi	r22, 0x10	; 16
  1c:	01 f0       	breq	.+0      	; 0x1e <__spiHWSetClock+0x16>
  1e:	61 31       	cpi	r22, 0x11	; 17
  20:	00 f4       	brcc	.+0      	; 0x22 <__spiHWSetClock+0x1a>
  22:	62 30       	cpi	r22, 0x02	; 2
  24:	01 f0       	breq	.+0      	; 0x26 <__spiHWSetClock+0x1e>
  26:	68 30       	cpi	r22, 0x08	; 8
  28:	01 f4       	brne	.+0      	; 0x2a <__spiHWSetClock+0x22>
  2a:	00 c0       	rjmp	.+0      	; 0x2c <__spiHWSetClock+0x24>
  2c:	60 34       	cpi	r22, 0x40	; 64
  2e:	01 f0       	breq	.+0      	; 0x30 <__spiHWSetClock+0x28>
  30:	60 38       	cpi	r22, 0x80	; 128
  32:	01 f0       	breq	.+0      	; 0x34 <__spiHWSetClock+0x2c>
  34:	60 32       	cpi	r22, 0x20	; 32
  36:	01 f4       	brne	.+0      	; 0x38 <__spiHWSetClock+0x30>
  38:	00 c0       	rjmp	.+0      	; 0x3a <__spiHWSetClock+0x32>
	case SPI_CLOCK_DIV2:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  3a:	8d b5       	in	r24, 0x2d	; 45
  3c:	81 60       	ori	r24, 0x01	; 1
  3e:	8d bd       	out	0x2d, r24	; 45
  40:	08 95       	ret
	case SPI_CLOCK_DIV4:
		break;

	case SPI_CLOCK_DIV8:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  42:	8d b5       	in	r24, 0x2d	; 45
  44:	81 60       	ori	r24, 0x01	; 1
  46:	8d bd       	out	0x2d, r24	; 45
#endif
	case SPI_CLOCK_DIV16:
		sbi(SPCR,SPR0);
  48:	8c b5       	in	r24, 0x2c	; 44
  4a:	81 60       	ori	r24, 0x01	; 1
  4c:	00 c0       	rjmp	.+0      	; 0x4e <__spiHWSetClock+0x46>
		break;

	case SPI_CLOCK_DIV32:
#ifdef SPI2X
		sbi(SPSR,SPI2X);
  4e:	8d b5       	in	r24, 0x2d	; 45
  50:	81 60       	ori	r24, 0x01	; 1
  52:	8d bd       	out	0x2d, r24	; 45
#endif
	case SPI_CLOCK_DIV64:
		sbi(SPCR,SPR1);
  54:	8c b5       	in	r24, 0x2c	; 44
  56:	82 60       	ori	r24, 0x02	; 2
  58:	8c bd       	out	0x2c, r24	; 44
		break;
  5a:	08 95       	ret

	case SPI_CLOCK_DIV128:
		sbi(SPCR,SPR0);
  5c:	8c b5       	in	r24, 0x2c	; 44
  5e:	81 60       	ori	r24, 0x01	; 1
  60:	8c bd       	out	0x2c, r24	; 44
		sbi(SPCR,SPR1);
  62:	8c b5       	in	r24, 0x2c	; 44
  64:	82 60       	ori	r24, 0x02	; 2
  66:	8c bd       	out	0x2c, r24	; 44
  68:	08 95       	ret

0000006a <__spiHWSendByte>:
		break;
	}
}

static uint8_t __spiHWSendByte(SPI_ABSTRACT_BUS* spi, uint8_t data){
    SPDR  = data;          			// send Character
  6a:	6e bd       	out	0x2e, r22	; 46
    while (!(SPSR & (1<<SPIF)));    // wait until Char is sent
  6c:	0d b4       	in	r0, 0x2d	; 45
  6e:	07 fe       	sbrs	r0, 7
  70:	00 c0       	rjmp	.+0      	; 0x72 <__spiHWSendByte+0x8>
    return SPDR;					// return the received byte
  72:	8e b5       	in	r24, 0x2e	; 46
}
  74:	08 95       	ret

00000076 <__spiHWSetDataOrder>:
	SPCR &= ~(1<<SPE);
}

static void __spiHWSetDataOrder(SPI_ABSTRACT_BUS* spi,SPI_DATA_ORDER order){
	if(order == SPI_DATA_ORDER_MSB){
		cbi(SPCR,DORD);
  76:	8c b5       	in	r24, 0x2c	; 44
static void __spiHWOff(SPI_ABSTRACT_BUS* spi){
	SPCR &= ~(1<<SPE);
}

static void __spiHWSetDataOrder(SPI_ABSTRACT_BUS* spi,SPI_DATA_ORDER order){
	if(order == SPI_DATA_ORDER_MSB){
  78:	66 23       	and	r22, r22
  7a:	01 f4       	brne	.+0      	; 0x7c <__spiHWSetDataOrder+0x6>
		cbi(SPCR,DORD);
  7c:	8f 7d       	andi	r24, 0xDF	; 223
  7e:	00 c0       	rjmp	.+0      	; 0x80 <__spiHWSetDataOrder+0xa>
	}else{
		sbi(SPCR,DORD);
  80:	80 62       	ori	r24, 0x20	; 32
  82:	8c bd       	out	0x2c, r24	; 44
  84:	08 95       	ret

00000086 <__spiHWSetMode>:
	}
}

static void __spiHWSetMode(SPI_ABSTRACT_BUS* spi,SPI_MODE mode){
	switch(mode){
  86:	61 30       	cpi	r22, 0x01	; 1
  88:	01 f0       	breq	.+0      	; 0x8a <__spiHWSetMode+0x4>
  8a:	61 30       	cpi	r22, 0x01	; 1
  8c:	00 f0       	brcs	.+0      	; 0x8e <__spiHWSetMode+0x8>
  8e:	62 30       	cpi	r22, 0x02	; 2
  90:	01 f0       	breq	.+0      	; 0x92 <__spiHWSetMode+0xc>
  92:	63 30       	cpi	r22, 0x03	; 3
  94:	01 f4       	brne	.+0      	; 0x96 <__spiHWSetMode+0x10>
  96:	00 c0       	rjmp	.+0      	; 0x98 <__spiHWSetMode+0x12>
	case SPI_MODE_0:
		cbi(SPCR,CPOL);
  98:	8c b5       	in	r24, 0x2c	; 44
  9a:	87 7f       	andi	r24, 0xF7	; 247
  9c:	00 c0       	rjmp	.+0      	; 0x9e <__spiHWSetMode+0x18>
		cbi(SPCR,CPHA);
		break;
	case SPI_MODE_1:
		cbi(SPCR,CPOL);
  9e:	8c b5       	in	r24, 0x2c	; 44
  a0:	87 7f       	andi	r24, 0xF7	; 247
  a2:	8c bd       	out	0x2c, r24	; 44
		sbi(SPCR,CPHA);
  a4:	8c b5       	in	r24, 0x2c	; 44
  a6:	84 60       	ori	r24, 0x04	; 4
  a8:	00 c0       	rjmp	.+0      	; 0xaa <__spiHWSetMode+0x24>
		break;
	case SPI_MODE_2:
		sbi(SPCR,CPOL);
  aa:	8c b5       	in	r24, 0x2c	; 44
  ac:	88 60       	ori	r24, 0x08	; 8
  ae:	8c bd       	out	0x2c, r24	; 44
		cbi(SPCR,CPHA);
  b0:	8c b5       	in	r24, 0x2c	; 44
  b2:	8b 7f       	andi	r24, 0xFB	; 251
  b4:	8c bd       	out	0x2c, r24	; 44
		break;
  b6:	08 95       	ret
	case SPI_MODE_3:
		sbi(SPCR,CPOL);
  b8:	8c b5       	in	r24, 0x2c	; 44
  ba:	88 60       	ori	r24, 0x08	; 8
  bc:	8c bd       	out	0x2c, r24	; 44
		sbi(SPCR,CPHA);
  be:	8c b5       	in	r24, 0x2c	; 44
  c0:	84 60       	ori	r24, 0x04	; 4
  c2:	8c bd       	out	0x2c, r24	; 44
  c4:	08 95       	ret

000000c6 <__spiHWInit>:




//------------- Private methods - dont call directly -----
static void __spiHWInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  c6:	ff 92       	push	r15
  c8:	0f 93       	push	r16
  ca:	1f 93       	push	r17
  cc:	cf 93       	push	r28
  ce:	df 93       	push	r29
  d0:	0f 92       	push	r0
  d2:	cd b7       	in	r28, 0x3d	; 61
  d4:	de b7       	in	r29, 0x3e	; 62
  d6:	8c 01       	movw	r16, r24
	//SPI* spi = (SPI*)_spi;
	CRITICAL_SECTION_START;
  d8:	ff b6       	in	r15, 0x3f	; 63
  da:	f8 94       	cli
    volatile char IOReg;
    if(master){
  dc:	66 23       	and	r22, r22
  de:	01 f0       	breq	.+0      	; 0xe0 <__spiHWInit+0x1a>
    	sbi(SCK_DDR, SCK_PIN);		// set SCK as output
  e0:	21 9a       	sbi	0x04, 1	; 4
    	sbi(MOSI_DDR, MOSI_PIN);	// set MOSI as output
  e2:	22 9a       	sbi	0x04, 2	; 4
    	cbi(MISO_DDR, MISO_PIN);	// set MISO as an input
  e4:	23 98       	cbi	0x04, 3	; 4
    	sbi(MISO_PORT,MISO_PIN);	// enable pullup on MISO
  e6:	2b 9a       	sbi	0x05, 3	; 5
    	sbi(SS_DDR, SS_PIN);		// set SS as output for Master mode to work
  e8:	20 9a       	sbi	0x04, 0	; 4
        // enable SPI in Master Mode, Data order=MSB first, Mode=0, with SCK = CK/4
        SPCR    = (1<<SPE)|(1<<MSTR);
  ea:	80 e5       	ldi	r24, 0x50	; 80
  ec:	00 c0       	rjmp	.+0      	; 0xee <__spiHWInit+0x28>
    }else{
    	sbi(MISO_DDR, MISO_PIN);	// set MISO as output
  ee:	23 9a       	sbi	0x04, 3	; 4
        SPCR    = (1<<SPE);
  f0:	80 e4       	ldi	r24, 0x40	; 64
  f2:	8c bd       	out	0x2c, r24	; 44
    }

    __spiHWSetClock(_spi,_spi->clock);
  f4:	c8 01       	movw	r24, r16
  f6:	f8 01       	movw	r30, r16
  f8:	66 81       	ldd	r22, Z+6	; 0x06
  fa:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>
    __spiHWSetDataOrder(_spi,_spi->order);
  fe:	c8 01       	movw	r24, r16
 100:	f8 01       	movw	r30, r16
 102:	60 85       	ldd	r22, Z+8	; 0x08
 104:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>
    __spiHWSetMode(_spi,_spi->mode);
 108:	c8 01       	movw	r24, r16
 10a:	f8 01       	movw	r30, r16
 10c:	67 81       	ldd	r22, Z+7	; 0x07
 10e:	0e 94 00 00 	call	0	; 0x0 <__spiHWOff>

    // clear SPIF bit in SPSR
    IOReg   = SPSR;
 112:	8d b5       	in	r24, 0x2d	; 45
 114:	89 83       	std	Y+1, r24	; 0x01
    IOReg   = SPDR;
 116:	8e b5       	in	r24, 0x2e	; 46
 118:	89 83       	std	Y+1, r24	; 0x01
    CRITICAL_SECTION_END;
 11a:	ff be       	out	0x3f, r15	; 63
}
 11c:	0f 90       	pop	r0
 11e:	df 91       	pop	r29
 120:	cf 91       	pop	r28
 122:	1f 91       	pop	r17
 124:	0f 91       	pop	r16
 126:	ff 90       	pop	r15
 128:	08 95       	ret

spiUart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000174  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  000001a8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  000001ba  2**0
                  ALLOC
  3 .debug_info   00000a6d  00000000  00000000  000001ba  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001b4  00000000  00000000  00000c27  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000043e  00000000  00000000  00000ddb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001219  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   00000164  00000000  00000000  00001239  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004f5  00000000  00000000  0000139d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000a0  00000000  00000000  00001894  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiUARTSetClock>:
	// Turn off the UART
	uartOff(uart);
}
static void __spiUARTSetClock(SPI_ABSTRACT_BUS* _spi, SPI_CLOCK clock){
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
   0:	dc 01       	movw	r26, r24
   2:	1c 96       	adiw	r26, 0x0c	; 12
   4:	ed 91       	ld	r30, X+
   6:	fc 91       	ld	r31, X
   8:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
   a:	84 a1       	ldd	r24, Z+36	; 0x24
   c:	95 a1       	ldd	r25, Z+37	; 0x25
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f0       	breq	.+0      	; 0x12 <__spiUARTSetClock+0x12>
		uint16_t bauddiv = (clock>>1)-1;
  12:	66 95       	lsr	r22
  14:	70 e0       	ldi	r23, 0x00	; 0
  16:	61 50       	subi	r22, 0x01	; 1
  18:	70 40       	sbci	r23, 0x00	; 0
		if(bauddiv==0){
  1a:	01 f4       	brne	.+0      	; 0x1c <__spiUARTSetClock+0x1c>
			bauddiv=1;
  1c:	61 e0       	ldi	r22, 0x01	; 1
  1e:	70 e0       	ldi	r23, 0x00	; 0
		}
		_SFR_MEM8(((HW_UART*)uart)->baudL) =  bauddiv;
  20:	a6 8d       	ldd	r26, Z+30	; 0x1e
  22:	b7 8d       	ldd	r27, Z+31	; 0x1f
  24:	6c 93       	st	X, r22
		_SFR_MEM8(((HW_UART*)uart)->baudH) = bauddiv>>8;
  26:	00 a0       	ldd	r0, Z+32	; 0x20
  28:	f1 a1       	ldd	r31, Z+33	; 0x21
  2a:	e0 2d       	mov	r30, r0
  2c:	70 83       	st	Z, r23
  2e:	08 95       	ret

00000030 <__spiUARTSetDataOrder>:
	}
}

static void __spiUARTSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  30:	dc 01       	movw	r26, r24
  32:	1c 96       	adiw	r26, 0x0c	; 12
  34:	ed 91       	ld	r30, X+
  36:	fc 91       	ld	r31, X
  38:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  3a:	84 a1       	ldd	r24, Z+36	; 0x24
  3c:	95 a1       	ldd	r25, Z+37	; 0x25
  3e:	00 97       	sbiw	r24, 0x00	; 0
  40:	01 f0       	breq	.+0      	; 0x42 <__spiUARTSetDataOrder+0x12>
		PORT statusC =uart->statusB+1;
  42:	04 8c       	ldd	r0, Z+28	; 0x1c
  44:	f5 8d       	ldd	r31, Z+29	; 0x1d
  46:	e0 2d       	mov	r30, r0
		if(order==SPI_DATA_ORDER_MSB){
			_SFR_MEM8(statusC) |= BV(2);	// Clear UDORD
  48:	81 81       	ldd	r24, Z+1	; 0x01
static void __spiUARTSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
	if(uart->spiClock!=null){
		PORT statusC =uart->statusB+1;
		if(order==SPI_DATA_ORDER_MSB){
  4a:	66 23       	and	r22, r22
  4c:	01 f4       	brne	.+0      	; 0x4e <__spiUARTSetDataOrder+0x1e>
			_SFR_MEM8(statusC) |= BV(2);	// Clear UDORD
  4e:	84 60       	ori	r24, 0x04	; 4
  50:	81 83       	std	Z+1, r24	; 0x01
  52:	08 95       	ret
		}else{
			_SFR_MEM8(statusC) &= ~(BV(2));	// Set UDORD
  54:	8b 7f       	andi	r24, 0xFB	; 251
  56:	81 83       	std	Z+1, r24	; 0x01
  58:	08 95       	ret

0000005a <__spiUARTSetMode>:
		}
	}
}
static void __spiUARTSetMode(SPI_ABSTRACT_BUS* _spi,SPI_MODE mode){
	SPI_UART* spi  =(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  5a:	dc 01       	movw	r26, r24
  5c:	1c 96       	adiw	r26, 0x0c	; 12
  5e:	ed 91       	ld	r30, X+
  60:	fc 91       	ld	r31, X
  62:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  64:	84 a1       	ldd	r24, Z+36	; 0x24
  66:	95 a1       	ldd	r25, Z+37	; 0x25
  68:	00 97       	sbiw	r24, 0x00	; 0
  6a:	01 f0       	breq	.+0      	; 0x6c <__spiUARTSetMode+0x12>
		PORT statusC =uart->statusB+1;
  6c:	04 8c       	ldd	r0, Z+28	; 0x1c
  6e:	f5 8d       	ldd	r31, Z+29	; 0x1d
  70:	e0 2d       	mov	r30, r0
		_SFR_MEM8(statusC) = (_SFR_MEM8(statusC) & ~(3)) | (mode & 3);
  72:	81 81       	ldd	r24, Z+1	; 0x01
  74:	63 70       	andi	r22, 0x03	; 3
  76:	8c 7f       	andi	r24, 0xFC	; 252
  78:	68 2b       	or	r22, r24
  7a:	61 83       	std	Z+1, r22	; 0x01
  7c:	08 95       	ret

0000007e <__spiUARTSendByte>:
	}
}

static uint8_t __spiUARTSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
  7e:	cf 93       	push	r28
  80:	df 93       	push	r29
#ifdef UDRE0
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART*  uart = spi->uart;
  82:	dc 01       	movw	r26, r24
  84:	1c 96       	adiw	r26, 0x0c	; 12
  86:	ed 91       	ld	r30, X+
  88:	fc 91       	ld	r31, X
  8a:	1d 97       	sbiw	r26, 0x0d	; 13
	if(uart->spiClock!=null){
  8c:	84 a1       	ldd	r24, Z+36	; 0x24
  8e:	95 a1       	ldd	r25, Z+37	; 0x25
  90:	00 97       	sbiw	r24, 0x00	; 0
  92:	01 f0       	breq	.+0      	; 0x94 <__spiUARTSendByte+0x16>
		PORT statusA =uart->statusA;
  94:	92 8d       	ldd	r25, Z+26	; 0x1a
  96:	83 8d       	ldd	r24, Z+27	; 0x1b

		// Wait for empty transmit buffer.
		do {} while( (_SFR_MEM8(statusA) & (1<<UDRE0)) == 0 );
  98:	a9 2f       	mov	r26, r25
  9a:	b8 2f       	mov	r27, r24
  9c:	2c 91       	ld	r18, X
  9e:	25 ff       	sbrs	r18, 5
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <__spiUARTSendByte+0x24>

		// Send data.
		_SFR_MEM8(uart->data) = data;
  a2:	c2 a1       	ldd	r28, Z+34	; 0x22
  a4:	d3 a1       	ldd	r29, Z+35	; 0x23
  a6:	68 83       	st	Y, r22

		// Wait for transfer to complete and return received value.
		do {} while( (_SFR_MEM8(statusA) & (1<<RXC0)) == 0 );
  a8:	8c 91       	ld	r24, X
  aa:	87 ff       	sbrs	r24, 7
  ac:	00 c0       	rjmp	.+0      	; 0xae <__spiUARTSendByte+0x30>

		return _SFR_MEM8(uart->data);
  ae:	02 a0       	ldd	r0, Z+34	; 0x22
  b0:	f3 a1       	ldd	r31, Z+35	; 0x23
  b2:	e0 2d       	mov	r30, r0
  b4:	80 81       	ld	r24, Z
  b6:	00 c0       	rjmp	.+0      	; 0xb8 <__spiUARTSendByte+0x3a>
	}
#endif
	return -1;
  b8:	8f ef       	ldi	r24, 0xFF	; 255
}
  ba:	df 91       	pop	r29
  bc:	cf 91       	pop	r28
  be:	08 95       	ret

000000c0 <__spiUARTOff>:
		setError(SPI_UART_ERROR);
	}
}
static void	__spiUARTOff(SPI_ABSTRACT_BUS* _spi){
	SPI_UART* spi=(SPI_UART*)_spi;
	HW_UART* uart=spi->uart;
  c0:	dc 01       	movw	r26, r24
  c2:	1c 96       	adiw	r26, 0x0c	; 12
  c4:	8d 91       	ld	r24, X+
  c6:	9c 91       	ld	r25, X
  c8:	1d 97       	sbiw	r26, 0x0d	; 13

	// Turn off SPI master mode
	_SFR_MEM8(uart->statusB+1) &=  ~(0xc0);
  ca:	dc 01       	movw	r26, r24
  cc:	5c 96       	adiw	r26, 0x1c	; 28
  ce:	ed 91       	ld	r30, X+
  d0:	fc 91       	ld	r31, X
  d2:	5d 97       	sbiw	r26, 0x1d	; 29
  d4:	21 81       	ldd	r18, Z+1	; 0x01
  d6:	2f 73       	andi	r18, 0x3F	; 63
  d8:	21 83       	std	Z+1, r18	; 0x01

	// Turn off the UART
	uartOff(uart);
  da:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>
}
  de:	08 95       	ret

000000e0 <__spiUARTInit>:
	#define RXEN	RXEN0
	#define TXEN	TXEN0
#endif

//------------- Private methods - dont call directly -----
static void __spiUARTInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  e0:	ef 92       	push	r14
  e2:	ff 92       	push	r15
  e4:	0f 93       	push	r16
  e6:	1f 93       	push	r17
  e8:	cf 93       	push	r28
  ea:	df 93       	push	r29
  ec:	ec 01       	movw	r28, r24
	SPI_UART* spi=(SPI_UART*)_spi;

	const IOPin* clock = spi->uart->spiClock;
  ee:	0c 85       	ldd	r16, Y+12	; 0x0c
  f0:	1d 85       	ldd	r17, Y+13	; 0x0d
  f2:	d8 01       	movw	r26, r16
  f4:	94 96       	adiw	r26, 0x24	; 36
  f6:	ed 90       	ld	r14, X+
  f8:	fc 90       	ld	r15, X
  fa:	95 97       	sbiw	r26, 0x25	; 37
	if(master && clock!=null){
  fc:	66 23       	and	r22, r22
  fe:	01 f0       	breq	.+0      	; 0x100 <__spiUARTInit+0x20>
 100:	e1 14       	cp	r14, r1
 102:	f1 04       	cpc	r15, r1
 104:	01 f0       	breq	.+0      	; 0x106 <__spiUARTInit+0x26>
		HW_UART* uart = spi->uart;

		// Turn off the UART whilst setting up
		uartOff(uart);
 106:	c8 01       	movw	r24, r16
 108:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// Baud rate must be set to 0 prior to enabling the USART as SPI
		// master, to ensure proper initialization of the XCK line.
		_SFR_MEM8(uart->baudL) =  0;
 10c:	d8 01       	movw	r26, r16
 10e:	5e 96       	adiw	r26, 0x1e	; 30
 110:	ed 91       	ld	r30, X+
 112:	fc 91       	ld	r31, X
 114:	5f 97       	sbiw	r26, 0x1f	; 31
 116:	10 82       	st	Z, r1
		_SFR_MEM8(uart->baudH) =  0;
 118:	90 96       	adiw	r26, 0x20	; 32
 11a:	ed 91       	ld	r30, X+
 11c:	fc 91       	ld	r31, X
 11e:	91 97       	sbiw	r26, 0x21	; 33
 120:	10 82       	st	Z, r1

		// Set XCK line to output, ie. set USART in master mode.
		pin_make_output(clock, TRUE);
 122:	c7 01       	movw	r24, r14
 124:	6f ef       	ldi	r22, 0xFF	; 255
 126:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// When creating the device files we have checked that the UMSEL bits use
		// mask 0xc0 in statusC and that statusC=statusB+1

		// Set USART to Master SPI mode.
		_SFR_MEM8(uart->statusB+1) =  0xc0;
 12a:	d8 01       	movw	r26, r16
 12c:	5c 96       	adiw	r26, 0x1c	; 28
 12e:	ed 91       	ld	r30, X+
 130:	fc 91       	ld	r31, X
 132:	5d 97       	sbiw	r26, 0x1d	; 29
 134:	80 ec       	ldi	r24, 0xC0	; 192
 136:	81 83       	std	Z+1, r24	; 0x01

		// Set clock polarity and phase to correct SPI mode.
	    __spiUARTSetDataOrder(_spi,_spi->order);
 138:	ce 01       	movw	r24, r28
 13a:	68 85       	ldd	r22, Y+8	; 0x08
 13c:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>
	    __spiUARTSetMode(_spi,_spi->mode);
 140:	ce 01       	movw	r24, r28
 142:	6f 81       	ldd	r22, Y+7	; 0x07
 144:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>

		// Enable RX and TX.
		_SFR_MEM8(uart->statusB) =  BV(RXEN)|BV(TXEN);
 148:	d8 01       	movw	r26, r16
 14a:	5c 96       	adiw	r26, 0x1c	; 28
 14c:	ed 91       	ld	r30, X+
 14e:	fc 91       	ld	r31, X
 150:	5d 97       	sbiw	r26, 0x1d	; 29
 152:	88 e1       	ldi	r24, 0x18	; 24
 154:	80 83       	st	Z, r24

		// Set baud rate. Must be set _after_ enabling the transmitter.
	    __spiUARTSetClock(_spi,_spi->clock);
 156:	ce 01       	movw	r24, r28
 158:	6e 81       	ldd	r22, Y+6	; 0x06
 15a:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>
//------------- Private methods - dont call directly -----
static void __spiUARTInit(SPI_ABSTRACT_BUS* _spi, boolean master){
	SPI_UART* spi=(SPI_UART*)_spi;

	const IOPin* clock = spi->uart->spiClock;
	if(master && clock!=null){
 15e:	00 c0       	rjmp	.+0      	; 0x160 <__spiUARTInit+0x80>

		// Set baud rate. Must be set _after_ enabling the transmitter.
	    __spiUARTSetClock(_spi,_spi->clock);
	}else{
		// Error - UART doesn't support SPI mode, or the clock pin is not available
		setError(SPI_UART_ERROR);
 160:	88 ee       	ldi	r24, 0xE8	; 232
 162:	0e 94 00 00 	call	0	; 0x0 <__spiUARTSetClock>
	}
}
 166:	df 91       	pop	r29
 168:	cf 91       	pop	r28
 16a:	1f 91       	pop	r17
 16c:	0f 91       	pop	r16
 16e:	ff 90       	pop	r15
 170:	ef 90       	pop	r14
 172:	08 95       	ret

spisw.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004f6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000012  00000000  00000000  0000052a  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, DATA
  2 .bss          00000000  00000000  00000000  0000053c  2**0
                  ALLOC
  3 .debug_info   0000104f  00000000  00000000  0000053c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000327  00000000  00000000  0000158b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000c10  00000000  00000000  000018b2  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000024c2  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000048  00000000  00000000  000024e2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000223  00000000  00000000  0000252a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000059a  00000000  00000000  0000274d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001a0  00000000  00000000  00002ce8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__spiSWOff>:
static void __spiSWOff(SPI_ABSTRACT_BUS* _spi){
//	SPI_SW* spi = (SPI_SW*)_spi;
//	if(spi->SELECT!=null){
//		pin_change_dettach(spi->SELECT);
//	}
}
   0:	08 95       	ret

00000002 <__spiSWSetClock>:

static void __spiSWSetClock(SPI_ABSTRACT_BUS* _spi, SPI_CLOCK clock){}
   2:	08 95       	ret

00000004 <__spiSWSetDataOrder>:
static void __spiSWSetDataOrder(SPI_ABSTRACT_BUS* _spi,SPI_DATA_ORDER order){}
   4:	08 95       	ret

00000006 <__spiSWSetMode>:

static void __spiSWSetMode(SPI_ABSTRACT_BUS* _spi,SPI_MODE mode){
   6:	26 2f       	mov	r18, r22
	SPI_SW* spi = (SPI_SW*)_spi;
	// Set the clock to its initial state
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
   8:	fc 01       	movw	r30, r24
   a:	80 89       	ldd	r24, Z+16	; 0x10
   c:	91 89       	ldd	r25, Z+17	; 0x11
   e:	22 50       	subi	r18, 0x02	; 2
  10:	61 e0       	ldi	r22, 0x01	; 1
  12:	22 30       	cpi	r18, 0x02	; 2
  14:	00 f0       	brcs	.+0      	; 0x16 <__spiSWSetMode+0x10>
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
}
  1c:	08 95       	ret

0000001e <__spiSWInit>:
//}



//------------- Private methods - dont call directly -----
static void __spiSWInit(SPI_ABSTRACT_BUS* _spi, boolean master){
  1e:	cf 93       	push	r28
  20:	df 93       	push	r29
  22:	ec 01       	movw	r28, r24
	SPI_SW* spi = (SPI_SW*)_spi;

    if(master){
  24:	66 23       	and	r22, r22
  26:	01 f0       	breq	.+0      	; 0x28 <__spiSWInit+0xa>
    	pin_make_output(spi->MOSI, TRUE); 	// make MOSI an output and set high
  28:	8c 85       	ldd	r24, Y+12	; 0x0c
  2a:	9d 85       	ldd	r25, Y+13	; 0x0d
  2c:	6f ef       	ldi	r22, 0xFF	; 255
  2e:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_input(spi->MISO,TRUE);  	// make MISO an input with a pullup
  32:	8e 85       	ldd	r24, Y+14	; 0x0e
  34:	9f 85       	ldd	r25, Y+15	; 0x0f
  36:	6f ef       	ldi	r22, 0xFF	; 255
  38:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <__spiSWInit+0x20>

    }else{
    	pin_make_input(spi->SCLK,FALSE);  	// make clock an input with no pullup
  3e:	88 89       	ldd	r24, Y+16	; 0x10
  40:	99 89       	ldd	r25, Y+17	; 0x11
  42:	60 e0       	ldi	r22, 0x00	; 0
  44:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_input(spi->MOSI,FALSE);  	// make MOSI an input with no pullup
  48:	8c 85       	ldd	r24, Y+12	; 0x0c
  4a:	9d 85       	ldd	r25, Y+13	; 0x0d
  4c:	60 e0       	ldi	r22, 0x00	; 0
  4e:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    	pin_make_output(spi->MISO,TRUE); 	// make MISO an output
  52:	8e 85       	ldd	r24, Y+14	; 0x0e
  54:	9f 85       	ldd	r25, Y+15	; 0x0f
  56:	6f ef       	ldi	r22, 0xFF	; 255
  58:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
    }

    __spiSWSetClock(_spi,_spi->clock);
    __spiSWSetDataOrder(_spi,_spi->order);
    __spiSWSetMode(_spi,_spi->mode);
  5c:	ce 01       	movw	r24, r28
  5e:	6f 81       	ldd	r22, Y+7	; 0x07
  60:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>

}
  64:	df 91       	pop	r29
  66:	cf 91       	pop	r28
  68:	08 95       	ret

0000006a <__spiWriteMOSI>:
		}
	}
	return data;
}

static uint8_t __spiWriteMOSI(const SPI_SW* spi, uint8_t data){
  6a:	cf 93       	push	r28
  6c:	fc 01       	movw	r30, r24
  6e:	c6 2f       	mov	r28, r22
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
  70:	20 85       	ldd	r18, Z+8	; 0x08
  72:	84 85       	ldd	r24, Z+12	; 0x0c
  74:	95 85       	ldd	r25, Z+13	; 0x0d
  76:	22 23       	and	r18, r18
  78:	01 f4       	brne	.+0      	; 0x7a <__spiWriteMOSI+0x10>
		// MSB is sent first
		pin_set(spi->MOSI, (data & 0x80));
  7a:	60 78       	andi	r22, 0x80	; 128
  7c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
		data<<=1;
  80:	8c 2f       	mov	r24, r28
  82:	88 0f       	add	r24, r24
  84:	00 c0       	rjmp	.+0      	; 0x86 <__spiWriteMOSI+0x1c>
	}else{
		// LSB is sent first
		pin_set(spi->MOSI, (data & 1));
  86:	61 70       	andi	r22, 0x01	; 1
  88:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
		data>>=1;
  8c:	8c 2f       	mov	r24, r28
  8e:	86 95       	lsr	r24
	}
	return data;
}
  90:	cf 91       	pop	r28
  92:	08 95       	ret

00000094 <writeMany>:
			*dst++ = rtn;								/* store byte			*/
		}
	}
}

static void writeMany(const SPI_ABSTRACT_DEVICE* device,const void* dta, size_t size){
  94:	8f 92       	push	r8
  96:	9f 92       	push	r9
  98:	af 92       	push	r10
  9a:	bf 92       	push	r11
  9c:	cf 92       	push	r12
  9e:	df 92       	push	r13
  a0:	ff 92       	push	r15
  a2:	0f 93       	push	r16
  a4:	1f 93       	push	r17
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	4c 01       	movw	r8, r24
  ac:	db 01       	movw	r26, r22
  ae:	5a 01       	movw	r10, r20
	SPI_SW* spi = (SPI_SW*)(device->bus);
  b0:	fc 01       	movw	r30, r24
  b2:	c0 80       	ld	r12, Z
  b4:	d1 80       	ldd	r13, Z+1	; 0x01
	uint8_t delay = spi->_bus_.clock / 3;		// delay loop is approx 3 cycles
  b6:	f6 01       	movw	r30, r12
  b8:	86 81       	ldd	r24, Z+6	; 0x06
  ba:	63 e0       	ldi	r22, 0x03	; 3
  bc:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
  c0:	58 2f       	mov	r21, r24
	uint8_t* src = (uint8_t*)dta;

	// Get MOSI pin data
	const IOPin*  io = spi->MOSI;
  c2:	24 85       	ldd	r18, Z+12	; 0x0c
  c4:	35 85       	ldd	r19, Z+13	; 0x0d
	const IOPort* mosiPortDef = (const IOPort*)pgm_read_word(&io->port);
  c6:	f9 01       	movw	r30, r18
  c8:	85 91       	lpm	r24, Z+
  ca:	94 91       	lpm	r25, Z
	PORT mosiPort  = pgm_read_word(&mosiPortDef->port);
  cc:	fc 01       	movw	r30, r24
  ce:	85 91       	lpm	r24, Z+
  d0:	94 91       	lpm	r25, Z
  d2:	8c 01       	movw	r16, r24
	PIN  mosiMask = pgm_read_byte(&io->pin);
  d4:	2e 5f       	subi	r18, 0xFE	; 254
  d6:	3f 4f       	sbci	r19, 0xFF	; 255
  d8:	f9 01       	movw	r30, r18
  da:	c4 91       	lpm	r28, Z

	// Get SCLK data
	io = spi->SCLK;
  dc:	f6 01       	movw	r30, r12
  de:	60 89       	ldd	r22, Z+16	; 0x10
  e0:	71 89       	ldd	r23, Z+17	; 0x11
	const IOPort* sclkPortDef = (const IOPort*)pgm_read_word(&io->port);
  e2:	fb 01       	movw	r30, r22
  e4:	85 91       	lpm	r24, Z+
  e6:	94 91       	lpm	r25, Z
	PORT sclkPort = pgm_read_word(&sclkPortDef->port);
  e8:	fc 01       	movw	r30, r24
  ea:	85 91       	lpm	r24, Z+
  ec:	94 91       	lpm	r25, Z
  ee:	48 2f       	mov	r20, r24
  f0:	39 2f       	mov	r19, r25
	PIN sclkMask = pgm_read_byte(&io->pin);
  f2:	fb 01       	movw	r30, r22
  f4:	32 96       	adiw	r30, 0x02	; 2
  f6:	24 91       	lpm	r18, Z

	uint8_t cpha = spi->_bus_.mode & 1;
  f8:	f6 01       	movw	r30, r12
  fa:	97 81       	ldd	r25, Z+7	; 0x07
  fc:	91 70       	andi	r25, 0x01	; 1


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
  fe:	80 85       	ldd	r24, Z+8	; 0x08
 100:	aa 0e       	add	r10, r26
 102:	bb 1e       	adc	r11, r27
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 0x80){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 104:	dc 2f       	mov	r29, r28
 106:	d0 95       	com	r29
	PIN sclkMask = pgm_read_byte(&io->pin);

	uint8_t cpha = spi->_bus_.mode & 1;


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 108:	88 23       	and	r24, r24
 10a:	01 f0       	breq	.+0      	; 0x10c <writeMany+0x78>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <writeMany+0x7a>
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
 10e:	8d 91       	ld	r24, X+
 110:	68 e0       	ldi	r22, 0x08	; 8
 112:	70 e0       	ldi	r23, 0x00	; 0
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 114:	99 23       	and	r25, r25
 116:	01 f0       	breq	.+0      	; 0x118 <writeMany+0x84>
 118:	e4 2f       	mov	r30, r20
 11a:	f3 2f       	mov	r31, r19
 11c:	f0 80       	ld	r15, Z
 11e:	f2 26       	eor	r15, r18
 120:	f0 82       	st	Z, r15
				if(rtn & 0x80){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 122:	f8 01       	movw	r30, r16
 124:	f0 80       	ld	r15, Z
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 0x80){
 126:	87 ff       	sbrs	r24, 7
 128:	00 c0       	rjmp	.+0      	; 0x12a <writeMany+0x96>
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 12a:	fc 2a       	or	r15, r28
 12c:	00 c0       	rjmp	.+0      	; 0x12e <writeMany+0x9a>
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 12e:	fd 22       	and	r15, r29
 130:	f0 82       	st	Z, r15
				}
				rtn<<=1;
 132:	88 0f       	add	r24, r24
				if(!cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 134:	99 23       	and	r25, r25
 136:	01 f4       	brne	.+0      	; 0x138 <writeMany+0xa4>
 138:	e4 2f       	mov	r30, r20
 13a:	f3 2f       	mov	r31, r19
 13c:	f0 80       	ld	r15, Z
 13e:	f2 26       	eor	r15, r18
 140:	f0 82       	st	Z, r15
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
 142:	55 23       	and	r21, r21
 144:	01 f0       	breq	.+0      	; 0x146 <writeMany+0xb2>

    Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
    can be achieved.
*/
static __inline__ void _delay_loop_1(uint8_t __count){
	__asm__ volatile (
 146:	e5 2f       	mov	r30, r21
 148:	ea 95       	dec	r30
 14a:	01 f4       	brne	.+0      	; 0x14c <writeMany+0xb8>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 14c:	e4 2f       	mov	r30, r20
 14e:	f3 2f       	mov	r31, r19
 150:	f0 80       	ld	r15, Z
 152:	f2 26       	eor	r15, r18
 154:	f0 82       	st	Z, r15
 156:	61 50       	subi	r22, 0x01	; 1
 158:	70 40       	sbci	r23, 0x00	; 0

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
 15a:	01 f4       	brne	.+0      	; 0x15c <writeMany+0xc8>
	uint8_t cpha = spi->_bus_.mode & 1;


	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
 15c:	aa 15       	cp	r26, r10
 15e:	bb 05       	cpc	r27, r11
 160:	01 f4       	brne	.+0      	; 0x162 <writeMany+0xce>
 162:	00 c0       	rjmp	.+0      	; 0x164 <writeMany+0xd0>
			}											/* next bit				*/
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
 164:	8d 91       	ld	r24, X+
 166:	68 e0       	ldi	r22, 0x08	; 8
 168:	70 e0       	ldi	r23, 0x00	; 0
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 16a:	99 23       	and	r25, r25
 16c:	01 f0       	breq	.+0      	; 0x16e <writeMany+0xda>
 16e:	e4 2f       	mov	r30, r20
 170:	f3 2f       	mov	r31, r19
 172:	f0 80       	ld	r15, Z
 174:	f2 26       	eor	r15, r18
 176:	f0 82       	st	Z, r15
				if(rtn & 1){
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 178:	f8 01       	movw	r30, r16
 17a:	f0 80       	ld	r15, Z
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
				if(cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
				if(rtn & 1){
 17c:	80 ff       	sbrs	r24, 0
 17e:	00 c0       	rjmp	.+0      	; 0x180 <writeMany+0xec>
					_SFR_MEM8(mosiPort) |= mosiMask;	/* set high 			*/
 180:	fc 2a       	or	r15, r28
 182:	00 c0       	rjmp	.+0      	; 0x184 <writeMany+0xf0>
				}else{
					_SFR_MEM8(mosiPort) &= ~mosiMask;	/* set low 				*/
 184:	fd 22       	and	r15, r29
 186:	f0 82       	st	Z, r15
				}
				rtn>>=1;
 188:	86 95       	lsr	r24
				if(!cpha) _SFR_MEM8(sclkPort) ^= sclkMask;/* toggle clock (high) 	*/
 18a:	99 23       	and	r25, r25
 18c:	01 f4       	brne	.+0      	; 0x18e <writeMany+0xfa>
 18e:	e4 2f       	mov	r30, r20
 190:	f3 2f       	mov	r31, r19
 192:	f0 80       	ld	r15, Z
 194:	f2 26       	eor	r15, r18
 196:	f0 82       	st	Z, r15
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
 198:	55 23       	and	r21, r21
 19a:	01 f0       	breq	.+0      	; 0x19c <writeMany+0x108>
 19c:	e5 2f       	mov	r30, r21
 19e:	ea 95       	dec	r30
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <writeMany+0x10e>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 1a2:	e4 2f       	mov	r30, r20
 1a4:	f3 2f       	mov	r31, r19
 1a6:	f0 80       	ld	r15, Z
 1a8:	f2 26       	eor	r15, r18
 1aa:	f0 82       	st	Z, r15
 1ac:	61 50       	subi	r22, 0x01	; 1
 1ae:	70 40       	sbci	r23, 0x00	; 0
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = *src++;
			for(int i=0; i<8; i++){						/* for each bit			*/
 1b0:	01 f4       	brne	.+0      	; 0x1b2 <writeMany+0x11e>
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
			}											/* next bit				*/
		}
	}else{
		// LSB is sent first
		while(size--){
 1b2:	aa 15       	cp	r26, r10
 1b4:	bb 05       	cpc	r27, r11
 1b6:	01 f4       	brne	.+0      	; 0x1b8 <writeMany+0x124>
				if(delay) _delay_loop_1(delay);			/* delay			  	*/
				_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
			}											/* next bit				*/
		}
	}
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 1b8:	c6 01       	movw	r24, r12
 1ba:	f4 01       	movw	r30, r8
 1bc:	67 81       	ldd	r22, Z+7	; 0x07
 1be:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
													/* using first bit of filler */
}
 1c2:	df 91       	pop	r29
 1c4:	cf 91       	pop	r28
 1c6:	1f 91       	pop	r17
 1c8:	0f 91       	pop	r16
 1ca:	ff 90       	pop	r15
 1cc:	df 90       	pop	r13
 1ce:	cf 90       	pop	r12
 1d0:	bf 90       	pop	r11
 1d2:	af 90       	pop	r10
 1d4:	9f 90       	pop	r9
 1d6:	8f 90       	pop	r8
 1d8:	08 95       	ret

000001da <readMany>:
	}											/* next bit				*/
	pin_high(spi->MOSI);						/* make MOSI high		*/
	return rtn;									/* return read byte		*/
}

static void readMany(const SPI_ABSTRACT_DEVICE* device,void* dta, size_t size){
 1da:	2f 92       	push	r2
 1dc:	3f 92       	push	r3
 1de:	4f 92       	push	r4
 1e0:	5f 92       	push	r5
 1e2:	6f 92       	push	r6
 1e4:	7f 92       	push	r7
 1e6:	8f 92       	push	r8
 1e8:	9f 92       	push	r9
 1ea:	af 92       	push	r10
 1ec:	bf 92       	push	r11
 1ee:	cf 92       	push	r12
 1f0:	df 92       	push	r13
 1f2:	ef 92       	push	r14
 1f4:	ff 92       	push	r15
 1f6:	0f 93       	push	r16
 1f8:	1f 93       	push	r17
 1fa:	cf 93       	push	r28
 1fc:	df 93       	push	r29
 1fe:	00 d0       	rcall	.+0      	; 0x200 <readMany+0x26>
 200:	0f 92       	push	r0
 202:	cd b7       	in	r28, 0x3d	; 61
 204:	de b7       	in	r29, 0x3e	; 62
 206:	fc 01       	movw	r30, r24
 208:	e6 2e       	mov	r14, r22
 20a:	07 2f       	mov	r16, r23
 20c:	5a 83       	std	Y+2, r21	; 0x02
 20e:	49 83       	std	Y+1, r20	; 0x01
	SPI_SW* spi = (SPI_SW*)(device->bus);
 210:	80 80       	ld	r8, Z
 212:	91 80       	ldd	r9, Z+1	; 0x01
	uint8_t delay = spi->_bus_.clock / 3;		// delay loop is approx 3 cycles
 214:	d4 01       	movw	r26, r8
 216:	16 96       	adiw	r26, 0x06	; 6
 218:	8c 91       	ld	r24, X
 21a:	63 e0       	ldi	r22, 0x03	; 3
 21c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 220:	c8 2e       	mov	r12, r24
	uint8_t* dst = (uint8_t*)dta;
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 222:	c4 01       	movw	r24, r8
 224:	67 81       	ldd	r22, Z+7	; 0x07
 226:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
													/* using first bit of filler */

	// Get MISO pin data
	const IOPin*  io = spi->MISO;
 22a:	f4 01       	movw	r30, r8
 22c:	26 85       	ldd	r18, Z+14	; 0x0e
 22e:	37 85       	ldd	r19, Z+15	; 0x0f
	const IOPort* misoPortDef = (const IOPort*)pgm_read_word(&io->port);
 230:	f9 01       	movw	r30, r18
 232:	85 91       	lpm	r24, Z+
 234:	94 91       	lpm	r25, Z
	PORT misoPin  = pgm_read_word(&misoPortDef->pin);
 236:	04 96       	adiw	r24, 0x04	; 4
 238:	fc 01       	movw	r30, r24
 23a:	85 91       	lpm	r24, Z+
 23c:	94 91       	lpm	r25, Z
 23e:	38 2e       	mov	r3, r24
 240:	69 2e       	mov	r6, r25
	PIN  misoMask = pgm_read_byte(&io->pin);
 242:	2e 5f       	subi	r18, 0xFE	; 254
 244:	3f 4f       	sbci	r19, 0xFF	; 255
 246:	f9 01       	movw	r30, r18
 248:	74 90       	lpm	r7, Z

	// Get SCLK data
	io = spi->SCLK;
 24a:	d4 01       	movw	r26, r8
 24c:	50 96       	adiw	r26, 0x10	; 16
 24e:	2d 91       	ld	r18, X+
 250:	3c 91       	ld	r19, X
 252:	51 97       	sbiw	r26, 0x11	; 17
	const IOPort* sclkPortDef = (const IOPort*)pgm_read_word(&io->port);
 254:	f9 01       	movw	r30, r18
 256:	85 91       	lpm	r24, Z+
 258:	94 91       	lpm	r25, Z
	PORT sclkPort = pgm_read_word(&sclkPortDef->port);
 25a:	fc 01       	movw	r30, r24
 25c:	85 91       	lpm	r24, Z+
 25e:	94 91       	lpm	r25, Z
 260:	5c 01       	movw	r10, r24
	PIN sclkMask = pgm_read_byte(&io->pin);
 262:	2e 5f       	subi	r18, 0xFE	; 254
 264:	3f 4f       	sbci	r19, 0xFF	; 255
 266:	f9 01       	movw	r30, r18
 268:	24 90       	lpm	r2, Z

	uint8_t cpha = spi->_bus_.mode & 1;
 26a:	17 96       	adiw	r26, 0x07	; 7
 26c:	dc 90       	ld	r13, X
 26e:	17 97       	sbiw	r26, 0x07	; 7
 270:	f1 e0       	ldi	r31, 0x01	; 1
 272:	df 22       	and	r13, r31

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 274:	18 96       	adiw	r26, 0x08	; 8
 276:	8c 91       	ld	r24, X
 278:	18 97       	sbiw	r26, 0x08	; 8
 27a:	4e 2c       	mov	r4, r14
 27c:	50 2e       	mov	r5, r16
 27e:	88 23       	and	r24, r24
 280:	01 f4       	brne	.+0      	; 0x282 <readMany+0xa8>
 282:	00 c0       	rjmp	.+0      	; 0x284 <readMany+0xaa>
 284:	00 c0       	rjmp	.+0      	; 0x286 <readMany+0xac>
		// MSB is sent first
		while(size--){
 286:	98 e0       	ldi	r25, 0x08	; 8
 288:	e9 2e       	mov	r14, r25
 28a:	f1 2c       	mov	r15, r1
 28c:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
				rtn<<=1;
 28e:	22 0f       	add	r18, r18
				if(!cpha){ // Mode 0 and 2
 290:	dd 20       	and	r13, r13
 292:	01 f4       	brne	.+0      	; 0x294 <readMany+0xba>
					pin_high(spi->MOSI);					/* make MOSI high		*/
 294:	d4 01       	movw	r26, r8
 296:	1c 96       	adiw	r26, 0x0c	; 12
 298:	8d 91       	ld	r24, X+
 29a:	9c 91       	ld	r25, X
 29c:	1d 97       	sbiw	r26, 0x0d	; 13
 29e:	2b 83       	std	Y+3, r18	; 0x03
 2a0:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 0 & 2 */
 2a4:	e3 2d       	mov	r30, r3
 2a6:	f6 2d       	mov	r31, r6
 2a8:	80 81       	ld	r24, Z
 2aa:	87 21       	and	r24, r7
 2ac:	2b 81       	ldd	r18, Y+3	; 0x03
 2ae:	81 11       	cpse	r24, r1
						rtn |= 1;
 2b0:	21 60       	ori	r18, 0x01	; 1
					}
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 2b2:	f5 01       	movw	r30, r10
 2b4:	80 81       	ld	r24, Z
 2b6:	82 25       	eor	r24, r2
 2b8:	80 83       	st	Z, r24
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 2ba:	cc 20       	and	r12, r12
 2bc:	01 f0       	breq	.+0      	; 0x2be <readMany+0xe4>
 2be:	8c 2d       	mov	r24, r12
 2c0:	8a 95       	dec	r24
 2c2:	01 f4       	brne	.+0      	; 0x2c4 <readMany+0xea>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 2c4:	80 81       	ld	r24, Z
 2c6:	82 25       	eor	r24, r2
 2c8:	80 83       	st	Z, r24
 2ca:	00 c0       	rjmp	.+0      	; 0x2cc <readMany+0xf2>

				}else{ // Mode 1 or 3
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 2cc:	85 01       	movw	r16, r10
 2ce:	f5 01       	movw	r30, r10
 2d0:	80 81       	ld	r24, Z
 2d2:	82 25       	eor	r24, r2
 2d4:	80 83       	st	Z, r24
					pin_high(spi->MOSI);					/* make MOSI high		*/
 2d6:	d4 01       	movw	r26, r8
 2d8:	1c 96       	adiw	r26, 0x0c	; 12
 2da:	8d 91       	ld	r24, X+
 2dc:	9c 91       	ld	r25, X
 2de:	1d 97       	sbiw	r26, 0x0d	; 13
 2e0:	2b 83       	std	Y+3, r18	; 0x03
 2e2:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 2e6:	2b 81       	ldd	r18, Y+3	; 0x03
 2e8:	cc 20       	and	r12, r12
 2ea:	01 f0       	breq	.+0      	; 0x2ec <readMany+0x112>
 2ec:	8c 2d       	mov	r24, r12
 2ee:	8a 95       	dec	r24
 2f0:	01 f4       	brne	.+0      	; 0x2f2 <readMany+0x118>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 2f2:	f8 01       	movw	r30, r16
 2f4:	80 81       	ld	r24, Z
 2f6:	82 25       	eor	r24, r2
 2f8:	80 83       	st	Z, r24

					if(_SFR_MEM8(misoPin) & misoMask){	    /* read input for modes 1 & 3 */
 2fa:	e3 2d       	mov	r30, r3
 2fc:	f6 2d       	mov	r31, r6
 2fe:	80 81       	ld	r24, Z
 300:	87 21       	and	r24, r7
 302:	01 f0       	breq	.+0      	; 0x304 <readMany+0x12a>
						rtn |= 1;
 304:	21 60       	ori	r18, 0x01	; 1
 306:	08 94       	sec
 308:	e1 08       	sbc	r14, r1
 30a:	f1 08       	sbc	r15, r1

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
 30c:	e1 14       	cp	r14, r1
 30e:	f1 04       	cpc	r15, r1
 310:	01 f0       	breq	.+0      	; 0x312 <readMany+0x138>
 312:	00 c0       	rjmp	.+0      	; 0x314 <readMany+0x13a>
					if(_SFR_MEM8(misoPin) & misoMask){	    /* read input for modes 1 & 3 */
						rtn |= 1;
					}
				}
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
 314:	d2 01       	movw	r26, r4
 316:	2d 93       	st	X+, r18
 318:	2d 01       	movw	r4, r26
 31a:	e9 81       	ldd	r30, Y+1	; 0x01
 31c:	fa 81       	ldd	r31, Y+2	; 0x02
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	fa 83       	std	Y+2, r31	; 0x02
 322:	e9 83       	std	Y+1, r30	; 0x01

	uint8_t cpha = spi->_bus_.mode & 1;

	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
		// MSB is sent first
		while(size--){
 324:	89 81       	ldd	r24, Y+1	; 0x01
 326:	9a 81       	ldd	r25, Y+2	; 0x02
 328:	00 97       	sbiw	r24, 0x00	; 0
 32a:	01 f0       	breq	.+0      	; 0x32c <readMany+0x152>
 32c:	00 c0       	rjmp	.+0      	; 0x32e <readMany+0x154>
 32e:	00 c0       	rjmp	.+0      	; 0x330 <readMany+0x156>
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}else{
		// LSB is sent first
		while(size--){
 330:	88 e0       	ldi	r24, 0x08	; 8
 332:	e8 2e       	mov	r14, r24
 334:	f1 2c       	mov	r15, r1
 336:	20 e0       	ldi	r18, 0x00	; 0
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
				rtn>>=1;
 338:	26 95       	lsr	r18
				if(!cpha){ // Mode 0 or 2
 33a:	dd 20       	and	r13, r13
 33c:	01 f4       	brne	.+0      	; 0x33e <readMany+0x164>
					pin_high(spi->MOSI);					/* make MOSI high		*/
 33e:	d4 01       	movw	r26, r8
 340:	1c 96       	adiw	r26, 0x0c	; 12
 342:	8d 91       	ld	r24, X+
 344:	9c 91       	ld	r25, X
 346:	1d 97       	sbiw	r26, 0x0d	; 13
 348:	2b 83       	std	Y+3, r18	; 0x03
 34a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 0 & 2 */
 34e:	e3 2d       	mov	r30, r3
 350:	f6 2d       	mov	r31, r6
 352:	80 81       	ld	r24, Z
 354:	87 21       	and	r24, r7
 356:	2b 81       	ldd	r18, Y+3	; 0x03
 358:	81 11       	cpse	r24, r1
						rtn |= 0x80;
 35a:	20 68       	ori	r18, 0x80	; 128
					}
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 35c:	f5 01       	movw	r30, r10
 35e:	80 81       	ld	r24, Z
 360:	82 25       	eor	r24, r2
 362:	80 83       	st	Z, r24
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 364:	cc 20       	and	r12, r12
 366:	01 f0       	breq	.+0      	; 0x368 <readMany+0x18e>
 368:	8c 2d       	mov	r24, r12
 36a:	8a 95       	dec	r24
 36c:	01 f4       	brne	.+0      	; 0x36e <readMany+0x194>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 36e:	80 81       	ld	r24, Z
 370:	82 25       	eor	r24, r2
 372:	80 83       	st	Z, r24
 374:	00 c0       	rjmp	.+0      	; 0x376 <readMany+0x19c>
				}else{		// Mode 1 or 3
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (high) 	*/
 376:	85 01       	movw	r16, r10
 378:	f5 01       	movw	r30, r10
 37a:	80 81       	ld	r24, Z
 37c:	82 25       	eor	r24, r2
 37e:	80 83       	st	Z, r24
					pin_high(spi->MOSI);					/* make MOSI high		*/
 380:	d4 01       	movw	r26, r8
 382:	1c 96       	adiw	r26, 0x0c	; 12
 384:	8d 91       	ld	r24, X+
 386:	9c 91       	ld	r25, X
 388:	1d 97       	sbiw	r26, 0x0d	; 13
 38a:	2b 83       	std	Y+3, r18	; 0x03
 38c:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
					if(delay) _delay_loop_1(delay);			/* delay			  	*/
 390:	2b 81       	ldd	r18, Y+3	; 0x03
 392:	cc 20       	and	r12, r12
 394:	01 f0       	breq	.+0      	; 0x396 <readMany+0x1bc>
 396:	8c 2d       	mov	r24, r12
 398:	8a 95       	dec	r24
 39a:	01 f4       	brne	.+0      	; 0x39c <readMany+0x1c2>
					_SFR_MEM8(sclkPort) ^= sclkMask;		/* toggle clock (low) 	*/
 39c:	f8 01       	movw	r30, r16
 39e:	80 81       	ld	r24, Z
 3a0:	82 25       	eor	r24, r2
 3a2:	80 83       	st	Z, r24
					if(_SFR_MEM8(misoPin) & misoMask){	/* read input for modes 1 & 3 */
 3a4:	e3 2d       	mov	r30, r3
 3a6:	f6 2d       	mov	r31, r6
 3a8:	80 81       	ld	r24, Z
 3aa:	87 21       	and	r24, r7
 3ac:	01 f0       	breq	.+0      	; 0x3ae <readMany+0x1d4>
						rtn |= 0x80;
 3ae:	20 68       	ori	r18, 0x80	; 128
 3b0:	08 94       	sec
 3b2:	e1 08       	sbc	r14, r1
 3b4:	f1 08       	sbc	r15, r1
		}
	}else{
		// LSB is sent first
		while(size--){
			uint8_t rtn = 0;
			for(int i=0; i<8; i++){						/* for each bit			*/
 3b6:	e1 14       	cp	r14, r1
 3b8:	f1 04       	cpc	r15, r1
 3ba:	01 f0       	breq	.+0      	; 0x3bc <readMany+0x1e2>
 3bc:	00 c0       	rjmp	.+0      	; 0x3be <readMany+0x1e4>
						rtn |= 0x80;
					}
				}

			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
 3be:	d2 01       	movw	r26, r4
 3c0:	2d 93       	st	X+, r18
 3c2:	2d 01       	movw	r4, r26
 3c4:	e9 81       	ldd	r30, Y+1	; 0x01
 3c6:	fa 81       	ldd	r31, Y+2	; 0x02
 3c8:	31 97       	sbiw	r30, 0x01	; 1
 3ca:	fa 83       	std	Y+2, r31	; 0x02
 3cc:	e9 83       	std	Y+1, r30	; 0x01
			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}else{
		// LSB is sent first
		while(size--){
 3ce:	89 81       	ldd	r24, Y+1	; 0x01
 3d0:	9a 81       	ldd	r25, Y+2	; 0x02
 3d2:	00 97       	sbiw	r24, 0x00	; 0
 3d4:	01 f0       	breq	.+0      	; 0x3d6 <readMany+0x1fc>
 3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <readMany+0x1fe>

			}											/* next bit				*/
			*dst++ = rtn;								/* store byte			*/
		}
	}
}
 3d8:	0f 90       	pop	r0
 3da:	0f 90       	pop	r0
 3dc:	0f 90       	pop	r0
 3de:	df 91       	pop	r29
 3e0:	cf 91       	pop	r28
 3e2:	1f 91       	pop	r17
 3e4:	0f 91       	pop	r16
 3e6:	ff 90       	pop	r15
 3e8:	ef 90       	pop	r14
 3ea:	df 90       	pop	r13
 3ec:	cf 90       	pop	r12
 3ee:	bf 90       	pop	r11
 3f0:	af 90       	pop	r10
 3f2:	9f 90       	pop	r9
 3f4:	8f 90       	pop	r8
 3f6:	7f 90       	pop	r7
 3f8:	6f 90       	pop	r6
 3fa:	5f 90       	pop	r5
 3fc:	4f 90       	pop	r4
 3fe:	3f 90       	pop	r3
 400:	2f 90       	pop	r2
 402:	08 95       	ret

00000404 <select>:
	}
	__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
													/* using first bit of filler */
}

static void	 select(const SPI_ABSTRACT_DEVICE* device,boolean selected){
 404:	fc 01       	movw	r30, r24
	if(selected){
 406:	66 23       	and	r22, r22
 408:	01 f0       	breq	.+0      	; 0x40a <select+0x6>
		// Set MOSI to initial value
		SPI_SW* spi = (SPI_SW*)(device->bus);
		__spiWriteMOSI(spi,device->fillerByte);			/* Set the output pin 	     */
 40a:	80 81       	ld	r24, Z
 40c:	91 81       	ldd	r25, Z+1	; 0x01
 40e:	67 81       	ldd	r22, Z+7	; 0x07
 410:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 414:	08 95       	ret

00000416 <__spiReadMISO>:
	// Set the clock to its initial state
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
}


static uint8_t __spiReadMISO(const SPI_SW* spi, uint8_t data){
 416:	cf 93       	push	r28
 418:	fc 01       	movw	r30, r24
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 41a:	80 85       	ldd	r24, Z+8	; 0x08
 41c:	26 85       	ldd	r18, Z+14	; 0x0e
 41e:	37 85       	ldd	r19, Z+15	; 0x0f
		// MSB is sent first
		data<<=1;
 420:	c6 2f       	mov	r28, r22
	pin_make_output(spi->SCLK, (mode == SPI_MODE_2 || mode == SPI_MODE_3));
}


static uint8_t __spiReadMISO(const SPI_SW* spi, uint8_t data){
	if(spi->_bus_.order == SPI_DATA_ORDER_MSB){
 422:	88 23       	and	r24, r24
 424:	01 f4       	brne	.+0      	; 0x426 <__spiReadMISO+0x10>
		// MSB is sent first
		data<<=1;
 426:	cc 0f       	add	r28, r28
		if(pin_is_high(spi->MISO)){
 428:	c9 01       	movw	r24, r18
 42a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 42e:	88 23       	and	r24, r24
 430:	01 f0       	breq	.+0      	; 0x432 <__spiReadMISO+0x1c>
			data |= 1;
 432:	c1 60       	ori	r28, 0x01	; 1
 434:	00 c0       	rjmp	.+0      	; 0x436 <__spiReadMISO+0x20>
		}
	}else{
		// LSB is sent first
		data>>=1;
 436:	c6 95       	lsr	r28
		if(pin_is_high(spi->MISO)){
 438:	c9 01       	movw	r24, r18
 43a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 43e:	81 11       	cpse	r24, r1
			data |= 0x80;
 440:	c0 68       	ori	r28, 0x80	; 128
		}
	}
	return data;
}
 442:	8c 2f       	mov	r24, r28
 444:	cf 91       	pop	r28
 446:	08 95       	ret

00000448 <__spiSWSendByte>:
	return data;
}


// only tested with modes 0 and 2 (cpha = 0)
static uint8_t __spiSWSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
 448:	cf 92       	push	r12
 44a:	df 92       	push	r13
 44c:	ef 92       	push	r14
 44e:	ff 92       	push	r15
 450:	0f 93       	push	r16
 452:	1f 93       	push	r17
 454:	cf 93       	push	r28
 456:	df 93       	push	r29
 458:	ec 01       	movw	r28, r24
 45a:	f6 2e       	mov	r15, r22
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
 45c:	8e 81       	ldd	r24, Y+6	; 0x06
 45e:	63 e0       	ldi	r22, 0x03	; 3
 460:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 464:	d8 2e       	mov	r13, r24
	uint8_t cpha = _spi->mode & 1;
 466:	cf 80       	ldd	r12, Y+7	; 0x07
 468:	81 e0       	ldi	r24, 0x01	; 1
 46a:	c8 22       	and	r12, r24
 46c:	08 e0       	ldi	r16, 0x08	; 8
 46e:	10 e0       	ldi	r17, 0x00	; 0


// only tested with modes 0 and 2 (cpha = 0)
static uint8_t __spiSWSendByte(SPI_ABSTRACT_BUS* _spi, uint8_t data){
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
 470:	ee 24       	eor	r14, r14
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
	uint8_t cpha = _spi->mode & 1;

	for(int i=0; i<8; i++){						/* for each bit			*/
		if(!cpha){ // Mode 0 or 2
 472:	cc 20       	and	r12, r12
 474:	01 f4       	brne	.+0      	; 0x476 <__spiSWSendByte+0x2e>
			data = __spiWriteMOSI(spi,data);		/* Set the output pin 	*/
 476:	ce 01       	movw	r24, r28
 478:	6f 2d       	mov	r22, r15
 47a:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 47e:	f8 2e       	mov	r15, r24
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 0 and 2	*/
 480:	ce 01       	movw	r24, r28
 482:	6e 2d       	mov	r22, r14
 484:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 488:	e8 2e       	mov	r14, r24
			pin_toggle(spi->SCLK);					/* toggle clock (high) 	*/
 48a:	88 89       	ldd	r24, Y+16	; 0x10
 48c:	99 89       	ldd	r25, Y+17	; 0x11
 48e:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
 492:	dd 20       	and	r13, r13
 494:	01 f0       	breq	.+0      	; 0x496 <__spiSWSendByte+0x4e>
 496:	8d 2d       	mov	r24, r13
 498:	8a 95       	dec	r24
 49a:	01 f4       	brne	.+0      	; 0x49c <__spiSWSendByte+0x54>
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
 49c:	88 89       	ldd	r24, Y+16	; 0x10
 49e:	99 89       	ldd	r25, Y+17	; 0x11
 4a0:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4a4:	00 c0       	rjmp	.+0      	; 0x4a6 <__spiSWSendByte+0x5e>
		}else{		// Mode 1 or 3
			pin_toggle(spi->SCLK);					/* toggle clock (high) 	*/
 4a6:	88 89       	ldd	r24, Y+16	; 0x10
 4a8:	99 89       	ldd	r25, Y+17	; 0x11
 4aa:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			data = __spiWriteMOSI(spi,data);		/* Set the output pin 	*/
 4ae:	ce 01       	movw	r24, r28
 4b0:	6f 2d       	mov	r22, r15
 4b2:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4b6:	f8 2e       	mov	r15, r24
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
 4b8:	dd 20       	and	r13, r13
 4ba:	01 f0       	breq	.+0      	; 0x4bc <__spiSWSendByte+0x74>
 4bc:	8d 2d       	mov	r24, r13
 4be:	8a 95       	dec	r24
 4c0:	01 f4       	brne	.+0      	; 0x4c2 <__spiSWSendByte+0x7a>
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
 4c2:	88 89       	ldd	r24, Y+16	; 0x10
 4c4:	99 89       	ldd	r25, Y+17	; 0x11
 4c6:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 1 and 3	*/
 4ca:	ce 01       	movw	r24, r28
 4cc:	6e 2d       	mov	r22, r14
 4ce:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
 4d2:	e8 2e       	mov	r14, r24
 4d4:	01 50       	subi	r16, 0x01	; 1
 4d6:	10 40       	sbci	r17, 0x00	; 0
	SPI_SW* spi = (SPI_SW*)_spi;
	uint8_t rtn=0;
	uint8_t delay = _spi->clock / 3;	// delay loop is approx 3 cycles
	uint8_t cpha = _spi->mode & 1;

	for(int i=0; i<8; i++){						/* for each bit			*/
 4d8:	01 f4       	brne	.+0      	; 0x4da <__spiSWSendByte+0x92>
			if(delay) _delay_loop_1(delay);			/* delay			  	*/
			pin_toggle(spi->SCLK);					/* toggle clock (low)	*/
			rtn  = __spiReadMISO(spi,rtn);			/* read input for modes 1 and 3	*/
		}
	}											/* next bit				*/
	pin_high(spi->MOSI);						/* make MOSI high		*/
 4da:	8c 85       	ldd	r24, Y+12	; 0x0c
 4dc:	9d 85       	ldd	r25, Y+13	; 0x0d
 4de:	0e 94 00 00 	call	0	; 0x0 <__spiSWOff>
	return rtn;									/* return read byte		*/
}
 4e2:	8e 2d       	mov	r24, r14
 4e4:	df 91       	pop	r29
 4e6:	cf 91       	pop	r28
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	df 90       	pop	r13
 4f2:	cf 90       	pop	r12
 4f4:	08 95       	ret

timer.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000110c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000016  00000000  00000000  00001140  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00000000  00000000  00001156  2**0
                  ALLOC
  3 .progmem.data 0000003f  00000000  00000000  00001156  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .debug_info   00002794  00000000  00000000  00001195  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000545  00000000  00000000  00003929  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00002a6a  00000000  00000000  00003e6e  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  000068d8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000158  00000000  00000000  000068f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000005a0  00000000  00000000  00006a50  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000bf8  00000000  00000000  00006ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  000005e8  00000000  00000000  00007be8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerOff>:

/* -----------------------------------------------
 *  Disable a timer
 -------------------------------------------------*/
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
       0:	fc 01       	movw	r30, r24
       2:	34 96       	adiw	r30, 0x04	; 4
       4:	85 91       	lpm	r24, Z+
       6:	94 91       	lpm	r25, Z
       8:	fc 01       	movw	r30, r24
       a:	80 81       	ld	r24, Z
       c:	88 7f       	andi	r24, 0xF8	; 248
       e:	80 83       	st	Z, r24
}
      10:	08 95       	ret

00000012 <nullTimerCompareCallback>:
	}
}

// Magic callback for compare matches that just mark the channel as in use
// but there is nothing to do in the interrupt routine
void nullTimerCompareCallback(const TimerCompare *timer_compare, void* data){}
      12:	08 95       	ret

00000014 <clockCallback>:

// Service interrupts for the system clock
static void clockCallback(const TimerCompare *timer_compare, void* data){
	clockTicks++;
      14:	80 91 00 00 	lds	r24, 0x0000
      18:	90 91 00 00 	lds	r25, 0x0000
      1c:	a0 91 00 00 	lds	r26, 0x0000
      20:	b0 91 00 00 	lds	r27, 0x0000
      24:	01 96       	adiw	r24, 0x01	; 1
      26:	a1 1d       	adc	r26, r1
      28:	b1 1d       	adc	r27, r1
      2a:	80 93 00 00 	sts	0x0000, r24
      2e:	90 93 00 00 	sts	0x0000, r25
      32:	a0 93 00 00 	sts	0x0000, r26
      36:	b0 93 00 00 	sts	0x0000, r27
}
      3a:	08 95       	ret

0000003c <__error_flash>:

ERROR_CODE getError(void){
	 return __error.errorCode;
}

void __error_flash(void * __error, TICK_COUNT lastTime, TICK_COUNT overflow){
      3c:	8f 92       	push	r8
      3e:	9f 92       	push	r9
      40:	af 92       	push	r10
      42:	bf 92       	push	r11
      44:	ef 92       	push	r14
      46:	ff 92       	push	r15
      48:	0f 93       	push	r16
      4a:	1f 93       	push	r17
      4c:	cf 93       	push	r28
      4e:	df 93       	push	r29
      50:	ec 01       	movw	r28, r24
      52:	4a 01       	movw	r8, r20
      54:	5b 01       	movw	r10, r22
	ERROR* err = (ERROR*) __error;

	if(err->remaining==0){
      56:	89 81       	ldd	r24, Y+1	; 0x01
      58:	88 23       	and	r24, r24
      5a:	01 f4       	brne	.+0      	; 0x5c <__error_flash+0x20>
		err->remaining = ABS(err->errorCode);
      5c:	88 81       	ld	r24, Y
      5e:	18 16       	cp	r1, r24
      60:	04 f4       	brge	.+0      	; 0x62 <__error_flash+0x26>
      62:	88 81       	ld	r24, Y
      64:	00 c0       	rjmp	.+0      	; 0x66 <__error_flash+0x2a>
      66:	88 81       	ld	r24, Y
      68:	81 95       	neg	r24
      6a:	89 83       	std	Y+1, r24	; 0x01
	}

	TICK_COUNT delay = (err->errorCode <0 ) ? (TICK_COUNT)250000UL : (TICK_COUNT)500000UL;
      6c:	88 81       	ld	r24, Y
      6e:	87 ff       	sbrs	r24, 7
      70:	00 c0       	rjmp	.+0      	; 0x72 <__error_flash+0x36>
      72:	20 e9       	ldi	r18, 0x90	; 144
      74:	e2 2e       	mov	r14, r18
      76:	20 ed       	ldi	r18, 0xD0	; 208
      78:	f2 2e       	mov	r15, r18
      7a:	23 e0       	ldi	r18, 0x03	; 3
      7c:	02 2f       	mov	r16, r18
      7e:	11 2d       	mov	r17, r1
      80:	00 c0       	rjmp	.+0      	; 0x82 <__error_flash+0x46>
      82:	90 e2       	ldi	r25, 0x20	; 32
      84:	e9 2e       	mov	r14, r25
      86:	91 ea       	ldi	r25, 0xA1	; 161
      88:	f9 2e       	mov	r15, r25
      8a:	97 e0       	ldi	r25, 0x07	; 7
      8c:	09 2f       	mov	r16, r25
      8e:	11 2d       	mov	r17, r1
	if(err->phase){
      90:	2a 81       	ldd	r18, Y+2	; 0x02
      92:	80 91 00 00 	lds	r24, 0x0000
      96:	90 91 00 00 	lds	r25, 0x0000
      9a:	20 ff       	sbrs	r18, 0
      9c:	00 c0       	rjmp	.+0      	; 0x9e <__error_flash+0x62>
		LED_on(&statusLED);
	}
}

static __inline__ void statusLED_off(){
	if(pin_is_output(statusLED.pin)){
      9e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
      a2:	88 23       	and	r24, r24
      a4:	01 f0       	breq	.+0      	; 0xa6 <__error_flash+0x6a>
static __inline__ void LED_on(LED* led){
	LED_set(led,TRUE);
}

static __inline__ void LED_off(LED* led){
	LED_set(led,FALSE);
      a6:	80 e0       	ldi	r24, 0x00	; 0
      a8:	90 e0       	ldi	r25, 0x00	; 0
      aa:	60 e0       	ldi	r22, 0x00	; 0
      ac:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		// turn led off
		statusLED_off();
		err->remaining--;
      b0:	89 81       	ldd	r24, Y+1	; 0x01
      b2:	81 50       	subi	r24, 0x01	; 1
      b4:	89 83       	std	Y+1, r24	; 0x01
		if(err->remaining==0){
      b6:	89 81       	ldd	r24, Y+1	; 0x01
      b8:	88 23       	and	r24, r24
      ba:	01 f4       	brne	.+0      	; 0xbc <__error_flash+0x80>
			delay = (TICK_COUNT)2000000UL;
      bc:	80 e8       	ldi	r24, 0x80	; 128
      be:	e8 2e       	mov	r14, r24
      c0:	84 e8       	ldi	r24, 0x84	; 132
      c2:	f8 2e       	mov	r15, r24
      c4:	8e e1       	ldi	r24, 0x1E	; 30
      c6:	08 2f       	mov	r16, r24
      c8:	11 2d       	mov	r17, r1
		}

		err->phase=FALSE;
      ca:	8a 81       	ldd	r24, Y+2	; 0x02
      cc:	8e 7f       	andi	r24, 0xFE	; 254
      ce:	00 c0       	rjmp	.+0      	; 0xd0 <__error_flash+0x94>
	statusLED.initialised=FALSE;
	LED_on(&statusLED);
}

static __inline__ void statusLED_on(){
	if(pin_is_output(statusLED.pin)){
      d0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
      d4:	88 23       	and	r24, r24
      d6:	01 f0       	breq	.+0      	; 0xd8 <__error_flash+0x9c>


void LED_set(LED* led,	boolean value);

static __inline__ void LED_on(LED* led){
	LED_set(led,TRUE);
      d8:	80 e0       	ldi	r24, 0x00	; 0
      da:	90 e0       	ldi	r25, 0x00	; 0
      dc:	6f ef       	ldi	r22, 0xFF	; 255
      de:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}else{
		// turn led on
		statusLED_on();
		err->phase=TRUE;
      e2:	8a 81       	ldd	r24, Y+2	; 0x02
      e4:	81 60       	ori	r24, 0x01	; 1
      e6:	8a 83       	std	Y+2, r24	; 0x02
		delay -= overflow;	// remove any overflow
	}
*/

	// queue the next event
	scheduleJob(&__error_flash, __error, lastTime, delay);
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	90 e0       	ldi	r25, 0x00	; 0
      ec:	be 01       	movw	r22, r28
      ee:	a5 01       	movw	r20, r10
      f0:	94 01       	movw	r18, r8
      f2:	0e 94 00 00 	call	0	; 0x0 <timerOff>

}
      f6:	df 91       	pop	r29
      f8:	cf 91       	pop	r28
      fa:	1f 91       	pop	r17
      fc:	0f 91       	pop	r16
      fe:	ff 90       	pop	r15
     100:	ef 90       	pop	r14
     102:	bf 90       	pop	r11
     104:	af 90       	pop	r10
     106:	9f 90       	pop	r9
     108:	8f 90       	pop	r8
     10a:	08 95       	ret

0000010c <ticks_per_ms>:
extern const uint8_t NUMBER_OF_TIMERS;

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
     10c:	0f 93       	push	r16
     10e:	1f 93       	push	r17
     110:	cf 93       	push	r28
     112:	df 93       	push	r29
     114:	ea 01       	movw	r28, r20
	return (ms * cpu_speed_div_1000)/prescale;
     116:	20 91 00 00 	lds	r18, 0x0000
     11a:	30 91 00 00 	lds	r19, 0x0000
     11e:	40 e0       	ldi	r20, 0x00	; 0
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     126:	9e 01       	movw	r18, r28
     128:	40 e0       	ldi	r20, 0x00	; 0
     12a:	50 e0       	ldi	r21, 0x00	; 0
     12c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     130:	b9 01       	movw	r22, r18
     132:	ca 01       	movw	r24, r20
     134:	df 91       	pop	r29
     136:	cf 91       	pop	r28
     138:	1f 91       	pop	r17
     13a:	0f 91       	pop	r16
     13c:	08 95       	ret

0000013e <delay_cycles>:

/*
	Delay for a given number of processor cycles
*/
void delay_cycles(uint32_t __cycles){
	if(__cycles <= (3*256U)){
     13e:	61 30       	cpi	r22, 0x01	; 1
     140:	23 e0       	ldi	r18, 0x03	; 3
     142:	72 07       	cpc	r23, r18
     144:	20 e0       	ldi	r18, 0x00	; 0
     146:	82 07       	cpc	r24, r18
     148:	20 e0       	ldi	r18, 0x00	; 0
     14a:	92 07       	cpc	r25, r18
     14c:	00 f4       	brcc	.+0      	; 0x14e <delay_cycles+0x10>
		_delay_loop_1((uint8_t) (__cycles / 3) );
     14e:	23 e0       	ldi	r18, 0x03	; 3
     150:	30 e0       	ldi	r19, 0x00	; 0
     152:	40 e0       	ldi	r20, 0x00	; 0
     154:	50 e0       	ldi	r21, 0x00	; 0
     156:	0e 94 00 00 	call	0	; 0x0 <timerOff>

    Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
    can be achieved.
*/
static __inline__ void _delay_loop_1(uint8_t __count){
	__asm__ volatile (
     15a:	2a 95       	dec	r18
     15c:	01 f4       	brne	.+0      	; 0x15e <delay_cycles+0x20>
     15e:	08 95       	ret
		return;
	}

	uint32_t cyc = __cycles / 4;
     160:	ab 01       	movw	r20, r22
     162:	bc 01       	movw	r22, r24
     164:	32 e0       	ldi	r19, 0x02	; 2
     166:	76 95       	lsr	r23
     168:	67 95       	ror	r22
     16a:	57 95       	ror	r21
     16c:	47 95       	ror	r20
     16e:	3a 95       	dec	r19
     170:	01 f4       	brne	.+0      	; 0x172 <delay_cycles+0x34>
	while(cyc != 0 ){
	   uint16_t actual = (cyc <= 65535U) ? cyc : 65535U;
     172:	db 01       	movw	r26, r22
     174:	ca 01       	movw	r24, r20
     176:	40 30       	cpi	r20, 0x00	; 0
     178:	20 e0       	ldi	r18, 0x00	; 0
     17a:	52 07       	cpc	r21, r18
     17c:	21 e0       	ldi	r18, 0x01	; 1
     17e:	62 07       	cpc	r22, r18
     180:	20 e0       	ldi	r18, 0x00	; 0
     182:	72 07       	cpc	r23, r18
     184:	00 f0       	brcs	.+0      	; 0x186 <delay_cycles+0x48>
     186:	8f ef       	ldi	r24, 0xFF	; 255
     188:	9f ef       	ldi	r25, 0xFF	; 255
     18a:	a0 e0       	ldi	r26, 0x00	; 0
     18c:	b0 e0       	ldi	r27, 0x00	; 0

    Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
    milliseconds can be achieved.
 */
static __inline__ void _delay_loop_2(uint16_t __count){
	__asm__ volatile (
     18e:	fc 01       	movw	r30, r24
     190:	31 97       	sbiw	r30, 0x01	; 1
     192:	01 f4       	brne	.+0      	; 0x194 <delay_cycles+0x56>
	   _delay_loop_2(actual);
	   cyc -= actual;
     194:	a0 e0       	ldi	r26, 0x00	; 0
     196:	b0 e0       	ldi	r27, 0x00	; 0
     198:	48 1b       	sub	r20, r24
     19a:	59 0b       	sbc	r21, r25
     19c:	6a 0b       	sbc	r22, r26
     19e:	7b 0b       	sbc	r23, r27
		_delay_loop_1((uint8_t) (__cycles / 3) );
		return;
	}

	uint32_t cyc = __cycles / 4;
	while(cyc != 0 ){
     1a0:	01 f4       	brne	.+0      	; 0x1a2 <delay_cycles+0x64>
     1a2:	08 95       	ret

000001a4 <__timerPrescalerIndex>:
/* -------------------------------------------------------
//
//  Does a timer support a given prescale value
//
------------------------------------------------------- */
int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler){
     1a4:	db 01       	movw	r26, r22
	uint8_t count;
	uint16_t *array;
	int8_t i;

	if(pgm_read_byte(&timer->pgm_rtc)){
     1a6:	fc 01       	movw	r30, r24
     1a8:	37 96       	adiw	r30, 0x07	; 7
     1aa:	e4 91       	lpm	r30, Z
     1ac:	ee 23       	and	r30, r30
     1ae:	01 f0       	breq	.+0      	; 0x1b0 <__timerPrescalerIndex+0xc>
		array =TimerRTCPrescaleFactor;
     1b0:	20 e0       	ldi	r18, 0x00	; 0
     1b2:	30 e0       	ldi	r19, 0x00	; 0
		count = sizeof(TimerRTCPrescaleFactor) / sizeof(uint16_t);
     1b4:	88 e0       	ldi	r24, 0x08	; 8
     1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <__timerPrescalerIndex+0x14>
	}else{
		array =TimerPrescaleFactor;
     1b8:	20 e0       	ldi	r18, 0x00	; 0
     1ba:	30 e0       	ldi	r19, 0x00	; 0
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);
     1bc:	86 e0       	ldi	r24, 0x06	; 6

	}

	for(i=count-1; i>=0; i--){
     1be:	81 50       	subi	r24, 0x01	; 1
     1c0:	60 e0       	ldi	r22, 0x00	; 0
     1c2:	70 e0       	ldi	r23, 0x00	; 0
/* -------------------------------------------------------
//
//  Does a timer support a given prescale value
//
------------------------------------------------------- */
int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler){
     1c4:	48 2f       	mov	r20, r24
     1c6:	55 27       	eor	r21, r21
     1c8:	47 fd       	sbrc	r20, 7
     1ca:	50 95       	com	r21
     1cc:	44 0f       	add	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	42 0f       	add	r20, r18
     1d2:	53 1f       	adc	r21, r19
     1d4:	fa 01       	movw	r30, r20
     1d6:	e6 0f       	add	r30, r22
     1d8:	f7 1f       	adc	r31, r23
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);

	}

	for(i=count-1; i>=0; i--){
		uint16_t one = pgm_read_word(array + i);
     1da:	25 91       	lpm	r18, Z+
     1dc:	34 91       	lpm	r19, Z
		if(one == prescaler){
     1de:	2a 17       	cp	r18, r26
     1e0:	3b 07       	cpc	r19, r27
     1e2:	01 f4       	brne	.+0      	; 0x1e4 <__timerPrescalerIndex+0x40>
			return i;
     1e4:	99 27       	eor	r25, r25
     1e6:	87 fd       	sbrc	r24, 7
     1e8:	90 95       	com	r25
     1ea:	08 95       	ret
		array =TimerPrescaleFactor;
		count = sizeof(TimerPrescaleFactor) / sizeof(uint16_t);

	}

	for(i=count-1; i>=0; i--){
     1ec:	81 50       	subi	r24, 0x01	; 1
     1ee:	62 50       	subi	r22, 0x02	; 2
     1f0:	70 40       	sbci	r23, 0x00	; 0
     1f2:	87 ff       	sbrs	r24, 7
     1f4:	00 c0       	rjmp	.+0      	; 0x1f6 <__timerPrescalerIndex+0x52>
		uint16_t one = pgm_read_word(array + i);
		if(one == prescaler){
			return i;
		}
	}
	return -1;
     1f6:	8f ef       	ldi	r24, 0xFF	; 255
     1f8:	9f ef       	ldi	r25, 0xFF	; 255
}
     1fa:	08 95       	ret

000001fc <timerGetClosestPrescale>:
	CRITICAL_SECTION_END;

}

// Round up to the nearest prescaler value
uint16_t timerGetClosestPrescale(const Timer* timer, uint16_t prescale){
     1fc:	0f 93       	push	r16
     1fe:	1f 93       	push	r17
     200:	cf 93       	push	r28
     202:	df 93       	push	r29
     204:	8c 01       	movw	r16, r24
	prescale = CLAMP(prescale, 1, MAX_PRESCALE);
     206:	eb 01       	movw	r28, r22
     208:	24 e0       	ldi	r18, 0x04	; 4
     20a:	61 30       	cpi	r22, 0x01	; 1
     20c:	72 07       	cpc	r23, r18
     20e:	00 f0       	brcs	.+0      	; 0x210 <timerGetClosestPrescale+0x14>
     210:	c0 e0       	ldi	r28, 0x00	; 0
     212:	d4 e0       	ldi	r29, 0x04	; 4
     214:	20 97       	sbiw	r28, 0x00	; 0
     216:	01 f4       	brne	.+0      	; 0x218 <timerGetClosestPrescale+0x1c>
     218:	c1 e0       	ldi	r28, 0x01	; 1
     21a:	d0 e0       	ldi	r29, 0x00	; 0
     21c:	00 c0       	rjmp	.+0      	; 0x21e <timerGetClosestPrescale+0x22>

	while(__timerPrescalerIndex(timer,prescale)==-1){
		prescale++;
     21e:	21 96       	adiw	r28, 0x01	; 1

// Round up to the nearest prescaler value
uint16_t timerGetClosestPrescale(const Timer* timer, uint16_t prescale){
	prescale = CLAMP(prescale, 1, MAX_PRESCALE);

	while(__timerPrescalerIndex(timer,prescale)==-1){
     220:	c8 01       	movw	r24, r16
     222:	be 01       	movw	r22, r28
     224:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     228:	2f ef       	ldi	r18, 0xFF	; 255
     22a:	8f 3f       	cpi	r24, 0xFF	; 255
     22c:	92 07       	cpc	r25, r18
     22e:	01 f0       	breq	.+0      	; 0x230 <timerGetClosestPrescale+0x34>
		prescale++;
	}
	return prescale;
}
     230:	ce 01       	movw	r24, r28
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	1f 91       	pop	r17
     238:	0f 91       	pop	r16
     23a:	08 95       	ret

0000023c <timerGetCounter>:
}



uint16_t timerGetCounter(const Timer* timer){
	PORT counter = pgm_read_word(&timer->pgm_counter);
     23c:	fc 01       	movw	r30, r24
     23e:	32 96       	adiw	r30, 0x02	; 2
     240:	25 91       	lpm	r18, Z+
     242:	34 91       	lpm	r19, Z
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     244:	06 96       	adiw	r24, 0x06	; 6
     246:	fc 01       	movw	r30, r24
     248:	84 91       	lpm	r24, Z
	if(timerIs16bit(timer)){
		return _SFR_MEM16(counter);
     24a:	f9 01       	movw	r30, r18



uint16_t timerGetCounter(const Timer* timer){
	PORT counter = pgm_read_word(&timer->pgm_counter);
	if(timerIs16bit(timer)){
     24c:	88 23       	and	r24, r24
     24e:	01 f0       	breq	.+0      	; 0x250 <timerGetCounter+0x14>
		return _SFR_MEM16(counter);
     250:	80 81       	ld	r24, Z
     252:	91 81       	ldd	r25, Z+1	; 0x01
     254:	08 95       	ret
	}
	return _SFR_MEM8(counter);
     256:	80 81       	ld	r24, Z
     258:	90 e0       	ldi	r25, 0x00	; 0
}
     25a:	08 95       	ret

0000025c <__timerRead>:

static void __timerRead(const Timer* timer,TIMER_SNAPSHOT* snapshot){
     25c:	af 92       	push	r10
     25e:	bf 92       	push	r11
     260:	cf 92       	push	r12
     262:	df 92       	push	r13
     264:	ff 92       	push	r15
     266:	0f 93       	push	r16
     268:	1f 93       	push	r17
     26a:	cf 93       	push	r28
     26c:	df 93       	push	r29
     26e:	8c 01       	movw	r16, r24
     270:	eb 01       	movw	r28, r22
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     272:	fc 01       	movw	r30, r24
     274:	a5 91       	lpm	r26, Z+
     276:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
     278:	1a 96       	adiw	r26, 0x0a	; 10
     27a:	8c 91       	ld	r24, X
     27c:	1a 97       	sbiw	r26, 0x0a	; 10
	TIMER_MODE mode = timerGetMode(timer);

	snapshot->timer = timer;
     27e:	19 83       	std	Y+1, r17	; 0x01
     280:	08 83       	st	Y, r16
	if(!timer){
     282:	01 15       	cp	r16, r1
     284:	11 05       	cpc	r17, r1
     286:	01 f4       	brne	.+0      	; 0x288 <__timerRead+0x2c>
		snapshot->part = snapshot->whole = 0;
     288:	1a 82       	std	Y+2, r1	; 0x02
     28a:	1b 82       	std	Y+3, r1	; 0x03
     28c:	1c 82       	std	Y+4, r1	; 0x04
     28e:	1d 82       	std	Y+5, r1	; 0x05
     290:	1f 82       	std	Y+7, r1	; 0x07
     292:	1e 82       	std	Y+6, r1	; 0x06
		return;
     294:	00 c0       	rjmp	.+0      	; 0x296 <__timerRead+0x3a>
	}

	if(mode==TIMER_MODE_CTC_OCR
     296:	84 30       	cpi	r24, 0x04	; 4
     298:	01 f0       	breq	.+0      	; 0x29a <__timerRead+0x3e>
			|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
     29a:	89 30       	cpi	r24, 0x09	; 9
     29c:	01 f0       	breq	.+0      	; 0x29e <__timerRead+0x42>
			|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
     29e:	8b 30       	cpi	r24, 0x0B	; 11
     2a0:	01 f0       	breq	.+0      	; 0x2a2 <__timerRead+0x46>
			|| mode==TIMER_MODE_PWM_FAST_OCR){
     2a2:	8f 30       	cpi	r24, 0x0F	; 15
     2a4:	01 f4       	brne	.+0      	; 0x2a6 <__timerRead+0x4a>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     2a6:	f8 01       	movw	r30, r16
     2a8:	77 96       	adiw	r30, 0x17	; 23
     2aa:	a5 90       	lpm	r10, Z+
     2ac:	b4 90       	lpm	r11, Z
		// These mode all generate compare interrupts on channel A
		const TimerCompare* channel = timerGetCompare(timer,0);
		CRITICAL_SECTION_START;
     2ae:	ff b6       	in	r15, 0x3f	; 63
     2b0:	f8 94       	cli
		{
			uint16_t tcnt  = timerGetCounter(timer);	// get the current ticks
     2b2:	c8 01       	movw	r24, r16
     2b4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     2b8:	6c 01       	movw	r12, r24
			snapshot->whole  = (timer==g_heartbeat) ? clockTicks : 0;
     2ba:	80 91 00 00 	lds	r24, 0x0000
     2be:	90 91 00 00 	lds	r25, 0x0000
     2c2:	08 17       	cp	r16, r24
     2c4:	19 07       	cpc	r17, r25
     2c6:	01 f4       	brne	.+0      	; 0x2c8 <__timerRead+0x6c>
     2c8:	80 91 00 00 	lds	r24, 0x0000
     2cc:	90 91 00 00 	lds	r25, 0x0000
     2d0:	a0 91 00 00 	lds	r26, 0x0000
     2d4:	b0 91 00 00 	lds	r27, 0x0000
     2d8:	00 c0       	rjmp	.+0      	; 0x2da <__timerRead+0x7e>
     2da:	80 e0       	ldi	r24, 0x00	; 0
     2dc:	90 e0       	ldi	r25, 0x00	; 0
     2de:	a0 e0       	ldi	r26, 0x00	; 0
     2e0:	b0 e0       	ldi	r27, 0x00	; 0
     2e2:	8a 83       	std	Y+2, r24	; 0x02
     2e4:	9b 83       	std	Y+3, r25	; 0x03
     2e6:	ac 83       	std	Y+4, r26	; 0x04
     2e8:	bd 83       	std	Y+5, r27	; 0x05
			snapshot->part   = timerGetCounter(timer);				// get the current ticks again
     2ea:	c8 01       	movw	r24, r16
     2ec:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     2f0:	9f 83       	std	Y+7, r25	; 0x07
     2f2:	8e 83       	std	Y+6, r24	; 0x06
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || compareIsInterruptPending(channel)){
     2f4:	8c 15       	cp	r24, r12
     2f6:	9d 05       	cpc	r25, r13
     2f8:	00 f0       	brcs	.+0      	; 0x2fa <__timerRead+0x9e>
//
//  Test if there is a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ boolean compareIsInterruptPending(const TimerCompare* channel){
	return __portMaskGet(&channel->pgm_intpending);
     2fa:	c5 01       	movw	r24, r10
     2fc:	08 96       	adiw	r24, 0x08	; 8
     2fe:	00 c0       	rjmp	.+0      	; 0x300 <__timerRead+0xa4>
			}
		}
		CRITICAL_SECTION_END;
	}else{
		// These modes generate overflow interrupts.
		CRITICAL_SECTION_START;
     300:	ff b6       	in	r15, 0x3f	; 63
     302:	f8 94       	cli
		{
			uint16_t tcnt  = timerGetCounter(timer);	// get the current ticks
     304:	c8 01       	movw	r24, r16
     306:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     30a:	6c 01       	movw	r12, r24
			snapshot->whole = (timer==g_heartbeat) ? clockTicks : 0;
     30c:	80 91 00 00 	lds	r24, 0x0000
     310:	90 91 00 00 	lds	r25, 0x0000
     314:	08 17       	cp	r16, r24
     316:	19 07       	cpc	r17, r25
     318:	01 f4       	brne	.+0      	; 0x31a <__timerRead+0xbe>
     31a:	80 91 00 00 	lds	r24, 0x0000
     31e:	90 91 00 00 	lds	r25, 0x0000
     322:	a0 91 00 00 	lds	r26, 0x0000
     326:	b0 91 00 00 	lds	r27, 0x0000
     32a:	00 c0       	rjmp	.+0      	; 0x32c <__timerRead+0xd0>
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	a0 e0       	ldi	r26, 0x00	; 0
     332:	b0 e0       	ldi	r27, 0x00	; 0
     334:	8a 83       	std	Y+2, r24	; 0x02
     336:	9b 83       	std	Y+3, r25	; 0x03
     338:	ac 83       	std	Y+4, r26	; 0x04
     33a:	bd 83       	std	Y+5, r27	; 0x05
			snapshot->part = timerGetCounter(timer);				// get the current ticks again
     33c:	c8 01       	movw	r24, r16
     33e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     342:	9f 83       	std	Y+7, r25	; 0x07
     344:	8e 83       	std	Y+6, r24	; 0x06
			// If the second reading of tcnt has gone down then there must have been an overflow
			// since reading the 'rtn' value. Or there may be a pending interrupt which may be
			// because interrupts are currently turned off. In either case increment the 'rtn' value
			// as if the interrupt has happened
			if(snapshot->part < tcnt || timerOverflowIsInterruptPending(timer)){
     346:	8c 15       	cp	r24, r12
     348:	9d 05       	cpc	r25, r13
     34a:	00 f0       	brcs	.+0      	; 0x34c <__timerRead+0xf0>
//
//  Test if there is a pending overflow interrupt on the timer
//
------------------------------------------------------- */
static __inline__ boolean timerOverflowIsInterruptPending(const Timer* timer){
	return __portMaskGet(&timer->pgm_overflowreq);
     34c:	c8 01       	movw	r24, r16
     34e:	4c 96       	adiw	r24, 0x1c	; 28
     350:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     354:	88 23       	and	r24, r24
     356:	01 f0       	breq	.+0      	; 0x358 <__timerRead+0xfc>
				snapshot->whole+=1;
     358:	8a 81       	ldd	r24, Y+2	; 0x02
     35a:	9b 81       	ldd	r25, Y+3	; 0x03
     35c:	ac 81       	ldd	r26, Y+4	; 0x04
     35e:	bd 81       	ldd	r27, Y+5	; 0x05
     360:	01 96       	adiw	r24, 0x01	; 1
     362:	a1 1d       	adc	r26, r1
     364:	b1 1d       	adc	r27, r1
     366:	8a 83       	std	Y+2, r24	; 0x02
     368:	9b 83       	std	Y+3, r25	; 0x03
     36a:	ac 83       	std	Y+4, r26	; 0x04
     36c:	bd 83       	std	Y+5, r27	; 0x05
				snapshot->part = timerGetCounter(timer); 		// get the current ticks again
     36e:	c8 01       	movw	r24, r16
     370:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     374:	9f 83       	std	Y+7, r25	; 0x07
     376:	8e 83       	std	Y+6, r24	; 0x06
			}
		}
		CRITICAL_SECTION_END;
     378:	ff be       	out	0x3f, r15	; 63
	}
}
     37a:	df 91       	pop	r29
     37c:	cf 91       	pop	r28
     37e:	1f 91       	pop	r17
     380:	0f 91       	pop	r16
     382:	ff 90       	pop	r15
     384:	df 90       	pop	r13
     386:	cf 90       	pop	r12
     388:	bf 90       	pop	r11
     38a:	af 90       	pop	r10
     38c:	08 95       	ret

0000038e <clockGetSnapshot>:
	__timerRead(timer, &snapshot);
	return timerSnapshotToTicks(&snapshot);
}


void clockGetSnapshot(TIMER_SNAPSHOT* snapshot){
     38e:	bc 01       	movw	r22, r24
	__timerRead(g_heartbeat, snapshot);
     390:	80 91 00 00 	lds	r24, 0x0000
     394:	90 91 00 00 	lds	r25, 0x0000
     398:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     39c:	08 95       	ret

0000039e <compareSetOutputMode>:
		}

	CRITICAL_SECTION_END;
}
void compareSetOutputMode(const TimerCompare* channel, CHANNEL_MODE mode){
	PORT port = pgm_read_word(&channel->pgm_com.port);
     39e:	fc 01       	movw	r30, r24
     3a0:	3b 96       	adiw	r30, 0x0b	; 11
     3a2:	25 91       	lpm	r18, Z+
     3a4:	34 91       	lpm	r19, Z
	PIN  bit = pgm_read_byte(&channel->pgm_com.mask);
     3a6:	0d 96       	adiw	r24, 0x0d	; 13
     3a8:	fc 01       	movw	r30, r24
     3aa:	84 91       	lpm	r24, Z
	mode <<= bit;
     3ac:	70 e0       	ldi	r23, 0x00	; 0
     3ae:	08 2e       	mov	r0, r24
     3b0:	00 c0       	rjmp	.+0      	; 0x3b2 <compareSetOutputMode+0x14>
     3b2:	66 0f       	add	r22, r22
     3b4:	77 1f       	adc	r23, r23
     3b6:	0a 94       	dec	r0
     3b8:	02 f4       	brpl	.+0      	; 0x3ba <compareSetOutputMode+0x1c>

	PIN mask = BV(bit);	// occupies the next bit up as well
     3ba:	41 e0       	ldi	r20, 0x01	; 1
     3bc:	50 e0       	ldi	r21, 0x00	; 0
     3be:	00 c0       	rjmp	.+0      	; 0x3c0 <compareSetOutputMode+0x22>
     3c0:	44 0f       	add	r20, r20
     3c2:	55 1f       	adc	r21, r21
     3c4:	8a 95       	dec	r24
     3c6:	02 f4       	brpl	.+0      	; 0x3c8 <compareSetOutputMode+0x2a>
	mask |= (mask<<1);
     3c8:	84 2f       	mov	r24, r20
     3ca:	88 0f       	add	r24, r24
     3cc:	84 2b       	or	r24, r20

	_SFR_MEM8(port) = (_SFR_MEM8(port) & ~mask) | (mode & mask);
     3ce:	f9 01       	movw	r30, r18
     3d0:	90 81       	ld	r25, Z
     3d2:	68 23       	and	r22, r24
     3d4:	80 95       	com	r24
     3d6:	89 23       	and	r24, r25
     3d8:	68 2b       	or	r22, r24
     3da:	60 83       	st	Z, r22
}
     3dc:	08 95       	ret

000003de <compareGetOutputMode>:

CHANNEL_MODE compareGetOutputMode(const TimerCompare* channel){
	PORT port = pgm_read_word(&channel->pgm_com.port);
     3de:	fc 01       	movw	r30, r24
     3e0:	3b 96       	adiw	r30, 0x0b	; 11
     3e2:	25 91       	lpm	r18, Z+
     3e4:	34 91       	lpm	r19, Z
	PIN  bit = pgm_read_byte(&channel->pgm_com.mask);
     3e6:	0d 96       	adiw	r24, 0x0d	; 13
     3e8:	fc 01       	movw	r30, r24
     3ea:	64 91       	lpm	r22, Z

	PIN mask = BV(bit);	// occupies the next bit up as well
     3ec:	41 e0       	ldi	r20, 0x01	; 1
     3ee:	50 e0       	ldi	r21, 0x00	; 0
     3f0:	06 2e       	mov	r0, r22
     3f2:	00 c0       	rjmp	.+0      	; 0x3f4 <compareGetOutputMode+0x16>
     3f4:	44 0f       	add	r20, r20
     3f6:	55 1f       	adc	r21, r21
     3f8:	0a 94       	dec	r0
     3fa:	02 f4       	brpl	.+0      	; 0x3fc <compareGetOutputMode+0x1e>
	mask |= (mask<<1);
     3fc:	94 2f       	mov	r25, r20
     3fe:	99 0f       	add	r25, r25
     400:	94 2b       	or	r25, r20

	uint8_t val = _SFR_MEM8(port) & mask;
     402:	d9 01       	movw	r26, r18
     404:	8c 91       	ld	r24, X
     406:	98 23       	and	r25, r24
	val >>= bit;
     408:	89 2f       	mov	r24, r25
     40a:	90 e0       	ldi	r25, 0x00	; 0
     40c:	00 c0       	rjmp	.+0      	; 0x40e <compareGetOutputMode+0x30>
     40e:	95 95       	asr	r25
     410:	87 95       	ror	r24
     412:	6a 95       	dec	r22
     414:	02 f4       	brpl	.+0      	; 0x416 <compareGetOutputMode+0x38>

	return (CHANNEL_MODE)val;
}
     416:	08 95       	ret

00000418 <__timer_overflowService>:
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     418:	fc 01       	movw	r30, r24
     41a:	25 91       	lpm	r18, Z+
     41c:	34 91       	lpm	r19, Z
     41e:	d9 01       	movw	r26, r18
------------------------------------------------------- */
void __timer_overflowService(const Timer* timer){
	TimerData* td = timerGetData(timer);

// 	td->overflow++;	// increment the overflow counter
	if(td->overflow_callback){
     420:	12 96       	adiw	r26, 0x02	; 2
     422:	ed 91       	ld	r30, X+
     424:	fc 91       	ld	r31, X
     426:	13 97       	sbiw	r26, 0x03	; 3
     428:	30 97       	sbiw	r30, 0x00	; 0
     42a:	01 f0       	breq	.+0      	; 0x42c <__timer_overflowService+0x14>
		td->overflow_callback(timer,td->overflow_data);
     42c:	14 96       	adiw	r26, 0x04	; 4
     42e:	6d 91       	ld	r22, X+
     430:	7c 91       	ld	r23, X
     432:	15 97       	sbiw	r26, 0x05	; 5
     434:	09 95       	icall
     436:	08 95       	ret

00000438 <__timer_captureService>:
     438:	fc 01       	movw	r30, r24
     43a:	25 91       	lpm	r18, Z+
     43c:	34 91       	lpm	r19, Z
     43e:	d9 01       	movw	r26, r18
//
------------------------------------------------------- */
void __timer_captureService(const Timer* timer){
	TimerData* td = timerGetData(timer);

	if(td->capture_callback){
     440:	16 96       	adiw	r26, 0x06	; 6
     442:	ed 91       	ld	r30, X+
     444:	fc 91       	ld	r31, X
     446:	17 97       	sbiw	r26, 0x07	; 7
     448:	30 97       	sbiw	r30, 0x00	; 0
     44a:	01 f0       	breq	.+0      	; 0x44c <__timer_captureService+0x14>
		td->capture_callback(timer,td->capture_data);
     44c:	18 96       	adiw	r26, 0x08	; 8
     44e:	6d 91       	ld	r22, X+
     450:	7c 91       	ld	r23, X
     452:	19 97       	sbiw	r26, 0x09	; 9
     454:	09 95       	icall
     456:	08 95       	ret

00000458 <__timer_compareService>:
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     458:	fc 01       	movw	r30, r24
     45a:	25 91       	lpm	r18, Z+
     45c:	34 91       	lpm	r19, Z
     45e:	d9 01       	movw	r26, r18
//
------------------------------------------------------- */
void __timer_compareService(const TimerCompare* channel){
	TimerDataCompare* td = compareGetData(channel);
//	td->overflow++;
	if(td->compare_callback){
     460:	ed 91       	ld	r30, X+
     462:	fc 91       	ld	r31, X
     464:	11 97       	sbiw	r26, 0x01	; 1
     466:	30 97       	sbiw	r30, 0x00	; 0
     468:	01 f0       	breq	.+0      	; 0x46a <__timer_compareService+0x12>
		td->compare_callback(channel,td->compare_data);
     46a:	12 96       	adiw	r26, 0x02	; 2
     46c:	6d 91       	ld	r22, X+
     46e:	7c 91       	ld	r23, X
     470:	13 97       	sbiw	r26, 0x03	; 3
     472:	09 95       	icall
     474:	08 95       	ret

00000476 <getError>:
	}

}

ERROR_CODE getError(void){
	 return __error.errorCode;
     476:	80 91 00 00 	lds	r24, 0x0000
}
     47a:	08 95       	ret

0000047c <setError>:
	// queue the next event
	scheduleJob(&__error_flash, __error, lastTime, delay);

}

void setError(ERROR_CODE err){
     47c:	ef 92       	push	r14
     47e:	ff 92       	push	r15
     480:	0f 93       	push	r16
     482:	1f 93       	push	r17
     484:	cf 93       	push	r28
     486:	c8 2f       	mov	r28, r24
	if(__error.errorCode==0){
     488:	80 91 00 00 	lds	r24, 0x0000
     48c:	88 23       	and	r24, r24
     48e:	01 f0       	breq	.+0      	; 0x490 <setError+0x14>
     490:	00 c0       	rjmp	.+0      	; 0x492 <setError+0x16>
		__error.errorCode = err;
     492:	c0 93 00 00 	sts	0x0000, r28
		// Start to flash the error code if we can
		if(statusLED.pin != null && g_heartbeat != null){
     496:	80 91 00 00 	lds	r24, 0x0000
     49a:	90 91 00 00 	lds	r25, 0x0000
     49e:	00 97       	sbiw	r24, 0x00	; 0
     4a0:	01 f0       	breq	.+0      	; 0x4a2 <setError+0x26>
     4a2:	80 91 00 00 	lds	r24, 0x0000
     4a6:	90 91 00 00 	lds	r25, 0x0000
     4aa:	00 97       	sbiw	r24, 0x00	; 0
     4ac:	01 f0       	breq	.+0      	; 0x4ae <setError+0x32>
			scheduleJob(&__error_flash, &__error, clockGetus(),0);
     4ae:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     4b2:	9b 01       	movw	r18, r22
     4b4:	ac 01       	movw	r20, r24
     4b6:	80 e0       	ldi	r24, 0x00	; 0
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	60 e0       	ldi	r22, 0x00	; 0
     4bc:	70 e0       	ldi	r23, 0x00	; 0
     4be:	ee 24       	eor	r14, r14
     4c0:	ff 24       	eor	r15, r15
     4c2:	87 01       	movw	r16, r14
     4c4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}

		// log to any rprintf writer
		Writer writer = __error.output;
     4c8:	80 91 00 00 	lds	r24, 0x0000
     4cc:	90 91 00 00 	lds	r25, 0x0000
		if(writer){
     4d0:	00 97       	sbiw	r24, 0x00	; 0
     4d2:	01 f0       	breq	.+0      	; 0x4d4 <setError+0x58>
			Writer old = rprintfInit(writer);
     4d4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     4d8:	8c 01       	movw	r16, r24
     4da:	2c 2f       	mov	r18, r28
     4dc:	33 27       	eor	r19, r19
     4de:	27 fd       	sbrc	r18, 7
     4e0:	30 95       	com	r19
			if(err < 0 ){
     4e2:	c7 ff       	sbrs	r28, 7
     4e4:	00 c0       	rjmp	.+0      	; 0x4e6 <setError+0x6a>
				rprintf("WebbotLib Error:%d\n",(int)-err);
     4e6:	00 d0       	rcall	.+0      	; 0x4e8 <setError+0x6c>
     4e8:	00 d0       	rcall	.+0      	; 0x4ea <setError+0x6e>
     4ea:	0f 92       	push	r0
     4ec:	ed b7       	in	r30, 0x3d	; 61
     4ee:	fe b7       	in	r31, 0x3e	; 62
     4f0:	31 96       	adiw	r30, 0x01	; 1
     4f2:	81 e0       	ldi	r24, 0x01	; 1
     4f4:	ad b7       	in	r26, 0x3d	; 61
     4f6:	be b7       	in	r27, 0x3e	; 62
     4f8:	11 96       	adiw	r26, 0x01	; 1
     4fa:	8c 93       	st	X, r24
     4fc:	11 97       	sbiw	r26, 0x01	; 1
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	92 83       	std	Z+2, r25	; 0x02
     504:	81 83       	std	Z+1, r24	; 0x01
     506:	30 95       	com	r19
     508:	21 95       	neg	r18
     50a:	3f 4f       	sbci	r19, 0xFF	; 255
     50c:	00 c0       	rjmp	.+0      	; 0x50e <setError+0x92>
			}else{
				rprintf("User Error:%d\n",(int)err);
     50e:	00 d0       	rcall	.+0      	; 0x510 <setError+0x94>
     510:	00 d0       	rcall	.+0      	; 0x512 <setError+0x96>
     512:	0f 92       	push	r0
     514:	ed b7       	in	r30, 0x3d	; 61
     516:	fe b7       	in	r31, 0x3e	; 62
     518:	31 96       	adiw	r30, 0x01	; 1
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	ad b7       	in	r26, 0x3d	; 61
     51e:	be b7       	in	r27, 0x3e	; 62
     520:	11 96       	adiw	r26, 0x01	; 1
     522:	8c 93       	st	X, r24
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	92 83       	std	Z+2, r25	; 0x02
     52a:	81 83       	std	Z+1, r24	; 0x01
     52c:	34 83       	std	Z+4, r19	; 0x04
     52e:	23 83       	std	Z+3, r18	; 0x03
     530:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     534:	0f 90       	pop	r0
     536:	0f 90       	pop	r0
     538:	0f 90       	pop	r0
     53a:	0f 90       	pop	r0
     53c:	0f 90       	pop	r0
			}
			rprintfInit(old);
     53e:	c8 01       	movw	r24, r16
     540:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}

	}
}
     544:	cf 91       	pop	r28
     546:	1f 91       	pop	r17
     548:	0f 91       	pop	r16
     54a:	ff 90       	pop	r15
     54c:	ef 90       	pop	r14
     54e:	08 95       	ret

00000550 <compareDetach>:
//
//  Detach any callback function from a timer
//
------------------------------------------------------- */
void compareDetach(const TimerCompare* channel)
{
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ec 01       	movw	r28, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     556:	fc 01       	movw	r30, r24
     558:	32 96       	adiw	r30, 0x02	; 2
     55a:	84 91       	lpm	r24, Z
     55c:	90 e0       	ldi	r25, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
     55e:	2c e2       	ldi	r18, 0x2C	; 44
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	82 9f       	mul	r24, r18
     564:	f0 01       	movw	r30, r0
     566:	83 9f       	mul	r24, r19
     568:	f0 0d       	add	r31, r0
     56a:	92 9f       	mul	r25, r18
     56c:	f0 0d       	add	r31, r0
     56e:	11 24       	eor	r1, r1

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     570:	e0 50       	subi	r30, 0x00	; 0
     572:	f0 40       	sbci	r31, 0x00	; 0
     574:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     576:	ee 23       	and	r30, r30
     578:	01 f0       	breq	.+0      	; 0x57a <compareDetach+0x2a>


		// Disallow compare interrupts for this channel
		__portMaskClear(&channel->pgm_intenable);
     57a:	ce 01       	movw	r24, r28
     57c:	03 96       	adiw	r24, 0x03	; 3
     57e:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Stop it from changing the output pin
		compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
     582:	ce 01       	movw	r24, r28
     584:	60 e0       	ldi	r22, 0x00	; 0
     586:	0e 94 00 00 	call	0	; 0x0 <timerOff>
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     58a:	fe 01       	movw	r30, r28
     58c:	a5 91       	lpm	r26, Z+
     58e:	b4 91       	lpm	r27, Z

		// remove routine
		compareGetData(channel)->compare_callback = null;
     590:	11 96       	adiw	r26, 0x01	; 1
     592:	1c 92       	st	X, r1
     594:	1e 92       	st	-X, r1
     596:	00 c0       	rjmp	.+0      	; 0x598 <compareDetach+0x48>
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     598:	8d ef       	ldi	r24, 0xFD	; 253
     59a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}
}
     59e:	df 91       	pop	r29
     5a0:	cf 91       	pop	r28
     5a2:	08 95       	ret

000005a4 <compareSetThreshold>:
	}
	return rtn;
}


void compareSetThreshold(const TimerCompare* channel, uint16_t threshold){
     5a4:	cf 93       	push	r28
     5a6:	df 93       	push	r29
     5a8:	ac 01       	movw	r20, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     5aa:	fc 01       	movw	r30, r24
     5ac:	32 96       	adiw	r30, 0x02	; 2
     5ae:	e4 91       	lpm	r30, Z
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
	const Timer* timer = compareGetTimer(channel);
     5b2:	8c e2       	ldi	r24, 0x2C	; 44
     5b4:	90 e0       	ldi	r25, 0x00	; 0
     5b6:	e8 9f       	mul	r30, r24
     5b8:	90 01       	movw	r18, r0
     5ba:	e9 9f       	mul	r30, r25
     5bc:	30 0d       	add	r19, r0
     5be:	f8 9f       	mul	r31, r24
     5c0:	30 0d       	add	r19, r0
     5c2:	11 24       	eor	r1, r1
     5c4:	20 50       	subi	r18, 0x00	; 0
     5c6:	30 40       	sbci	r19, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     5c8:	f9 01       	movw	r30, r18
     5ca:	38 96       	adiw	r30, 0x08	; 8
     5cc:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     5ce:	ee 23       	and	r30, r30
     5d0:	01 f0       	breq	.+0      	; 0x5d2 <compareSetThreshold+0x2e>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
     5d2:	fa 01       	movw	r30, r20
     5d4:	36 96       	adiw	r30, 0x06	; 6
     5d6:	85 91       	lpm	r24, Z+
     5d8:	94 91       	lpm	r25, Z
     5da:	d8 2f       	mov	r29, r24
     5dc:	c9 2f       	mov	r28, r25
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     5de:	2a 5f       	subi	r18, 0xFA	; 250
     5e0:	3f 4f       	sbci	r19, 0xFF	; 255
     5e2:	f9 01       	movw	r30, r18
     5e4:	24 91       	lpm	r18, Z
		if(timerIs16bit(timer)){
     5e6:	22 23       	and	r18, r18
     5e8:	01 f0       	breq	.+0      	; 0x5ea <compareSetThreshold+0x46>
			_SFR_MEM16(port) = threshold; 					// set 16 bit word
     5ea:	fc 01       	movw	r30, r24
     5ec:	71 83       	std	Z+1, r23	; 0x01
     5ee:	60 83       	st	Z, r22
     5f0:	00 c0       	rjmp	.+0      	; 0x5f2 <compareSetThreshold+0x4e>
		}else{
			if(threshold > 0xffU){
     5f2:	6f 3f       	cpi	r22, 0xFF	; 255
     5f4:	71 05       	cpc	r23, r1
     5f6:	01 f0       	breq	.+0      	; 0x5f8 <compareSetThreshold+0x54>
     5f8:	00 f0       	brcs	.+0      	; 0x5fa <compareSetThreshold+0x56>
				threshold=0xffU;
				setError(TIMER_COMPARE_NOT_8_BIT);
     5fa:	8e ef       	ldi	r24, 0xFE	; 254
     5fc:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
		if(timerIs16bit(timer)){
			_SFR_MEM16(port) = threshold; 					// set 16 bit word
		}else{
			if(threshold > 0xffU){
				threshold=0xffU;
     600:	6f ef       	ldi	r22, 0xFF	; 255
     602:	70 e0       	ldi	r23, 0x00	; 0
				setError(TIMER_COMPARE_NOT_8_BIT);
			}
			_SFR_MEM8(port) = threshold; 				// set low byte
     604:	ed 2f       	mov	r30, r29
     606:	fc 2f       	mov	r31, r28
     608:	60 83       	st	Z, r22
     60a:	00 c0       	rjmp	.+0      	; 0x60c <compareSetThreshold+0x68>
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     60c:	8d ef       	ldi	r24, 0xFD	; 253
     60e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}
}
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	08 95       	ret

00000618 <compareGetThreshold>:
	}
	setError(NO_APPROPRIATE_TIMER_PRESCALE_VALUES);
	return available;
}

uint16_t compareGetThreshold(const TimerCompare* channel){
     618:	ac 01       	movw	r20, r24
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     61a:	fc 01       	movw	r30, r24
     61c:	32 96       	adiw	r30, 0x02	; 2
     61e:	e4 91       	lpm	r30, Z
     620:	f0 e0       	ldi	r31, 0x00	; 0
	uint16_t rtn;

	const Timer* timer = compareGetTimer(channel);
     622:	8c e2       	ldi	r24, 0x2C	; 44
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	e8 9f       	mul	r30, r24
     628:	90 01       	movw	r18, r0
     62a:	e9 9f       	mul	r30, r25
     62c:	30 0d       	add	r19, r0
     62e:	f8 9f       	mul	r31, r24
     630:	30 0d       	add	r19, r0
     632:	11 24       	eor	r1, r1
     634:	20 50       	subi	r18, 0x00	; 0
     636:	30 40       	sbci	r19, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     638:	f9 01       	movw	r30, r18
     63a:	38 96       	adiw	r30, 0x08	; 8
     63c:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     63e:	ee 23       	and	r30, r30
     640:	01 f0       	breq	.+0      	; 0x642 <compareGetThreshold+0x2a>
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
     642:	4a 5f       	subi	r20, 0xFA	; 250
     644:	5f 4f       	sbci	r21, 0xFF	; 255
     646:	fa 01       	movw	r30, r20
     648:	85 91       	lpm	r24, Z+
     64a:	94 91       	lpm	r25, Z
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     64c:	2a 5f       	subi	r18, 0xFA	; 250
     64e:	3f 4f       	sbci	r19, 0xFF	; 255
     650:	f9 01       	movw	r30, r18
     652:	24 91       	lpm	r18, Z
		if(timerIs16bit(timer)){
			rtn = _SFR_MEM16(port); 					// set 16 bit word
     654:	fc 01       	movw	r30, r24
	uint16_t rtn;

	const Timer* timer = compareGetTimer(channel);
	if(timerSupportsCompare(timer)){
		PORT port = (PORT)pgm_read_word(&channel->pgm_threshold);
		if(timerIs16bit(timer)){
     656:	22 23       	and	r18, r18
     658:	01 f0       	breq	.+0      	; 0x65a <compareGetThreshold+0x42>
			rtn = _SFR_MEM16(port); 					// set 16 bit word
     65a:	80 81       	ld	r24, Z
     65c:	91 81       	ldd	r25, Z+1	; 0x01
     65e:	08 95       	ret
		}else{
			rtn = _SFR_MEM8(port); 					// set low byte
     660:	80 81       	ld	r24, Z
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	08 95       	ret
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     666:	8d ef       	ldi	r24, 0xFD	; 253
     668:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		rtn = 0xff;
     66c:	8f ef       	ldi	r24, 0xFF	; 255
     66e:	90 e0       	ldi	r25, 0x00	; 0
	}
	return rtn;
}
     670:	08 95       	ret

00000672 <timerGetTOP>:
 *
 *  	Get the value of TOP for a given timer
 *  	will return 0 if the timer is not in use
 *
 -------------------------------------------------------*/
uint16_t timerGetTOP(const Timer* timer){
     672:	cf 93       	push	r28
     674:	df 93       	push	r29
     676:	ec 01       	movw	r28, r24
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
     678:	fc 01       	movw	r30, r24
     67a:	34 96       	adiw	r30, 0x04	; 4
     67c:	85 91       	lpm	r24, Z+
     67e:	94 91       	lpm	r25, Z
     680:	fc 01       	movw	r30, r24
     682:	80 81       	ld	r24, Z
     684:	90 e0       	ldi	r25, 0x00	; 0
     686:	87 70       	andi	r24, 0x07	; 7
     688:	90 70       	andi	r25, 0x00	; 0
     68a:	00 97       	sbiw	r24, 0x00	; 0
     68c:	01 f4       	brne	.+0      	; 0x68e <timerGetTOP+0x1c>
     68e:	00 c0       	rjmp	.+0      	; 0x690 <timerGetTOP+0x1e>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     690:	fe 01       	movw	r30, r28
     692:	a5 91       	lpm	r26, Z+
     694:	b4 91       	lpm	r27, Z
	uint16_t rtn = 0;
	if(timerIsInUse(timer)){
		switch(timerGetMode(timer)){
     696:	1a 96       	adiw	r26, 0x0a	; 10
     698:	8c 91       	ld	r24, X
     69a:	1a 97       	sbiw	r26, 0x0a	; 10
     69c:	87 30       	cpi	r24, 0x07	; 7
     69e:	01 f0       	breq	.+0      	; 0x6a0 <timerGetTOP+0x2e>
     6a0:	88 30       	cpi	r24, 0x08	; 8
     6a2:	00 f4       	brcc	.+0      	; 0x6a4 <timerGetTOP+0x32>
     6a4:	83 30       	cpi	r24, 0x03	; 3
     6a6:	01 f0       	breq	.+0      	; 0x6a8 <timerGetTOP+0x36>
     6a8:	84 30       	cpi	r24, 0x04	; 4
     6aa:	00 f4       	brcc	.+0      	; 0x6ac <timerGetTOP+0x3a>
     6ac:	81 30       	cpi	r24, 0x01	; 1
     6ae:	01 f0       	breq	.+0      	; 0x6b0 <timerGetTOP+0x3e>
     6b0:	82 30       	cpi	r24, 0x02	; 2
     6b2:	00 f4       	brcc	.+0      	; 0x6b4 <timerGetTOP+0x42>
     6b4:	00 c0       	rjmp	.+0      	; 0x6b6 <timerGetTOP+0x44>
     6b6:	85 30       	cpi	r24, 0x05	; 5
     6b8:	01 f0       	breq	.+0      	; 0x6ba <timerGetTOP+0x48>
     6ba:	86 30       	cpi	r24, 0x06	; 6
     6bc:	00 f4       	brcc	.+0      	; 0x6be <timerGetTOP+0x4c>
     6be:	00 c0       	rjmp	.+0      	; 0x6c0 <timerGetTOP+0x4e>
     6c0:	8b 30       	cpi	r24, 0x0B	; 11
     6c2:	01 f0       	breq	.+0      	; 0x6c4 <timerGetTOP+0x52>
     6c4:	8c 30       	cpi	r24, 0x0C	; 12
     6c6:	00 f4       	brcc	.+0      	; 0x6c8 <timerGetTOP+0x56>
     6c8:	89 30       	cpi	r24, 0x09	; 9
     6ca:	01 f4       	brne	.+0      	; 0x6cc <timerGetTOP+0x5a>
     6cc:	00 c0       	rjmp	.+0      	; 0x6ce <timerGetTOP+0x5c>
     6ce:	8e 30       	cpi	r24, 0x0E	; 14
     6d0:	01 f0       	breq	.+0      	; 0x6d2 <timerGetTOP+0x60>
     6d2:	8f 30       	cpi	r24, 0x0F	; 15
     6d4:	01 f0       	breq	.+0      	; 0x6d6 <timerGetTOP+0x64>
     6d6:	8c 30       	cpi	r24, 0x0C	; 12
     6d8:	01 f4       	brne	.+0      	; 0x6da <timerGetTOP+0x68>
     6da:	00 c0       	rjmp	.+0      	; 0x6dc <timerGetTOP+0x6a>
		case TIMER_MODE_NORMAL:
			rtn = 0xffffU;
			break;
		case TIMER_MODE_PWM8_PHASE_CORRECT:
		case TIMER_MODE_PWM8_FAST:
			rtn = 0xffU;
     6dc:	8f ef       	ldi	r24, 0xFF	; 255
     6de:	90 e0       	ldi	r25, 0x00	; 0
			break;
     6e0:	00 c0       	rjmp	.+0      	; 0x6e2 <timerGetTOP+0x70>
		case TIMER_MODE_PWM9_PHASE_CORRECT:
		case TIMER_MODE_PWM9_FAST:
			rtn = 0x1ffU;
     6e2:	8f ef       	ldi	r24, 0xFF	; 255
     6e4:	91 e0       	ldi	r25, 0x01	; 1
			break;
     6e6:	00 c0       	rjmp	.+0      	; 0x6e8 <timerGetTOP+0x76>
		case TIMER_MODE_PWM10_PHASE_CORRECT:
		case TIMER_MODE_PWM10_FAST:
			rtn = 0x3ffU;
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	93 e0       	ldi	r25, 0x03	; 3
			break;
     6ec:	00 c0       	rjmp	.+0      	; 0x6ee <timerGetTOP+0x7c>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     6ee:	fe 01       	movw	r30, r28
     6f0:	77 96       	adiw	r30, 0x17	; 23
     6f2:	85 91       	lpm	r24, Z+
     6f4:	94 91       	lpm	r25, Z
		case TIMER_MODE_PWM_PHASE_FREQ_OCR:
		case TIMER_MODE_PWM_PHASE_CORRECT_OCR:
		case TIMER_MODE_PWM_FAST_OCR:
			{
				const TimerCompare* tc = timerGetCompare(timer,0); // uses channel A
				rtn = compareGetThreshold(tc);
     6f6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
			}
			break;
     6fa:	00 c0       	rjmp	.+0      	; 0x6fc <timerGetTOP+0x8a>
		case TIMER_MODE_PWM_PHASE_FREQ_ICR:
		case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
		case TIMER_MODE_CTC_ICR:
		case TIMER_MODE_PWM_FAST_ICR:
			{
				PORT icr = pgm_read_word(&timer->pgm_icr);
     6fc:	fe 01       	movw	r30, r28
     6fe:	7f 96       	adiw	r30, 0x1f	; 31
     700:	85 91       	lpm	r24, Z+
     702:	94 91       	lpm	r25, Z
				rtn = _SFR_MEM16(icr);
     704:	fc 01       	movw	r30, r24
     706:	80 81       	ld	r24, Z
     708:	91 81       	ldd	r25, Z+1	; 0x01
			}
			break;
     70a:	00 c0       	rjmp	.+0      	; 0x70c <timerGetTOP+0x9a>
 *  	Get the value of TOP for a given timer
 *  	will return 0 if the timer is not in use
 *
 -------------------------------------------------------*/
uint16_t timerGetTOP(const Timer* timer){
	uint16_t rtn = 0;
     70c:	80 e0       	ldi	r24, 0x00	; 0
     70e:	90 e0       	ldi	r25, 0x00	; 0
     710:	00 c0       	rjmp	.+0      	; 0x712 <timerGetTOP+0xa0>
	if(timerIsInUse(timer)){
		switch(timerGetMode(timer)){
		case TIMER_MODE_NORMAL:
			rtn = 0xffffU;
     712:	8f ef       	ldi	r24, 0xFF	; 255
     714:	9f ef       	ldi	r25, 0xFF	; 255
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     716:	26 96       	adiw	r28, 0x06	; 6
     718:	fe 01       	movw	r30, r28
     71a:	c4 91       	lpm	r28, Z
			break;
		case TIMER_MODE_13_RESVD:
			break;
		}// end switch
	}
	if(!timerIs16bit(timer)){
     71c:	cc 23       	and	r28, r28
     71e:	01 f4       	brne	.+0      	; 0x720 <timerGetTOP+0xae>
		rtn &= 0xffu;
     720:	90 70       	andi	r25, 0x00	; 0
	}
	return rtn;
}
     722:	df 91       	pop	r29
     724:	cf 91       	pop	r28
     726:	08 95       	ret

00000728 <timerSnapshotToTicks>:
		}
		CRITICAL_SECTION_END;
	}
}

TICK_COUNT timerSnapshotToTicks(const TIMER_SNAPSHOT* snapshot){
     728:	4f 92       	push	r4
     72a:	5f 92       	push	r5
     72c:	6f 92       	push	r6
     72e:	7f 92       	push	r7
     730:	8f 92       	push	r8
     732:	9f 92       	push	r9
     734:	af 92       	push	r10
     736:	bf 92       	push	r11
     738:	cf 92       	push	r12
     73a:	df 92       	push	r13
     73c:	ef 92       	push	r14
     73e:	ff 92       	push	r15
     740:	0f 93       	push	r16
     742:	1f 93       	push	r17
     744:	cf 93       	push	r28
     746:	df 93       	push	r29
     748:	ec 01       	movw	r28, r24
	TICK_COUNT rtn;
	TICK_COUNT top = timerGetTOP(snapshot->timer);
     74a:	88 81       	ld	r24, Y
     74c:	99 81       	ldd	r25, Y+1	; 0x01
     74e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     752:	4c 01       	movw	r8, r24
     754:	aa 24       	eor	r10, r10
     756:	bb 24       	eor	r11, r11

	if(snapshot->timer == g_heartbeat){
     758:	88 81       	ld	r24, Y
     75a:	99 81       	ldd	r25, Y+1	; 0x01
     75c:	60 91 00 00 	lds	r22, 0x0000
     760:	70 91 00 00 	lds	r23, 0x0000
     764:	2a 81       	ldd	r18, Y+2	; 0x02
     766:	3b 81       	ldd	r19, Y+3	; 0x03
     768:	4c 81       	ldd	r20, Y+4	; 0x04
     76a:	5d 81       	ldd	r21, Y+5	; 0x05
     76c:	0e 80       	ldd	r0, Y+6	; 0x06
     76e:	df 81       	ldd	r29, Y+7	; 0x07
     770:	c0 2d       	mov	r28, r0
     772:	86 17       	cp	r24, r22
     774:	97 07       	cpc	r25, r23
     776:	01 f4       	brne	.+0      	; 0x778 <timerSnapshotToTicks+0x50>
		rtn = snapshot->whole * _CLOCK_US_;
     778:	c0 90 00 00 	lds	r12, 0x0000
     77c:	d0 90 00 00 	lds	r13, 0x0000
     780:	e0 90 00 00 	lds	r14, 0x0000
     784:	f0 90 00 00 	lds	r15, 0x0000
     788:	c7 01       	movw	r24, r14
     78a:	b6 01       	movw	r22, r12
     78c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     790:	2b 01       	movw	r4, r22
     792:	3c 01       	movw	r6, r24

		// top = _CLOCK_US_
		// part     x
		TICK_COUNT frac  = snapshot->part;
     794:	be 01       	movw	r22, r28
     796:	80 e0       	ldi	r24, 0x00	; 0
     798:	90 e0       	ldi	r25, 0x00	; 0
		frac *= _CLOCK_US_;
     79a:	a7 01       	movw	r20, r14
     79c:	96 01       	movw	r18, r12
     79e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		frac /= top;
     7a2:	a5 01       	movw	r20, r10
     7a4:	94 01       	movw	r18, r8
     7a6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     7aa:	89 01       	movw	r16, r18
     7ac:	9a 01       	movw	r18, r20

		rtn += frac;
     7ae:	04 0d       	add	r16, r4
     7b0:	15 1d       	adc	r17, r5
     7b2:	26 1d       	adc	r18, r6
     7b4:	37 1d       	adc	r19, r7
     7b6:	00 c0       	rjmp	.+0      	; 0x7b8 <timerSnapshotToTicks+0x90>

	}else{
		rtn = snapshot->whole;
		rtn*= (top + 1);
     7b8:	c5 01       	movw	r24, r10
     7ba:	b4 01       	movw	r22, r8
     7bc:	6f 5f       	subi	r22, 0xFF	; 255
     7be:	7f 4f       	sbci	r23, 0xFF	; 255
     7c0:	8f 4f       	sbci	r24, 0xFF	; 255
     7c2:	9f 4f       	sbci	r25, 0xFF	; 255
     7c4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     7c8:	8b 01       	movw	r16, r22
     7ca:	9c 01       	movw	r18, r24
		rtn+= snapshot->part;
     7cc:	ce 01       	movw	r24, r28
     7ce:	a0 e0       	ldi	r26, 0x00	; 0
     7d0:	b0 e0       	ldi	r27, 0x00	; 0
     7d2:	08 0f       	add	r16, r24
     7d4:	19 1f       	adc	r17, r25
     7d6:	2a 1f       	adc	r18, r26
     7d8:	3b 1f       	adc	r19, r27

	}
	return rtn;
}
     7da:	b8 01       	movw	r22, r16
     7dc:	c9 01       	movw	r24, r18
     7de:	df 91       	pop	r29
     7e0:	cf 91       	pop	r28
     7e2:	1f 91       	pop	r17
     7e4:	0f 91       	pop	r16
     7e6:	ff 90       	pop	r15
     7e8:	ef 90       	pop	r14
     7ea:	df 90       	pop	r13
     7ec:	cf 90       	pop	r12
     7ee:	bf 90       	pop	r11
     7f0:	af 90       	pop	r10
     7f2:	9f 90       	pop	r9
     7f4:	8f 90       	pop	r8
     7f6:	7f 90       	pop	r7
     7f8:	6f 90       	pop	r6
     7fa:	5f 90       	pop	r5
     7fc:	4f 90       	pop	r4
     7fe:	08 95       	ret

00000800 <timerGetTicks>:

TICK_COUNT timerGetTicks(const Timer* timer){
     800:	cf 93       	push	r28
     802:	df 93       	push	r29
     804:	cd b7       	in	r28, 0x3d	; 61
     806:	de b7       	in	r29, 0x3e	; 62
     808:	28 97       	sbiw	r28, 0x08	; 8
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	f8 94       	cli
     80e:	de bf       	out	0x3e, r29	; 62
     810:	0f be       	out	0x3f, r0	; 63
     812:	cd bf       	out	0x3d, r28	; 61

	TIMER_SNAPSHOT snapshot;
	__timerRead(timer, &snapshot);
     814:	be 01       	movw	r22, r28
     816:	6f 5f       	subi	r22, 0xFF	; 255
     818:	7f 4f       	sbci	r23, 0xFF	; 255
     81a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	return timerSnapshotToTicks(&snapshot);
     81e:	ce 01       	movw	r24, r28
     820:	01 96       	adiw	r24, 0x01	; 1
     822:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     826:	28 96       	adiw	r28, 0x08	; 8
     828:	0f b6       	in	r0, 0x3f	; 63
     82a:	f8 94       	cli
     82c:	de bf       	out	0x3e, r29	; 62
     82e:	0f be       	out	0x3f, r0	; 63
     830:	cd bf       	out	0x3d, r28	; 61
     832:	df 91       	pop	r29
     834:	cf 91       	pop	r28
     836:	08 95       	ret

00000838 <clockGetus>:
//  is about 70 minutes - this should not be a problem as you
//  will normally be using the heartbeat to measure durations
//  of less than one second.
------------------------------------------------------- */
TICK_COUNT clockGetus(void){
	return timerGetTicks(g_heartbeat);
     838:	80 91 00 00 	lds	r24, 0x0000
     83c:	90 91 00 00 	lds	r25, 0x0000
     840:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     844:	08 95       	ret

00000846 <clockHasElapsedGetOverflow>:
   returns true if the specified number of microseconds
   has passed since the start time
   If true then set overflow to the number of microseconds
   that it is exceeded bt
*/
boolean clockHasElapsedGetOverflow(TICK_COUNT usStart, TICK_COUNT usWait, TICK_COUNT* overflow){
     846:	8f 92       	push	r8
     848:	9f 92       	push	r9
     84a:	af 92       	push	r10
     84c:	bf 92       	push	r11
     84e:	cf 92       	push	r12
     850:	df 92       	push	r13
     852:	ef 92       	push	r14
     854:	ff 92       	push	r15
     856:	0f 93       	push	r16
     858:	1f 93       	push	r17
     85a:	cf 93       	push	r28
     85c:	df 93       	push	r29
     85e:	4b 01       	movw	r8, r22
     860:	5c 01       	movw	r10, r24
     862:	69 01       	movw	r12, r18
     864:	7a 01       	movw	r14, r20
     866:	e8 01       	movw	r28, r16
	boolean rtn = FALSE;
	TICK_COUNT now = clockGetus();
     868:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     86c:	dc 01       	movw	r26, r24
     86e:	cb 01       	movw	r24, r22
	TICK_COUNT test = now;
	test -= usStart;			// The actual delay that has happened
     870:	88 19       	sub	r24, r8
     872:	99 09       	sbc	r25, r9
     874:	aa 09       	sbc	r26, r10
     876:	bb 09       	sbc	r27, r11
	if( test  > usWait){
     878:	c8 16       	cp	r12, r24
     87a:	d9 06       	cpc	r13, r25
     87c:	ea 06       	cpc	r14, r26
     87e:	fb 06       	cpc	r15, r27
     880:	00 f4       	brcc	.+0      	; 0x882 <clockHasElapsedGetOverflow+0x3c>
		TICK_COUNT ovr = test - usWait;
     882:	8c 19       	sub	r24, r12
     884:	9d 09       	sbc	r25, r13
     886:	ae 09       	sbc	r26, r14
     888:	bf 09       	sbc	r27, r15
		*overflow = ovr;		// Return the number of microseconds we have overshot by
     88a:	88 83       	st	Y, r24
     88c:	99 83       	std	Y+1, r25	; 0x01
     88e:	aa 83       	std	Y+2, r26	; 0x02
     890:	bb 83       	std	Y+3, r27	; 0x03
		rtn = TRUE;
     892:	8f ef       	ldi	r24, 0xFF	; 255
     894:	00 c0       	rjmp	.+0      	; 0x896 <clockHasElapsedGetOverflow+0x50>
	}else{
		TICK_COUNT ovr = usWait - test;
     896:	c8 1a       	sub	r12, r24
     898:	d9 0a       	sbc	r13, r25
     89a:	ea 0a       	sbc	r14, r26
     89c:	fb 0a       	sbc	r15, r27
		*overflow = ovr;		// Return the number of microseconds remaining
     89e:	c8 82       	st	Y, r12
     8a0:	d9 82       	std	Y+1, r13	; 0x01
     8a2:	ea 82       	std	Y+2, r14	; 0x02
     8a4:	fb 82       	std	Y+3, r15	; 0x03
   has passed since the start time
   If true then set overflow to the number of microseconds
   that it is exceeded bt
*/
boolean clockHasElapsedGetOverflow(TICK_COUNT usStart, TICK_COUNT usWait, TICK_COUNT* overflow){
	boolean rtn = FALSE;
     8a6:	80 e0       	ldi	r24, 0x00	; 0
	}else{
		TICK_COUNT ovr = usWait - test;
		*overflow = ovr;		// Return the number of microseconds remaining
	}
	return rtn;
}
     8a8:	df 91       	pop	r29
     8aa:	cf 91       	pop	r28
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	df 90       	pop	r13
     8b6:	cf 90       	pop	r12
     8b8:	bf 90       	pop	r11
     8ba:	af 90       	pop	r10
     8bc:	9f 90       	pop	r9
     8be:	8f 90       	pop	r8
     8c0:	08 95       	ret

000008c2 <clockWaitus>:
void clockWaitms(TICK_COUNT ms){
	clockWaitus(ms*1000UL);
}

/* Pause for the given number of microseconds */
void clockWaitus(TICK_COUNT us){
     8c2:	8f 92       	push	r8
     8c4:	9f 92       	push	r9
     8c6:	af 92       	push	r10
     8c8:	bf 92       	push	r11
     8ca:	cf 92       	push	r12
     8cc:	df 92       	push	r13
     8ce:	ef 92       	push	r14
     8d0:	ff 92       	push	r15
     8d2:	6b 01       	movw	r12, r22
     8d4:	7c 01       	movw	r14, r24
	TICK_COUNT start = clockGetus();
     8d6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     8da:	4b 01       	movw	r8, r22
     8dc:	5c 01       	movw	r10, r24
	while(clockGetus() - start < us){
     8de:	00 c0       	rjmp	.+0      	; 0x8e0 <clockWaitus+0x1e>
		nop();
     8e0:	00 00       	nop
}

/* Pause for the given number of microseconds */
void clockWaitus(TICK_COUNT us){
	TICK_COUNT start = clockGetus();
	while(clockGetus() - start < us){
     8e2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     8e6:	dc 01       	movw	r26, r24
     8e8:	cb 01       	movw	r24, r22
     8ea:	88 19       	sub	r24, r8
     8ec:	99 09       	sbc	r25, r9
     8ee:	aa 09       	sbc	r26, r10
     8f0:	bb 09       	sbc	r27, r11
     8f2:	8c 15       	cp	r24, r12
     8f4:	9d 05       	cpc	r25, r13
     8f6:	ae 05       	cpc	r26, r14
     8f8:	bf 05       	cpc	r27, r15
     8fa:	00 f0       	brcs	.+0      	; 0x8fc <clockWaitus+0x3a>
//	uint16_t mhz = cpu_speed_div_1000000;
//	TICK_COUNT pause = (us / prescaler) * mhz;
//	while(pause > (timerGetTicks(g_heartbeat) - start)){
//		nop();
//	}
}
     8fc:	ff 90       	pop	r15
     8fe:	ef 90       	pop	r14
     900:	df 90       	pop	r13
     902:	cf 90       	pop	r12
     904:	bf 90       	pop	r11
     906:	af 90       	pop	r10
     908:	9f 90       	pop	r9
     90a:	8f 90       	pop	r8
     90c:	08 95       	ret

0000090e <clockWaitms>:
}


/* waits (pauses) for the specified number of milliseconds */
void clockWaitms(TICK_COUNT ms){
	clockWaitus(ms*1000UL);
     90e:	28 ee       	ldi	r18, 0xE8	; 232
     910:	33 e0       	ldi	r19, 0x03	; 3
     912:	40 e0       	ldi	r20, 0x00	; 0
     914:	50 e0       	ldi	r21, 0x00	; 0
     916:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     91a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
}
     91e:	08 95       	ret

00000920 <delay_ms>:

/*
    Delay for a given number of milliseconds
*/
void delay_ms(uint32_t __ms){
	if(g_heartbeat){
     920:	20 91 00 00 	lds	r18, 0x0000
     924:	30 91 00 00 	lds	r19, 0x0000
     928:	21 15       	cp	r18, r1
     92a:	31 05       	cpc	r19, r1
     92c:	01 f0       	breq	.+0      	; 0x92e <delay_ms+0xe>
		clockWaitms(__ms);
     92e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     932:	08 95       	ret

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     934:	20 91 00 00 	lds	r18, 0x0000
     938:	30 91 00 00 	lds	r19, 0x0000
     93c:	40 e0       	ldi	r20, 0x00	; 0
     93e:	50 e0       	ldi	r21, 0x00	; 0
     940:	0e 94 00 00 	call	0	; 0x0 <timerOff>
void delay_ms(uint32_t __ms){
	if(g_heartbeat){
		clockWaitms(__ms);
	}else{
		uint32_t cycles = ticks_per_ms(__ms, 1U);
		delay_cycles(cycles);
     944:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     948:	08 95       	ret

0000094a <delay_us>:

/*
	Delay for a given number of microseconds
*/
void delay_us(uint32_t __us){
	if(g_heartbeat && __us > 100){
     94a:	20 91 00 00 	lds	r18, 0x0000
     94e:	30 91 00 00 	lds	r19, 0x0000
     952:	21 15       	cp	r18, r1
     954:	31 05       	cpc	r19, r1
     956:	01 f0       	breq	.+0      	; 0x958 <delay_us+0xe>
     958:	65 36       	cpi	r22, 0x65	; 101
     95a:	71 05       	cpc	r23, r1
     95c:	81 05       	cpc	r24, r1
     95e:	91 05       	cpc	r25, r1
     960:	00 f0       	brcs	.+0      	; 0x962 <delay_us+0x18>
		clockWaitus(__us);
     962:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     966:	08 95       	ret

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     968:	20 91 00 00 	lds	r18, 0x0000
     96c:	30 91 00 00 	lds	r19, 0x0000
     970:	40 e0       	ldi	r20, 0x00	; 0
     972:	50 e0       	ldi	r21, 0x00	; 0
     974:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     978:	28 ee       	ldi	r18, 0xE8	; 232
     97a:	33 e0       	ldi	r19, 0x03	; 3
     97c:	40 e0       	ldi	r20, 0x00	; 0
     97e:	50 e0       	ldi	r21, 0x00	; 0
     980:	0e 94 00 00 	call	0	; 0x0 <timerOff>
void delay_us(uint32_t __us){
	if(g_heartbeat && __us > 100){
		clockWaitus(__us);
	}else{
		uint32_t cycles = ticks_per_ms(__us, 1000U);
		delay_cycles(cycles);
     984:	ca 01       	movw	r24, r20
     986:	b9 01       	movw	r22, r18
     988:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     98c:	08 95       	ret

0000098e <clockHasElapsed>:

/*
   returns true if the specified number of microseconds
   has passed since the start time
*/
boolean clockHasElapsed(TICK_COUNT usStart, TICK_COUNT usWait){
     98e:	8f 92       	push	r8
     990:	9f 92       	push	r9
     992:	af 92       	push	r10
     994:	bf 92       	push	r11
     996:	cf 92       	push	r12
     998:	df 92       	push	r13
     99a:	ef 92       	push	r14
     99c:	ff 92       	push	r15
     99e:	4b 01       	movw	r8, r22
     9a0:	5c 01       	movw	r10, r24
     9a2:	69 01       	movw	r12, r18
     9a4:	7a 01       	movw	r14, r20
	TICK_COUNT now = clockGetus();
     9a6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     9aa:	dc 01       	movw	r26, r24
     9ac:	cb 01       	movw	r24, r22
	TICK_COUNT test = now;
	test -= usStart;
     9ae:	88 19       	sub	r24, r8
     9b0:	99 09       	sbc	r25, r9
     9b2:	aa 09       	sbc	r26, r10
     9b4:	bb 09       	sbc	r27, r11
	if( test  >= usWait){
     9b6:	8c 15       	cp	r24, r12
     9b8:	9d 05       	cpc	r25, r13
     9ba:	ae 05       	cpc	r26, r14
     9bc:	bf 05       	cpc	r27, r15
     9be:	00 f0       	brcs	.+0      	; 0x9c0 <clockHasElapsed+0x32>
		return TRUE;
     9c0:	8f ef       	ldi	r24, 0xFF	; 255
     9c2:	00 c0       	rjmp	.+0      	; 0x9c4 <clockHasElapsed+0x36>
	}
	return FALSE;
     9c4:	80 e0       	ldi	r24, 0x00	; 0
}
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	df 90       	pop	r13
     9cc:	cf 90       	pop	r12
     9ce:	bf 90       	pop	r11
     9d0:	af 90       	pop	r10
     9d2:	9f 90       	pop	r9
     9d4:	8f 90       	pop	r8
     9d6:	08 95       	ret

000009d8 <timerGetBestPrescaler>:
		prescale++;
	}
	return prescale;
}

uint16_t timerGetBestPrescaler(const Timer* timer, uint16_t repeat_ms){
     9d8:	4f 92       	push	r4
     9da:	5f 92       	push	r5
     9dc:	6f 92       	push	r6
     9de:	7f 92       	push	r7
     9e0:	8f 92       	push	r8
     9e2:	9f 92       	push	r9
     9e4:	af 92       	push	r10
     9e6:	bf 92       	push	r11
     9e8:	cf 92       	push	r12
     9ea:	df 92       	push	r13
     9ec:	ef 92       	push	r14
     9ee:	ff 92       	push	r15
     9f0:	0f 93       	push	r16
     9f2:	1f 93       	push	r17
     9f4:	cf 93       	push	r28
     9f6:	df 93       	push	r29
     9f8:	6c 01       	movw	r12, r24
     9fa:	fc 01       	movw	r30, r24
     9fc:	36 96       	adiw	r30, 0x06	; 6
     9fe:	e4 91       	lpm	r30, Z
	uint32_t maxval;

	// Find maximum value for the timer counter
	if(timerIs16bit(timer)){
     a00:	ee 23       	and	r30, r30
     a02:	01 f0       	breq	.+0      	; 0xa04 <timerGetBestPrescaler+0x2c>
		maxval = 0xffffU;
     a04:	cf ef       	ldi	r28, 0xFF	; 255
     a06:	8c 2e       	mov	r8, r28
     a08:	cf ef       	ldi	r28, 0xFF	; 255
     a0a:	9c 2e       	mov	r9, r28
     a0c:	a1 2c       	mov	r10, r1
     a0e:	b1 2c       	mov	r11, r1
     a10:	00 c0       	rjmp	.+0      	; 0xa12 <timerGetBestPrescaler+0x3a>
	}else{
		maxval = 0xffU;
     a12:	bf ef       	ldi	r27, 0xFF	; 255
     a14:	8b 2e       	mov	r8, r27
     a16:	91 2c       	mov	r9, r1
     a18:	a1 2c       	mov	r10, r1
     a1a:	b1 2c       	mov	r11, r1
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
		int inx = __timerPrescalerIndex(timer, prescale);
		if(inx!=-1){
			available = prescale;

			if(ticks_per_ms(repeat_ms,prescale)<= maxval){
     a1c:	80 e0       	ldi	r24, 0x00	; 0
     a1e:	90 e0       	ldi	r25, 0x00	; 0

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     a20:	20 91 00 00 	lds	r18, 0x0000
     a24:	30 91 00 00 	lds	r19, 0x0000
     a28:	40 e0       	ldi	r20, 0x00	; 0
     a2a:	50 e0       	ldi	r21, 0x00	; 0
     a2c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     a30:	2b 01       	movw	r4, r22
     a32:	3c 01       	movw	r6, r24
     a34:	ab e0       	ldi	r26, 0x0B	; 11
     a36:	ea 2e       	mov	r14, r26
     a38:	f1 2c       	mov	r15, r1
	}else{
		maxval = 0xffU;
	}

	uint16_t prescale;
	uint16_t available=1;
     a3a:	01 e0       	ldi	r16, 0x01	; 1
     a3c:	10 e0       	ldi	r17, 0x00	; 0
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
     a3e:	c1 e0       	ldi	r28, 0x01	; 1
     a40:	d0 e0       	ldi	r29, 0x00	; 0
		int inx = __timerPrescalerIndex(timer, prescale);
     a42:	c6 01       	movw	r24, r12
     a44:	be 01       	movw	r22, r28
     a46:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		if(inx!=-1){
     a4a:	2f ef       	ldi	r18, 0xFF	; 255
     a4c:	8f 3f       	cpi	r24, 0xFF	; 255
     a4e:	92 07       	cpc	r25, r18
     a50:	01 f0       	breq	.+0      	; 0xa52 <timerGetBestPrescaler+0x7a>

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     a52:	9e 01       	movw	r18, r28
     a54:	40 e0       	ldi	r20, 0x00	; 0
     a56:	50 e0       	ldi	r21, 0x00	; 0
     a58:	c3 01       	movw	r24, r6
     a5a:	b2 01       	movw	r22, r4
     a5c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
		int inx = __timerPrescalerIndex(timer, prescale);
		if(inx!=-1){
			available = prescale;

			if(ticks_per_ms(repeat_ms,prescale)<= maxval){
     a60:	82 16       	cp	r8, r18
     a62:	93 06       	cpc	r9, r19
     a64:	a4 06       	cpc	r10, r20
     a66:	b5 06       	cpc	r11, r21
     a68:	00 f4       	brcc	.+0      	; 0xa6a <timerGetBestPrescaler+0x92>
     a6a:	8e 01       	movw	r16, r28
		maxval = 0xffU;
	}

	uint16_t prescale;
	uint16_t available=1;
	for(prescale=1; prescale<=MAX_PRESCALE; prescale<<=1){
     a6c:	cc 0f       	add	r28, r28
     a6e:	dd 1f       	adc	r29, r29
     a70:	08 94       	sec
     a72:	e1 08       	sbc	r14, r1
     a74:	f1 08       	sbc	r15, r1
     a76:	e1 14       	cp	r14, r1
     a78:	f1 04       	cpc	r15, r1
     a7a:	01 f4       	brne	.+0      	; 0xa7c <timerGetBestPrescaler+0xa4>
			if(ticks_per_ms(repeat_ms,prescale)<= maxval){
				return prescale;
			}
		}
	}
	setError(NO_APPROPRIATE_TIMER_PRESCALE_VALUES);
     a7c:	88 ef       	ldi	r24, 0xF8	; 248
     a7e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	return available;
     a82:	e8 01       	movw	r28, r16
}
     a84:	ce 01       	movw	r24, r28
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	1f 91       	pop	r17
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	df 90       	pop	r13
     a94:	cf 90       	pop	r12
     a96:	bf 90       	pop	r11
     a98:	af 90       	pop	r10
     a9a:	9f 90       	pop	r9
     a9c:	8f 90       	pop	r8
     a9e:	7f 90       	pop	r7
     aa0:	6f 90       	pop	r6
     aa2:	5f 90       	pop	r5
     aa4:	4f 90       	pop	r4
     aa6:	08 95       	ret

00000aa8 <timerSetPrescaler>:
	return -1;
}



void timerSetPrescaler(const Timer* timer, uint16_t prescaler){
     aa8:	cf 92       	push	r12
     aaa:	df 92       	push	r13
     aac:	ff 92       	push	r15
     aae:	0f 93       	push	r16
     ab0:	1f 93       	push	r17
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	ec 01       	movw	r28, r24
     ab8:	8b 01       	movw	r16, r22
	PORT pre = pgm_read_word(&timer->pgm_prescaler);
     aba:	fc 01       	movw	r30, r24
     abc:	34 96       	adiw	r30, 0x04	; 4
     abe:	c5 90       	lpm	r12, Z+
     ac0:	d4 90       	lpm	r13, Z

	CRITICAL_SECTION_START;
     ac2:	ff b6       	in	r15, 0x3f	; 63
     ac4:	f8 94       	cli
	int inx = __timerPrescalerIndex(timer,prescaler);
     ac6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	if(inx!=-1){
     aca:	2f ef       	ldi	r18, 0xFF	; 255
     acc:	8f 3f       	cpi	r24, 0xFF	; 255
     ace:	92 07       	cpc	r25, r18
     ad0:	01 f0       	breq	.+0      	; 0xad2 <timerSetPrescaler+0x2a>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     ad2:	fe 01       	movw	r30, r28
     ad4:	a5 91       	lpm	r26, Z+
     ad6:	b4 91       	lpm	r27, Z
		timerGetData(timer)->prescale_value = prescaler;
     ad8:	11 96       	adiw	r26, 0x01	; 1
     ada:	1c 93       	st	X, r17
     adc:	0e 93       	st	-X, r16
		_SFR_MEM8(pre) &= ~ TIMER_PRESCALE_MASK;
     ade:	f6 01       	movw	r30, r12
     ae0:	90 81       	ld	r25, Z
     ae2:	98 7f       	andi	r25, 0xF8	; 248
     ae4:	90 83       	st	Z, r25
		_SFR_MEM8(pre) |= inx;
     ae6:	90 81       	ld	r25, Z
     ae8:	98 2b       	or	r25, r24
     aea:	90 83       	st	Z, r25
     aec:	00 c0       	rjmp	.+0      	; 0xaee <timerSetPrescaler+0x46>
	}else{
		setError(TIMER_PRESCALER_UNSUPPORTED);
     aee:	8a ef       	ldi	r24, 0xFA	; 250
     af0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}
	CRITICAL_SECTION_END;
     af4:	ff be       	out	0x3f, r15	; 63

}
     af6:	df 91       	pop	r29
     af8:	cf 91       	pop	r28
     afa:	1f 91       	pop	r17
     afc:	0f 91       	pop	r16
     afe:	ff 90       	pop	r15
     b00:	df 90       	pop	r13
     b02:	cf 90       	pop	r12
     b04:	08 95       	ret

00000b06 <timerInit>:
//  Reset the timer + overflow to 0
//  Reset the prescaler to the current value
//  leave any overflow callback methods in place
//
------------------------------------------------------- */
void timerInit(const Timer* timer){
     b06:	7f 92       	push	r7
     b08:	8f 92       	push	r8
     b0a:	9f 92       	push	r9
     b0c:	af 92       	push	r10
     b0e:	bf 92       	push	r11
     b10:	cf 92       	push	r12
     b12:	df 92       	push	r13
     b14:	ef 92       	push	r14
     b16:	ff 92       	push	r15
     b18:	0f 93       	push	r16
     b1a:	1f 93       	push	r17
     b1c:	cf 93       	push	r28
     b1e:	df 93       	push	r29
     b20:	8c 01       	movw	r16, r24
	uint8_t i;

	// Get data from ROM to RAM
	PORT counter = pgm_read_word(&timer->pgm_counter);
     b22:	fc 01       	movw	r30, r24
     b24:	32 96       	adiw	r30, 0x02	; 2
     b26:	c5 91       	lpm	r28, Z+
     b28:	d4 91       	lpm	r29, Z
     b2a:	fc 01       	movw	r30, r24
     b2c:	85 91       	lpm	r24, Z+
     b2e:	94 91       	lpm	r25, Z
     b30:	4c 01       	movw	r8, r24
	TimerData* data = timerGetData(timer);

	CRITICAL_SECTION_START;
     b32:	7f b6       	in	r7, 0x3f	; 63
     b34:	f8 94       	cli

		// Turn the timer off for now
		timerOff(timer);
     b36:	c8 01       	movw	r24, r16
     b38:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Disallow timer overflow interrupt for now
		__portMaskClear(&timer->pgm_overflowint);
     b3c:	29 e1       	ldi	r18, 0x19	; 25
     b3e:	a2 2e       	mov	r10, r18
     b40:	b1 2c       	mov	r11, r1
     b42:	a0 0e       	add	r10, r16
     b44:	b1 1e       	adc	r11, r17
     b46:	c5 01       	movw	r24, r10
     b48:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Clear the pre-overflow counter register
		_SFR_MEM8(counter) = 0;
     b4c:	ec 2f       	mov	r30, r28
     b4e:	fd 2f       	mov	r31, r29
     b50:	10 82       	st	Z, r1

		// Clear the overflow counter
//		data->overflow = 0;

		// Set up the prescaler and turn the timer back on
		timerSetPrescaler(timer,data->prescale_value);
     b52:	f4 01       	movw	r30, r8
     b54:	60 81       	ld	r22, Z
     b56:	71 81       	ldd	r23, Z+1	; 0x01
     b58:	c8 01       	movw	r24, r16
     b5a:	0e 94 00 00 	call	0	; 0x0 <timerOff>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     b5e:	f8 01       	movw	r30, r16
     b60:	38 96       	adiw	r30, 0x08	; 8
     b62:	e4 90       	lpm	r14, Z

		// Initialise the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(i=0;i<numCompare;i++){
     b64:	cc 24       	eor	r12, r12
     b66:	dd 24       	eor	r13, r13
     b68:	ff 24       	eor	r15, r15
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     b6a:	f8 01       	movw	r30, r16
     b6c:	77 96       	adiw	r30, 0x17	; 23
     b6e:	c5 91       	lpm	r28, Z+
     b70:	d4 91       	lpm	r29, Z
     b72:	00 c0       	rjmp	.+0      	; 0xb74 <timerInit+0x6e>
     b74:	ce 01       	movw	r24, r28
     b76:	8c 0d       	add	r24, r12
     b78:	9d 1d       	adc	r25, r13
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
     b7a:	08 96       	adiw	r24, 0x08	; 8
     b7c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     b80:	f3 94       	inc	r15
     b82:	80 e1       	ldi	r24, 0x10	; 16
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	c8 0e       	add	r12, r24
     b88:	d9 1e       	adc	r13, r25
     b8a:	fe 14       	cp	r15, r14
     b8c:	01 f4       	brne	.+0      	; 0xb8e <timerInit+0x88>
//
//  Remove any pending overflow interrupt
//
------------------------------------------------------- */
static __inline__ void timerOverflowClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_overflowreq);
     b8e:	c8 01       	movw	r24, r16
     b90:	4c 96       	adiw	r24, 0x1c	; 28
     b92:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Remove any interrupt pending
		timerOverflowClearInterruptPending(timer);

		// If there is an overflow callback then re-enable timer overflow interrupt
		if(data->overflow_callback!=null){
     b96:	f4 01       	movw	r30, r8
     b98:	82 81       	ldd	r24, Z+2	; 0x02
     b9a:	93 81       	ldd	r25, Z+3	; 0x03
     b9c:	00 97       	sbiw	r24, 0x00	; 0
     b9e:	01 f0       	breq	.+0      	; 0xba0 <timerInit+0x9a>
			__portMaskSet(&timer->pgm_overflowint);
     ba0:	c5 01       	movw	r24, r10
     ba2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}

	CRITICAL_SECTION_END;
     ba6:	7f be       	out	0x3f, r7	; 63
}
     ba8:	df 91       	pop	r29
     baa:	cf 91       	pop	r28
     bac:	1f 91       	pop	r17
     bae:	0f 91       	pop	r16
     bb0:	ff 90       	pop	r15
     bb2:	ef 90       	pop	r14
     bb4:	df 90       	pop	r13
     bb6:	cf 90       	pop	r12
     bb8:	bf 90       	pop	r11
     bba:	af 90       	pop	r10
     bbc:	9f 90       	pop	r9
     bbe:	8f 90       	pop	r8
     bc0:	7f 90       	pop	r7
     bc2:	08 95       	ret

00000bc4 <timerSetMode>:
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     bc4:	cf 92       	push	r12
     bc6:	df 92       	push	r13
     bc8:	ef 92       	push	r14
     bca:	ff 92       	push	r15
     bcc:	0f 93       	push	r16
     bce:	1f 93       	push	r17
     bd0:	cf 93       	push	r28
     bd2:	df 93       	push	r29
     bd4:	7c 01       	movw	r14, r24
	if(mode == TIMER_MODE_NORMAL || timerGetMode(timer)!=mode){
     bd6:	66 23       	and	r22, r22
     bd8:	01 f0       	breq	.+0      	; 0xbda <timerSetMode+0x16>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     bda:	fc 01       	movw	r30, r24
     bdc:	a5 91       	lpm	r26, Z+
     bde:	b4 91       	lpm	r27, Z
     be0:	1a 96       	adiw	r26, 0x0a	; 10
     be2:	8c 91       	ld	r24, X
     be4:	1a 97       	sbiw	r26, 0x0a	; 10
     be6:	86 17       	cp	r24, r22
     be8:	01 f4       	brne	.+0      	; 0xbea <timerSetMode+0x26>
     bea:	00 c0       	rjmp	.+0      	; 0xbec <timerSetMode+0x28>
		uint16_t abilities = pgm_read_word(&timer->pgm_modes);	// Get the bitmasks of modes availables
     bec:	f7 01       	movw	r30, r14
     bee:	39 96       	adiw	r30, 0x09	; 9
     bf0:	85 91       	lpm	r24, Z+
     bf2:	94 91       	lpm	r25, Z
		uint8_t wgm=255;

		if(BV(mode) & abilities){
     bf4:	21 e0       	ldi	r18, 0x01	; 1
     bf6:	30 e0       	ldi	r19, 0x00	; 0
     bf8:	06 2e       	mov	r0, r22
     bfa:	00 c0       	rjmp	.+0      	; 0xbfc <timerSetMode+0x38>
     bfc:	22 0f       	add	r18, r18
     bfe:	33 1f       	adc	r19, r19
     c00:	0a 94       	dec	r0
     c02:	02 f4       	brpl	.+0      	; 0xc04 <timerSetMode+0x40>
     c04:	28 23       	and	r18, r24
     c06:	39 23       	and	r19, r25
     c08:	21 15       	cp	r18, r1
     c0a:	31 05       	cpc	r19, r1
     c0c:	01 f4       	brne	.+0      	; 0xc0e <timerSetMode+0x4a>
     c0e:	00 c0       	rjmp	.+0      	; 0xc10 <timerSetMode+0x4c>
     c10:	f7 01       	movw	r30, r14
     c12:	a5 91       	lpm	r26, Z+
     c14:	b4 91       	lpm	r27, Z
			// It is capable of the mode

			// Save the new mode
			timerGetData(timer)->mode = mode;
     c16:	1a 96       	adiw	r26, 0x0a	; 10
     c18:	6c 93       	st	X, r22
     c1a:	1a 97       	sbiw	r26, 0x0a	; 10

			if(abilities == TIMER_ALL_MODES){
     c1c:	2f ed       	ldi	r18, 0xDF	; 223
     c1e:	8f 3f       	cpi	r24, 0xFF	; 255
     c20:	92 07       	cpc	r25, r18
     c22:	01 f0       	breq	.+0      	; 0xc24 <timerSetMode+0x60>
				wgm = mode;
			}else if(abilities == TIMER_3BIT_MODES){
     c24:	a8 e8       	ldi	r26, 0x88	; 136
     c26:	83 33       	cpi	r24, 0x33	; 51
     c28:	9a 07       	cpc	r25, r26
     c2a:	01 f4       	brne	.+0      	; 0xc2c <timerSetMode+0x68>
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__3bit_modes[mode]);
     c2c:	e6 2f       	mov	r30, r22
     c2e:	f0 e0       	ldi	r31, 0x00	; 0
     c30:	e0 50       	subi	r30, 0x00	; 0
     c32:	f0 40       	sbci	r31, 0x00	; 0
     c34:	00 c0       	rjmp	.+0      	; 0xc36 <timerSetMode+0x72>
			}else if(abilities == TIMER_2BIT_MODES){
     c36:	83 33       	cpi	r24, 0x33	; 51
     c38:	91 05       	cpc	r25, r1
     c3a:	01 f0       	breq	.+0      	; 0xc3c <timerSetMode+0x78>
     c3c:	00 c0       	rjmp	.+0      	; 0xc3e <timerSetMode+0x7a>
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__2bit_modes[mode]);
     c3e:	e6 2f       	mov	r30, r22
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	e0 50       	subi	r30, 0x00	; 0
     c44:	f0 40       	sbci	r31, 0x00	; 0
     c46:	c4 91       	lpm	r28, Z
     c48:	00 c0       	rjmp	.+0      	; 0xc4a <timerSetMode+0x86>
			// It is capable of the mode

			// Save the new mode
			timerGetData(timer)->mode = mode;

			if(abilities == TIMER_ALL_MODES){
     c4a:	c6 2f       	mov	r28, r22
				wgm = pgm_read_byte(&__3bit_modes[mode]);
			}else if(abilities == TIMER_2BIT_MODES){
				// Timer has the small subset of modes
				wgm = pgm_read_byte(&__2bit_modes[mode]);
			}
			if(wgm==255){
     c4c:	cf 3f       	cpi	r28, 0xFF	; 255
     c4e:	01 f4       	brne	.+0      	; 0xc50 <timerSetMode+0x8c>
     c50:	00 c0       	rjmp	.+0      	; 0xc52 <timerSetMode+0x8e>
				// Mode is not supported
				setError(TIMER_MODE_NOT_SUPPORTED);
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode
     c52:	c7 01       	movw	r24, r14
     c54:	0e 94 00 00 	call	0	; 0x0 <timerOff>

				const PORT_MASK* pm = &timer->pgm_wgm[0];
     c58:	87 01       	movw	r16, r14
     c5a:	05 5f       	subi	r16, 0xF5	; 245
     c5c:	1f 4f       	sbci	r17, 0xFF	; 255
/* -------------------------------------------------------
//  Set the mode for a given timer
//  This will disconnect the output OCx pins on all
//  channels and will remove any callbacks on the channels
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode){
     c5e:	47 e1       	ldi	r20, 0x17	; 23
     c60:	c4 2e       	mov	r12, r20
     c62:	d1 2c       	mov	r13, r1
     c64:	ce 0c       	add	r12, r14
     c66:	df 1c       	adc	r13, r15
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode

				const PORT_MASK* pm = &timer->pgm_wgm[0];
				for(int i=0; i<4;i++,pm++){
					PORT port= pgm_read_word(pm->port);
     c68:	d8 01       	movw	r26, r16
     c6a:	ed 91       	ld	r30, X+
     c6c:	fc 91       	ld	r31, X
     c6e:	11 97       	sbiw	r26, 0x01	; 1
     c70:	85 91       	lpm	r24, Z+
     c72:	94 91       	lpm	r25, Z

					if(port==0){
     c74:	00 97       	sbiw	r24, 0x00	; 0
     c76:	01 f0       	breq	.+0      	; 0xc78 <timerSetMode+0xb4>
						break;
					}

					if(wgm & 1){
						__portMaskSet(pm);
     c78:	c8 01       	movw	r24, r16

					if(port==0){
						break;
					}

					if(wgm & 1){
     c7a:	c0 ff       	sbrs	r28, 0
     c7c:	00 c0       	rjmp	.+0      	; 0xc7e <timerSetMode+0xba>
						__portMaskSet(pm);
     c7e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     c82:	00 c0       	rjmp	.+0      	; 0xc84 <timerSetMode+0xc0>
					}else{
						__portMaskClear(pm);
     c84:	0e 94 00 00 	call	0	; 0x0 <timerOff>
					}
					wgm>>=1;
     c88:	c6 95       	lsr	r28
				setError(TIMER_MODE_NOT_SUPPORTED);
			}else{
				timerOff(timer);	// turn timer off whilst changing the mode

				const PORT_MASK* pm = &timer->pgm_wgm[0];
				for(int i=0; i<4;i++,pm++){
     c8a:	0d 5f       	subi	r16, 0xFD	; 253
     c8c:	1f 4f       	sbci	r17, 0xFF	; 255
     c8e:	0c 15       	cp	r16, r12
     c90:	1d 05       	cpc	r17, r13
     c92:	01 f4       	brne	.+0      	; 0xc94 <timerSetMode+0xd0>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     c94:	f7 01       	movw	r30, r14
     c96:	38 96       	adiw	r30, 0x08	; 8
     c98:	04 91       	lpm	r16, Z
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
     c9a:	f7 01       	movw	r30, r14
     c9c:	77 96       	adiw	r30, 0x17	; 23
     c9e:	c5 91       	lpm	r28, Z+
     ca0:	d4 91       	lpm	r29, Z
				}

				// For each channel - disconnect the output pins and remove any callback
				uint8_t numCompare = timerNumberOfCompareUnits(timer);
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
     ca2:	00 c0       	rjmp	.+0      	; 0xca4 <timerSetMode+0xe0>
     ca4:	80 2f       	mov	r24, r16
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	34 e0       	ldi	r19, 0x04	; 4
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	3a 95       	dec	r19
     cb0:	01 f4       	brne	.+0      	; 0xcb2 <timerSetMode+0xee>
					const TimerCompare* channel = timerGetCompare(timer,i);
// is done in compareDetach
//					compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
					compareDetach(channel);
     cb2:	8c 0f       	add	r24, r28
     cb4:	9d 1f       	adc	r25, r29
     cb6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     cba:	01 50       	subi	r16, 0x01	; 1
				}

				// For each channel - disconnect the output pins and remove any callback
				uint8_t numCompare = timerNumberOfCompareUnits(timer);
				int8_t i;
				for(i=numCompare-1; i>=0;i--){
     cbc:	07 ff       	sbrs	r16, 7
     cbe:	00 c0       	rjmp	.+0      	; 0xcc0 <timerSetMode+0xfc>
//					compareSetOutputMode(channel,CHANNEL_MODE_DISCONNECT);
					compareDetach(channel);
				}

				// re-initialise the timer and its channels
				timerInit(timer);
     cc0:	c7 01       	movw	r24, r14
     cc2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     cc6:	00 c0       	rjmp	.+0      	; 0xcc8 <timerSetMode+0x104>

			}
		}else{
			// Timer is not able to do this mode
			setError(TIMER_MODE_NOT_SUPPORTED);
     cc8:	86 ef       	ldi	r24, 0xF6	; 246
     cca:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		}
	}
}
     cce:	df 91       	pop	r29
     cd0:	cf 91       	pop	r28
     cd2:	1f 91       	pop	r17
     cd4:	0f 91       	pop	r16
     cd6:	ff 90       	pop	r15
     cd8:	ef 90       	pop	r14
     cda:	df 90       	pop	r13
     cdc:	cf 90       	pop	r12
     cde:	08 95       	ret

00000ce0 <initTimers>:
//  Initialise all timers:
//  	Detach any overflow interrupt
//		timerInit
//
------------------------------------------------------- */
void initTimers(void){
     ce0:	ef 92       	push	r14
     ce2:	ff 92       	push	r15
     ce4:	0f 93       	push	r16
     ce6:	1f 93       	push	r17
     ce8:	cf 93       	push	r28
     cea:	df 93       	push	r29
	uint8_t t;
    cli();
     cec:	f8 94       	cli
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     cee:	10 e0       	ldi	r17, 0x00	; 0
     cf0:	00 91 00 00 	lds	r16, 0x0000
		const Timer * timer = &pgm_Timers[t];
     cf4:	5c e2       	ldi	r21, 0x2C	; 44
     cf6:	e5 2e       	mov	r14, r21
     cf8:	f1 2c       	mov	r15, r1
//
------------------------------------------------------- */
void initTimers(void){
	uint8_t t;
    cli();
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     cfa:	00 c0       	rjmp	.+0      	; 0xcfc <initTimers+0x1c>
		const Timer * timer = &pgm_Timers[t];
     cfc:	81 2f       	mov	r24, r17
     cfe:	90 e0       	ldi	r25, 0x00	; 0
     d00:	8e 9d       	mul	r24, r14
     d02:	e0 01       	movw	r28, r0
     d04:	8f 9d       	mul	r24, r15
     d06:	d0 0d       	add	r29, r0
     d08:	9e 9d       	mul	r25, r14
     d0a:	d0 0d       	add	r29, r0
     d0c:	11 24       	eor	r1, r1
     d0e:	c0 50       	subi	r28, 0x00	; 0
     d10:	d0 40       	sbci	r29, 0x00	; 0
//  Detach any callback function to a timer
//
------------------------------------------------------- */
static __inline__ void timerOverflowDetach(const Timer* timer)
{
	timerOverflowAttach(timer,null,null);
     d12:	ce 01       	movw	r24, r28
     d14:	60 e0       	ldi	r22, 0x00	; 0
     d16:	70 e0       	ldi	r23, 0x00	; 0
     d18:	40 e0       	ldi	r20, 0x00	; 0
     d1a:	50 e0       	ldi	r21, 0x00	; 0
     d1c:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerOverflowDetach(timer);						// Detach any overyflow call back
		timerCaptureDetach(timer);						// Detach any capture call back
     d20:	ce 01       	movw	r24, r28
     d22:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerSetMode(timer,TIMER_MODE_NORMAL);
     d26:	ce 01       	movw	r24, r28
     d28:	60 e0       	ldi	r22, 0x00	; 0
     d2a:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		timerOff(timer);						// initialise the timer
     d2e:	ce 01       	movw	r24, r28
     d30:	0e 94 00 00 	call	0	; 0x0 <timerOff>
//
------------------------------------------------------- */
void initTimers(void){
	uint8_t t;
    cli();
    for(t=0; t < NUMBER_OF_TIMERS; t++){
     d34:	1f 5f       	subi	r17, 0xFF	; 255
     d36:	10 17       	cp	r17, r16
     d38:	00 f0       	brcs	.+0      	; 0xd3a <initTimers+0x5a>
		timerOverflowDetach(timer);						// Detach any overyflow call back
		timerCaptureDetach(timer);						// Detach any capture call back
		timerSetMode(timer,TIMER_MODE_NORMAL);
		timerOff(timer);						// initialise the timer
	}
    sei();
     d3a:	78 94       	sei
}
     d3c:	df 91       	pop	r29
     d3e:	cf 91       	pop	r28
     d40:	1f 91       	pop	r17
     d42:	0f 91       	pop	r16
     d44:	ff 90       	pop	r15
     d46:	ef 90       	pop	r14
     d48:	08 95       	ret

00000d4a <compareAttach>:
/* -------------------------------------------------------
//
//  Attach a callback function to a timer when the compare is met
//
------------------------------------------------------- */
void compareAttach(const TimerCompare* channel, TimerCompareCallback callback, uint16_t threshold, void* data ){
     d4a:	8f 92       	push	r8
     d4c:	9f 92       	push	r9
     d4e:	af 92       	push	r10
     d50:	bf 92       	push	r11
     d52:	cf 92       	push	r12
     d54:	df 92       	push	r13
     d56:	ef 92       	push	r14
     d58:	ff 92       	push	r15
     d5a:	0f 93       	push	r16
     d5c:	1f 93       	push	r17
     d5e:	cf 93       	push	r28
     d60:	df 93       	push	r29
     d62:	7c 01       	movw	r14, r24
     d64:	6b 01       	movw	r12, r22
     d66:	4a 01       	movw	r8, r20
     d68:	59 01       	movw	r10, r18
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
     d6a:	fc 01       	movw	r30, r24
     d6c:	32 96       	adiw	r30, 0x02	; 2
     d6e:	e4 91       	lpm	r30, Z
     d70:	f0 e0       	ldi	r31, 0x00	; 0

	const Timer* timer = compareGetTimer(channel);
     d72:	8c e2       	ldi	r24, 0x2C	; 44
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	e8 9f       	mul	r30, r24
     d78:	e0 01       	movw	r28, r0
     d7a:	e9 9f       	mul	r30, r25
     d7c:	d0 0d       	add	r29, r0
     d7e:	f8 9f       	mul	r31, r24
     d80:	d0 0d       	add	r29, r0
     d82:	11 24       	eor	r1, r1
     d84:	c0 50       	subi	r28, 0x00	; 0
     d86:	d0 40       	sbci	r29, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     d88:	fe 01       	movw	r30, r28
     d8a:	38 96       	adiw	r30, 0x08	; 8
     d8c:	e4 91       	lpm	r30, Z
	if(timerSupportsCompare(timer)){
     d8e:	ee 23       	and	r30, r30
     d90:	01 f0       	breq	.+0      	; 0xd92 <compareAttach+0x48>
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
     d92:	f7 01       	movw	r30, r14
     d94:	85 91       	lpm	r24, Z+
     d96:	94 91       	lpm	r25, Z
     d98:	8c 01       	movw	r16, r24

		TimerDataCompare* td = compareGetData(channel);

		// Check if compare is already in use
		if(callback!=null && td->compare_callback!=null){
     d9a:	61 15       	cp	r22, r1
     d9c:	71 05       	cpc	r23, r1
     d9e:	01 f0       	breq	.+0      	; 0xda0 <compareAttach+0x56>
     da0:	fc 01       	movw	r30, r24
     da2:	80 81       	ld	r24, Z
     da4:	91 81       	ldd	r25, Z+1	; 0x01
     da6:	00 97       	sbiw	r24, 0x00	; 0
     da8:	01 f0       	breq	.+0      	; 0xdaa <compareAttach+0x60>
			setError(TIMER_COMPARE_CALLBACK_EXISTS);
     daa:	8b ef       	ldi	r24, 0xFB	; 251
     dac:	0e 94 00 00 	call	0	; 0x0 <timerOff>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
     db0:	fe 01       	movw	r30, r28
     db2:	a5 91       	lpm	r26, Z+
     db4:	b4 91       	lpm	r27, Z
		}

		// Make sure the timer is set up and running
		timerSetPrescaler(timer,timerGetPrescaler(timer));
     db6:	6d 91       	ld	r22, X+
     db8:	7c 91       	ld	r23, X
     dba:	ce 01       	movw	r24, r28
     dbc:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Disallow compare interrupts whilst changing
		__portMaskClear(&channel->pgm_intenable);
     dc0:	e7 01       	movw	r28, r14
     dc2:	23 96       	adiw	r28, 0x03	; 3
     dc4:	ce 01       	movw	r24, r28
     dc6:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Set the compare threshold
		compareSetThreshold(channel, threshold);
     dca:	c7 01       	movw	r24, r14
     dcc:	b4 01       	movw	r22, r8
     dce:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Add the callback routine
		td->compare_callback = callback;
     dd2:	f8 01       	movw	r30, r16
     dd4:	d1 82       	std	Z+1, r13	; 0x01
     dd6:	c0 82       	st	Z, r12
		td->compare_data = data;
     dd8:	b3 82       	std	Z+3, r11	; 0x03
     dda:	a2 82       	std	Z+2, r10	; 0x02
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
     ddc:	c7 01       	movw	r24, r14
     dde:	08 96       	adiw	r24, 0x08	; 8
     de0:	0e 94 00 00 	call	0	; 0x0 <timerOff>

		// Clear old interrupt pending before re-enabling interrupt
		compareClearInterruptPending(channel);

		// Allow compare interrupts - unless it is the null routine
		if(callback && callback != &nullTimerCompareCallback){
     de4:	c1 14       	cp	r12, r1
     de6:	d1 04       	cpc	r13, r1
     de8:	01 f0       	breq	.+0      	; 0xdea <compareAttach+0xa0>
     dea:	f0 e0       	ldi	r31, 0x00	; 0
     dec:	cf 16       	cp	r12, r31
     dee:	f0 e0       	ldi	r31, 0x00	; 0
     df0:	df 06       	cpc	r13, r31
     df2:	01 f0       	breq	.+0      	; 0xdf4 <compareAttach+0xaa>
			__portMaskSet(&channel->pgm_intenable);
     df4:	ce 01       	movw	r24, r28
     df6:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     dfa:	00 c0       	rjmp	.+0      	; 0xdfc <compareAttach+0xb2>
		}
	}else{
		setError(TIMER_COMPARE_NOT_SUPPORTED);
     dfc:	8d ef       	ldi	r24, 0xFD	; 253
     dfe:	0e 94 00 00 	call	0	; 0x0 <timerOff>
	}
}
     e02:	df 91       	pop	r29
     e04:	cf 91       	pop	r28
     e06:	1f 91       	pop	r17
     e08:	0f 91       	pop	r16
     e0a:	ff 90       	pop	r15
     e0c:	ef 90       	pop	r14
     e0e:	df 90       	pop	r13
     e10:	cf 90       	pop	r12
     e12:	bf 90       	pop	r11
     e14:	af 90       	pop	r10
     e16:	9f 90       	pop	r9
     e18:	8f 90       	pop	r8
     e1a:	08 95       	ret

00000e1c <__clockInit>:
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     e1c:	2f 92       	push	r2
     e1e:	3f 92       	push	r3
     e20:	4f 92       	push	r4
     e22:	5f 92       	push	r5
     e24:	6f 92       	push	r6
     e26:	7f 92       	push	r7
     e28:	8f 92       	push	r8
     e2a:	9f 92       	push	r9
     e2c:	af 92       	push	r10
     e2e:	bf 92       	push	r11
     e30:	cf 92       	push	r12
     e32:	df 92       	push	r13
     e34:	ef 92       	push	r14
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
     e40:	cd b7       	in	r28, 0x3d	; 61
     e42:	de b7       	in	r29, 0x3e	; 62
     e44:	60 97       	sbiw	r28, 0x10	; 16
     e46:	0f b6       	in	r0, 0x3f	; 63
     e48:	f8 94       	cli
     e4a:	de bf       	out	0x3e, r29	; 62
     e4c:	0f be       	out	0x3f, r0	; 63
     e4e:	cd bf       	out	0x3d, r28	; 61

	const Timer* bestTimer;
	uint16_t     bestCompare;
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
     e50:	10 92 00 00 	sts	0x0000, r1
     e54:	10 92 00 00 	sts	0x0000, r1
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     e58:	c0 90 00 00 	lds	r12, 0x0000
     e5c:	ca 94       	dec	r12
     e5e:	44 24       	eor	r4, r4
     e60:	55 24       	eor	r5, r5
	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
	bestCompare = 0;
	bestPrescaler = 0;
     e62:	1e 82       	std	Y+6, r1	; 0x06
     e64:	1d 82       	std	Y+5, r1	; 0x05

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
	bestCompare = 0;
     e66:	1c 82       	std	Y+4, r1	; 0x04
     e68:	1b 82       	std	Y+3, r1	; 0x03
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case

	bestTimer=null;
     e6a:	1a 82       	std	Y+2, r1	; 0x02
     e6c:	19 82       	std	Y+1, r1	; 0x01
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     e6e:	2c 2c       	mov	r2, r12
     e70:	33 24       	eor	r3, r3
     e72:	27 fc       	sbrc	r2, 7
     e74:	30 94       	com	r3
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
		const Timer * timer = &pgm_Timers[t];
     e76:	fc e2       	ldi	r31, 0x2C	; 44
     e78:	ef 2e       	mov	r14, r31
     e7a:	f1 2c       	mov	r15, r1

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     e7c:	80 91 00 00 	lds	r24, 0x0000
     e80:	90 91 00 00 	lds	r25, 0x0000
     e84:	9c 01       	movw	r18, r24
     e86:	40 e0       	ldi	r20, 0x00	; 0
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	2f 83       	std	Y+7, r18	; 0x07
     e8c:	38 87       	std	Y+8, r19	; 0x08
     e8e:	49 87       	std	Y+9, r20	; 0x09
     e90:	5a 87       	std	Y+10, r21	; 0x0a
     e92:	aa 24       	eor	r10, r10
     e94:	bb 24       	eor	r11, r11
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     e96:	00 c0       	rjmp	.+0      	; 0xe98 <__clockInit+0x7c>
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     e98:	c1 01       	movw	r24, r2
     e9a:	84 19       	sub	r24, r4
     e9c:	95 09       	sbc	r25, r5
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
		const Timer * timer = &pgm_Timers[t];
     e9e:	8e 9d       	mul	r24, r14
     ea0:	30 01       	movw	r6, r0
     ea2:	8f 9d       	mul	r24, r15
     ea4:	70 0c       	add	r7, r0
     ea6:	9e 9d       	mul	r25, r14
     ea8:	70 0c       	add	r7, r0
     eaa:	11 24       	eor	r1, r1
     eac:	40 e0       	ldi	r20, 0x00	; 0
     eae:	50 e0       	ldi	r21, 0x00	; 0
     eb0:	64 0e       	add	r6, r20
     eb2:	75 1e       	adc	r7, r21
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
     eb4:	f3 01       	movw	r30, r6
     eb6:	34 96       	adiw	r30, 0x04	; 4
     eb8:	85 91       	lpm	r24, Z+
     eba:	94 91       	lpm	r25, Z
     ebc:	fc 01       	movw	r30, r24
     ebe:	80 81       	ld	r24, Z
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	87 70       	andi	r24, 0x07	; 7
     ec4:	90 70       	andi	r25, 0x00	; 0
     ec6:	00 97       	sbiw	r24, 0x00	; 0
     ec8:	01 f4       	brne	.+0      	; 0xeca <__clockInit+0xae>
     eca:	00 c0       	rjmp	.+0      	; 0xecc <__clockInit+0xb0>

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
     ecc:	f3 01       	movw	r30, r6
     ece:	38 96       	adiw	r30, 0x08	; 8
     ed0:	e4 91       	lpm	r30, Z
		if(!timerIsInUse(timer) && timerIsModeSupported(timer,TIMER_MODE_CTC_OCR)
				&& timerNumberOfCompareUnits(timer) >= 2 // Need one for timer and one for scheduler
     ed2:	e2 30       	cpi	r30, 0x02	; 2
     ed4:	00 f0       	brcs	.+0      	; 0xed6 <__clockInit+0xba>
				){
			if(bestCompare>0xFFU && !timerIs16bit(timer)){
     ed6:	5f ef       	ldi	r21, 0xFF	; 255
     ed8:	a5 16       	cp	r10, r21
     eda:	b1 04       	cpc	r11, r1
     edc:	01 f0       	breq	.+0      	; 0xede <__clockInit+0xc2>
     ede:	00 f0       	brcs	.+0      	; 0xee0 <__clockInit+0xc4>
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
     ee0:	f3 01       	movw	r30, r6
     ee2:	36 96       	adiw	r30, 0x06	; 6
     ee4:	e4 91       	lpm	r30, Z
     ee6:	ee 23       	and	r30, r30
     ee8:	01 f0       	breq	.+0      	; 0xeea <__clockInit+0xce>
				continue;
			}
			// It is a candidate
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
     eea:	c3 01       	movw	r24, r6
     eec:	6c e0       	ldi	r22, 0x0C	; 12
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     ef4:	4c 01       	movw	r8, r24

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     ef6:	6f 81       	ldd	r22, Y+7	; 0x07
     ef8:	78 85       	ldd	r23, Y+8	; 0x08
     efa:	89 85       	ldd	r24, Y+9	; 0x09
     efc:	9a 85       	ldd	r25, Y+10	; 0x0a
     efe:	2c e0       	ldi	r18, 0x0C	; 12
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	40 e0       	ldi	r20, 0x00	; 0
     f04:	50 e0       	ldi	r21, 0x00	; 0
     f06:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     f0a:	94 01       	movw	r18, r8
     f0c:	40 e0       	ldi	r20, 0x00	; 0
     f0e:	50 e0       	ldi	r21, 0x00	; 0
     f10:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     f14:	89 01       	movw	r16, r18
     f16:	9a 01       	movw	r18, r20
			// It is a candidate
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
			uint32_t compare = ticks_per_ms(clock_ms,thePreScale);		// Get the value for top

			// See if it is the best so far - and if so then remember it
			if(bestTimer==null || compare > bestCompare){
     f18:	89 81       	ldd	r24, Y+1	; 0x01
     f1a:	9a 81       	ldd	r25, Y+2	; 0x02
     f1c:	00 97       	sbiw	r24, 0x00	; 0
     f1e:	01 f0       	breq	.+0      	; 0xf20 <__clockInit+0x104>
     f20:	c5 01       	movw	r24, r10
     f22:	a0 e0       	ldi	r26, 0x00	; 0
     f24:	b0 e0       	ldi	r27, 0x00	; 0
     f26:	80 17       	cp	r24, r16
     f28:	91 07       	cpc	r25, r17
     f2a:	a2 07       	cpc	r26, r18
     f2c:	b3 07       	cpc	r27, r19
     f2e:	00 f4       	brcc	.+0      	; 0xf30 <__clockInit+0x114>
				bestTimer = timer;
				bestCompare = compare;
     f30:	58 01       	movw	r10, r16
				bestPrescaler = thePreScale;
     f32:	9e 82       	std	Y+6, r9	; 0x06
     f34:	8d 82       	std	Y+5, r8	; 0x05
			uint16_t thePreScale = timerGetBestPrescaler(timer, clock_ms); // At least 16ms before overflow
			uint32_t compare = ticks_per_ms(clock_ms,thePreScale);		// Get the value for top

			// See if it is the best so far - and if so then remember it
			if(bestTimer==null || compare > bestCompare){
				bestTimer = timer;
     f36:	7a 82       	std	Y+2, r7	; 0x02
     f38:	69 82       	std	Y+1, r6	; 0x01
				bestCompare = compare;
     f3a:	08 94       	sec
     f3c:	41 1c       	adc	r4, r1
     f3e:	51 1c       	adc	r5, r1
//  Find a free channel to use for the heartbeat
//
------------------------------------------------------- */
ERROR __error; // All zeros so exclude -  = {0,0,FALSE,null};

void __clockInit(void){
     f40:	8c 2d       	mov	r24, r12
     f42:	84 19       	sub	r24, r4
	bestCompare = 0;
	bestPrescaler = 0;

	// find a free timer that can support the required mode with lowest prescaler
	// Since this mode will always use channel A to set the value of top then the timer must be completely unused
    for(int8_t t=NUMBER_OF_TIMERS-1; t>=0 ; t--){
     f44:	87 ff       	sbrs	r24, 7
     f46:	00 c0       	rjmp	.+0      	; 0xf48 <__clockInit+0x12c>
     f48:	bc 82       	std	Y+4, r11	; 0x04
     f4a:	ab 82       	std	Y+3, r10	; 0x03
				bestPrescaler = thePreScale;
			}
		}
    }

    if(bestTimer!=null){
     f4c:	a9 81       	ldd	r26, Y+1	; 0x01
     f4e:	ba 81       	ldd	r27, Y+2	; 0x02
     f50:	10 97       	sbiw	r26, 0x00	; 0
     f52:	01 f4       	brne	.+0      	; 0xf54 <__clockInit+0x138>
     f54:	00 c0       	rjmp	.+0      	; 0xf56 <__clockInit+0x13a>
     f56:	fd 01       	movw	r30, r26
     f58:	36 96       	adiw	r30, 0x06	; 6
     f5a:	e4 91       	lpm	r30, Z
    	// The largest possible value for top
    	TICK_COUNT max = (timerIs16bit(bestTimer)) ? 0xFFFFUL : 0xFFUL;
     f5c:	ee 23       	and	r30, r30
     f5e:	01 f0       	breq	.+0      	; 0xf60 <__clockInit+0x144>
     f60:	ef ef       	ldi	r30, 0xFF	; 255
     f62:	8e 2e       	mov	r8, r30
     f64:	ef ef       	ldi	r30, 0xFF	; 255
     f66:	9e 2e       	mov	r9, r30
     f68:	a1 2c       	mov	r10, r1
     f6a:	b1 2c       	mov	r11, r1
     f6c:	00 c0       	rjmp	.+0      	; 0xf6e <__clockInit+0x152>
     f6e:	7f ef       	ldi	r23, 0xFF	; 255
     f70:	87 2e       	mov	r8, r23
     f72:	91 2c       	mov	r9, r1
     f74:	a1 2c       	mov	r10, r1
     f76:	b1 2c       	mov	r11, r1
	const Timer* bestTimer;
	uint16_t     bestCompare;
	uint16_t	 bestPrescaler;

	g_heartbeat = null;
	uint16_t	 clock_ms=12;		// 12ms work on 8 bit timer, 20MHz ie the worst case
     f78:	6c e0       	ldi	r22, 0x0C	; 12
     f7a:	26 2e       	mov	r2, r22
     f7c:	31 2c       	mov	r3, r1

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
     f7e:	80 91 00 00 	lds	r24, 0x0000
     f82:	90 91 00 00 	lds	r25, 0x0000
     f86:	9c 01       	movw	r18, r24
     f88:	40 e0       	ldi	r20, 0x00	; 0
     f8a:	50 e0       	ldi	r21, 0x00	; 0
     f8c:	2f 83       	std	Y+7, r18	; 0x07
     f8e:	38 87       	std	Y+8, r19	; 0x08
     f90:	49 87       	std	Y+9, r20	; 0x09
     f92:	5a 87       	std	Y+10, r21	; 0x0a
     f94:	ad 81       	ldd	r26, Y+5	; 0x05
     f96:	be 81       	ldd	r27, Y+6	; 0x06
     f98:	cd 01       	movw	r24, r26
     f9a:	a0 e0       	ldi	r26, 0x00	; 0
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	8b 87       	std	Y+11, r24	; 0x0b
     fa0:	9c 87       	std	Y+12, r25	; 0x0c
     fa2:	ad 87       	std	Y+13, r26	; 0x0d
     fa4:	be 87       	std	Y+14, r27	; 0x0e
     fa6:	ca 01       	movw	r24, r20
     fa8:	b9 01       	movw	r22, r18
     faa:	2b 85       	ldd	r18, Y+11	; 0x0b
     fac:	3c 85       	ldd	r19, Y+12	; 0x0c
     fae:	4d 85       	ldd	r20, Y+13	; 0x0d
     fb0:	5e 85       	ldd	r21, Y+14	; 0x0e
     fb2:	0e 94 00 00 	call	0	; 0x0 <timerOff>
     fb6:	69 01       	movw	r12, r18
     fb8:	7a 01       	movw	r14, r20

    if(bestTimer!=null){
    	// The largest possible value for top
    	TICK_COUNT max = (timerIs16bit(bestTimer)) ? 0xFFFFUL : 0xFFUL;
recalc:
    	if(bestCompare + ticks_per_ms(1,bestPrescaler) + 1 < max){
     fba:	08 94       	sec
     fbc:	c1 1c       	adc	r12, r1
     fbe:	d1 1c       	adc	r13, r1
     fc0:	e1 1c       	adc	r14, r1
     fc2:	f1 1c       	adc	r15, r1
     fc4:	eb 81       	ldd	r30, Y+3	; 0x03
     fc6:	fc 81       	ldd	r31, Y+4	; 0x04
     fc8:	2f 01       	movw	r4, r30
     fca:	66 24       	eor	r6, r6
     fcc:	77 24       	eor	r7, r7
     fce:	d7 01       	movw	r26, r14
     fd0:	c6 01       	movw	r24, r12
     fd2:	84 0d       	add	r24, r4
     fd4:	95 1d       	adc	r25, r5
     fd6:	a6 1d       	adc	r26, r6
     fd8:	b7 1d       	adc	r27, r7
     fda:	88 15       	cp	r24, r8
     fdc:	99 05       	cpc	r25, r9
     fde:	aa 05       	cpc	r26, r10
     fe0:	bb 05       	cpc	r27, r11
     fe2:	00 f4       	brcc	.+0      	; 0xfe4 <__clockInit+0x1c8>
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
     fe4:	91 01       	movw	r18, r2
     fe6:	2f 5f       	subi	r18, 0xFF	; 255
     fe8:	3f 4f       	sbci	r19, 0xFF	; 255
     fea:	38 8b       	std	Y+16, r19	; 0x10
     fec:	2f 87       	std	Y+15, r18	; 0x0f
     fee:	89 81       	ldd	r24, Y+1	; 0x01
     ff0:	9a 81       	ldd	r25, Y+2	; 0x02
     ff2:	b9 01       	movw	r22, r18
     ff4:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    		if(thePreScale==bestPrescaler && compare <= max && compare>bestCompare){
     ff8:	4d 81       	ldd	r20, Y+5	; 0x05
     ffa:	5e 81       	ldd	r21, Y+6	; 0x06
     ffc:	84 17       	cp	r24, r20
     ffe:	95 07       	cpc	r25, r21
    1000:	01 f4       	brne	.+0      	; 0x1002 <__clockInit+0x1e6>
    	TICK_COUNT max = (timerIs16bit(bestTimer)) ? 0xFFFFUL : 0xFFUL;
recalc:
    	if(bestCompare + ticks_per_ms(1,bestPrescaler) + 1 < max){
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    1002:	af 85       	ldd	r26, Y+15	; 0x0f
    1004:	b8 89       	ldd	r27, Y+16	; 0x10
    1006:	bd 01       	movw	r22, r26
    1008:	80 e0       	ldi	r24, 0x00	; 0
    100a:	90 e0       	ldi	r25, 0x00	; 0

// The timer used for the clock, or null if not set
const Timer* g_heartbeat;

uint32_t ticks_per_ms(uint32_t ms, uint16_t prescale){
	return (ms * cpu_speed_div_1000)/prescale;
    100c:	2f 81       	ldd	r18, Y+7	; 0x07
    100e:	38 85       	ldd	r19, Y+8	; 0x08
    1010:	49 85       	ldd	r20, Y+9	; 0x09
    1012:	5a 85       	ldd	r21, Y+10	; 0x0a
    1014:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    1018:	2b 85       	ldd	r18, Y+11	; 0x0b
    101a:	3c 85       	ldd	r19, Y+12	; 0x0c
    101c:	4d 85       	ldd	r20, Y+13	; 0x0d
    101e:	5e 85       	ldd	r21, Y+14	; 0x0e
    1020:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    1024:	89 01       	movw	r16, r18
    1026:	9a 01       	movw	r18, r20
recalc:
    	if(bestCompare + ticks_per_ms(1,bestPrescaler) + 1 < max){
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    		if(thePreScale==bestPrescaler && compare <= max && compare>bestCompare){
    1028:	80 16       	cp	r8, r16
    102a:	91 06       	cpc	r9, r17
    102c:	a2 06       	cpc	r10, r18
    102e:	b3 06       	cpc	r11, r19
    1030:	00 f0       	brcs	.+0      	; 0x1032 <__clockInit+0x216>
    1032:	40 16       	cp	r4, r16
    1034:	51 06       	cpc	r5, r17
    1036:	62 06       	cpc	r6, r18
    1038:	73 06       	cpc	r7, r19
    103a:	00 f4       	brcc	.+0      	; 0x103c <__clockInit+0x220>
    			// Same prescaler and increased compare
    			clock_ms++;
    			bestCompare = compare;
    103c:	1c 83       	std	Y+4, r17	; 0x04
    103e:	0b 83       	std	Y+3, r16	; 0x03
        	// See if we can boost the number of 'ms'
    		uint16_t thePreScale = timerGetBestPrescaler(bestTimer, clock_ms+1); // Try another ms
    		uint32_t compare = ticks_per_ms(clock_ms+1,thePreScale);			 // Get the value for top
    		if(thePreScale==bestPrescaler && compare <= max && compare>bestCompare){
    			// Same prescaler and increased compare
    			clock_ms++;
    1040:	2f 84       	ldd	r2, Y+15	; 0x0f
    1042:	38 88       	ldd	r3, Y+16	; 0x10
    			bestCompare = compare;
    			goto recalc;
    1044:	00 c0       	rjmp	.+0      	; 0x1046 <__clockInit+0x22a>
    		}
    	}

		// We have got the highest setting
    	g_heartbeat = bestTimer;
    1046:	e9 81       	ldd	r30, Y+1	; 0x01
    1048:	fa 81       	ldd	r31, Y+2	; 0x02
    104a:	f0 93 00 00 	sts	0x0000, r31
    104e:	e0 93 00 00 	sts	0x0000, r30
    	_CLOCK_US_ = clock_ms * 1000UL;
    1052:	b1 01       	movw	r22, r2
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	28 ee       	ldi	r18, 0xE8	; 232
    105a:	33 e0       	ldi	r19, 0x03	; 3
    105c:	40 e0       	ldi	r20, 0x00	; 0
    105e:	50 e0       	ldi	r21, 0x00	; 0
    1060:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    1064:	dc 01       	movw	r26, r24
    1066:	cb 01       	movw	r24, r22
    1068:	80 93 00 00 	sts	0x0000, r24
    106c:	90 93 00 00 	sts	0x0000, r25
    1070:	a0 93 00 00 	sts	0x0000, r26
    1074:	b0 93 00 00 	sts	0x0000, r27
        timerSetPrescaler(g_heartbeat, bestPrescaler);
    1078:	89 81       	ldd	r24, Y+1	; 0x01
    107a:	9a 81       	ldd	r25, Y+2	; 0x02
    107c:	6d 81       	ldd	r22, Y+5	; 0x05
    107e:	7e 81       	ldd	r23, Y+6	; 0x06
    1080:	0e 94 00 00 	call	0	; 0x0 <timerOff>


		// Change the mode of the timer
		timerSetMode(g_heartbeat, TIMER_MODE_CTC_OCR);
    1084:	80 91 00 00 	lds	r24, 0x0000
    1088:	90 91 00 00 	lds	r25, 0x0000
    108c:	64 e0       	ldi	r22, 0x04	; 4
    108e:	0e 94 00 00 	call	0	; 0x0 <timerOff>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
    1092:	e0 91 00 00 	lds	r30, 0x0000
    1096:	f0 91 00 00 	lds	r31, 0x0000
    109a:	77 96       	adiw	r30, 0x17	; 23
    109c:	85 91       	lpm	r24, Z+
    109e:	94 91       	lpm	r25, Z
		const TimerCompare* channel = timerGetCompare(g_heartbeat, 0);
		compareAttach(channel, &clockCallback, bestCompare, null);
    10a0:	60 e0       	ldi	r22, 0x00	; 0
    10a2:	70 e0       	ldi	r23, 0x00	; 0
    10a4:	4b 81       	ldd	r20, Y+3	; 0x03
    10a6:	5c 81       	ldd	r21, Y+4	; 0x04
    10a8:	20 e0       	ldi	r18, 0x00	; 0
    10aa:	30 e0       	ldi	r19, 0x00	; 0
    10ac:	0e 94 00 00 	call	0	; 0x0 <timerOff>
		// Enable overflow interrupts - NOT NEEDED - uses compare interrupts
		//__portMaskSet(&g_heartbeat->pgm_overflowint);
	}

	// if an error was previously set then start it flashing on the LED
	ERROR_CODE current = __error.errorCode;
    10b0:	80 91 00 00 	lds	r24, 0x0000
	if(current!=0){
    10b4:	88 23       	and	r24, r24
    10b6:	01 f0       	breq	.+0      	; 0x10b8 <__clockInit+0x29c>
		__error.errorCode = 0;
    10b8:	10 92 00 00 	sts	0x0000, r1
		setError(current);
    10bc:	0e 94 00 00 	call	0	; 0x0 <timerOff>
    10c0:	00 c0       	rjmp	.+0      	; 0x10c2 <__clockInit+0x2a6>
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
    10c2:	f3 01       	movw	r30, r6
    10c4:	39 96       	adiw	r30, 0x09	; 9
    10c6:	85 91       	lpm	r24, Z+
    10c8:	94 91       	lpm	r25, Z
    10ca:	84 fd       	sbrc	r24, 4
    10cc:	00 c0       	rjmp	.+0      	; 0x10ce <__clockInit+0x2b2>
    10ce:	00 c0       	rjmp	.+0      	; 0x10d0 <__clockInit+0x2b4>
	}

}
    10d0:	60 96       	adiw	r28, 0x10	; 16
    10d2:	0f b6       	in	r0, 0x3f	; 63
    10d4:	f8 94       	cli
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	0f be       	out	0x3f, r0	; 63
    10da:	cd bf       	out	0x3d, r28	; 61
    10dc:	df 91       	pop	r29
    10de:	cf 91       	pop	r28
    10e0:	1f 91       	pop	r17
    10e2:	0f 91       	pop	r16
    10e4:	ff 90       	pop	r15
    10e6:	ef 90       	pop	r14
    10e8:	df 90       	pop	r13
    10ea:	cf 90       	pop	r12
    10ec:	bf 90       	pop	r11
    10ee:	af 90       	pop	r10
    10f0:	9f 90       	pop	r9
    10f2:	8f 90       	pop	r8
    10f4:	7f 90       	pop	r7
    10f6:	6f 90       	pop	r6
    10f8:	5f 90       	pop	r5
    10fa:	4f 90       	pop	r4
    10fc:	3f 90       	pop	r3
    10fe:	2f 90       	pop	r2
    1100:	08 95       	ret

00001102 <setErrorLog>:

	}
}

void setErrorLog(Writer log){
	__error.output = log;
    1102:	90 93 00 00 	sts	0x0000, r25
    1106:	80 93 00 00 	sts	0x0000, r24
}
    110a:	08 95       	ret

timerCapture.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000000b6  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000ea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000ea  2**0
                  ALLOC
  3 .debug_info   00000672  00000000  00000000  000000ea  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001ec  00000000  00000000  0000075c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000270  00000000  00000000  00000948  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00000bb8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000d6  00000000  00000000  00000bd8  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    00000537  00000000  00000000  00000cae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000088  00000000  00000000  000011e8  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerCaptureAttach>:
 */

#include "timer.h"

void timerCaptureAttach(const Timer* timer, TimerCallback callback, void* user_data, boolean risingEdge )
{
   0:	8f 92       	push	r8
   2:	9f 92       	push	r9
   4:	af 92       	push	r10
   6:	bf 92       	push	r11
   8:	df 92       	push	r13
   a:	ef 92       	push	r14
   c:	ff 92       	push	r15
   e:	0f 93       	push	r16
  10:	1f 93       	push	r17
  12:	cf 93       	push	r28
  14:	df 93       	push	r29
  16:	0f 92       	push	r0
  18:	cd b7       	in	r28, 0x3d	; 61
  1a:	de b7       	in	r29, 0x3e	; 62
  1c:	8c 01       	movw	r16, r24
  1e:	5b 01       	movw	r10, r22
  20:	7a 01       	movw	r14, r20
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  22:	fc 01       	movw	r30, r24
  24:	85 91       	lpm	r24, Z+
  26:	94 91       	lpm	r25, Z
  28:	4c 01       	movw	r8, r24
	TimerData* data = timerGetData(timer);
	if(data->capture_callback != null){
  2a:	fc 01       	movw	r30, r24
  2c:	86 81       	ldd	r24, Z+6	; 0x06
  2e:	97 81       	ldd	r25, Z+7	; 0x07
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f0       	breq	.+0      	; 0x34 <timerCaptureAttach+0x34>
		setError(TIMER_CAPTURE_CALLBACK_EXISTS);
  34:	8a ee       	ldi	r24, 0xEA	; 234
  36:	29 83       	std	Y+1, r18	; 0x01
  38:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
  3c:	29 81       	ldd	r18, Y+1	; 0x01
	}

	// Turn off interrupts whilst changing
	// in case an interrupt happens half way through
	CRITICAL_SECTION_START;
  3e:	df b6       	in	r13, 0x3f	; 63
  40:	f8 94       	cli

	// Set callback
	data->capture_callback = callback;
  42:	f4 01       	movw	r30, r8
  44:	b7 82       	std	Z+7, r11	; 0x07
  46:	a6 82       	std	Z+6, r10	; 0x06
	data->capture_data = user_data;
  48:	f1 86       	std	Z+9, r15	; 0x09
  4a:	e0 86       	std	Z+8, r14	; 0x08
  4c:	c8 01       	movw	r24, r16
  4e:	87 96       	adiw	r24, 0x27	; 39

	// Set the rising falling edge
	if(risingEdge){
  50:	22 23       	and	r18, r18
  52:	01 f0       	breq	.+0      	; 0x54 <timerCaptureAttach+0x54>
		__portMaskSet(&timer->pgm_captureedge);
  54:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
  58:	00 c0       	rjmp	.+0      	; 0x5a <timerCaptureAttach+0x5a>
	}else{
		__portMaskClear(&timer->pgm_captureedge);
  5a:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
  5e:	c8 01       	movw	r24, r16
  60:	84 96       	adiw	r24, 0x24	; 36
  62:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	// Clear any pending capture interrupt flag
	timerCaptureClearInterruptPending(timer);

	// enable interrupt
	__portMaskSet(&timer->pgm_captureint);
  66:	c8 01       	movw	r24, r16
  68:	81 96       	adiw	r24, 0x21	; 33
  6a:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	CRITICAL_SECTION_END;
  6e:	df be       	out	0x3f, r13	; 63
}
  70:	0f 90       	pop	r0
  72:	df 91       	pop	r29
  74:	cf 91       	pop	r28
  76:	1f 91       	pop	r17
  78:	0f 91       	pop	r16
  7a:	ff 90       	pop	r15
  7c:	ef 90       	pop	r14
  7e:	df 90       	pop	r13
  80:	bf 90       	pop	r11
  82:	af 90       	pop	r10
  84:	9f 90       	pop	r9
  86:	8f 90       	pop	r8
  88:	08 95       	ret

0000008a <timerCaptureDetach>:

void timerCaptureDetach(const Timer* timer){
  8a:	0f 93       	push	r16
  8c:	1f 93       	push	r17
  8e:	cf 93       	push	r28
  90:	df 93       	push	r29
  92:	8c 01       	movw	r16, r24
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  94:	fc 01       	movw	r30, r24
  96:	c5 91       	lpm	r28, Z+
  98:	d4 91       	lpm	r29, Z
	TimerData* data = timerGetData(timer);

	// stop interrupt
	__portMaskClear(&timer->pgm_captureint);
  9a:	81 96       	adiw	r24, 0x21	; 33
  9c:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
  a0:	c8 01       	movw	r24, r16
  a2:	84 96       	adiw	r24, 0x24	; 36
  a4:	0e 94 00 00 	call	0	; 0x0 <timerCaptureAttach>

	// Clear any pending capture interrupt flag
	timerCaptureClearInterruptPending(timer);

	// Set callback
	data->capture_callback = null;
  a8:	1f 82       	std	Y+7, r1	; 0x07
  aa:	1e 82       	std	Y+6, r1	; 0x06
}
  ac:	df 91       	pop	r29
  ae:	cf 91       	pop	r28
  b0:	1f 91       	pop	r17
  b2:	0f 91       	pop	r16
  b4:	08 95       	ret

timerCompare.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000010e  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000142  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000142  2**0
                  ALLOC
  3 .debug_info   000009a0  00000000  00000000  00000142  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 00000262  00000000  00000000  00000ae2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000037c  00000000  00000000  00000d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000010c0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000060  00000000  00000000  000010e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000012b  00000000  00000000  00001140  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    000005e9  00000000  00000000  0000126b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000070  00000000  00000000  00001854  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <compareIsInUse>:
 *      Author: Clive Webster
 */
#include "timer.h"


boolean compareIsInUse(const TimerCompare* channel){
   0:	ac 01       	movw	r20, r24
static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
}

static __inline__ TimerDataCompare* compareGetData(const TimerCompare* compare){
	return (TimerDataCompare*)pgm_read_word(&compare->pgm_data);
   2:	fc 01       	movw	r30, r24
   4:	a5 91       	lpm	r26, Z+
   6:	b4 91       	lpm	r27, Z
	TimerDataCompare* data = compareGetData(channel);

	// if it has a callback then it is in use
	if(data->compare_callback != null)
   8:	8d 91       	ld	r24, X+
   a:	9c 91       	ld	r25, X
   c:	11 97       	sbiw	r26, 0x01	; 1
   e:	00 97       	sbiw	r24, 0x00	; 0
  10:	01 f4       	brne	.+0      	; 0x12 <compareIsInUse+0x12>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
  12:	fa 01       	movw	r30, r20
  14:	32 96       	adiw	r30, 0x02	; 2
  16:	e4 91       	lpm	r30, Z
  18:	f0 e0       	ldi	r31, 0x00	; 0
		return TRUE;

	// if it is channel A and the Timer is is a mode where TOP is set channel A then it is also
	// in use (for defining the Timer TOP value)
	if(timerGetCompare(compareGetTimer(channel),0)==channel){
  1a:	8c e2       	ldi	r24, 0x2C	; 44
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	e8 9f       	mul	r30, r24
  20:	90 01       	movw	r18, r0
  22:	e9 9f       	mul	r30, r25
  24:	30 0d       	add	r19, r0
  26:	f8 9f       	mul	r31, r24
  28:	30 0d       	add	r19, r0
  2a:	11 24       	eor	r1, r1
  2c:	20 50       	subi	r18, 0x00	; 0
  2e:	30 40       	sbci	r19, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  30:	f9 01       	movw	r30, r18
  32:	77 96       	adiw	r30, 0x17	; 23
  34:	85 91       	lpm	r24, Z+
  36:	94 91       	lpm	r25, Z
  38:	48 17       	cp	r20, r24
  3a:	59 07       	cpc	r21, r25
  3c:	01 f4       	brne	.+0      	; 0x3e <compareIsInUse+0x3e>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  3e:	f9 01       	movw	r30, r18
  40:	a5 91       	lpm	r26, Z+
  42:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
  44:	1a 96       	adiw	r26, 0x0a	; 10
  46:	8c 91       	ld	r24, X
  48:	1a 97       	sbiw	r26, 0x0a	; 10
		TIMER_MODE mode = timerGetMode(compareGetTimer(channel));
		if(mode==TIMER_MODE_CTC_OCR
  4a:	84 30       	cpi	r24, 0x04	; 4
  4c:	01 f0       	breq	.+0      	; 0x4e <compareIsInUse+0x4e>
				|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
  4e:	89 30       	cpi	r24, 0x09	; 9
  50:	01 f0       	breq	.+0      	; 0x52 <compareIsInUse+0x52>
				|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
  52:	8b 30       	cpi	r24, 0x0B	; 11
  54:	01 f0       	breq	.+0      	; 0x56 <compareIsInUse+0x56>
				|| mode==TIMER_MODE_PWM_FAST_OCR){
  56:	8f 30       	cpi	r24, 0x0F	; 15
  58:	01 f0       	breq	.+0      	; 0x5a <compareIsInUse+0x5a>
			return TRUE;
		}
	}

	return FALSE;
  5a:	80 e0       	ldi	r24, 0x00	; 0
  5c:	08 95       	ret
		TIMER_MODE mode = timerGetMode(compareGetTimer(channel));
		if(mode==TIMER_MODE_CTC_OCR
				|| mode==TIMER_MODE_PWM_PHASE_FREQ_OCR
				|| mode==TIMER_MODE_PWM_PHASE_CORRECT_OCR
				|| mode==TIMER_MODE_PWM_FAST_OCR){
			return TRUE;
  5e:	8f ef       	ldi	r24, 0xFF	; 255
  60:	08 95       	ret
  62:	8f ef       	ldi	r24, 0xFF	; 255
		}
	}

	return FALSE;
}
  64:	08 95       	ret

00000066 <compareFromIOPin>:
//  May return null if this pin is not to do with a timer
//  or it does not exist on this system board
//  An IOPin may actually support more than one compare
// channel - in which case give priority to 16 bit timers
------------------------------------------------------- */
const TimerCompare* compareFromIOPin(const IOPin* pin){
  66:	8f 92       	push	r8
  68:	9f 92       	push	r9
  6a:	af 92       	push	r10
  6c:	bf 92       	push	r11
  6e:	cf 92       	push	r12
  70:	df 92       	push	r13
  72:	ef 92       	push	r14
  74:	ff 92       	push	r15
  76:	0f 93       	push	r16
  78:	1f 93       	push	r17
  7a:	cf 93       	push	r28
  7c:	df 93       	push	r29
  7e:	6c 01       	movw	r12, r24
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  80:	e0 90 00 00 	lds	r14, 0x0000
  84:	60 e0       	ldi	r22, 0x00	; 0
  86:	70 e0       	ldi	r23, 0x00	; 0
// channel - in which case give priority to 16 bit timers
------------------------------------------------------- */
const TimerCompare* compareFromIOPin(const IOPin* pin){
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;
  88:	a0 e0       	ldi	r26, 0x00	; 0
  8a:	b0 e0       	ldi	r27, 0x00	; 0

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
		const Timer * timer = &pgm_Timers[t];
  8c:	2c e2       	ldi	r18, 0x2C	; 44
  8e:	82 2e       	mov	r8, r18
  90:	91 2c       	mov	r9, r1
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  92:	00 c0       	rjmp	.+0      	; 0x94 <compareFromIOPin+0x2e>
		const Timer * timer = &pgm_Timers[t];
  94:	68 9d       	mul	r22, r8
  96:	c0 01       	movw	r24, r0
  98:	69 9d       	mul	r22, r9
  9a:	90 0d       	add	r25, r0
  9c:	78 9d       	mul	r23, r8
  9e:	90 0d       	add	r25, r0
  a0:	11 24       	eor	r1, r1
  a2:	80 50       	subi	r24, 0x00	; 0
  a4:	90 40       	sbci	r25, 0x00	; 0

// Read the timer counter TCNTxx
uint16_t timerGetCounter(const Timer* timer);

static __inline__ uint8_t timerNumberOfCompareUnits(const Timer* timer){
	return((uint8_t)pgm_read_byte(&timer->pgm_numCompare));
  a6:	fc 01       	movw	r30, r24
  a8:	38 96       	adiw	r30, 0x08	; 8
  aa:	f4 90       	lpm	r15, Z

		// Iterate over the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(c=0;c<numCompare;c++){
  ac:	c0 e0       	ldi	r28, 0x00	; 0
  ae:	d0 e0       	ldi	r29, 0x00	; 0
  b0:	40 e0       	ldi	r20, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  b2:	fc 01       	movw	r30, r24
  b4:	77 96       	adiw	r30, 0x17	; 23
  b6:	a5 90       	lpm	r10, Z+
  b8:	b4 90       	lpm	r11, Z
static __inline__ void timerOff(const Timer* timer){
	_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) &= ~ TIMER_PRESCALE_MASK;
}

static __inline__ boolean timerIs16bit(const Timer* timer){
	return pgm_read_byte(&timer->pgm_sixteenBit);
  ba:	fc 01       	movw	r30, r24
  bc:	36 96       	adiw	r30, 0x06	; 6
  be:	54 91       	lpm	r21, Z
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <compareFromIOPin+0x5c>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  c2:	95 01       	movw	r18, r10
  c4:	2c 0f       	add	r18, r28
  c6:	3d 1f       	adc	r19, r29
//  Get the pin which this channel uses for output
//  Return IOpin* or null if it has no header pins
//
------------------------------------------------------- */
static __inline__ const IOPin * compareGetPin(const TimerCompare* channel){
	return  (const IOPin *)pgm_read_word(&channel->pgm_pwm);
  c8:	f9 01       	movw	r30, r18
  ca:	3e 96       	adiw	r30, 0x0e	; 14
  cc:	05 91       	lpm	r16, Z+
  ce:	14 91       	lpm	r17, Z
  d0:	c8 01       	movw	r24, r16
			const TimerCompare* channel = timerGetCompare(timer,c);
			const IOPin* thisPin = compareGetPin(channel);
			if(thisPin != null && thisPin==pin){
  d2:	00 97       	sbiw	r24, 0x00	; 0
  d4:	01 f0       	breq	.+0      	; 0xd6 <compareFromIOPin+0x70>
  d6:	0c 15       	cp	r16, r12
  d8:	1d 05       	cpc	r17, r13
  da:	01 f4       	brne	.+0      	; 0xdc <compareFromIOPin+0x76>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  dc:	d9 01       	movw	r26, r18
				rtn = channel;					// remember the channel
				if(timerIs16bit(timer)){
  de:	55 23       	and	r21, r21
  e0:	01 f4       	brne	.+0      	; 0xe2 <compareFromIOPin+0x7c>
	for(t=0; t < NUMBER_OF_TIMERS; t++){
		const Timer * timer = &pgm_Timers[t];

		// Iterate over the compare units
		uint8_t numCompare = timerNumberOfCompareUnits(timer);
		for(c=0;c<numCompare;c++){
  e2:	4f 5f       	subi	r20, 0xFF	; 255
  e4:	60 96       	adiw	r28, 0x10	; 16
  e6:	4f 15       	cp	r20, r15
  e8:	01 f4       	brne	.+0      	; 0xea <compareFromIOPin+0x84>
  ea:	6f 5f       	subi	r22, 0xFF	; 255
  ec:	7f 4f       	sbci	r23, 0xFF	; 255
	uint8_t t;
	uint8_t c;
	const TimerCompare* rtn=null;

	// Iterate over the timers
	for(t=0; t < NUMBER_OF_TIMERS; t++){
  ee:	6e 15       	cp	r22, r14
  f0:	00 f0       	brcs	.+0      	; 0xf2 <compareFromIOPin+0x8c>
			}
		}
	}

	return rtn;
}
  f2:	cd 01       	movw	r24, r26
  f4:	df 91       	pop	r29
  f6:	cf 91       	pop	r28
  f8:	1f 91       	pop	r17
  fa:	0f 91       	pop	r16
  fc:	ff 90       	pop	r15
  fe:	ef 90       	pop	r14
 100:	df 90       	pop	r13
 102:	cf 90       	pop	r12
 104:	bf 90       	pop	r11
 106:	af 90       	pop	r10
 108:	9f 90       	pop	r9
 10a:	8f 90       	pop	r8
 10c:	08 95       	ret

timerOverflow.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000006c  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000000a0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000000a0  2**0
                  ALLOC
  3 .debug_info   000005de  00000000  00000000  000000a0  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 000001ce  00000000  00000000  0000067e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    0000015f  00000000  00000000  0000084c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  000009ab  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_line   000000bc  00000000  00000000  000009cb  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_str    000004f9  00000000  00000000  00000a87  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000048  00000000  00000000  00000f80  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <timerOverflowAttach>:
//  This function is called during an interrupt so should
//  be quick.
//
------------------------------------------------------- */
void timerOverflowAttach(const Timer* timer, TimerCallback callback, void* user_data )
{
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ff 92       	push	r15
   6:	0f 93       	push	r16
   8:	1f 93       	push	r17
   a:	cf 93       	push	r28
   c:	df 93       	push	r29
   e:	ec 01       	movw	r28, r24
  10:	8b 01       	movw	r16, r22
  12:	6a 01       	movw	r12, r20
	// Turn off interrupts whilst changing
	// in case an interrupt happens half way through
	CRITICAL_SECTION_START;
  14:	ff b6       	in	r15, 0x3f	; 63
  16:	f8 94       	cli
	if(callback!=null && timerGetData(timer)->overflow_callback != null){
  18:	61 15       	cp	r22, r1
  1a:	71 05       	cpc	r23, r1
  1c:	01 f0       	breq	.+0      	; 0x1e <timerOverflowAttach+0x1e>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
  1e:	fc 01       	movw	r30, r24
  20:	a5 91       	lpm	r26, Z+
  22:	b4 91       	lpm	r27, Z
  24:	12 96       	adiw	r26, 0x02	; 2
  26:	8d 91       	ld	r24, X+
  28:	9c 91       	ld	r25, X
  2a:	13 97       	sbiw	r26, 0x03	; 3
  2c:	00 97       	sbiw	r24, 0x00	; 0
  2e:	01 f0       	breq	.+0      	; 0x30 <timerOverflowAttach+0x30>
		setError(TIMER_OVERFLOW_CALLBACK_EXISTS);
  30:	8c ef       	ldi	r24, 0xFC	; 252
  32:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
  36:	fe 01       	movw	r30, r28
  38:	85 91       	lpm	r24, Z+
  3a:	94 91       	lpm	r25, Z
  3c:	fc 01       	movw	r30, r24
	}

	// Set callback
	TimerData* data = timerGetData(timer);
	data->overflow_callback = callback;
  3e:	13 83       	std	Z+3, r17	; 0x03
  40:	02 83       	std	Z+2, r16	; 0x02
	data->overflow_data = user_data;
  42:	d5 82       	std	Z+5, r13	; 0x05
  44:	c4 82       	std	Z+4, r12	; 0x04
  46:	ce 01       	movw	r24, r28
  48:	49 96       	adiw	r24, 0x19	; 25

	// enable interrupt if there is callback
	if(callback!=null){
  4a:	01 15       	cp	r16, r1
  4c:	11 05       	cpc	r17, r1
  4e:	01 f0       	breq	.+0      	; 0x50 <timerOverflowAttach+0x50>
		// enable overflow interrupts
		__portMaskSet(&timer->pgm_overflowint);
  50:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
  54:	00 c0       	rjmp	.+0      	; 0x56 <timerOverflowAttach+0x56>
	}else{
		// Disable overflow interrupts
		__portMaskClear(&timer->pgm_overflowint);
  56:	0e 94 00 00 	call	0	; 0x0 <timerOverflowAttach>
	}

	CRITICAL_SECTION_END;
  5a:	ff be       	out	0x3f, r15	; 63
}
  5c:	df 91       	pop	r29
  5e:	cf 91       	pop	r28
  60:	1f 91       	pop	r17
  62:	0f 91       	pop	r16
  64:	ff 90       	pop	r15
  66:	df 90       	pop	r13
  68:	cf 90       	pop	r12
  6a:	08 95       	ret

timerPWM.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005c0  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000005f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000005f4  2**0
                  ALLOC
  3 .debug_info   00000a37  00000000  00000000  000005f4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .debug_abbrev 0000028b  00000000  00000000  0000102b  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_loc    00000b5e  00000000  00000000  000012b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000020  00000000  00000000  00001e14  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_ranges 00000080  00000000  00000000  00001e34  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000001b0  00000000  00000000  00001eb4  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    0000061b  00000000  00000000  00002064  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000d8  00000000  00000000  00002680  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__timerPWMGetDeciHertz>:


// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
   0:	cf 92       	push	r12
   2:	df 92       	push	r13
   4:	ef 92       	push	r14
   6:	ff 92       	push	r15
   8:	0f 93       	push	r16
   a:	1f 93       	push	r17
   c:	cf 93       	push	r28
   e:	df 93       	push	r29
  10:	d8 2f       	mov	r29, r24
  12:	6b 01       	movw	r12, r22
  14:	c4 2f       	mov	r28, r20
  16:	15 2f       	mov	r17, r21
	uint32_t deciHertz=0;
	uint16_t top = icr;
	uint32_t cpuDivPrescale = cpu_speed * 10 / prescaler;
  18:	60 91 00 00 	lds	r22, 0x0000
  1c:	70 91 00 00 	lds	r23, 0x0000
  20:	80 91 00 00 	lds	r24, 0x0000
  24:	90 91 00 00 	lds	r25, 0x0000
  28:	2a e0       	ldi	r18, 0x0A	; 10
  2a:	30 e0       	ldi	r19, 0x00	; 0
  2c:	40 e0       	ldi	r20, 0x00	; 0
  2e:	50 e0       	ldi	r21, 0x00	; 0
  30:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  34:	96 01       	movw	r18, r12
  36:	40 e0       	ldi	r20, 0x00	; 0
  38:	50 e0       	ldi	r21, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  3e:	69 01       	movw	r12, r18
  40:	7a 01       	movw	r14, r20

	switch(mode){
  42:	d6 30       	cpi	r29, 0x06	; 6
  44:	01 f0       	breq	.+0      	; 0x46 <__timerPWMGetDeciHertz+0x46>
  46:	d7 30       	cpi	r29, 0x07	; 7
  48:	00 f4       	brcc	.+0      	; 0x4a <__timerPWMGetDeciHertz+0x4a>
  4a:	d2 30       	cpi	r29, 0x02	; 2
  4c:	01 f0       	breq	.+0      	; 0x4e <__timerPWMGetDeciHertz+0x4e>
  4e:	d3 30       	cpi	r29, 0x03	; 3
  50:	00 f4       	brcc	.+0      	; 0x52 <__timerPWMGetDeciHertz+0x52>
  52:	d1 30       	cpi	r29, 0x01	; 1
  54:	01 f4       	brne	.+0      	; 0x56 <__timerPWMGetDeciHertz+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <__timerPWMGetDeciHertz+0x58>
  58:	d3 30       	cpi	r29, 0x03	; 3
  5a:	01 f0       	breq	.+0      	; 0x5c <__timerPWMGetDeciHertz+0x5c>
  5c:	d5 30       	cpi	r29, 0x05	; 5
  5e:	01 f4       	brne	.+0      	; 0x60 <__timerPWMGetDeciHertz+0x60>
  60:	00 c0       	rjmp	.+0      	; 0x62 <__timerPWMGetDeciHertz+0x62>
  62:	d8 30       	cpi	r29, 0x08	; 8
  64:	01 f0       	breq	.+0      	; 0x66 <__timerPWMGetDeciHertz+0x66>
  66:	d8 30       	cpi	r29, 0x08	; 8
  68:	00 f0       	brcs	.+0      	; 0x6a <__timerPWMGetDeciHertz+0x6a>
  6a:	da 30       	cpi	r29, 0x0A	; 10
  6c:	01 f0       	breq	.+0      	; 0x6e <__timerPWMGetDeciHertz+0x6e>
  6e:	de 30       	cpi	r29, 0x0E	; 14
  70:	01 f4       	brne	.+0      	; 0x72 <__timerPWMGetDeciHertz+0x72>
// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
	uint32_t deciHertz=0;
	uint16_t top = icr;
  72:	2c 2f       	mov	r18, r28
  74:	31 2f       	mov	r19, r17
  76:	00 c0       	rjmp	.+0      	; 0x78 <__timerPWMGetDeciHertz+0x78>
  78:	2c 2f       	mov	r18, r28
  7a:	31 2f       	mov	r19, r17
  7c:	00 c0       	rjmp	.+0      	; 0x7e <__timerPWMGetDeciHertz+0x7e>
	switch(mode){
	case TIMER_MODE_PWM8_PHASE_CORRECT:
		top=0xffU;
		goto PhaseCorrect;
	case TIMER_MODE_PWM9_PHASE_CORRECT:
		top=0x1ffU;
  7e:	2f ef       	ldi	r18, 0xFF	; 255
  80:	31 e0       	ldi	r19, 0x01	; 1
		goto PhaseCorrect;
  82:	00 c0       	rjmp	.+0      	; 0x84 <__timerPWMGetDeciHertz+0x84>
	case TIMER_MODE_PWM10_PHASE_CORRECT:
		top=0x3ffU;
  84:	2f ef       	ldi	r18, 0xFF	; 255
  86:	33 e0       	ldi	r19, 0x03	; 3
		goto PhaseCorrect;
  88:	00 c0       	rjmp	.+0      	; 0x8a <__timerPWMGetDeciHertz+0x8a>
	uint16_t top = icr;
	uint32_t cpuDivPrescale = cpu_speed * 10 / prescaler;

	switch(mode){
	case TIMER_MODE_PWM8_PHASE_CORRECT:
		top=0xffU;
  8a:	2f ef       	ldi	r18, 0xFF	; 255
  8c:	30 e0       	ldi	r19, 0x00	; 0
	case TIMER_MODE_PWM_PHASE_FREQ_ICR:
	case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
		PhaseCorrect:
		// freq      = clock / (prescaler * 2 * top);
		deciHertz = cpuDivPrescale;
		deciHertz /= top;
  8e:	40 e0       	ldi	r20, 0x00	; 0
  90:	50 e0       	ldi	r21, 0x00	; 0
  92:	c7 01       	movw	r24, r14
  94:	b6 01       	movw	r22, r12
  96:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  9a:	89 01       	movw	r16, r18
  9c:	9a 01       	movw	r18, r20
		deciHertz /= 2;
  9e:	36 95       	lsr	r19
  a0:	27 95       	ror	r18
  a2:	17 95       	ror	r17
  a4:	07 95       	ror	r16
		break;
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <__timerPWMGetDeciHertz+0xa8>

	case TIMER_MODE_PWM8_FAST:
		top=0xffU;
		goto Fast;
	case TIMER_MODE_PWM9_FAST:
		top=0x1ffU;
  a8:	2f ef       	ldi	r18, 0xFF	; 255
  aa:	31 e0       	ldi	r19, 0x01	; 1
		goto Fast;
  ac:	00 c0       	rjmp	.+0      	; 0xae <__timerPWMGetDeciHertz+0xae>
	case TIMER_MODE_PWM10_FAST:
		top=0x3ffU;
  ae:	2f ef       	ldi	r18, 0xFF	; 255
  b0:	33 e0       	ldi	r19, 0x03	; 3
		goto Fast;
  b2:	00 c0       	rjmp	.+0      	; 0xb4 <__timerPWMGetDeciHertz+0xb4>
		deciHertz /= 2;
		break;


	case TIMER_MODE_PWM8_FAST:
		top=0xffU;
  b4:	2f ef       	ldi	r18, 0xFF	; 255
  b6:	30 e0       	ldi	r19, 0x00	; 0
		goto Fast;
	case TIMER_MODE_PWM_FAST_ICR:
		Fast:
		// freq = clock / ( prescaler * (1+top) );
		deciHertz = cpuDivPrescale;
		deciHertz /= (((uint32_t)(top))+1UL);
  b8:	40 e0       	ldi	r20, 0x00	; 0
  ba:	50 e0       	ldi	r21, 0x00	; 0
  bc:	2f 5f       	subi	r18, 0xFF	; 255
  be:	3f 4f       	sbci	r19, 0xFF	; 255
  c0:	4f 4f       	sbci	r20, 0xFF	; 255
  c2:	5f 4f       	sbci	r21, 0xFF	; 255
  c4:	c7 01       	movw	r24, r14
  c6:	b6 01       	movw	r22, r12
  c8:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
  cc:	89 01       	movw	r16, r18
  ce:	9a 01       	movw	r18, r20
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <__timerPWMGetDeciHertz+0xd2>

// Calc the frequency of a PWM given various settings
// Note that no checks are performed as to whether timers are 16 bit or not
// Return the value in 10'ths of a hertz ie deciHertz
static uint32_t __timerPWMGetDeciHertz(TIMER_MODE mode,uint16_t prescaler,uint16_t icr){
	uint32_t deciHertz=0;
  d2:	00 e0       	ldi	r16, 0x00	; 0
  d4:	10 e0       	ldi	r17, 0x00	; 0
  d6:	20 e0       	ldi	r18, 0x00	; 0
  d8:	30 e0       	ldi	r19, 0x00	; 0
	default:
		break;

	}
	return deciHertz;
}
  da:	b8 01       	movw	r22, r16
  dc:	c9 01       	movw	r24, r18
  de:	df 91       	pop	r29
  e0:	cf 91       	pop	r28
  e2:	1f 91       	pop	r17
  e4:	0f 91       	pop	r16
  e6:	ff 90       	pop	r15
  e8:	ef 90       	pop	r14
  ea:	df 90       	pop	r13
  ec:	cf 90       	pop	r12
  ee:	08 95       	ret

000000f0 <TimerGetPwmDeciHertz>:

uint32_t TimerGetPwmDeciHertz(const Timer* timer){
  f0:	0f 93       	push	r16
  f2:	1f 93       	push	r17
  f4:	9c 01       	movw	r18, r24
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
  f6:	fc 01       	movw	r30, r24
  f8:	34 96       	adiw	r30, 0x04	; 4
  fa:	85 91       	lpm	r24, Z+
  fc:	94 91       	lpm	r25, Z
  fe:	fc 01       	movw	r30, r24
 100:	80 81       	ld	r24, Z
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	87 70       	andi	r24, 0x07	; 7
 106:	90 70       	andi	r25, 0x00	; 0
 108:	00 97       	sbiw	r24, 0x00	; 0
 10a:	01 f0       	breq	.+0      	; 0x10c <TimerGetPwmDeciHertz+0x1c>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 10c:	f9 01       	movw	r30, r18
 10e:	a5 91       	lpm	r26, Z+
 110:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
 112:	1a 96       	adiw	r26, 0x0a	; 10
 114:	8c 91       	ld	r24, X
 116:	1a 97       	sbiw	r26, 0x0a	; 10
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
 118:	6d 91       	ld	r22, X+
 11a:	7c 91       	ld	r23, X
 11c:	11 97       	sbiw	r26, 0x01	; 1
	uint32_t rtn = 0;
	if(timerIsInUse(timer)){
		TIMER_MODE mode = timerGetMode(timer);
		uint16_t prescale = timerGetPrescaler(timer);
		uint16_t icr;
		if(modeIsICR(mode)){
 11e:	41 e0       	ldi	r20, 0x01	; 1
 120:	50 e0       	ldi	r21, 0x00	; 0
 122:	08 2e       	mov	r0, r24
 124:	00 c0       	rjmp	.+0      	; 0x126 <TimerGetPwmDeciHertz+0x36>
 126:	44 0f       	add	r20, r20
 128:	55 1f       	adc	r21, r21
 12a:	0a 94       	dec	r0
 12c:	02 f4       	brpl	.+0      	; 0x12e <TimerGetPwmDeciHertz+0x3e>
 12e:	40 70       	andi	r20, 0x00	; 0
 130:	55 75       	andi	r21, 0x55	; 85
 132:	41 15       	cp	r20, r1
 134:	51 05       	cpc	r21, r1
 136:	01 f0       	breq	.+0      	; 0x138 <TimerGetPwmDeciHertz+0x48>
			PORT icrPort = pgm_read_word(&timer->pgm_icr);
 138:	21 5e       	subi	r18, 0xE1	; 225
 13a:	3f 4f       	sbci	r19, 0xFF	; 255
 13c:	f9 01       	movw	r30, r18
 13e:	45 91       	lpm	r20, Z+
 140:	54 91       	lpm	r21, Z
			icr = _SFR_MEM16(icrPort);
 142:	fa 01       	movw	r30, r20
 144:	40 81       	ld	r20, Z
 146:	51 81       	ldd	r21, Z+1	; 0x01
 148:	00 c0       	rjmp	.+0      	; 0x14a <TimerGetPwmDeciHertz+0x5a>
		}else{
			icr = 0;
 14a:	40 e0       	ldi	r20, 0x00	; 0
 14c:	50 e0       	ldi	r21, 0x00	; 0
		}
		rtn =  __timerPWMGetDeciHertz(mode,prescale,icr);
 14e:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 152:	8b 01       	movw	r16, r22
 154:	9c 01       	movw	r18, r24
 156:	00 c0       	rjmp	.+0      	; 0x158 <TimerGetPwmDeciHertz+0x68>
	}
	return deciHertz;
}

uint32_t TimerGetPwmDeciHertz(const Timer* timer){
	uint32_t rtn = 0;
 158:	00 e0       	ldi	r16, 0x00	; 0
 15a:	10 e0       	ldi	r17, 0x00	; 0
 15c:	20 e0       	ldi	r18, 0x00	; 0
 15e:	30 e0       	ldi	r19, 0x00	; 0
			icr = 0;
		}
		rtn =  __timerPWMGetDeciHertz(mode,prescale,icr);
	}
	return rtn;
}
 160:	b8 01       	movw	r22, r16
 162:	c9 01       	movw	r24, r18
 164:	1f 91       	pop	r17
 166:	0f 91       	pop	r16
 168:	08 95       	ret

0000016a <timerCalcPwm>:

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
 16a:	2f 92       	push	r2
 16c:	3f 92       	push	r3
 16e:	4f 92       	push	r4
 170:	5f 92       	push	r5
 172:	6f 92       	push	r6
 174:	7f 92       	push	r7
 176:	8f 92       	push	r8
 178:	9f 92       	push	r9
 17a:	af 92       	push	r10
 17c:	bf 92       	push	r11
 17e:	cf 92       	push	r12
 180:	df 92       	push	r13
 182:	ef 92       	push	r14
 184:	ff 92       	push	r15
 186:	0f 93       	push	r16
 188:	1f 93       	push	r17
 18a:	cf 93       	push	r28
 18c:	df 93       	push	r29
 18e:	cd b7       	in	r28, 0x3d	; 61
 190:	de b7       	in	r29, 0x3e	; 62
 192:	a0 97       	sbiw	r28, 0x20	; 32
 194:	0f b6       	in	r0, 0x3f	; 63
 196:	f8 94       	cli
 198:	de bf       	out	0x3e, r29	; 62
 19a:	0f be       	out	0x3f, r0	; 63
 19c:	cd bf       	out	0x3d, r28	; 61
 19e:	9a 83       	std	Y+2, r25	; 0x02
 1a0:	89 83       	std	Y+1, r24	; 0x01
 1a2:	2a 01       	movw	r4, r20
 1a4:	3b 01       	movw	r6, r22
 1a6:	3a 8b       	std	Y+18, r19	; 0x12
 1a8:	29 8b       	std	Y+17, r18	; 0x11
 1aa:	1c 8b       	std	Y+20, r17	; 0x14
 1ac:	0b 8b       	std	Y+19, r16	; 0x13
 1ae:	fe 8a       	std	Y+22, r15	; 0x16
 1b0:	ed 8a       	std	Y+21, r14	; 0x15
 1b2:	d8 8e       	std	Y+24, r13	; 0x18
 1b4:	cf 8a       	std	Y+23, r12	; 0x17
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 1b6:	fc 01       	movw	r30, r24
 1b8:	34 96       	adiw	r30, 0x04	; 4
 1ba:	85 91       	lpm	r24, Z+
 1bc:	94 91       	lpm	r25, Z
 1be:	fc 01       	movw	r30, r24
 1c0:	80 81       	ld	r24, Z
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	87 70       	andi	r24, 0x07	; 7
 1c6:	90 70       	andi	r25, 0x00	; 0
 1c8:	00 97       	sbiw	r24, 0x00	; 0
 1ca:	01 f0       	breq	.+0      	; 0x1cc <timerCalcPwm+0x62>
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 1cc:	e9 81       	ldd	r30, Y+1	; 0x01
 1ce:	fa 81       	ldd	r31, Y+2	; 0x02
 1d0:	a5 91       	lpm	r26, Z+
 1d2:	b4 91       	lpm	r27, Z
------------------------------------------------------- */
void timerSetMode(const Timer* timer, TIMER_MODE mode);

//TIMER_MODE timerGetMode(const Timer*timer);
static __inline__ TIMER_MODE timerGetMode(const Timer* timer){
	return timerGetData(timer)->mode;
 1d4:	1a 96       	adiw	r26, 0x0a	; 10
 1d6:	2c 91       	ld	r18, X
 1d8:	1a 97       	sbiw	r26, 0x0a	; 10
 1da:	2b 83       	std	Y+3, r18	; 0x03
	TIMER_MODE max = MAX_MODES-1;
	boolean rtn = FALSE;	// Default return is that it cannot be set

	// Only try the current setting if the timer is in use
	if(timerIsInUse(timer)){
		min = max = timerGetMode(timer);
 1dc:	02 2f       	mov	r16, r18
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <timerCalcPwm+0x76>
	return rtn;
}

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
	TIMER_MODE min = 0;
	TIMER_MODE max = MAX_MODES-1;
 1e0:	3f e0       	ldi	r19, 0x0F	; 15
 1e2:	3b 83       	std	Y+3, r19	; 0x03
	}
	return rtn;
}

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
	TIMER_MODE min = 0;
 1e4:	00 e0       	ldi	r16, 0x00	; 0
	// Only try the current setting if the timer is in use
	if(timerIsInUse(timer)){
		min = max = timerGetMode(timer);
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);
 1e6:	80 91 00 00 	lds	r24, 0x0000
 1ea:	90 91 00 00 	lds	r25, 0x0000
 1ee:	a0 91 00 00 	lds	r26, 0x0000
 1f2:	b0 91 00 00 	lds	r27, 0x0000
 1f6:	8d 87       	std	Y+13, r24	; 0x0d
 1f8:	9e 87       	std	Y+14, r25	; 0x0e
 1fa:	af 87       	std	Y+15, r26	; 0x0f
 1fc:	b8 8b       	std	Y+16, r27	; 0x10
 1fe:	bc 01       	movw	r22, r24
 200:	cd 01       	movw	r24, r26
 202:	96 95       	lsr	r25
 204:	87 95       	ror	r24
 206:	77 95       	ror	r23
 208:	67 95       	ror	r22
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
 20a:	2a e0       	ldi	r18, 0x0A	; 10
 20c:	30 e0       	ldi	r19, 0x00	; 0
 20e:	40 e0       	ldi	r20, 0x00	; 0
 210:	50 e0       	ldi	r21, 0x00	; 0
 212:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 216:	96 2e       	mov	r9, r22
 218:	87 2e       	mov	r8, r23
 21a:	38 2e       	mov	r3, r24
 21c:	29 2e       	mov	r2, r25
	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;
 21e:	1c 86       	std	Y+12, r1	; 0x0c
 220:	1b 86       	std	Y+11, r1	; 0x0b

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
 222:	1a 86       	std	Y+10, r1	; 0x0a
 224:	19 86       	std	Y+9, r1	; 0x09
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
 226:	18 86       	std	Y+8, r1	; 0x08
		min = max = timerGetMode(timer);
	}

	uint32_t clockDiv2 = (cpu_speed >> 1);

	uint32_t bestError=0;
 228:	1c 82       	std	Y+4, r1	; 0x04
 22a:	1d 82       	std	Y+5, r1	; 0x05
 22c:	1e 82       	std	Y+6, r1	; 0x06
 22e:	1f 82       	std	Y+7, r1	; 0x07
}

boolean timerCalcPwm(const Timer* timer, uint32_t deciHertz, uint16_t steps, TIMER_MODE *modeRtn, uint16_t* icrRtn, uint16_t* prescaleRtn){
	TIMER_MODE min = 0;
	TIMER_MODE max = MAX_MODES-1;
	boolean rtn = FALSE;	// Default return is that it cannot be set
 230:	30 e0       	ldi	r19, 0x00	; 0
//
//	return TRUE if it does, FALSE if not
//
------------------------------------------------------- */
static __inline__ boolean timerIsModeSupported(const Timer* timer, TIMER_MODE mode){
	return (pgm_read_word(&timer->pgm_modes) & BV(mode)) ? TRUE : FALSE;
 232:	e9 81       	ldd	r30, Y+1	; 0x01
 234:	fa 81       	ldd	r31, Y+2	; 0x02
 236:	39 96       	adiw	r30, 0x09	; 9
 238:	a5 91       	lpm	r26, Z+
 23a:	b4 91       	lpm	r27, Z
 23c:	be 8f       	std	Y+30, r27	; 0x1e
 23e:	ad 8f       	std	Y+29, r26	; 0x1d
						default:
							break;
						}

					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
					icr = CLAMP(tempTop, steps, 0xffffu);
 240:	a9 89       	ldd	r26, Y+17	; 0x11
 242:	ba 89       	ldd	r27, Y+18	; 0x12
 244:	cd 01       	movw	r24, r26
 246:	a0 e0       	ldi	r26, 0x00	; 0
 248:	b0 e0       	ldi	r27, 0x00	; 0
 24a:	89 8f       	std	Y+25, r24	; 0x19
 24c:	9a 8f       	std	Y+26, r25	; 0x1a
 24e:	ab 8f       	std	Y+27, r26	; 0x1b
 250:	bc 8f       	std	Y+28, r27	; 0x1c
 252:	38 a3       	std	Y+32, r19	; 0x20
 254:	0f 8f       	std	Y+31, r16	; 0x1f
	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;

	for(TIMER_MODE mode = min ; mode <= max; mode++){
 256:	00 c0       	rjmp	.+0      	; 0x258 <timerCalcPwm+0xee>
		// Try the next mode
		if(modeIsPWM(mode) && timerIsModeSupported(timer,mode)){
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	90 e0       	ldi	r25, 0x00	; 0
 25c:	0f 8c       	ldd	r0, Y+31	; 0x1f
 25e:	00 c0       	rjmp	.+0      	; 0x260 <timerCalcPwm+0xf6>
 260:	88 0f       	add	r24, r24
 262:	99 1f       	adc	r25, r25
 264:	0a 94       	dec	r0
 266:	02 f4       	brpl	.+0      	; 0x268 <timerCalcPwm+0xfe>
 268:	9c 01       	movw	r18, r24
 26a:	2e 7e       	andi	r18, 0xEE	; 238
 26c:	3f 7c       	andi	r19, 0xCF	; 207
 26e:	21 15       	cp	r18, r1
 270:	31 05       	cpc	r19, r1
 272:	01 f4       	brne	.+0      	; 0x274 <timerCalcPwm+0x10a>
 274:	00 c0       	rjmp	.+0      	; 0x276 <timerCalcPwm+0x10c>
 276:	ed 8d       	ldd	r30, Y+29	; 0x1d
 278:	fe 8d       	ldd	r31, Y+30	; 0x1e
 27a:	8e 23       	and	r24, r30
 27c:	9f 23       	and	r25, r31
 27e:	00 97       	sbiw	r24, 0x00	; 0
 280:	01 f4       	brne	.+0      	; 0x282 <timerCalcPwm+0x118>
 282:	00 c0       	rjmp	.+0      	; 0x284 <timerCalcPwm+0x11a>
			// The timer supports this mode
			uint16_t top;
			uint32_t exactPrescaler;
			boolean usable=FALSE;

			switch(mode){
 284:	ff 8d       	ldd	r31, Y+31	; 0x1f
 286:	f6 30       	cpi	r31, 0x06	; 6
 288:	01 f4       	brne	.+0      	; 0x28a <timerCalcPwm+0x120>
 28a:	00 c0       	rjmp	.+0      	; 0x28c <timerCalcPwm+0x122>
 28c:	f7 30       	cpi	r31, 0x07	; 7
 28e:	00 f4       	brcc	.+0      	; 0x290 <timerCalcPwm+0x126>
 290:	f2 30       	cpi	r31, 0x02	; 2
 292:	01 f0       	breq	.+0      	; 0x294 <timerCalcPwm+0x12a>
 294:	f3 30       	cpi	r31, 0x03	; 3
 296:	00 f4       	brcc	.+0      	; 0x298 <timerCalcPwm+0x12e>
 298:	f1 30       	cpi	r31, 0x01	; 1
 29a:	01 f0       	breq	.+0      	; 0x29c <timerCalcPwm+0x132>
 29c:	00 c0       	rjmp	.+0      	; 0x29e <timerCalcPwm+0x134>
 29e:	00 c0       	rjmp	.+0      	; 0x2a0 <timerCalcPwm+0x136>
 2a0:	2f 8d       	ldd	r18, Y+31	; 0x1f
 2a2:	23 30       	cpi	r18, 0x03	; 3
 2a4:	01 f0       	breq	.+0      	; 0x2a6 <timerCalcPwm+0x13c>
 2a6:	25 30       	cpi	r18, 0x05	; 5
 2a8:	01 f0       	breq	.+0      	; 0x2aa <timerCalcPwm+0x140>
 2aa:	00 c0       	rjmp	.+0      	; 0x2ac <timerCalcPwm+0x142>
 2ac:	00 c0       	rjmp	.+0      	; 0x2ae <timerCalcPwm+0x144>
 2ae:	3f 8d       	ldd	r19, Y+31	; 0x1f
 2b0:	38 30       	cpi	r19, 0x08	; 8
 2b2:	01 f0       	breq	.+0      	; 0x2b4 <timerCalcPwm+0x14a>
 2b4:	38 30       	cpi	r19, 0x08	; 8
 2b6:	00 f0       	brcs	.+0      	; 0x2b8 <timerCalcPwm+0x14e>
 2b8:	3a 30       	cpi	r19, 0x0A	; 10
 2ba:	01 f0       	breq	.+0      	; 0x2bc <timerCalcPwm+0x152>
 2bc:	3e 30       	cpi	r19, 0x0E	; 14
 2be:	01 f0       	breq	.+0      	; 0x2c0 <timerCalcPwm+0x156>
 2c0:	00 c0       	rjmp	.+0      	; 0x2c2 <timerCalcPwm+0x158>
 2c2:	00 c0       	rjmp	.+0      	; 0x2c4 <timerCalcPwm+0x15a>
				}
				exactPrescaler /= top;
				goto Usable;

			case TIMER_MODE_PWM8_FAST:
				top=0xffU;
 2c4:	0f ef       	ldi	r16, 0xFF	; 255
 2c6:	10 e0       	ldi	r17, 0x00	; 0
 2c8:	00 c0       	rjmp	.+0      	; 0x2ca <timerCalcPwm+0x160>
			uint32_t exactPrescaler;
			boolean usable=FALSE;

			switch(mode){
			case TIMER_MODE_PWM8_PHASE_CORRECT:
				top=0xffU;
 2ca:	0f ef       	ldi	r16, 0xFF	; 255
 2cc:	10 e0       	ldi	r17, 0x00	; 0
 2ce:	00 c0       	rjmp	.+0      	; 0x2d0 <timerCalcPwm+0x166>
				goto PhaseCorrect;
			case TIMER_MODE_PWM9_PHASE_CORRECT:
				top=0x1ffU;
				goto PhaseCorrect;
			case TIMER_MODE_PWM10_PHASE_CORRECT:
				top=0x3ffU;
 2d0:	0f ef       	ldi	r16, 0xFF	; 255
 2d2:	13 e0       	ldi	r17, 0x03	; 3
				goto PhaseCorrect;
 2d4:	00 c0       	rjmp	.+0      	; 0x2d6 <timerCalcPwm+0x16c>
			case TIMER_MODE_PWM_PHASE_FREQ_ICR:
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
 2d6:	0f ef       	ldi	r16, 0xFF	; 255
 2d8:	1f ef       	ldi	r17, 0xFF	; 255
 2da:	00 c0       	rjmp	.+0      	; 0x2dc <timerCalcPwm+0x172>
			switch(mode){
			case TIMER_MODE_PWM8_PHASE_CORRECT:
				top=0xffU;
				goto PhaseCorrect;
			case TIMER_MODE_PWM9_PHASE_CORRECT:
				top=0x1ffU;
 2dc:	0f ef       	ldi	r16, 0xFF	; 255
 2de:	11 e0       	ldi	r17, 0x01	; 1
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
				if(deciHertz){
 2e0:	41 14       	cp	r4, r1
 2e2:	51 04       	cpc	r5, r1
 2e4:	61 04       	cpc	r6, r1
 2e6:	71 04       	cpc	r7, r1
 2e8:	01 f0       	breq	.+0      	; 0x2ea <timerCalcPwm+0x180>
					exactPrescaler /= deciHertz;
 2ea:	69 2d       	mov	r22, r9
 2ec:	78 2d       	mov	r23, r8
 2ee:	83 2d       	mov	r24, r3
 2f0:	92 2d       	mov	r25, r2
 2f2:	a3 01       	movw	r20, r6
 2f4:	92 01       	movw	r18, r4
 2f6:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 2fa:	b2 2f       	mov	r27, r18
 2fc:	a3 2f       	mov	r26, r19
 2fe:	f4 2f       	mov	r31, r20
 300:	e5 2f       	mov	r30, r21
 302:	00 c0       	rjmp	.+0      	; 0x304 <timerCalcPwm+0x19a>
			case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
				// freq      = clock / (prescaler * 2 * top);
				// prescaler = clock / (frequency * 2 * top);
				top = 0xffffU;
				PhaseCorrect:
				exactPrescaler = clockDiv2 * 10;
 304:	d4 01       	movw	r26, r8
 306:	f1 01       	movw	r30, r2
				if(deciHertz){
					exactPrescaler /= deciHertz;
				}
				exactPrescaler /= top;
 308:	98 01       	movw	r18, r16
 30a:	40 e0       	ldi	r20, 0x00	; 0
 30c:	50 e0       	ldi	r21, 0x00	; 0
 30e:	6b 2f       	mov	r22, r27
 310:	7a 2f       	mov	r23, r26
 312:	8f 2f       	mov	r24, r31
 314:	9e 2f       	mov	r25, r30
 316:	00 c0       	rjmp	.+0      	; 0x318 <timerCalcPwm+0x1ae>
				goto Fast;
			case TIMER_MODE_PWM9_FAST:
				top=0x1ffU;
				goto Fast;
			case TIMER_MODE_PWM10_FAST:
				top=0x3ffU;
 318:	0f ef       	ldi	r16, 0xFF	; 255
 31a:	13 e0       	ldi	r17, 0x03	; 3
				goto Fast;
 31c:	00 c0       	rjmp	.+0      	; 0x31e <timerCalcPwm+0x1b4>
			case TIMER_MODE_PWM_FAST_ICR:
				top = 0xffffU;
 31e:	0f ef       	ldi	r16, 0xFF	; 255
 320:	1f ef       	ldi	r17, 0xFF	; 255
 322:	00 c0       	rjmp	.+0      	; 0x324 <timerCalcPwm+0x1ba>

			case TIMER_MODE_PWM8_FAST:
				top=0xffU;
				goto Fast;
			case TIMER_MODE_PWM9_FAST:
				top=0x1ffU;
 324:	0f ef       	ldi	r16, 0xFF	; 255
 326:	11 e0       	ldi	r17, 0x01	; 1
			case TIMER_MODE_PWM_FAST_ICR:
				top = 0xffffU;
				Fast:
				// freq      = clock / ( prescaler * (1+top) );
				// prescaler = clock / ( freq * (1+top) )
				exactPrescaler = cpu_speed * 10; // convert deciHertz to Hertz
 328:	6d 85       	ldd	r22, Y+13	; 0x0d
 32a:	7e 85       	ldd	r23, Y+14	; 0x0e
 32c:	8f 85       	ldd	r24, Y+15	; 0x0f
 32e:	98 89       	ldd	r25, Y+16	; 0x10
 330:	2a e0       	ldi	r18, 0x0A	; 10
 332:	30 e0       	ldi	r19, 0x00	; 0
 334:	40 e0       	ldi	r20, 0x00	; 0
 336:	50 e0       	ldi	r21, 0x00	; 0
 338:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 33c:	6b 01       	movw	r12, r22
 33e:	7c 01       	movw	r14, r24
				// avoid div by 0
				if(deciHertz){
 340:	41 14       	cp	r4, r1
 342:	51 04       	cpc	r5, r1
 344:	61 04       	cpc	r6, r1
 346:	71 04       	cpc	r7, r1
 348:	01 f0       	breq	.+0      	; 0x34a <timerCalcPwm+0x1e0>
					exactPrescaler /= deciHertz;
 34a:	a3 01       	movw	r20, r6
 34c:	92 01       	movw	r18, r4
 34e:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 352:	69 01       	movw	r12, r18
 354:	7a 01       	movw	r14, r20
				}
				exactPrescaler /= ( ((uint32_t)(top)) + 1UL );
 356:	98 01       	movw	r18, r16
 358:	40 e0       	ldi	r20, 0x00	; 0
 35a:	50 e0       	ldi	r21, 0x00	; 0
 35c:	2f 5f       	subi	r18, 0xFF	; 255
 35e:	3f 4f       	sbci	r19, 0xFF	; 255
 360:	4f 4f       	sbci	r20, 0xFF	; 255
 362:	5f 4f       	sbci	r21, 0xFF	; 255
 364:	c7 01       	movw	r24, r14
 366:	b6 01       	movw	r22, r12
 368:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
				break;
			}

			if(usable){
				// Make sure the prescaler is in valid bounds - even tho value may not be available
				uint16_t prescaler = CLAMP(exactPrescaler, 1, MAX_PRESCALE);
 36c:	22 30       	cpi	r18, 0x02	; 2
 36e:	31 05       	cpc	r19, r1
 370:	41 05       	cpc	r20, r1
 372:	51 05       	cpc	r21, r1
 374:	00 f0       	brcs	.+0      	; 0x376 <timerCalcPwm+0x20c>
 376:	da 01       	movw	r26, r20
 378:	c9 01       	movw	r24, r18
 37a:	81 30       	cpi	r24, 0x01	; 1
 37c:	44 e0       	ldi	r20, 0x04	; 4
 37e:	94 07       	cpc	r25, r20
 380:	40 e0       	ldi	r20, 0x00	; 0
 382:	a4 07       	cpc	r26, r20
 384:	40 e0       	ldi	r20, 0x00	; 0
 386:	b4 07       	cpc	r27, r20
 388:	00 f0       	brcs	.+0      	; 0x38a <timerCalcPwm+0x220>
 38a:	80 e0       	ldi	r24, 0x00	; 0
 38c:	94 e0       	ldi	r25, 0x04	; 4
 38e:	a0 e0       	ldi	r26, 0x00	; 0
 390:	b0 e0       	ldi	r27, 0x00	; 0
 392:	bc 01       	movw	r22, r24
 394:	00 c0       	rjmp	.+0      	; 0x396 <timerCalcPwm+0x22c>
 396:	61 e0       	ldi	r22, 0x01	; 1
 398:	70 e0       	ldi	r23, 0x00	; 0
				uint16_t icr = 0;
				uint32_t tempTop=0;

				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);
 39a:	89 81       	ldd	r24, Y+1	; 0x01
 39c:	9a 81       	ldd	r25, Y+2	; 0x02
 39e:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>

				if(deciHertz==PWM_SLOWEST){
 3a2:	41 14       	cp	r4, r1
 3a4:	51 04       	cpc	r5, r1
 3a6:	61 04       	cpc	r6, r1
 3a8:	71 04       	cpc	r7, r1
 3aa:	01 f4       	brne	.+0      	; 0x3ac <timerCalcPwm+0x242>
 3ac:	00 c0       	rjmp	.+0      	; 0x3ae <timerCalcPwm+0x244>
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
 3ae:	5f ef       	ldi	r21, 0xFF	; 255
 3b0:	45 16       	cp	r4, r21
 3b2:	5f ef       	ldi	r21, 0xFF	; 255
 3b4:	55 06       	cpc	r5, r21
 3b6:	5f ef       	ldi	r21, 0xFF	; 255
 3b8:	65 06       	cpc	r6, r21
 3ba:	5f ef       	ldi	r21, 0xFF	; 255
 3bc:	75 06       	cpc	r7, r21
 3be:	01 f4       	brne	.+0      	; 0x3c0 <timerCalcPwm+0x256>
 3c0:	00 c0       	rjmp	.+0      	; 0x3c2 <timerCalcPwm+0x258>
					prescaler = 1;
					icr = steps;		// At least the required number of steps
				}else{
					// Work out the value for top
					prescaler--;
 3c2:	5c 01       	movw	r10, r24
 3c4:	08 94       	sec
 3c6:	a1 08       	sbc	r10, r1
 3c8:	b1 08       	sbc	r11, r1

			if(usable){
				// Make sure the prescaler is in valid bounds - even tho value may not be available
				uint16_t prescaler = CLAMP(exactPrescaler, 1, MAX_PRESCALE);
				uint16_t icr = 0;
				uint32_t tempTop=0;
 3ca:	cc 24       	eor	r12, r12
 3cc:	dd 24       	eor	r13, r13
 3ce:	76 01       	movw	r14, r12
 3d0:	18 a1       	ldd	r17, Y+32	; 0x20
 3d2:	0f 8d       	ldd	r16, Y+31	; 0x1f
					icr = steps;		// At least the required number of steps
				}else{
					// Work out the value for top
					prescaler--;
					do{
						prescaler = timerGetClosestPrescale(timer, ++prescaler);
 3d4:	b5 01       	movw	r22, r10
 3d6:	6f 5f       	subi	r22, 0xFF	; 255
 3d8:	7f 4f       	sbci	r23, 0xFF	; 255
 3da:	89 81       	ldd	r24, Y+1	; 0x01
 3dc:	9a 81       	ldd	r25, Y+2	; 0x02
 3de:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 3e2:	5c 01       	movw	r10, r24

						// Find value for TOP
						switch(mode){
 3e4:	0a 30       	cpi	r16, 0x0A	; 10
 3e6:	01 f0       	breq	.+0      	; 0x3e8 <timerCalcPwm+0x27e>
 3e8:	0e 30       	cpi	r16, 0x0E	; 14
 3ea:	01 f0       	breq	.+0      	; 0x3ec <timerCalcPwm+0x282>
 3ec:	08 30       	cpi	r16, 0x08	; 8
 3ee:	01 f4       	brne	.+0      	; 0x3f0 <timerCalcPwm+0x286>
						case TIMER_MODE_PWM_PHASE_FREQ_ICR:
						case TIMER_MODE_PWM_PHASE_CORRECT_ICR:
							// freq = clock / (prescaler * 2 * top);
							// top  = clock / (prescaler * 2 * freq);
							tempTop = clockDiv2 * 10;
							tempTop /= deciHertz;
 3f0:	69 2d       	mov	r22, r9
 3f2:	78 2d       	mov	r23, r8
 3f4:	83 2d       	mov	r24, r3
 3f6:	92 2d       	mov	r25, r2
 3f8:	a3 01       	movw	r20, r6
 3fa:	92 01       	movw	r18, r4
 3fc:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 400:	69 01       	movw	r12, r18
 402:	7a 01       	movw	r14, r20
							tempTop /= prescaler;
 404:	95 01       	movw	r18, r10
 406:	40 e0       	ldi	r20, 0x00	; 0
 408:	50 e0       	ldi	r21, 0x00	; 0
 40a:	c7 01       	movw	r24, r14
 40c:	b6 01       	movw	r22, r12
 40e:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 412:	69 01       	movw	r12, r18
 414:	7a 01       	movw	r14, r20
							break;
 416:	00 c0       	rjmp	.+0      	; 0x418 <timerCalcPwm+0x2ae>
						case TIMER_MODE_PWM_FAST_ICR:
							// freq = clock / ( prescaler * (1+top) );
							// top  = (clock / ( prescaler * freq)) - 1
							tempTop = cpu_speed * 10;
 418:	6d 85       	ldd	r22, Y+13	; 0x0d
 41a:	7e 85       	ldd	r23, Y+14	; 0x0e
 41c:	8f 85       	ldd	r24, Y+15	; 0x0f
 41e:	98 89       	ldd	r25, Y+16	; 0x10
 420:	2a e0       	ldi	r18, 0x0A	; 10
 422:	30 e0       	ldi	r19, 0x00	; 0
 424:	40 e0       	ldi	r20, 0x00	; 0
 426:	50 e0       	ldi	r21, 0x00	; 0
 428:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
							tempTop /= deciHertz;
 42c:	a3 01       	movw	r20, r6
 42e:	92 01       	movw	r18, r4
 430:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 434:	69 01       	movw	r12, r18
 436:	7a 01       	movw	r14, r20
							tempTop /= prescaler;
 438:	95 01       	movw	r18, r10
 43a:	40 e0       	ldi	r20, 0x00	; 0
 43c:	50 e0       	ldi	r21, 0x00	; 0
 43e:	c7 01       	movw	r24, r14
 440:	b6 01       	movw	r22, r12
 442:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 446:	69 01       	movw	r12, r18
 448:	7a 01       	movw	r14, r20
							tempTop--;
 44a:	08 94       	sec
 44c:	c1 08       	sbc	r12, r1
 44e:	d1 08       	sbc	r13, r1
 450:	e1 08       	sbc	r14, r1
 452:	f1 08       	sbc	r15, r1
							break;
						default:
							break;
						}

					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
 454:	80 e0       	ldi	r24, 0x00	; 0
 456:	a8 16       	cp	r10, r24
 458:	84 e0       	ldi	r24, 0x04	; 4
 45a:	b8 06       	cpc	r11, r24
 45c:	00 f4       	brcc	.+0      	; 0x45e <timerCalcPwm+0x2f4>
 45e:	d7 01       	movw	r26, r14
 460:	c6 01       	movw	r24, r12
 462:	80 70       	andi	r24, 0x00	; 0
 464:	90 70       	andi	r25, 0x00	; 0
 466:	00 97       	sbiw	r24, 0x00	; 0
 468:	a1 05       	cpc	r26, r1
 46a:	b1 05       	cpc	r27, r1
 46c:	01 f0       	breq	.+0      	; 0x46e <timerCalcPwm+0x304>
 46e:	00 c0       	rjmp	.+0      	; 0x470 <timerCalcPwm+0x306>
 470:	18 a3       	std	Y+32, r17	; 0x20
 472:	0f 8f       	std	Y+31, r16	; 0x1f
					icr = CLAMP(tempTop, steps, 0xffffu);
 474:	d7 01       	movw	r26, r14
 476:	c6 01       	movw	r24, r12
 478:	80 30       	cpi	r24, 0x00	; 0
 47a:	e0 e0       	ldi	r30, 0x00	; 0
 47c:	9e 07       	cpc	r25, r30
 47e:	e1 e0       	ldi	r30, 0x01	; 1
 480:	ae 07       	cpc	r26, r30
 482:	e0 e0       	ldi	r30, 0x00	; 0
 484:	be 07       	cpc	r27, r30
 486:	00 f0       	brcs	.+0      	; 0x488 <timerCalcPwm+0x31e>
 488:	8f ef       	ldi	r24, 0xFF	; 255
 48a:	9f ef       	ldi	r25, 0xFF	; 255
 48c:	a0 e0       	ldi	r26, 0x00	; 0
 48e:	b0 e0       	ldi	r27, 0x00	; 0
 490:	29 8d       	ldd	r18, Y+25	; 0x19
 492:	3a 8d       	ldd	r19, Y+26	; 0x1a
 494:	4b 8d       	ldd	r20, Y+27	; 0x1b
 496:	5c 8d       	ldd	r21, Y+28	; 0x1c
 498:	82 17       	cp	r24, r18
 49a:	93 07       	cpc	r25, r19
 49c:	a4 07       	cpc	r26, r20
 49e:	b5 07       	cpc	r27, r21
 4a0:	00 f4       	brcc	.+0      	; 0x4a2 <timerCalcPwm+0x338>
 4a2:	da 01       	movw	r26, r20
 4a4:	c9 01       	movw	r24, r18
 4a6:	8c 01       	movw	r16, r24
 4a8:	00 c0       	rjmp	.+0      	; 0x4aa <timerCalcPwm+0x340>
				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
 4aa:	0f ef       	ldi	r16, 0xFF	; 255
 4ac:	1f ef       	ldi	r17, 0xFF	; 255

				// Make the prescaler a valid value
				prescaler = timerGetClosestPrescale(timer, prescaler);

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
 4ae:	a1 2c       	mov	r10, r1
 4b0:	24 e0       	ldi	r18, 0x04	; 4
 4b2:	b2 2e       	mov	r11, r18
 4b4:	00 c0       	rjmp	.+0      	; 0x4b6 <timerCalcPwm+0x34c>
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
					prescaler = 1;
					icr = steps;		// At least the required number of steps
 4b6:	09 89       	ldd	r16, Y+17	; 0x11
 4b8:	1a 89       	ldd	r17, Y+18	; 0x12

				if(deciHertz==PWM_SLOWEST){
					prescaler = MAX_PRESCALE;
					icr = 0xffffU;
				}else if(deciHertz==PWM_FASTEST){
					prescaler = 1;
 4ba:	91 e0       	ldi	r25, 0x01	; 1
 4bc:	a9 2e       	mov	r10, r25
 4be:	b1 2c       	mov	r11, r1
					}while(prescaler<MAX_PRESCALE && (tempTop &0xffff0000UL)!=0);
					icr = CLAMP(tempTop, steps, 0xffffu);
				}

				// Now calc the frequency it would achieve
				uint32_t actual = __timerPWMGetDeciHertz(mode,prescaler,icr);
 4c0:	8f 8d       	ldd	r24, Y+31	; 0x1f
 4c2:	b5 01       	movw	r22, r10
 4c4:	a8 01       	movw	r20, r16
 4c6:	0e 94 00 00 	call	0	; 0x0 <__timerPWMGetDeciHertz>
 4ca:	dc 01       	movw	r26, r24
 4cc:	cb 01       	movw	r24, r22

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;
 4ce:	48 16       	cp	r4, r24
 4d0:	59 06       	cpc	r5, r25
 4d2:	6a 06       	cpc	r6, r26
 4d4:	7b 06       	cpc	r7, r27
 4d6:	00 f4       	brcc	.+0      	; 0x4d8 <timerCalcPwm+0x36e>
 4d8:	84 19       	sub	r24, r4
 4da:	95 09       	sbc	r25, r5
 4dc:	a6 09       	sbc	r26, r6
 4de:	b7 09       	sbc	r27, r7
 4e0:	00 c0       	rjmp	.+0      	; 0x4e2 <timerCalcPwm+0x378>
 4e2:	a3 01       	movw	r20, r6
 4e4:	92 01       	movw	r18, r4
 4e6:	28 1b       	sub	r18, r24
 4e8:	39 0b       	sbc	r19, r25
 4ea:	4a 0b       	sbc	r20, r26
 4ec:	5b 0b       	sbc	r21, r27
 4ee:	da 01       	movw	r26, r20
 4f0:	c9 01       	movw	r24, r18

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 4f2:	38 a1       	ldd	r19, Y+32	; 0x20
 4f4:	33 23       	and	r19, r19
 4f6:	01 f0       	breq	.+0      	; 0x4f8 <timerCalcPwm+0x38e>
 4f8:	2c 81       	ldd	r18, Y+4	; 0x04
 4fa:	3d 81       	ldd	r19, Y+5	; 0x05
 4fc:	4e 81       	ldd	r20, Y+6	; 0x06
 4fe:	5f 81       	ldd	r21, Y+7	; 0x07
 500:	82 17       	cp	r24, r18
 502:	93 07       	cpc	r25, r19
 504:	a4 07       	cpc	r26, r20
 506:	b5 07       	cpc	r27, r21
 508:	00 f0       	brcs	.+0      	; 0x50a <timerCalcPwm+0x3a0>
 50a:	00 c0       	rjmp	.+0      	; 0x50c <timerCalcPwm+0x3a2>
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
					bestICR = icr;
 50c:	1c 87       	std	Y+12, r17	; 0x0c
 50e:	0b 87       	std	Y+11, r16	; 0x0b
				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
 510:	ba 86       	std	Y+10, r11	; 0x0a
 512:	a9 86       	std	Y+9, r10	; 0x09

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 514:	3f 8d       	ldd	r19, Y+31	; 0x1f
 516:	38 87       	std	Y+8, r19	; 0x08
 518:	8c 83       	std	Y+4, r24	; 0x04
 51a:	9d 83       	std	Y+5, r25	; 0x05
 51c:	ae 83       	std	Y+6, r26	; 0x06
 51e:	bf 83       	std	Y+7, r27	; 0x07
					bestError = error;
					rtn = TRUE;
 520:	4f ef       	ldi	r20, 0xFF	; 255
 522:	48 a3       	std	Y+32, r20	; 0x20
 524:	00 c0       	rjmp	.+0      	; 0x526 <timerCalcPwm+0x3bc>
					bestMode = mode;
					bestPrescaler = prescaler;
					bestICR = icr;
 526:	1c 87       	std	Y+12, r17	; 0x0c
 528:	0b 87       	std	Y+11, r16	; 0x0b
				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
					bestError = error;
					rtn = TRUE;
					bestMode = mode;
					bestPrescaler = prescaler;
 52a:	ba 86       	std	Y+10, r11	; 0x0a
 52c:	a9 86       	std	Y+9, r10	; 0x09

				// Calc the absolute error
				uint32_t error = (actual > deciHertz) ? actual - deciHertz : deciHertz - actual;

				// Keep the one with the least error
				if(rtn==FALSE || error < bestError){
 52e:	5f 8d       	ldd	r21, Y+31	; 0x1f
 530:	58 87       	std	Y+8, r21	; 0x08
 532:	8c 83       	std	Y+4, r24	; 0x04
 534:	9d 83       	std	Y+5, r25	; 0x05
 536:	ae 83       	std	Y+6, r26	; 0x06
 538:	bf 83       	std	Y+7, r27	; 0x07
					bestError = error;
					rtn = TRUE;
 53a:	8f ef       	ldi	r24, 0xFF	; 255
 53c:	88 a3       	std	Y+32, r24	; 0x20
	uint32_t bestError=0;
	TIMER_MODE bestMode=0;
	uint16_t bestPrescaler=0;
	uint16_t bestICR=0;

	for(TIMER_MODE mode = min ; mode <= max; mode++){
 53e:	9f 8d       	ldd	r25, Y+31	; 0x1f
 540:	9f 5f       	subi	r25, 0xFF	; 255
 542:	9f 8f       	std	Y+31, r25	; 0x1f
 544:	af 8d       	ldd	r26, Y+31	; 0x1f
 546:	bb 81       	ldd	r27, Y+3	; 0x03
 548:	ba 17       	cp	r27, r26
 54a:	00 f0       	brcs	.+0      	; 0x54c <timerCalcPwm+0x3e2>
 54c:	00 c0       	rjmp	.+0      	; 0x54e <timerCalcPwm+0x3e4>
 54e:	38 a1       	ldd	r19, Y+32	; 0x20
			} // End if usable
		} // this mode cannot be used
	} // next mode

	// Return values
	if(rtn){
 550:	33 23       	and	r19, r19
 552:	01 f0       	breq	.+0      	; 0x554 <timerCalcPwm+0x3ea>
		if(modeRtn){
 554:	eb 89       	ldd	r30, Y+19	; 0x13
 556:	fc 89       	ldd	r31, Y+20	; 0x14
 558:	30 97       	sbiw	r30, 0x00	; 0
 55a:	01 f0       	breq	.+0      	; 0x55c <timerCalcPwm+0x3f2>
			*modeRtn = bestMode;
 55c:	28 85       	ldd	r18, Y+8	; 0x08
 55e:	20 83       	st	Z, r18
		}
		if(icrRtn){
 560:	4d 89       	ldd	r20, Y+21	; 0x15
 562:	5e 89       	ldd	r21, Y+22	; 0x16
 564:	41 15       	cp	r20, r1
 566:	51 05       	cpc	r21, r1
 568:	01 f0       	breq	.+0      	; 0x56a <timerCalcPwm+0x400>
			*icrRtn = bestICR;
 56a:	eb 85       	ldd	r30, Y+11	; 0x0b
 56c:	fc 85       	ldd	r31, Y+12	; 0x0c
 56e:	da 01       	movw	r26, r20
 570:	11 96       	adiw	r26, 0x01	; 1
 572:	fc 93       	st	X, r31
 574:	ee 93       	st	-X, r30
		}
		if(prescaleRtn){
 576:	4f 89       	ldd	r20, Y+23	; 0x17
 578:	58 8d       	ldd	r21, Y+24	; 0x18
 57a:	41 15       	cp	r20, r1
 57c:	51 05       	cpc	r21, r1
 57e:	01 f0       	breq	.+0      	; 0x580 <timerCalcPwm+0x416>
			*prescaleRtn = bestPrescaler;
 580:	e9 85       	ldd	r30, Y+9	; 0x09
 582:	fa 85       	ldd	r31, Y+10	; 0x0a
 584:	da 01       	movw	r26, r20
 586:	11 96       	adiw	r26, 0x01	; 1
 588:	fc 93       	st	X, r31
 58a:	ee 93       	st	-X, r30
		}
	}

	return rtn;
}
 58c:	83 2f       	mov	r24, r19
 58e:	a0 96       	adiw	r28, 0x20	; 32
 590:	0f b6       	in	r0, 0x3f	; 63
 592:	f8 94       	cli
 594:	de bf       	out	0x3e, r29	; 62
 596:	0f be       	out	0x3f, r0	; 63
 598:	cd bf       	out	0x3d, r28	; 61
 59a:	df 91       	pop	r29
 59c:	cf 91       	pop	r28
 59e:	1f 91       	pop	r17
 5a0:	0f 91       	pop	r16
 5a2:	ff 90       	pop	r15
 5a4:	ef 90       	pop	r14
 5a6:	df 90       	pop	r13
 5a8:	cf 90       	pop	r12
 5aa:	bf 90       	pop	r11
 5ac:	af 90       	pop	r10
 5ae:	9f 90       	pop	r9
 5b0:	8f 90       	pop	r8
 5b2:	7f 90       	pop	r7
 5b4:	6f 90       	pop	r6
 5b6:	5f 90       	pop	r5
 5b8:	4f 90       	pop	r4
 5ba:	3f 90       	pop	r3
 5bc:	2f 90       	pop	r2
 5be:	08 95       	ret

uart.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000222  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000256  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000256  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  00000256  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000007d0  00000000  00000000  00000262  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 00000239  00000000  00000000  00000a32  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    000003da  00000000  00000000  00000c6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00001045  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_line   00000129  00000000  00000000  00001065  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_str    00000376  00000000  00000000  0000118e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000000d0  00000000  00000000  00001504  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__uartHWSetBaudRate>:


// Sets the uart baud rate.
// Argument should be in bits-per-second, like uartSetBaudRate(9600);
// or may be BAUD_RATE_MAX to use the highest possible(if inaccurate) baud rate
void __uartHWSetBaudRate(UART* uart, BAUD_RATE baudrate){
   0:	bf 92       	push	r11
   2:	cf 92       	push	r12
   4:	df 92       	push	r13
   6:	ef 92       	push	r14
   8:	ff 92       	push	r15
   a:	0f 93       	push	r16
   c:	1f 93       	push	r17
   e:	cf 93       	push	r28
  10:	df 93       	push	r29
  12:	8c 01       	movw	r16, r24
  14:	6a 01       	movw	r12, r20
  16:	7b 01       	movw	r14, r22
	HW_UART* hwUart = (HW_UART*)uart;
	CRITICAL_SECTION_START;
  18:	bf b6       	in	r11, 0x3f	; 63
  1a:	f8 94       	cli
	// calculate division factor for requested baud rate, and set it
	uint16_t bauddiv = (baudrate==BAUD_RATE_MAX) ? 1 : ((cpu_speed + (baudrate*8L))/(baudrate*16L)-1);
  1c:	4f 3f       	cpi	r20, 0xFF	; 255
  1e:	8f ef       	ldi	r24, 0xFF	; 255
  20:	58 07       	cpc	r21, r24
  22:	8f ef       	ldi	r24, 0xFF	; 255
  24:	68 07       	cpc	r22, r24
  26:	8f ef       	ldi	r24, 0xFF	; 255
  28:	78 07       	cpc	r23, r24
  2a:	01 f0       	breq	.+0      	; 0x2c <__uartHWSetBaudRate+0x2c>
  2c:	db 01       	movw	r26, r22
  2e:	ca 01       	movw	r24, r20
  30:	f3 e0       	ldi	r31, 0x03	; 3
  32:	88 0f       	add	r24, r24
  34:	99 1f       	adc	r25, r25
  36:	aa 1f       	adc	r26, r26
  38:	bb 1f       	adc	r27, r27
  3a:	fa 95       	dec	r31
  3c:	01 f4       	brne	.+0      	; 0x3e <__uartHWSetBaudRate+0x3e>
  3e:	40 91 00 00 	lds	r20, 0x0000
  42:	50 91 00 00 	lds	r21, 0x0000
  46:	60 91 00 00 	lds	r22, 0x0000
  4a:	70 91 00 00 	lds	r23, 0x0000
  4e:	84 0f       	add	r24, r20
  50:	95 1f       	adc	r25, r21
  52:	a6 1f       	adc	r26, r22
  54:	b7 1f       	adc	r27, r23
  56:	a7 01       	movw	r20, r14
  58:	96 01       	movw	r18, r12
  5a:	c4 e0       	ldi	r28, 0x04	; 4
  5c:	22 0f       	add	r18, r18
  5e:	33 1f       	adc	r19, r19
  60:	44 1f       	adc	r20, r20
  62:	55 1f       	adc	r21, r21
  64:	ca 95       	dec	r28
  66:	01 f4       	brne	.+0      	; 0x68 <__uartHWSetBaudRate+0x68>
  68:	bc 01       	movw	r22, r24
  6a:	cd 01       	movw	r24, r26
  6c:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>
  70:	e9 01       	movw	r28, r18
  72:	21 97       	sbiw	r28, 0x01	; 1
  74:	00 c0       	rjmp	.+0      	; 0x76 <__uartHWSetBaudRate+0x76>
  76:	c1 e0       	ldi	r28, 0x01	; 1
  78:	d0 e0       	ldi	r29, 0x00	; 0
	if(hwUart->u2xMask != 0){
  7a:	d8 01       	movw	r26, r16
  7c:	96 96       	adiw	r26, 0x26	; 38
  7e:	9c 91       	ld	r25, X
  80:	96 97       	sbiw	r26, 0x26	; 38
  82:	99 23       	and	r25, r25
  84:	01 f4       	brne	.+0      	; 0x86 <__uartHWSetBaudRate+0x86>
  86:	00 c0       	rjmp	.+0      	; 0x88 <__uartHWSetBaudRate+0x88>
		_SFR_MEM8(hwUart->statusA) &=  ~(hwUart->u2xMask);	// turn off u2x
  88:	5a 96       	adiw	r26, 0x1a	; 26
  8a:	ed 91       	ld	r30, X+
  8c:	fc 91       	ld	r31, X
  8e:	5b 97       	sbiw	r26, 0x1b	; 27
  90:	80 81       	ld	r24, Z
  92:	90 95       	com	r25
  94:	89 23       	and	r24, r25
  96:	80 83       	st	Z, r24
		uint16_t bauddiv2 = (baudrate==BAUD_RATE_MAX) ? 1 : ((cpu_speed + (baudrate*4L))/(baudrate*8L)-1);
  98:	bf ef       	ldi	r27, 0xFF	; 255
  9a:	cb 16       	cp	r12, r27
  9c:	bf ef       	ldi	r27, 0xFF	; 255
  9e:	db 06       	cpc	r13, r27
  a0:	bf ef       	ldi	r27, 0xFF	; 255
  a2:	eb 06       	cpc	r14, r27
  a4:	bf ef       	ldi	r27, 0xFF	; 255
  a6:	fb 06       	cpc	r15, r27
  a8:	01 f0       	breq	.+0      	; 0xaa <__uartHWSetBaudRate+0xaa>
  aa:	d7 01       	movw	r26, r14
  ac:	c6 01       	movw	r24, r12
  ae:	22 e0       	ldi	r18, 0x02	; 2
  b0:	88 0f       	add	r24, r24
  b2:	99 1f       	adc	r25, r25
  b4:	aa 1f       	adc	r26, r26
  b6:	bb 1f       	adc	r27, r27
  b8:	2a 95       	dec	r18
  ba:	01 f4       	brne	.+0      	; 0xbc <__uartHWSetBaudRate+0xbc>
  bc:	40 91 00 00 	lds	r20, 0x0000
  c0:	50 91 00 00 	lds	r21, 0x0000
  c4:	60 91 00 00 	lds	r22, 0x0000
  c8:	70 91 00 00 	lds	r23, 0x0000
  cc:	84 0f       	add	r24, r20
  ce:	95 1f       	adc	r25, r21
  d0:	a6 1f       	adc	r26, r22
  d2:	b7 1f       	adc	r27, r23
  d4:	a7 01       	movw	r20, r14
  d6:	96 01       	movw	r18, r12
  d8:	e3 e0       	ldi	r30, 0x03	; 3
  da:	22 0f       	add	r18, r18
  dc:	33 1f       	adc	r19, r19
  de:	44 1f       	adc	r20, r20
  e0:	55 1f       	adc	r21, r21
  e2:	ea 95       	dec	r30
  e4:	01 f4       	brne	.+0      	; 0xe6 <__uartHWSetBaudRate+0xe6>
  e6:	bc 01       	movw	r22, r24
  e8:	cd 01       	movw	r24, r26
  ea:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>
  ee:	21 50       	subi	r18, 0x01	; 1
  f0:	30 40       	sbci	r19, 0x00	; 0
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <__uartHWSetBaudRate+0xf4>
  f4:	21 e0       	ldi	r18, 0x01	; 1
  f6:	30 e0       	ldi	r19, 0x00	; 0
		if(bauddiv2 >= bauddiv){
  f8:	2c 17       	cp	r18, r28
  fa:	3d 07       	cpc	r19, r29
  fc:	00 f0       	brcs	.+0      	; 0xfe <__uartHWSetBaudRate+0xfe>
			_SFR_MEM8(hwUart->statusA) |=  hwUart->u2xMask;	// turn on u2x
  fe:	d8 01       	movw	r26, r16
 100:	5a 96       	adiw	r26, 0x1a	; 26
 102:	ed 91       	ld	r30, X+
 104:	fc 91       	ld	r31, X
 106:	5b 97       	sbiw	r26, 0x1b	; 27
 108:	80 81       	ld	r24, Z
 10a:	96 96       	adiw	r26, 0x26	; 38
 10c:	9c 91       	ld	r25, X
 10e:	89 2b       	or	r24, r25
 110:	80 83       	st	Z, r24
 112:	e9 01       	movw	r28, r18
			bauddiv = bauddiv2;
		}
	}
	_SFR_MEM8(hwUart->baudL) =  bauddiv;
 114:	d8 01       	movw	r26, r16
 116:	5e 96       	adiw	r26, 0x1e	; 30
 118:	ed 91       	ld	r30, X+
 11a:	fc 91       	ld	r31, X
 11c:	5f 97       	sbiw	r26, 0x1f	; 31
 11e:	c0 83       	st	Z, r28
	_SFR_MEM8(hwUart->baudH) = bauddiv>>8;
 120:	d8 01       	movw	r26, r16
 122:	90 96       	adiw	r26, 0x20	; 32
 124:	ed 91       	ld	r30, X+
 126:	fc 91       	ld	r31, X
 128:	91 97       	sbiw	r26, 0x21	; 33
 12a:	d0 83       	st	Z, r29
	CRITICAL_SECTION_END;
 12c:	bf be       	out	0x3f, r11	; 63
}
 12e:	df 91       	pop	r29
 130:	cf 91       	pop	r28
 132:	1f 91       	pop	r17
 134:	0f 91       	pop	r16
 136:	ff 90       	pop	r15
 138:	ef 90       	pop	r14
 13a:	df 90       	pop	r13
 13c:	cf 90       	pop	r12
 13e:	bf 90       	pop	r11
 140:	08 95       	ret

00000142 <__uartHWStartXmit>:
}

// Sends a single byte over the uart.
void __uartHWStartXmit(UART* _uart, uint8_t txData){
	HW_UART* uart = (HW_UART*)_uart;
	_SFR_MEM8(uart->data) = txData;		// Start sending the character
 142:	dc 01       	movw	r26, r24
 144:	92 96       	adiw	r26, 0x22	; 34
 146:	ed 91       	ld	r30, X+
 148:	fc 91       	ld	r31, X
 14a:	93 97       	sbiw	r26, 0x23	; 35
 14c:	60 83       	st	Z, r22
}
 14e:	08 95       	ret

00000150 <__uartHWInit>:

// Initializes one UART to the default baud rate
// After running this init function, the processor
// I/O pins that used for uart communications (RXD, TXD)
// are no long available for general purpose I/O.
void __uartHWInit(UART* _uart, BAUD_RATE baud){
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
 154:	ec 01       	movw	r28, r24
	HW_UART* uart = (HW_UART*) _uart;

	// set default baud rate
	uartSetBaudRate(uart, baud);
 156:	0e 94 00 00 	call	0	; 0x0 <__uartHWSetBaudRate>


	uint8_t statB = 0;
	if(_uartIsOneWire(_uart)){
 15a:	8d 89       	ldd	r24, Y+21	; 0x15
 15c:	88 23       	and	r24, r24
 15e:	01 f4       	brne	.+0      	; 0x160 <__uartHWInit+0x10>
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
	}else{
		// enable RxD/TxD and interrupts
		if(uart->_uart_.rx_pin){
 160:	8d 85       	ldd	r24, Y+13	; 0x0d
 162:	9e 85       	ldd	r25, Y+14	; 0x0e
 164:	00 97       	sbiw	r24, 0x00	; 0
 166:	01 f4       	brne	.+0      	; 0x168 <__uartHWInit+0x18>

	// set default baud rate
	uartSetBaudRate(uart, baud);


	uint8_t statB = 0;
 168:	20 e0       	ldi	r18, 0x00	; 0
 16a:	00 c0       	rjmp	.+0      	; 0x16c <__uartHWInit+0x1c>
	if(_uartIsOneWire(_uart)){
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
	}else{
		// enable RxD/TxD and interrupts
		if(uart->_uart_.rx_pin){
			statB = BV(RXCIE) | BV(RXEN);
 16c:	20 e9       	ldi	r18, 0x90	; 144
		}
		if(uart->_uart_.tx_pin){
 16e:	8f 85       	ldd	r24, Y+15	; 0x0f
 170:	98 89       	ldd	r25, Y+16	; 0x10
 172:	00 97       	sbiw	r24, 0x00	; 0
 174:	01 f0       	breq	.+0      	; 0x176 <__uartHWInit+0x26>
			statB |= BV(TXCIE) | BV(TXEN);
 176:	28 64       	ori	r18, 0x48	; 72
 178:	00 c0       	rjmp	.+0      	; 0x17a <__uartHWInit+0x2a>
	uartSetBaudRate(uart, baud);


	uint8_t statB = 0;
	if(_uartIsOneWire(_uart)){
		statB =  BV(RXCIE) | BV(RXEN);		// Rx on
 17a:	20 e9       	ldi	r18, 0x90	; 144
		}

//		_SFR_MEM8(uart->statusB) =  BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN);
	}

	_SFR_MEM8(uart->statusB) = statB;
 17c:	ec 8d       	ldd	r30, Y+28	; 0x1c
 17e:	fd 8d       	ldd	r31, Y+29	; 0x1d
 180:	20 83       	st	Z, r18
}
 182:	df 91       	pop	r29
 184:	cf 91       	pop	r28
 186:	08 95       	ret

00000188 <__uartHWOff>:

// Disable the uart
static void __uartHWOff(UART * _uart){
 188:	fc 01       	movw	r30, r24
	HW_UART* uart = (HW_UART*) _uart;

	_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE)|BV(TXCIE)|BV(RXEN)|BV(TXEN));
 18a:	a4 8d       	ldd	r26, Z+28	; 0x1c
 18c:	b5 8d       	ldd	r27, Z+29	; 0x1d
 18e:	8c 91       	ld	r24, X
 190:	87 72       	andi	r24, 0x27	; 39
 192:	8c 93       	st	X, r24

	if(uart->u2xMask != 0){
 194:	96 a1       	ldd	r25, Z+38	; 0x26
 196:	99 23       	and	r25, r25
 198:	01 f0       	breq	.+0      	; 0x19a <__uartHWOff+0x12>
		_SFR_MEM8(uart->statusA) &=  ~(uart->u2xMask);	// turn off u2x
 19a:	02 8c       	ldd	r0, Z+26	; 0x1a
 19c:	f3 8d       	ldd	r31, Z+27	; 0x1b
 19e:	e0 2d       	mov	r30, r0
 1a0:	80 81       	ld	r24, Z
 1a2:	90 95       	com	r25
 1a4:	89 23       	and	r24, r25
 1a6:	80 83       	st	Z, r24
 1a8:	08 95       	ret

000001aa <oneWireReceiveMode>:

}


// If one wire - then go into receive mode
static void oneWireReceiveMode(UART* _uart){
 1aa:	fc 01       	movw	r30, r24
	if(_uartIsOneWire(_uart)){
 1ac:	85 89       	ldd	r24, Z+21	; 0x15
 1ae:	88 23       	and	r24, r24
 1b0:	01 f0       	breq	.+0      	; 0x1b2 <oneWireReceiveMode+0x8>
		HW_UART* uart = (HW_UART*)_uart;
		// Place into receive mode and turn transmitter off
		_SFR_MEM8(uart->statusB) &=  ~(BV(TXCIE)|BV(TXEN));		// Tx Off
 1b2:	a4 8d       	ldd	r26, Z+28	; 0x1c
 1b4:	b5 8d       	ldd	r27, Z+29	; 0x1d
 1b6:	8c 91       	ld	r24, X
 1b8:	87 7b       	andi	r24, 0xB7	; 183
 1ba:	8c 93       	st	X, r24
		_SFR_MEM8(uart->statusB) |=  (BV(RXCIE)|BV(RXEN));		// Rx on
 1bc:	04 8c       	ldd	r0, Z+28	; 0x1c
 1be:	f5 8d       	ldd	r31, Z+29	; 0x1d
 1c0:	e0 2d       	mov	r30, r0
 1c2:	80 81       	ld	r24, Z
 1c4:	80 69       	ori	r24, 0x90	; 144
 1c6:	80 83       	st	Z, r24
 1c8:	08 95       	ret

000001ca <startXmitMode>:
	_SFR_MEM8(uart->data) = txData;		// Start sending the character
}


// Put the uart into xmit mode
static void	startXmitMode(UART* _uart){
 1ca:	fc 01       	movw	r30, r24
	if(_uartIsOneWire(_uart)){
 1cc:	85 89       	ldd	r24, Z+21	; 0x15
 1ce:	88 23       	and	r24, r24
 1d0:	01 f0       	breq	.+0      	; 0x1d2 <startXmitMode+0x8>
		HW_UART* uart = (HW_UART*)_uart;
		// Place into transmit mode and turn receiver off
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE)|BV(RXEN));		// Rx Off
 1d2:	a4 8d       	ldd	r26, Z+28	; 0x1c
 1d4:	b5 8d       	ldd	r27, Z+29	; 0x1d
 1d6:	8c 91       	ld	r24, X
 1d8:	8f 76       	andi	r24, 0x6F	; 111
 1da:	8c 93       	st	X, r24
		_SFR_MEM8(uart->statusB) |=  (BV(TXCIE)|BV(TXEN));		// Tx on
 1dc:	04 8c       	ldd	r0, Z+28	; 0x1c
 1de:	f5 8d       	ldd	r31, Z+29	; 0x1d
 1e0:	e0 2d       	mov	r30, r0
 1e2:	80 81       	ld	r24, Z
 1e4:	88 64       	ori	r24, 0x48	; 72
 1e6:	80 83       	st	Z, r24
 1e8:	08 95       	ret

000001ea <uartReceivePollingMode>:
		&__uartHWOff,			\
		&startXmitMode, \
		&oneWireReceiveMode );

// Put the receiver in polling mode (TRUE) or interrupt mode (FALSE)
void uartReceivePollingMode(const HW_UART* uart,boolean polling){
 1ea:	dc 01       	movw	r26, r24
 1ec:	5c 96       	adiw	r26, 0x1c	; 28
 1ee:	ed 91       	ld	r30, X+
 1f0:	fc 91       	ld	r31, X
 1f2:	5d 97       	sbiw	r26, 0x1d	; 29
	if(polling){
		// turn off receive interrupts
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE));		// Rx Off
 1f4:	80 81       	ld	r24, Z
		&startXmitMode, \
		&oneWireReceiveMode );

// Put the receiver in polling mode (TRUE) or interrupt mode (FALSE)
void uartReceivePollingMode(const HW_UART* uart,boolean polling){
	if(polling){
 1f6:	66 23       	and	r22, r22
 1f8:	01 f0       	breq	.+0      	; 0x1fa <uartReceivePollingMode+0x10>
		// turn off receive interrupts
		_SFR_MEM8(uart->statusB) &=  ~(BV(RXCIE));		// Rx Off
 1fa:	8f 77       	andi	r24, 0x7F	; 127
 1fc:	00 c0       	rjmp	.+0      	; 0x1fe <uartReceivePollingMode+0x14>
	}else{
		// turn on receive interrupts
		_SFR_MEM8(uart->statusB) |=  BV(RXCIE);			// Rx On
 1fe:	80 68       	ori	r24, 0x80	; 128
 200:	80 83       	st	Z, r24
 202:	08 95       	ret

00000204 <uartPollByte>:
	}
}


// Poll the hardware for the next receive character
int uartPollByte(const HW_UART* uart){
 204:	fc 01       	movw	r30, r24
	int ch=-1;
	if( _SFR_MEM8(uart->statusA) & BV(RXC)){
 206:	a2 8d       	ldd	r26, Z+26	; 0x1a
 208:	b3 8d       	ldd	r27, Z+27	; 0x1b
 20a:	8c 91       	ld	r24, X
 20c:	87 ff       	sbrs	r24, 7
 20e:	00 c0       	rjmp	.+0      	; 0x210 <uartPollByte+0xc>
		// A character is waiting
		ch = _SFR_MEM8(uart->data);
 210:	02 a0       	ldd	r0, Z+34	; 0x22
 212:	f3 a1       	ldd	r31, Z+35	; 0x23
 214:	e0 2d       	mov	r30, r0
 216:	80 81       	ld	r24, Z
 218:	90 e0       	ldi	r25, 0x00	; 0
 21a:	08 95       	ret
}


// Poll the hardware for the next receive character
int uartPollByte(const HW_UART* uart){
	int ch=-1;
 21c:	8f ef       	ldi	r24, 0xFF	; 255
 21e:	9f ef       	ldi	r25, 0xFF	; 255
		// A character is waiting
		ch = _SFR_MEM8(uart->data);

	}
	return ch;
}
 220:	08 95       	ret

uartsw.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000065a  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  0000068e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  0000068e  2**0
                  ALLOC
  3 .progmem.data 0000000c  00000000  00000000  0000068e  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
  4 .debug_info   000013cd  00000000  00000000  0000069a  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  5 .debug_abbrev 000003a2  00000000  00000000  00001a67  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_loc    00000f3b  00000000  00000000  00001e09  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 00000020  00000000  00000000  00002d44  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  8 .debug_ranges 00000018  00000000  00000000  00002d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000287  00000000  00000000  00002d7c  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .debug_str    00000869  00000000  00000000  00003003  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  0000020c  00000000  00000000  0000386c  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__uartswOff>:
		__uartReceiveService(&uart->_uart_, c);
	}
}

// Disable the uart
static void __uartswOff(UART * _uart){
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	cf 93       	push	r28
   6:	df 93       	push	r29
	SW_UART* uart = (SW_UART*) _uart;

	const Timer* timer = &pgm_Timers[uart->timer];
   8:	fc 01       	movw	r30, r24
   a:	22 8d       	ldd	r18, Z+26	; 0x1a
   c:	30 e0       	ldi	r19, 0x00	; 0
   e:	8c e2       	ldi	r24, 0x2C	; 44
  10:	90 e0       	ldi	r25, 0x00	; 0
  12:	28 9f       	mul	r18, r24
  14:	80 01       	movw	r16, r0
  16:	29 9f       	mul	r18, r25
  18:	10 0d       	add	r17, r0
  1a:	38 9f       	mul	r19, r24
  1c:	10 0d       	add	r17, r0
  1e:	11 24       	eor	r1, r1
  20:	00 50       	subi	r16, 0x00	; 0
  22:	10 40       	sbci	r17, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
  24:	f8 01       	movw	r30, r16
  26:	77 96       	adiw	r30, 0x17	; 23
  28:	c5 91       	lpm	r28, Z+
  2a:	d4 91       	lpm	r29, Z

	// detach the service routines
	compareDetach(timerGetCompare(timer,0));
  2c:	ce 01       	movw	r24, r28
  2e:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	compareDetach(timerGetCompare(timer,1));
  32:	ce 01       	movw	r24, r28
  34:	40 96       	adiw	r24, 0x10	; 16
  36:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	timerCaptureDetach(timer);
  3a:	c8 01       	movw	r24, r16
  3c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
}
  40:	df 91       	pop	r29
  42:	cf 91       	pop	r28
  44:	1f 91       	pop	r17
  46:	0f 91       	pop	r16
  48:	08 95       	ret

0000004a <uartswRxStartService>:
	}
}


// Start receiving a new byte. Caused by a change on the input capture
static void uartswRxStartService(const Timer *timer, void* _uart){
  4a:	ef 92       	push	r14
  4c:	ff 92       	push	r15
  4e:	0f 93       	push	r16
  50:	1f 93       	push	r17
  52:	cf 93       	push	r28
  54:	df 93       	push	r29
  56:	ec 01       	movw	r28, r24
  58:	7b 01       	movw	r14, r22
	SW_UART* uart = (SW_UART*)_uart;
	// disable ICP interrupt - as remainder are done by OC1B
	__portMaskClear(&timer->pgm_captureint);
  5a:	81 96       	adiw	r24, 0x21	; 33
  5c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

	// Get the timer value of when the interrupt happened
	PORT icr = pgm_read_word(&timer->pgm_icr);
  60:	fe 01       	movw	r30, r28
  62:	7f 96       	adiw	r30, 0x1f	; 31
  64:	85 91       	lpm	r24, Z+
  66:	94 91       	lpm	r25, Z
	uint16_t capture = _SFR_MEM16(icr);
  68:	fc 01       	movw	r30, r24
  6a:	20 81       	ld	r18, Z
  6c:	31 81       	ldd	r19, Z+1	; 0x01
  6e:	67 96       	adiw	r28, 0x17	; 23
  70:	fe 01       	movw	r30, r28
  72:	05 91       	lpm	r16, Z+
  74:	14 91       	lpm	r17, Z

	// attach RxBit service routine to OC1B for 1.5 bit from now
	const TimerCompare* rx = timerGetCompare(timer,1);
	compareSetThreshold(rx, (capture + uart->dataBitLength + uart->dataBitLength/2) );
  76:	f7 01       	movw	r30, r14
  78:	81 a1       	ldd	r24, Z+33	; 0x21
  7a:	92 a1       	ldd	r25, Z+34	; 0x22
  7c:	61 a1       	ldd	r22, Z+33	; 0x21
  7e:	72 a1       	ldd	r23, Z+34	; 0x22
  80:	76 95       	lsr	r23
  82:	67 95       	ror	r22
  84:	68 0f       	add	r22, r24
  86:	79 1f       	adc	r23, r25
  88:	62 0f       	add	r22, r18
  8a:	73 1f       	adc	r23, r19
  8c:	c8 01       	movw	r24, r16
  8e:	40 96       	adiw	r24, 0x10	; 16
  90:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
  94:	c8 01       	movw	r24, r16
  96:	48 96       	adiw	r24, 0x18	; 24
  98:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	compareClearInterruptPending(rx);		// clear any interrupt pending
	__portMaskSet(&rx->pgm_intenable);		// turn interrupt on
  9c:	c8 01       	movw	r24, r16
  9e:	43 96       	adiw	r24, 0x13	; 19
  a0:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

	// reset bit counter and data
	uart->rxBitNum = uart->rxData = 0;
  a4:	f7 01       	movw	r30, r14
  a6:	13 8e       	std	Z+27, r1	; 0x1b
  a8:	14 8e       	std	Z+28, r1	; 0x1c

}
  aa:	df 91       	pop	r29
  ac:	cf 91       	pop	r28
  ae:	1f 91       	pop	r17
  b0:	0f 91       	pop	r16
  b2:	ff 90       	pop	r15
  b4:	ef 90       	pop	r14
  b6:	08 95       	ret

000000b8 <__uartswStartXmit>:


}

// Start transmitting the given byte
void __uartswStartXmit(UART* _uart, uint8_t data){
  b8:	cf 92       	push	r12
  ba:	df 92       	push	r13
  bc:	ef 92       	push	r14
  be:	ff 92       	push	r15
  c0:	0f 93       	push	r16
  c2:	1f 93       	push	r17
  c4:	cf 93       	push	r28
  c6:	df 93       	push	r29
  c8:	ec 01       	movw	r28, r24

	SW_UART* uart = (SW_UART*)_uart;

	// save data
	uart->txData = (uart->inverted) ? ~data : data;
  ca:	8b a1       	ldd	r24, Y+35	; 0x23
  cc:	81 11       	cpse	r24, r1
  ce:	60 95       	com	r22
  d0:	6d 8f       	std	Y+29, r22	; 0x1d

	// set number of bits (+1 for stop bit)
	uart->txBitNum = 9;
  d2:	89 e0       	ldi	r24, 0x09	; 9
  d4:	8e 8f       	std	Y+30, r24	; 0x1e

	const Timer* timer = &pgm_Timers[uart->timer];
  d6:	2a 8d       	ldd	r18, Y+26	; 0x1a
  d8:	30 e0       	ldi	r19, 0x00	; 0
  da:	8c e2       	ldi	r24, 0x2C	; 44
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	28 9f       	mul	r18, r24
  e0:	70 01       	movw	r14, r0
  e2:	29 9f       	mul	r18, r25
  e4:	f0 0c       	add	r15, r0
  e6:	38 9f       	mul	r19, r24
  e8:	f0 0c       	add	r15, r0
  ea:	11 24       	eor	r1, r1
  ec:	80 e0       	ldi	r24, 0x00	; 0
  ee:	90 e0       	ldi	r25, 0x00	; 0
  f0:	e8 0e       	add	r14, r24
  f2:	f9 1e       	adc	r15, r25

	// Get the time when the start bit is set
	uint16_t start;
	start = timerGetCounter(timer);
  f4:	c7 01       	movw	r24, r14
  f6:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
  fa:	6c 01       	movw	r12, r24
	// set the start bit
	if(uart->inverted){
  fc:	2b a1       	ldd	r18, Y+35	; 0x23
  fe:	8f 85       	ldd	r24, Y+15	; 0x0f
 100:	98 89       	ldd	r25, Y+16	; 0x10
 102:	22 23       	and	r18, r18
 104:	01 f0       	breq	.+0      	; 0x106 <__uartswStartXmit+0x4e>
		pin_high(uart->_uart_.tx_pin);
 106:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <__uartswStartXmit+0x54>
	}else{
		pin_low(uart->_uart_.tx_pin);
 10c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}

	if(uart->_uart_.tx_pin){
 110:	8f 85       	ldd	r24, Y+15	; 0x0f
 112:	98 89       	ldd	r25, Y+16	; 0x10
 114:	00 97       	sbiw	r24, 0x00	; 0
 116:	01 f0       	breq	.+0      	; 0x118 <__uartswStartXmit+0x60>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 118:	f7 01       	movw	r30, r14
 11a:	77 96       	adiw	r30, 0x17	; 23
 11c:	85 91       	lpm	r24, Z+
 11e:	94 91       	lpm	r25, Z
 120:	8c 01       	movw	r16, r24
		const TimerCompare* channel = timerGetCompare(timer,0);

		// schedule the next bit
		uint16_t top = 1 + timerGetTOP(timer);
 122:	c7 01       	movw	r24, r14
 124:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 128:	01 96       	adiw	r24, 0x01	; 1
		uint16_t next = (start + uart->startBitLength);
 12a:	6f 8d       	ldd	r22, Y+31	; 0x1f
 12c:	78 a1       	ldd	r23, Y+32	; 0x20
 12e:	6c 0d       	add	r22, r12
 130:	7d 1d       	adc	r23, r13
		if(next >= top){
 132:	68 17       	cp	r22, r24
 134:	79 07       	cpc	r23, r25
 136:	00 f0       	brcs	.+0      	; 0x138 <__uartswStartXmit+0x80>
			next -= top;
 138:	68 1b       	sub	r22, r24
 13a:	79 0b       	sbc	r23, r25
		}
		compareSetThreshold(channel, next);
 13c:	c8 01       	movw	r24, r16
 13e:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 142:	c8 01       	movw	r24, r16
 144:	08 96       	adiw	r24, 0x08	; 8
 146:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		// No interrupt pending
		compareClearInterruptPending(channel);

		// Allow compare interrupts
		__portMaskSet(&channel->pgm_intenable);
 14a:	c8 01       	movw	r24, r16
 14c:	03 96       	adiw	r24, 0x03	; 3
 14e:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 152:	00 c0       	rjmp	.+0      	; 0x154 <__uartswStartXmit+0x9c>

	}else{
		// There is no iopin - so we have finished sending the current byte
		__uartTransmitService(&uart->_uart_);
 154:	ce 01       	movw	r24, r28
 156:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}

}
 15a:	df 91       	pop	r29
 15c:	cf 91       	pop	r28
 15e:	1f 91       	pop	r17
 160:	0f 91       	pop	r16
 162:	ff 90       	pop	r15
 164:	ef 90       	pop	r14
 166:	df 90       	pop	r13
 168:	cf 90       	pop	r12
 16a:	08 95       	ret

0000016c <__uartswSetBaudRate>:
	}
	oneWireReceiveMode(_uart);
}


void __uartswSetBaudRate(UART* _uart, BAUD_RATE baudrate){
 16c:	2f 92       	push	r2
 16e:	3f 92       	push	r3
 170:	4f 92       	push	r4
 172:	5f 92       	push	r5
 174:	7f 92       	push	r7
 176:	8f 92       	push	r8
 178:	9f 92       	push	r9
 17a:	af 92       	push	r10
 17c:	bf 92       	push	r11
 17e:	cf 92       	push	r12
 180:	df 92       	push	r13
 182:	ef 92       	push	r14
 184:	ff 92       	push	r15
 186:	0f 93       	push	r16
 188:	1f 93       	push	r17
 18a:	cf 93       	push	r28
 18c:	df 93       	push	r29
 18e:	00 d0       	rcall	.+0      	; 0x190 <__uartswSetBaudRate+0x24>
 190:	00 d0       	rcall	.+0      	; 0x192 <__uartswSetBaudRate+0x26>
 192:	cd b7       	in	r28, 0x3d	; 61
 194:	de b7       	in	r29, 0x3e	; 62
 196:	4c 01       	movw	r8, r24
 198:	1a 01       	movw	r2, r20
 19a:	2b 01       	movw	r4, r22
	SW_UART* uart = (SW_UART*)_uart;

	const Timer* timer = &pgm_Timers[uart->timer];
 19c:	fc 01       	movw	r30, r24
 19e:	22 8d       	ldd	r18, Z+26	; 0x1a
 1a0:	30 e0       	ldi	r19, 0x00	; 0
 1a2:	8c e2       	ldi	r24, 0x2C	; 44
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	28 9f       	mul	r18, r24
 1a8:	80 01       	movw	r16, r0
 1aa:	29 9f       	mul	r18, r25
 1ac:	10 0d       	add	r17, r0
 1ae:	38 9f       	mul	r19, r24
 1b0:	10 0d       	add	r17, r0
 1b2:	11 24       	eor	r1, r1
 1b4:	00 50       	subi	r16, 0x00	; 0
 1b6:	10 40       	sbci	r17, 0x00	; 0
}

boolean compareIsInUse(const TimerCompare* channel);

static __inline__ boolean timerIsInUse(const Timer* timer){
	return ((_SFR_MEM8(pgm_read_word(&timer->pgm_prescaler)) & TIMER_PRESCALE_MASK) != 0) ? TRUE : FALSE;
 1b8:	f8 01       	movw	r30, r16
 1ba:	34 96       	adiw	r30, 0x04	; 4
 1bc:	85 91       	lpm	r24, Z+
 1be:	94 91       	lpm	r25, Z
 1c0:	fc 01       	movw	r30, r24
 1c2:	80 81       	ld	r24, Z
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	87 70       	andi	r24, 0x07	; 7
 1c8:	90 70       	andi	r25, 0x00	; 0
 1ca:	00 97       	sbiw	r24, 0x00	; 0
 1cc:	01 f4       	brne	.+0      	; 0x1ce <__uartswSetBaudRate+0x62>
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <__uartswSetBaudRate+0x64>
	boolean	isMyTimer = FALSE;
 1d0:	77 24       	eor	r7, r7
		timerSetPrescaler(timer,1);

		isMyTimer = TRUE;
	}

	uint16_t top = timerGetTOP(timer);
 1d2:	c8 01       	movw	r24, r16
 1d4:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 1d8:	9a 83       	std	Y+2, r25	; 0x02
 1da:	89 83       	std	Y+1, r24	; 0x01
// Private methods

int __timerPrescalerIndex(const Timer* timer, uint16_t prescaler);

static __inline__ TimerData* timerGetData(const Timer* timer){
	return (TimerData*)pgm_read_word(&timer->pgm_data);
 1dc:	f8 01       	movw	r30, r16
 1de:	a5 91       	lpm	r26, Z+
 1e0:	b4 91       	lpm	r27, Z
//  So an 8MHz clock with a prescaler of 8 results in the
//  timer being incremented at the same frequency as an
//  1MHz clock with a prescaler of 1.
------------------------------------------------------- */
static __inline__ uint16_t timerGetPrescaler(const Timer* timer){
	return timerGetData(timer)->prescale_value;
 1e2:	ad 90       	ld	r10, X+
 1e4:	bc 90       	ld	r11, X
	// Get the current prescaler
	uint16_t prescale = timerGetPrescaler(timer);

	// calculate division factor for requested baud rate, and set it
calcBaud:
	uart->dataBitLength = (uint16_t)(  (cpu_speed+(baudrate/2L)) / (prescale * baudrate * 1L)  );
 1e6:	72 01       	movw	r14, r4
 1e8:	61 01       	movw	r12, r2
 1ea:	f6 94       	lsr	r15
 1ec:	e7 94       	ror	r14
 1ee:	d7 94       	ror	r13
 1f0:	c7 94       	ror	r12
 1f2:	80 91 00 00 	lds	r24, 0x0000
 1f6:	90 91 00 00 	lds	r25, 0x0000
 1fa:	a0 91 00 00 	lds	r26, 0x0000
 1fe:	b0 91 00 00 	lds	r27, 0x0000
 202:	c8 0e       	add	r12, r24
 204:	d9 1e       	adc	r13, r25
 206:	ea 1e       	adc	r14, r26
 208:	fb 1e       	adc	r15, r27
 20a:	b5 01       	movw	r22, r10
 20c:	80 e0       	ldi	r24, 0x00	; 0
 20e:	90 e0       	ldi	r25, 0x00	; 0
 210:	a2 01       	movw	r20, r4
 212:	91 01       	movw	r18, r2
 214:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 218:	9b 01       	movw	r18, r22
 21a:	ac 01       	movw	r20, r24
 21c:	c7 01       	movw	r24, r14
 21e:	b6 01       	movw	r22, r12
 220:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 224:	f4 01       	movw	r30, r8
 226:	32 a3       	std	Z+34, r19	; 0x22
 228:	21 a3       	std	Z+33, r18	; 0x21

	// Fudge factor compensates for interrupt processing overhead
	// The larger this number then the shorter the start bit
	//
	uint16_t pre = prescale;
 22a:	c5 01       	movw	r24, r10
	uint16_t fudge = 104U;
 22c:	28 e6       	ldi	r18, 0x68	; 104
 22e:	30 e0       	ldi	r19, 0x00	; 0
	while(pre > 1){
 230:	00 c0       	rjmp	.+0      	; 0x232 <__uartswSetBaudRate+0xc6>
		fudge>>=1;
 232:	36 95       	lsr	r19
 234:	27 95       	ror	r18
		pre>>=1;
 236:	96 95       	lsr	r25
 238:	87 95       	ror	r24
	// Fudge factor compensates for interrupt processing overhead
	// The larger this number then the shorter the start bit
	//
	uint16_t pre = prescale;
	uint16_t fudge = 104U;
	while(pre > 1){
 23a:	82 30       	cpi	r24, 0x02	; 2
 23c:	91 05       	cpc	r25, r1
 23e:	00 f4       	brcc	.+0      	; 0x240 <__uartswSetBaudRate+0xd4>
		fudge>>=1;
		pre>>=1;
	}
	uart->startBitLength = uart->dataBitLength - fudge;
 240:	f4 01       	movw	r30, r8
 242:	81 a1       	ldd	r24, Z+33	; 0x21
 244:	92 a1       	ldd	r25, Z+34	; 0x22
 246:	82 1b       	sub	r24, r18
 248:	93 0b       	sbc	r25, r19
 24a:	90 a3       	std	Z+32, r25	; 0x20
 24c:	87 8f       	std	Z+31, r24	; 0x1f

	if(uart->dataBitLength > top){
 24e:	81 a1       	ldd	r24, Z+33	; 0x21
 250:	92 a1       	ldd	r25, Z+34	; 0x22
 252:	29 81       	ldd	r18, Y+1	; 0x01
 254:	3a 81       	ldd	r19, Y+2	; 0x02
 256:	28 17       	cp	r18, r24
 258:	39 07       	cpc	r19, r25
 25a:	00 f4       	brcc	.+0      	; 0x25c <__uartswSetBaudRate+0xf0>
		uart->dataBitLength = top;
 25c:	32 a3       	std	Z+34, r19	; 0x22
 25e:	21 a3       	std	Z+33, r18	; 0x21
		if(isMyTimer){
 260:	77 20       	and	r7, r7
 262:	01 f0       	breq	.+0      	; 0x264 <__uartswSetBaudRate+0xf8>
			// Try increasing the prescaler
			uint16_t nextpre = timerGetClosestPrescale(timer, prescale+1);
 264:	b5 01       	movw	r22, r10
 266:	6f 5f       	subi	r22, 0xFF	; 255
 268:	7f 4f       	sbci	r23, 0xFF	; 255
 26a:	c8 01       	movw	r24, r16
 26c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 270:	9c 01       	movw	r18, r24
			if(nextpre != prescale){
 272:	8a 15       	cp	r24, r10
 274:	9b 05       	cpc	r25, r11
 276:	01 f0       	breq	.+0      	; 0x278 <__uartswSetBaudRate+0x10c>
				prescale = nextpre;
				timerSetPrescaler(timer,prescale);
 278:	c8 01       	movw	r24, r16
 27a:	b9 01       	movw	r22, r18
 27c:	2b 83       	std	Y+3, r18	; 0x03
 27e:	3c 83       	std	Y+4, r19	; 0x04
 280:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 284:	2b 81       	ldd	r18, Y+3	; 0x03
 286:	3c 81       	ldd	r19, Y+4	; 0x04
 288:	59 01       	movw	r10, r18
				goto calcBaud;
 28a:	00 c0       	rjmp	.+0      	; 0x28c <__uartswSetBaudRate+0x120>
	const Timer* timer = &pgm_Timers[uart->timer];
	boolean	isMyTimer = FALSE;

	// Make sure the timer is in normal mode
	if(!timerIsInUse(timer)){
		timerSetMode(timer,TIMER_MODE_NORMAL);
 28c:	c8 01       	movw	r24, r16
 28e:	60 e0       	ldi	r22, 0x00	; 0
 290:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
		// set timer prescaler
		timerSetPrescaler(timer,1);
 294:	c8 01       	movw	r24, r16
 296:	61 e0       	ldi	r22, 0x01	; 1
 298:	70 e0       	ldi	r23, 0x00	; 0
 29a:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		isMyTimer = TRUE;
 29e:	77 24       	eor	r7, r7
 2a0:	7a 94       	dec	r7
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <__uartswSetBaudRate+0x138>
		}
	}



}
 2a4:	0f 90       	pop	r0
 2a6:	0f 90       	pop	r0
 2a8:	0f 90       	pop	r0
 2aa:	0f 90       	pop	r0
 2ac:	df 91       	pop	r29
 2ae:	cf 91       	pop	r28
 2b0:	1f 91       	pop	r17
 2b2:	0f 91       	pop	r16
 2b4:	ff 90       	pop	r15
 2b6:	ef 90       	pop	r14
 2b8:	df 90       	pop	r13
 2ba:	cf 90       	pop	r12
 2bc:	bf 90       	pop	r11
 2be:	af 90       	pop	r10
 2c0:	9f 90       	pop	r9
 2c2:	8f 90       	pop	r8
 2c4:	7f 90       	pop	r7
 2c6:	5f 90       	pop	r5
 2c8:	4f 90       	pop	r4
 2ca:	3f 90       	pop	r3
 2cc:	2f 90       	pop	r2
 2ce:	08 95       	ret

000002d0 <uartswTxBitService>:
static void	startXmitMode(UART* _uart);
static void	endXmitMode(UART* _uart);
static void oneWireReceiveMode(const UART* _uart);

static void uartswTxBitService(const TimerCompare *channel, void* _uart)
{
 2d0:	ef 92       	push	r14
 2d2:	ff 92       	push	r15
 2d4:	0f 93       	push	r16
 2d6:	1f 93       	push	r17
 2d8:	cf 93       	push	r28
 2da:	df 93       	push	r29
 2dc:	7c 01       	movw	r14, r24
 2de:	8b 01       	movw	r16, r22
	SW_UART* uart = (SW_UART*) _uart;
	if(uart->txBitNum)
 2e0:	fb 01       	movw	r30, r22
 2e2:	86 8d       	ldd	r24, Z+30	; 0x1e
 2e4:	88 23       	and	r24, r24
 2e6:	01 f4       	brne	.+0      	; 0x2e8 <uartswTxBitService+0x18>
 2e8:	00 c0       	rjmp	.+0      	; 0x2ea <uartswTxBitService+0x1a>
	{
		// there are bits still waiting to be transmitted
		if(uart->txBitNum > 1)
 2ea:	26 8d       	ldd	r18, Z+30	; 0x1e
 2ec:	87 85       	ldd	r24, Z+15	; 0x0f
 2ee:	90 89       	ldd	r25, Z+16	; 0x10
 2f0:	22 30       	cpi	r18, 0x02	; 2
 2f2:	00 f0       	brcs	.+0      	; 0x2f4 <uartswTxBitService+0x24>
		{
			// transmit data bits (inverted, LSB first)
			if( (uart->txData & 0x01) )
 2f4:	25 8d       	ldd	r18, Z+29	; 0x1d
 2f6:	20 ff       	sbrs	r18, 0
 2f8:	00 c0       	rjmp	.+0      	; 0x2fa <uartswTxBitService+0x2a>
				pin_high(uart->_uart_.tx_pin);
 2fa:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 2fe:	00 c0       	rjmp	.+0      	; 0x300 <uartswTxBitService+0x30>
			else
				pin_low(uart->_uart_.tx_pin);
 300:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
			// shift bits down
			uart->txData >>= 1;
 304:	f8 01       	movw	r30, r16
 306:	85 8d       	ldd	r24, Z+29	; 0x1d
 308:	86 95       	lsr	r24
 30a:	85 8f       	std	Z+29, r24	; 0x1d
 30c:	00 c0       	rjmp	.+0      	; 0x30e <uartswTxBitService+0x3e>
		}
		else
		{
			// transmit stop bit
			if(uart->inverted){
 30e:	fb 01       	movw	r30, r22
 310:	23 a1       	ldd	r18, Z+35	; 0x23
 312:	22 23       	and	r18, r18
 314:	01 f0       	breq	.+0      	; 0x316 <uartswTxBitService+0x46>
				pin_low(uart->_uart_.tx_pin);
 316:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 31a:	00 c0       	rjmp	.+0      	; 0x31c <uartswTxBitService+0x4c>
			}else{
				pin_high(uart->_uart_.tx_pin);
 31c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
//
//  For a TimerCompare channel return the Timer it uses
//
------------------------------------------------------- */
static __inline__ const Timer* compareGetTimer(const TimerCompare* compare){
	return &pgm_Timers[pgm_read_byte(&compare->pgm_timer)];
 320:	f7 01       	movw	r30, r14
 322:	32 96       	adiw	r30, 0x02	; 2
 324:	e4 91       	lpm	r30, Z
 326:	f0 e0       	ldi	r31, 0x00	; 0
			}
		}
		// schedule the next bit
		uint16_t top = 1 + timerGetTOP(compareGetTimer(channel));
 328:	2c e2       	ldi	r18, 0x2C	; 44
 32a:	30 e0       	ldi	r19, 0x00	; 0
 32c:	e2 9f       	mul	r30, r18
 32e:	c0 01       	movw	r24, r0
 330:	e3 9f       	mul	r30, r19
 332:	90 0d       	add	r25, r0
 334:	f2 9f       	mul	r31, r18
 336:	90 0d       	add	r25, r0
 338:	11 24       	eor	r1, r1
 33a:	80 50       	subi	r24, 0x00	; 0
 33c:	90 40       	sbci	r25, 0x00	; 0
 33e:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 342:	ec 01       	movw	r28, r24
 344:	21 96       	adiw	r28, 0x01	; 1
		uint16_t next = (compareGetThreshold(channel) + uart->dataBitLength);
 346:	c7 01       	movw	r24, r14
 348:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 34c:	f8 01       	movw	r30, r16
 34e:	61 a1       	ldd	r22, Z+33	; 0x21
 350:	72 a1       	ldd	r23, Z+34	; 0x22
 352:	68 0f       	add	r22, r24
 354:	79 1f       	adc	r23, r25
		if(next >= top){
 356:	6c 17       	cp	r22, r28
 358:	7d 07       	cpc	r23, r29
 35a:	00 f0       	brcs	.+0      	; 0x35c <uartswTxBitService+0x8c>
			next -= top;
 35c:	6c 1b       	sub	r22, r28
 35e:	7d 0b       	sbc	r23, r29
		}
		compareSetThreshold(channel, next );
 360:	c7 01       	movw	r24, r14
 362:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		// count down
		uart->txBitNum--;
 366:	f8 01       	movw	r30, r16
 368:	86 8d       	ldd	r24, Z+30	; 0x1e
 36a:	81 50       	subi	r24, 0x01	; 1
 36c:	86 8f       	std	Z+30, r24	; 0x1e
 36e:	00 c0       	rjmp	.+0      	; 0x370 <uartswTxBitService+0xa0>
	}
	else
	{
		// We have finished sending the current byte - look for the next byte to send
		__uartTransmitService(&uart->_uart_);
 370:	cb 01       	movw	r24, r22
 372:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}
}
 376:	df 91       	pop	r29
 378:	cf 91       	pop	r28
 37a:	1f 91       	pop	r17
 37c:	0f 91       	pop	r16
 37e:	ff 90       	pop	r15
 380:	ef 90       	pop	r14
 382:	08 95       	ret

00000384 <uartswRxBitService>:
	// reset bit counter and data
	uart->rxBitNum = uart->rxData = 0;

}

static void uartswRxBitService(const TimerCompare *channel, void* _uart){
 384:	ef 92       	push	r14
 386:	ff 92       	push	r15
 388:	0f 93       	push	r16
 38a:	1f 93       	push	r17
 38c:	cf 93       	push	r28
 38e:	df 93       	push	r29
 390:	00 d0       	rcall	.+0      	; 0x392 <uartswRxBitService+0xe>
 392:	0f 92       	push	r0
 394:	cd b7       	in	r28, 0x3d	; 61
 396:	de b7       	in	r29, 0x3e	; 62
 398:	7c 01       	movw	r14, r24
 39a:	8b 01       	movw	r16, r22
	SW_UART* uart = (SW_UART*)_uart;
	// start bit has already been received
	// we're in the data bits

	// shift data byte to make room for new bit
	uart->rxData >>= 1;
 39c:	fb 01       	movw	r30, r22
 39e:	83 8d       	ldd	r24, Z+27	; 0x1b
 3a0:	86 95       	lsr	r24
 3a2:	83 8f       	std	Z+27, r24	; 0x1b

	// sample the data line
	if(uart->inverted){
 3a4:	23 a1       	ldd	r18, Z+35	; 0x23
 3a6:	85 85       	ldd	r24, Z+13	; 0x0d
 3a8:	96 85       	ldd	r25, Z+14	; 0x0e
 3aa:	22 23       	and	r18, r18
 3ac:	01 f0       	breq	.+0      	; 0x3ae <uartswRxBitService+0x2a>
		if( pin_is_low(uart->_uart_.rx_pin) ){
 3ae:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 3b2:	88 23       	and	r24, r24
 3b4:	01 f4       	brne	.+0      	; 0x3b6 <uartswRxBitService+0x32>
 3b6:	00 c0       	rjmp	.+0      	; 0x3b8 <uartswRxBitService+0x34>
			uart->rxData |= 0x80;
		}
	}else{
		if( pin_is_high(uart->_uart_.rx_pin) ){
 3b8:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 3bc:	88 23       	and	r24, r24
 3be:	01 f0       	breq	.+0      	; 0x3c0 <uartswRxBitService+0x3c>
			uart->rxData |= 0x80;
 3c0:	f8 01       	movw	r30, r16
 3c2:	83 8d       	ldd	r24, Z+27	; 0x1b
 3c4:	80 68       	ori	r24, 0x80	; 128
 3c6:	83 8f       	std	Z+27, r24	; 0x1b
		}
	}

	// schedule next bit sample
	compareSetThreshold(channel, (compareGetThreshold(channel) + uart->dataBitLength));
 3c8:	c7 01       	movw	r24, r14
 3ca:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 3ce:	f8 01       	movw	r30, r16
 3d0:	61 a1       	ldd	r22, Z+33	; 0x21
 3d2:	72 a1       	ldd	r23, Z+34	; 0x22
 3d4:	68 0f       	add	r22, r24
 3d6:	79 1f       	adc	r23, r25
 3d8:	c7 01       	movw	r24, r14
 3da:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

	// check if we have a full byte
	if(++uart->rxBitNum >= 8)
 3de:	f8 01       	movw	r30, r16
 3e0:	84 8d       	ldd	r24, Z+28	; 0x1c
 3e2:	8f 5f       	subi	r24, 0xFF	; 255
 3e4:	84 8f       	std	Z+28, r24	; 0x1c
 3e6:	88 30       	cpi	r24, 0x08	; 8
 3e8:	00 f0       	brcs	.+0      	; 0x3ea <uartswRxBitService+0x66>
	{
		uint8_t c = uart->rxData;
 3ea:	63 8d       	ldd	r22, Z+27	; 0x1b

		// Detach the OC1B interrupt
//		compareDetach(channel);
		__portMaskClear(&channel->pgm_intenable);		// turn interrupt off
 3ec:	c7 01       	movw	r24, r14
 3ee:	03 96       	adiw	r24, 0x03	; 3
 3f0:	6b 83       	std	Y+3, r22	; 0x03
 3f2:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 3f6:	f7 01       	movw	r30, r14
 3f8:	32 96       	adiw	r30, 0x02	; 2
 3fa:	e4 91       	lpm	r30, Z
 3fc:	f0 e0       	ldi	r31, 0x00	; 0

		// attach RxBit service routine to ICP
		// trigger on rising edge if inverted, or falling if not
//		timerCaptureAttach(compareGetTimer(channel), uartswRxStartService, uart, uart->inverted );
		const Timer* timer = compareGetTimer(channel);
 3fe:	8c e2       	ldi	r24, 0x2C	; 44
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	e8 9f       	mul	r30, r24
 404:	90 01       	movw	r18, r0
 406:	e9 9f       	mul	r30, r25
 408:	30 0d       	add	r19, r0
 40a:	f8 9f       	mul	r31, r24
 40c:	30 0d       	add	r19, r0
 40e:	11 24       	eor	r1, r1
 410:	20 50       	subi	r18, 0x00	; 0
 412:	30 40       	sbci	r19, 0x00	; 0
//
//  Clear any pending capture interrupt
//
------------------------------------------------------- */
static __inline__ void timerCaptureClearInterruptPending(const Timer* timer){
	__portMaskSet(&timer->pgm_capturereq);
 414:	c9 01       	movw	r24, r18
 416:	84 96       	adiw	r24, 0x24	; 36
 418:	29 83       	std	Y+1, r18	; 0x01
 41a:	3a 83       	std	Y+2, r19	; 0x02
 41c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
		timerCaptureClearInterruptPending(timer);	// Clear any pending capture interrupt flag
		__portMaskSet(&timer->pgm_captureint);		// Re-enable capture interrupt
 420:	29 81       	ldd	r18, Y+1	; 0x01
 422:	3a 81       	ldd	r19, Y+2	; 0x02
 424:	c9 01       	movw	r24, r18
 426:	81 96       	adiw	r24, 0x21	; 33
 428:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		// save data in receive buffer
		__uartReceiveService(&uart->_uart_, c);
 42c:	c8 01       	movw	r24, r16
 42e:	6b 81       	ldd	r22, Y+3	; 0x03
 430:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}
}
 434:	0f 90       	pop	r0
 436:	0f 90       	pop	r0
 438:	0f 90       	pop	r0
 43a:	df 91       	pop	r29
 43c:	cf 91       	pop	r28
 43e:	1f 91       	pop	r17
 440:	0f 91       	pop	r16
 442:	ff 90       	pop	r15
 444:	ef 90       	pop	r14
 446:	08 95       	ret

00000448 <oneWireReceiveMode.part.1>:

	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
 448:	1f 93       	push	r17
 44a:	cf 93       	push	r28
 44c:	df 93       	push	r29
 44e:	fc 01       	movw	r30, r24
	if(_uartIsOneWire(_uart)){
		const SW_UART* uart = (const SW_UART*)_uart;
		// Place into receive mode and turn transmitter off

		const Timer* timer = &pgm_Timers[uart->timer];
 450:	22 8d       	ldd	r18, Z+26	; 0x1a
 452:	30 e0       	ldi	r19, 0x00	; 0
 454:	8c e2       	ldi	r24, 0x2C	; 44
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	28 9f       	mul	r18, r24
 45a:	e0 01       	movw	r28, r0
 45c:	29 9f       	mul	r18, r25
 45e:	d0 0d       	add	r29, r0
 460:	38 9f       	mul	r19, r24
 462:	d0 0d       	add	r29, r0
 464:	11 24       	eor	r1, r1
 466:	c0 50       	subi	r28, 0x00	; 0
 468:	d0 40       	sbci	r29, 0x00	; 0

		CRITICAL_SECTION_START;
 46a:	1f b7       	in	r17, 0x3f	; 63
 46c:	f8 94       	cli

		// Turn the transmitter/receiver pin back into an output
//		setTxIdle(uart);

		// Turn the xmit into an input pin with pullup
		pin_make_input(_uart->tx_pin,TRUE);
 46e:	87 85       	ldd	r24, Z+15	; 0x0f
 470:	90 89       	ldd	r25, Z+16	; 0x10
 472:	6f ef       	ldi	r22, 0xFF	; 255
 474:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 478:	ce 01       	movw	r24, r28
 47a:	84 96       	adiw	r24, 0x24	; 36
 47c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		// Clear any pending capture interrupt flag
		timerCaptureClearInterruptPending(timer);

		// Re-enable the input capture to detect the start of a byte
		__portMaskSet(&timer->pgm_captureint);
 480:	ce 01       	movw	r24, r28
 482:	81 96       	adiw	r24, 0x21	; 33
 484:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		CRITICAL_SECTION_END;
 488:	1f bf       	out	0x3f, r17	; 63
	}
}
 48a:	df 91       	pop	r29
 48c:	cf 91       	pop	r28
 48e:	1f 91       	pop	r17
 490:	08 95       	ret

00000492 <endXmitMode>:

// We have finished sending stuff
static void	endXmitMode(UART* _uart){
 492:	cf 93       	push	r28
 494:	df 93       	push	r29
 496:	ec 01       	movw	r28, r24
	const SW_UART* uart = (const SW_UART*)_uart;
	// Turn timer interrupt off
	const Timer* timer = &pgm_Timers[uart->timer];
 498:	8a 8d       	ldd	r24, Y+26	; 0x1a
 49a:	90 e0       	ldi	r25, 0x00	; 0
 49c:	2c e2       	ldi	r18, 0x2C	; 44
 49e:	30 e0       	ldi	r19, 0x00	; 0
 4a0:	82 9f       	mul	r24, r18
 4a2:	f0 01       	movw	r30, r0
 4a4:	83 9f       	mul	r24, r19
 4a6:	f0 0d       	add	r31, r0
 4a8:	92 9f       	mul	r25, r18
 4aa:	f0 0d       	add	r31, r0
 4ac:	11 24       	eor	r1, r1
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 4ae:	e0 50       	subi	r30, 0x00	; 0
 4b0:	f0 40       	sbci	r31, 0x00	; 0
 4b2:	85 91       	lpm	r24, Z+
 4b4:	94 91       	lpm	r25, Z
	const TimerCompare* channel = timerGetCompare(timer,0);
	__portMaskClear(&channel->pgm_intenable);
 4b6:	03 96       	adiw	r24, 0x03	; 3
 4b8:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
	if(_uartIsOneWire(_uart)){
 4bc:	8d 89       	ldd	r24, Y+21	; 0x15
 4be:	88 23       	and	r24, r24
 4c0:	01 f0       	breq	.+0      	; 0x4c2 <endXmitMode+0x30>
 4c2:	ce 01       	movw	r24, r28
 4c4:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	const Timer* timer = &pgm_Timers[uart->timer];
	const TimerCompare* channel = timerGetCompare(timer,0);
	__portMaskClear(&channel->pgm_intenable);

	oneWireReceiveMode(_uart);
}
 4c8:	df 91       	pop	r29
 4ca:	cf 91       	pop	r28
 4cc:	08 95       	ret

000004ce <__uartswInit>:
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
}


// enable and initialize the software uart - called with interrupts turned off
void __uartswInit(UART* _uart, BAUD_RATE baud){
 4ce:	df 92       	push	r13
 4d0:	ef 92       	push	r14
 4d2:	ff 92       	push	r15
 4d4:	0f 93       	push	r16
 4d6:	1f 93       	push	r17
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	8c 01       	movw	r16, r24
	SW_UART* uart = (SW_UART*) _uart;
	if(uart->_uart_.rx_pin!=null || uart->_uart_.tx_pin!=null){
 4de:	fc 01       	movw	r30, r24
 4e0:	85 85       	ldd	r24, Z+13	; 0x0d
 4e2:	96 85       	ldd	r25, Z+14	; 0x0e
 4e4:	00 97       	sbiw	r24, 0x00	; 0
 4e6:	01 f4       	brne	.+0      	; 0x4e8 <__uartswInit+0x1a>
 4e8:	87 85       	ldd	r24, Z+15	; 0x0f
 4ea:	90 89       	ldd	r25, Z+16	; 0x10
 4ec:	00 97       	sbiw	r24, 0x00	; 0
 4ee:	01 f4       	brne	.+0      	; 0x4f0 <__uartswInit+0x22>
 4f0:	00 c0       	rjmp	.+0      	; 0x4f2 <__uartswInit+0x24>

		const Timer* timer = &pgm_Timers[uart->timer];
 4f2:	f8 01       	movw	r30, r16
 4f4:	22 8d       	ldd	r18, Z+26	; 0x1a
 4f6:	30 e0       	ldi	r19, 0x00	; 0
 4f8:	8c e2       	ldi	r24, 0x2C	; 44
 4fa:	90 e0       	ldi	r25, 0x00	; 0
 4fc:	28 9f       	mul	r18, r24
 4fe:	70 01       	movw	r14, r0
 500:	29 9f       	mul	r18, r25
 502:	f0 0c       	add	r15, r0
 504:	38 9f       	mul	r19, r24
 506:	f0 0c       	add	r15, r0
 508:	11 24       	eor	r1, r1
 50a:	80 e0       	ldi	r24, 0x00	; 0
 50c:	90 e0       	ldi	r25, 0x00	; 0
 50e:	e8 0e       	add	r14, r24
 510:	f9 1e       	adc	r15, r25

		// initialize baud rate
		uartSetBaudRate(uart, baud);
 512:	c8 01       	movw	r24, r16
 514:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

		// setup the transmitter
		if(uart->_uart_.tx_pin!=null){
 518:	f8 01       	movw	r30, r16
 51a:	87 85       	ldd	r24, Z+15	; 0x0f
 51c:	90 89       	ldd	r25, Z+16	; 0x10
 51e:	00 97       	sbiw	r24, 0x00	; 0
 520:	01 f0       	breq	.+0      	; 0x522 <__uartswInit+0x54>
			uart->txBitNum=0;
 522:	16 8e       	std	Z+30, r1	; 0x1e

			// set the output idle state of the transmitter
			if(!uartIsOneWire(uart)){
 524:	25 89       	ldd	r18, Z+21	; 0x15
 526:	22 23       	and	r18, r18
 528:	01 f4       	brne	.+0      	; 0x52a <__uartswInit+0x5c>
}


static void setTxIdle(SW_UART* uart){
	// set the output idle state of the transmitter
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
 52a:	23 a1       	ldd	r18, Z+35	; 0x23
 52c:	22 23       	and	r18, r18
 52e:	01 f0       	breq	.+0      	; 0x530 <__uartswInit+0x62>
 530:	60 e0       	ldi	r22, 0x00	; 0
 532:	00 c0       	rjmp	.+0      	; 0x534 <__uartswInit+0x66>
 534:	6f ef       	ldi	r22, 0xFF	; 255
 536:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
			// set the output idle state of the transmitter
			if(!uartIsOneWire(uart)){
				setTxIdle(uart);
			}

			CRITICAL_SECTION{
 53a:	df b6       	in	r13, 0x3f	; 63
# define null ((void*)0)
#endif


#ifndef _WINDOWS_
static __inline__ uint8_t __iCliRetVal(void){ cli(); return 1; }
 53c:	f8 94       	cli
 53e:	f7 01       	movw	r30, r14
 540:	77 96       	adiw	r30, 0x17	; 23
 542:	85 91       	lpm	r24, Z+
 544:	94 91       	lpm	r25, Z
 546:	c8 2f       	mov	r28, r24
 548:	d9 2f       	mov	r29, r25
				const TimerCompare* channel = timerGetCompare(timer,0);
				// Mark the transmit channel as in use
				compareAttach(channel,&uartswTxBitService,0,uart);
 54a:	ce 01       	movw	r24, r28
 54c:	60 e0       	ldi	r22, 0x00	; 0
 54e:	70 e0       	ldi	r23, 0x00	; 0
 550:	40 e0       	ldi	r20, 0x00	; 0
 552:	50 e0       	ldi	r21, 0x00	; 0
 554:	98 01       	movw	r18, r16
 556:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

				// But turn off interrupt for now
				__portMaskClear(&channel->pgm_intenable);
 55a:	ce 01       	movw	r24, r28
 55c:	03 96       	adiw	r24, 0x03	; 3
 55e:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
static __inline__ uint8_t __iSeiRetVal(void){ sei(); return 1; }
static __inline__ void __iRestore(const  uint8_t *__s){ SREG = *__s; __asm__ volatile ("" ::: "memory");}
 562:	df be       	out	0x3f, r13	; 63
			}

		}

		// setup the receiver
		if(uart->_uart_.rx_pin!=null){
 564:	f8 01       	movw	r30, r16
 566:	25 85       	ldd	r18, Z+13	; 0x0d
 568:	36 85       	ldd	r19, Z+14	; 0x0e
 56a:	21 15       	cp	r18, r1
 56c:	31 05       	cpc	r19, r1
 56e:	01 f0       	breq	.+0      	; 0x570 <__uartswInit+0xa2>
//  Get the capture pin for a timer
//  Return the IOPin or null if there isn't one
//
------------------------------------------------------- */
static __inline__ const IOPin* timerGetCapturePin(const Timer* timer){
	return (const IOPin*)(pgm_read_word(&timer->pgm_capturepin));
 570:	f7 01       	movw	r30, r14
 572:	ba 96       	adiw	r30, 0x2a	; 42
 574:	45 91       	lpm	r20, Z+
 576:	54 91       	lpm	r21, Z
 578:	ca 01       	movw	r24, r20

			// Locate the timer whose capture input is this pin
			const IOPin* tCapture = timerGetCapturePin(timer);
			if(tCapture!=uart->_uart_.rx_pin){
 57a:	42 17       	cp	r20, r18
 57c:	53 07       	cpc	r21, r19
 57e:	01 f0       	breq	.+0      	; 0x580 <__uartswInit+0xb2>
				setError(UARTSW_NOT_CAPTURE);
 580:	89 ee       	ldi	r24, 0xE9	; 233
 582:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 586:	00 c0       	rjmp	.+0      	; 0x588 <__uartswInit+0xba>
			}else{
				// Make the Rx pin an input with no pullup
				pin_make_input(uart->_uart_.rx_pin,FALSE);
 588:	60 e0       	ldi	r22, 0x00	; 0
 58a:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>

				// attach RxBit service routine to ICP
				// trigger on rising edge if inverted, falling if not
				timerCaptureAttach(timer, uartswRxStartService, uart, uart->inverted );
 58e:	c7 01       	movw	r24, r14
 590:	60 e0       	ldi	r22, 0x00	; 0
 592:	70 e0       	ldi	r23, 0x00	; 0
 594:	a8 01       	movw	r20, r16
 596:	f8 01       	movw	r30, r16
 598:	23 a1       	ldd	r18, Z+35	; 0x23
 59a:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 59e:	f7 01       	movw	r30, r14
 5a0:	77 96       	adiw	r30, 0x17	; 23
 5a2:	e5 90       	lpm	r14, Z+
 5a4:	f4 90       	lpm	r15, Z
 5a6:	e7 01       	movw	r28, r14
 5a8:	60 96       	adiw	r28, 0x10	; 16

				// Set up receive interrupt for bit handling - then immediately disable it
				const TimerCompare* rx = timerGetCompare(timer,1);
				compareAttach(rx, uartswRxBitService, compareGetThreshold(rx)-1, uart);
 5aa:	ce 01       	movw	r24, r28
 5ac:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
 5b0:	ac 01       	movw	r20, r24
 5b2:	41 50       	subi	r20, 0x01	; 1
 5b4:	50 40       	sbci	r21, 0x00	; 0
 5b6:	ce 01       	movw	r24, r28
 5b8:	60 e0       	ldi	r22, 0x00	; 0
 5ba:	70 e0       	ldi	r23, 0x00	; 0
 5bc:	98 01       	movw	r18, r16
 5be:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
				__portMaskClear(&rx->pgm_intenable);	// turn interrupt off
 5c2:	c7 01       	movw	r24, r14
 5c4:	43 96       	adiw	r24, 0x13	; 19
 5c6:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
//
//  Clear a pending interrupt on a compare unit
//
------------------------------------------------------- */
static __inline__ void compareClearInterruptPending(const TimerCompare* channel){
	__portMaskSet(&channel->pgm_intpending);
 5ca:	c7 01       	movw	r24, r14
 5cc:	48 96       	adiw	r24, 0x18	; 24
 5ce:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
	}
}

// If one wire - then go into receive mode
static void oneWireReceiveMode(const UART* _uart){
	if(_uartIsOneWire(_uart)){
 5d2:	f8 01       	movw	r30, r16
 5d4:	85 89       	ldd	r24, Z+21	; 0x15
 5d6:	88 23       	and	r24, r24
 5d8:	01 f0       	breq	.+0      	; 0x5da <__uartswInit+0x10c>
 5da:	c8 01       	movw	r24, r16
 5dc:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
				compareClearInterruptPending(rx);		// clear any interrupt pending
			}
		}
	}
	oneWireReceiveMode(_uart);
}
 5e0:	df 91       	pop	r29
 5e2:	cf 91       	pop	r28
 5e4:	1f 91       	pop	r17
 5e6:	0f 91       	pop	r16
 5e8:	ff 90       	pop	r15
 5ea:	ef 90       	pop	r14
 5ec:	df 90       	pop	r13
 5ee:	08 95       	ret

000005f0 <startXmitMode>:
	}

}

// We are about to start sending stuff
static void	startXmitMode(UART* _uart){
 5f0:	ff 92       	push	r15
 5f2:	0f 93       	push	r16
 5f4:	1f 93       	push	r17
 5f6:	cf 93       	push	r28
 5f8:	df 93       	push	r29
 5fa:	ec 01       	movw	r28, r24
	if(_uartIsOneWire(_uart)){
 5fc:	8d 89       	ldd	r24, Y+21	; 0x15
 5fe:	88 23       	and	r24, r24
 600:	01 f0       	breq	.+0      	; 0x602 <startXmitMode+0x12>
		SW_UART* uart = (SW_UART*)_uart;
		// Place into transmit mode and turn receiver off
		const Timer* timer = &pgm_Timers[uart->timer];
 602:	2a 8d       	ldd	r18, Y+26	; 0x1a
 604:	30 e0       	ldi	r19, 0x00	; 0
 606:	8c e2       	ldi	r24, 0x2C	; 44
 608:	90 e0       	ldi	r25, 0x00	; 0
 60a:	28 9f       	mul	r18, r24
 60c:	a0 01       	movw	r20, r0
 60e:	29 9f       	mul	r18, r25
 610:	50 0d       	add	r21, r0
 612:	38 9f       	mul	r19, r24
 614:	50 0d       	add	r21, r0
 616:	11 24       	eor	r1, r1
 618:	40 50       	subi	r20, 0x00	; 0
 61a:	50 40       	sbci	r21, 0x00	; 0
 *
 *   Get a given compare channel for a timer
 *
 --------------------------------------------------------*/
static __inline__ const TimerCompare* timerGetCompare(const Timer* timer, uint8_t channel){
	return ((const TimerCompare*)pgm_read_word(&timer->pgm_compares)) + channel;
 61c:	fa 01       	movw	r30, r20
 61e:	77 96       	adiw	r30, 0x17	; 23
 620:	05 91       	lpm	r16, Z+
 622:	14 91       	lpm	r17, Z
		const TimerCompare* rx = timerGetCompare(timer,1);

		CRITICAL_SECTION_START;
 624:	ff b6       	in	r15, 0x3f	; 63
 626:	f8 94       	cli

		// Disable the input capture
		__portMaskClear(&timer->pgm_captureint);	// disable capture interrupt on timer
 628:	ca 01       	movw	r24, r20
 62a:	81 96       	adiw	r24, 0x21	; 33
 62c:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
		__portMaskClear(&rx->pgm_intenable);		// disable timer compare interrupt for recv bits
 630:	c8 01       	movw	r24, r16
 632:	43 96       	adiw	r24, 0x13	; 19
 634:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
}


static void setTxIdle(SW_UART* uart){
	// set the output idle state of the transmitter
	pin_make_output(uart->_uart_.tx_pin, (uart->inverted) ? FALSE : TRUE);
 638:	8f 85       	ldd	r24, Y+15	; 0x0f
 63a:	98 89       	ldd	r25, Y+16	; 0x10
 63c:	2b a1       	ldd	r18, Y+35	; 0x23
 63e:	22 23       	and	r18, r18
 640:	01 f0       	breq	.+0      	; 0x642 <startXmitMode+0x52>
 642:	60 e0       	ldi	r22, 0x00	; 0
 644:	00 c0       	rjmp	.+0      	; 0x646 <startXmitMode+0x56>
 646:	6f ef       	ldi	r22, 0xFF	; 255
 648:	0e 94 00 00 	call	0	; 0x0 <__uartswOff>
		__portMaskClear(&rx->pgm_intenable);		// disable timer compare interrupt for recv bits

		// Turn the transmitter pin back into an output
		setTxIdle(uart);

		CRITICAL_SECTION_END;
 64c:	ff be       	out	0x3f, r15	; 63

	}
}
 64e:	df 91       	pop	r29
 650:	cf 91       	pop	r28
 652:	1f 91       	pop	r17
 654:	0f 91       	pop	r16
 656:	ff 90       	pop	r15
 658:	08 95       	ret
